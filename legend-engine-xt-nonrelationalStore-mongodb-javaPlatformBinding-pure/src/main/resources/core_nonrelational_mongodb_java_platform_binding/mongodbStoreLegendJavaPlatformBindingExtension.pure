// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::language::java::metamodel::project::*;
import meta::pure::executionPlan::platformBinding::legendJava::shared::naming::*;
import meta::external::language::java::factory::project::*;
import meta::pure::executionPlan::platformBinding::legendJava::graphFetch::common::*;
import meta::external::language::java::metamodel::*;
import meta::pure::executionPlan::*;
import meta::pure::executionPlan::platformBinding::*;
import meta::pure::executionPlan::platformBinding::legendJava::*;
import meta::pure::extension::*;
import meta::pure::mapping::*;
import meta::external::store::mongodb::executionPlan::platformBinding::legendJava::*;
import meta::external::store::mongodb::metamodel::pure::graphFetch::executionPlan::*;
import meta::external::store::mongodb::metamodel::pure::*;
import meta::external::store::mongodb::metamodel::mapping::*;

function meta::external::store::mongodb::executionPlan::platformBinding::legendJava::mongoDBStoreLegendJavaPlatformBindingExtension(): LegendJavaPlatformBindingExtension[1]
{
   ^LegendJavaPlatformBindingExtension
   (
      platformId = legendJavaPlatformBindingId(),

      id = 'MongoDBStoreLegendJavaPlatformBindingExtension',

      // Node based extensions ------------------------------------------------------

      supportedExecutionNodes = [
        MongoDBGraphFetchExecutionNode
      ],

      updateGenerationContextForNode = {node: ExecutionNode[1], context: GenerationContext[1], path: String[1], extensions: Extension[*], debug: DebugContext[1] |
         $node->match([
            n: MongoDBGraphFetchExecutionNode[1]       | $context
         ])
      },

      generateLegendJavaCodeForNode = {node: ExecutionNode[1], path: String[1], context: GenerationContext[1], extensions: Extension[*], debug: DebugContext[1] |
         $node->match([
            { n: MongoDBGraphFetchExecutionNode[1]                            | 
               let mongoDBGraphImplUpdateFunction = {impl: meta::external::language::java::metamodel::Class[1] |
               $impl->enrichForMongoDBGraphExecution($n, $context, $extensions, $debug)
               };
               let baseProject  = $n->generateBaseProjectForLocalGraphFetchNode($path, $context, $mongoDBGraphImplUpdateFunction, $debug);
               let storeProject = $n->generateMongoDBGraphFetchNodeProject($path, $context, $extensions, $debug);

               generatedCode(
                  $baseProject->concatenate($storeProject)->toOneMany()->mergeProjects(),
                  $storeProject->resolve($context.conventions->planNodeClass('public', $path, 'Execute'))
               );
            },
            n: ExecutionNode[1]                                             | ^GeneratedCode()
         ])
      },


      /*
      /*
            {r: RelationalGraphFetchExecutionNode[1] |
               let relationalGraphImplUpdateFunction = {impl: meta::external::language::java::metamodel::Class[1] |
                  $impl->enrichForRelationalGraphExecution($r, $context, $extensions, $debug)
               };
               let baseProject  = $r->generateBaseProjectForLocalGraphFetchNode($path, $context, $relationalGraphImplUpdateFunction, $debug);
               let storeProject = $r->generateRelationalStoreGraphFetchProject($path, $context, $extensions, $debug);

               generatedCode(
                  $baseProject->concatenate($storeProject)->toOneMany()->mergeProjects(),
                  $storeProject->resolve($context.conventions->planNodeClass('public', $path, 'Execute'))
               );
            },
            {r: RelationalClassInstantiationExecutionNode[1] |
               $r.resultType->match([
                  pc : PartialClassResultType[1] | $r->generateImplementionForRelationalPartialClassResult($path, $pc.propertiesWithParameters.property, $context, $debug),
                  c  : ClassResultType[1]        | $r->generateImplementionForRelationalClassResult($path, $context, $debug)
               ])
            },
            r: CreateAndPopulateTempTableExecutionNode[1] | $r->generateImplementationForCreateAndPopulateTempTableNode($path, $context, $debug),
            n: ExecutionNode[1]                           | ^GeneratedCode()
      */


      // ------------------------------------------------------ Node based extensions




      // Adhoc extensions -----------------------------------------------------------

      adhocExtensions = [

         ^meta::pure::mapping::modelToModel::executionPlan::platformBinding::legendJava::graphFetch::LegendJavaInMemoryGraphFetchExtension
         (
            filterCodeGenerator = {set: InstanceSetImplementation[1], src: Code[1], withoutFilter: Code[1..*], context: GenerationContext[1], debug:DebugContext[1] |
               [
                  rootsi: RootMongoDBSetImplementation[1]  | $withoutFilter,
                  msi: MongoDBSetImplementation[1] | $withoutFilter
               ]
            },

            mappingTransformExtractors = [
               {spm : MongoDBPropertyMapping[1] | let dummyLambda = {|'ok'};
                                                      let gen = ^GenericType
                                                                  (
                                                                     rawType = LambdaFunction,
                                                                     typeArguments = ^GenericType
                                                                                       (
                                                                                          rawType = ^meta::pure::metamodel::type::FunctionType
                                                                                                   (
                                                                                                      parameters = [],
                                                                                                      returnType = $spm.property->functionReturnType(),
                                                                                                      returnMultiplicity= $spm.property->functionReturnMultiplicity()
                                                                                                   )
                                                                                       )
                                                                  );
                                                      let exp = ^SimpleFunctionExpression(func = $spm.property,
                                                                                          genericType = $spm.property.genericType,
                                                                                          importGroup = system.children->at(0)->cast(@Package).children->at(0)->cast(@ImportGroup),
                                                                                          multiplicity = $spm.property.multiplicity,
                                                                                          parametersValues = ^VariableExpression(genericType=^GenericType(rawType = $spm.property.owner->cast(@meta::pure::metamodel::type::Class<Any>)), multiplicity = PureOne, name = 'src'),
                                                                                          propertyName = ^InstanceValue(genericType = ^GenericType(rawType = String), multiplicity = PureOne, values = $spm.property.name));
                                                      ^$dummyLambda(classifierGenericType = $gen, expressionSequence = $exp);}
//               {epm : EmbeddedServiceStoreSetImplementation[1] | let dummyLambda = {|'ok'};
//                                                      let gen = ^GenericType
//                                                                  (
//                                                                     rawType = LambdaFunction,
//                                                                     typeArguments = ^GenericType
//                                                                                       (
//                                                                                          rawType = ^meta::pure::metamodel::type::FunctionType
//                                                                                                   (
//                                                                                                      parameters = [],
//                                                                                                      returnType = $epm.property->functionReturnType(),
//                                                                                                      returnMultiplicity= $epm.property->functionReturnMultiplicity()
//                                                                                                   )
//                                                                                       )
//                                                                  );
//                                                      let exp = ^SimpleFunctionExpression(func = $epm.property,
//                                                                                          genericType = $epm.property.genericType,
//                                                                                          importGroup = system.children->at(0)->cast(@Package).children->at(0)->cast(@ImportGroup),
//                                                                                          multiplicity = $epm.property.multiplicity,
//                                                                                          parametersValues = ^VariableExpression(genericType=^GenericType(rawType = $epm.property.owner->cast(@meta::pure::metamodel::type::Class<Any>)), multiplicity = PureOne, name = 'src'),
//                                                                                          propertyName = ^InstanceValue(genericType = ^GenericType(rawType = String), multiplicity = PureOne, values = $epm.property.name));
//                                                      ^$dummyLambda(classifierGenericType = $gen, expressionSequence = $exp);}
            ],

            valueTransformerExtractors = [
               mpm : MongoDBPropertyMapping[1]           | []
               // epm : EmbeddedServiceStoreSetImplementation[1] | []
            ]
         )

      ]

      // ----------------------------------------------------------- Adhoc extensions

   )
}

function meta::external::store::mongodb::executionPlan::platformBinding::legendJava::mongoDBStoreExtensionsWithLegendJavaPlatformBinding(externalFormatDescriptors: meta::external::shared::format::executionPlan::platformBinding::legendJava::ExternalFormatLegendJavaPlatformBindingDescriptor[*]): Extension[*]
{
   meta::external::store::mongodb::extension::mongoDBExtensions()->concatenate(
      meta::pure::executionPlan::platformBinding::platformBindingExtension([
         meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBinding([
            meta::pure::mapping::modelToModel::executionPlan::platformBinding::legendJava::inMemoryLegendJavaPlatformBindingExtension(),
            meta::external::store::mongodb::executionPlan::platformBinding::legendJava::mongoDBStoreLegendJavaPlatformBindingExtension(),
            meta::external::shared::format::executionPlan::platformBinding::legendJava::bindingLegendJavaPlatformBindingExtension($externalFormatDescriptors)
         ])
      ])
   )
}
