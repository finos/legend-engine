// Copyright 2025 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::functions::collection::tests::intersection::*;
import meta::pure::functions::collection::*;
import meta::pure::store::*;
import meta::pure::metamodel::relation::*;
import meta::pure::executionPlan::*;
import meta::pure::router::utils::*;
import meta::pure::router::metamodel::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::extension::*;
import meta::pure::mapping::*;
import meta::core::runtime::*;
import meta::pure::functions::lang::*;
import meta::external::store::deephaven::metamodel::*;
import meta::external::store::deephaven::metamodel::store::*;
import meta::external::store::deephaven::metamodel::executionPlan::context::*;
import meta::external::store::deephaven::extension::*;
import meta::external::store::deephaven::pureToDeephaven::*;

Class meta::external::store::deephaven::metamodel::DeephavenQuery extends DeephavenOperationElement
{
  source : meta::external::store::deephaven::metamodel::store::Table[0..1];
  operations: QueryOperation[*];
  selectQueryExists: Boolean[0..1]; // to omit unnecessary select clause
}

Class meta::external::store::deephaven::metamodel::QueryOperation extends DeephavenOperationElement
{
}

Class meta::external::store::deephaven::metamodel::SelectOperation extends QueryOperation
{
  columns: meta::external::store::deephaven::metamodel::store::Column[*];
}

Class meta::external::store::deephaven::metamodel::FilterOperation extends QueryOperation
{
  condition: FilterExpression[1];
}

Class meta::external::store::deephaven::metamodel::SortOperation extends QueryOperation
{
  columns: SortColumn[*];
}

Class meta::external::store::deephaven::metamodel::JoinOperation extends QueryOperation
{
  rightTable: meta::external::store::deephaven::metamodel::store::Table[1];
  joinType: meta::external::store::deephaven::metamodel::JoinKind[1];
  conditions: JoinCondition[*];
}

Class meta::external::store::deephaven::metamodel::NumericOperation extends QueryOperation
{
  methodName: String[1];
  methodArguments : DeephavenOperationElement[*];
}

Class meta::external::store::deephaven::metamodel::RoundWithScaleOperation extends QueryOperation
{
  methodArguments : DeephavenOperationElement[*];
}

Class meta::external::store::deephaven::metamodel::NegationOperation extends QueryOperation
{
  methodArgument : DeephavenOperationElement[1];
}

Enum meta::external::store::deephaven::metamodel::JoinKind
{
  JOIN, LEFT, RIGHT, OUTER
}

Class meta::external::store::deephaven::metamodel::JoinCondition
{
  leftColumn: String[1];
  rightColumn: String[1];
}

Class meta::external::store::deephaven::metamodel::SortColumn
{
  name: String[1];
  direction: meta::external::store::deephaven::metamodel::SortDirection[1];
}

Enum meta::external::store::deephaven::metamodel::SortDirection
{
  ASCENDING, DESCENDING
}

Class meta::external::store::deephaven::metamodel::FilterExpression extends DeephavenOperationElement
{
}

Class meta::external::store::deephaven::metamodel::DeephavenOperationElement
{
}

Class meta::external::store::deephaven::metamodel::ComparisonOperatorExpression extends FilterExpression
{
  expressions: DeephavenOperationElement[2];
}

Class meta::external::store::deephaven::metamodel::LogicalOperatorExpression extends FilterExpression
{
  expressions: DeephavenOperationElement[1..*];
}

Class meta::external::store::deephaven::metamodel::NotOperatorExpression extends FilterExpression
{
  expression: FilterExpression[1];
}

Class meta::external::store::deephaven::metamodel::EqOperatorExpression extends ComparisonOperatorExpression
{
}

Class meta::external::store::deephaven::metamodel::InOperatorExpression extends ComparisonOperatorExpression
{
}

Class meta::external::store::deephaven::metamodel::AndOperatorExpression extends LogicalOperatorExpression
{
}

Class meta::external::store::deephaven::metamodel::OrOperatorExpression extends LogicalOperatorExpression
{
}

Class meta::external::store::deephaven::pureToDeephaven::State
{
  dhQuery: meta::external::store::deephaven::metamodel::DeephavenQuery[0..1];
  // mapping:Mapping[0..1];
  inFilter: Boolean[1];
  inProject: Boolean[1];
  sq: StoreQuery[1];
  exeCtx: DeephavenExecutionContext[1];
  extensions: Extension[*];
  ext: RoutedValueSpecification[0..1];
  supportedRoutingFunctions: Pair<LambdaFunction<{Function<Any>[1],State[0..1]->Boolean[1]}>, Function<{FunctionExpression[1], DeephavenOperationElement[1], State[1]->DeephavenOperationElement[1]}>>[*];
  supportedFilterFunctions: Pair<LambdaFunction<{Function<Any>[1],State[0..1]->Boolean[1]}>, Function<{FunctionExpression[1], DeephavenOperationElement[1], State[1]->DeephavenOperationElement[1]}>>[*];
  supportedSimpleValueFunctions: Pair<LambdaFunction<{Function<Any>[1],State[0..1]->Boolean[1]}>, Function<{FunctionExpression[1],  State[1]->Pair<List<Any>, State>[1]}>>[*];
  debug: DebugContext[1];
  debug(s : Function<{->String[1]}>[1])
  {
    if($this.debug.debug, |println($this.debug.space + $s->eval()), |[]);
  }:Any[0];
}

function meta::external::store::deephaven::pureToDeephaven::process(sq:StoreQuery[1], ext:RoutedValueSpecification[0..1], m:Mapping[0..1], runtime:Runtime[0..1], exeCtx:DeephavenExecutionContext[1], extensions:Extension[*], debug:DebugContext[1]): State[1]
{
  let req = ^State(
    inFilter = false,
    inProject = false,
    sq = $sq,
    exeCtx = $exeCtx,
    extensions = $extensions,
    ext = $ext,
    debug = $debug,
    supportedFilterFunctions = supportedFilterFunctions(),
    supportedRoutingFunctions = supportedRoutingFunctions(),
    supportedSimpleValueFunctions = supportedSimpleValueFunctions()
  );
  let processedReq = $sq.vs->processValueSpecification(^DeephavenOperationElement(), $req)->toOne();
  $processedReq->match([
                         dhQuery: DeephavenQuery[1] | ^$req(dhQuery = $dhQuery);,
                         queryOp: QueryOperation[1] | ^$req(dhQuery = ^DeephavenQuery(operations = $queryOp));
  ]);
}


///////////////////////////////////////////////////////////////////////////////////////// process ValueSpecification Functions ///////////////////////////////////////////////////////////////////////////////////////////////////////

function meta::external::store::deephaven::pureToDeephaven::processValueSpecification(vs: ValueSpecification[1], operation: DeephavenOperationElement[1], req: State[1]): DeephavenOperationElement[*]
{
  $req.debug(|'-- processing VS ' + $vs->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  $vs->match([
                fe: FunctionExpression[1] | let res  = $fe.func->match([
                                                                          c:meta::pure::metamodel::relation::Column<Nil,Any|*>[1] | processCol($fe, $operation, $req);,
                                                                          a:Any[1]| if($req.inFilter,
                                                                                        | $req.supportedFilterFunctions->findAndEvalSupportedFunction($fe, $operation, $req),
                                                                                        | $req.supportedRoutingFunctions->findAndEvalSupportedFunction($fe, $operation, $req));
                                                                       ]);
                                            $res;,
                tds: TDSRoutedValueSpecification[1] |       $tds.value->processValueSpecification($operation, $req);,
                ervs: ExtendedRoutedValueSpecification[1] | $ervs.value->processValueSpecification($operation, $req);,
                v: VariableExpression[1] |                  $v->processVariableExpression($operation, $req);,
                ins: InstanceValue[1] |                     $ins->processInstanceValue($operation, $req);
  ]);
}

function meta::external::store::deephaven::pureToDeephaven::processCol(fe: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'-- processing Col ' + $fe->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  let debug = $initReq.debug;

  let currReq = processValueSpecification($fe.parametersValues->at(0), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')));
  let colFuncName = $fe.func.name->toOne();
  let foundColumn = $currReq->cast(@DeephavenQuery)->toOne()->findColumn($colFuncName);
  $foundColumn->toOne();
}

function meta::external::store::deephaven::pureToDeephaven::findColumn(dhQuery:DeephavenQuery[1], name:String[1]):meta::external::store::deephaven::metamodel::store::Column[0..1]
{
  $dhQuery.operations->filter(o | $o->instanceOf(SelectOperation))->toOne()->cast(@SelectOperation).columns->filter(c | let colName = $c->match([
                                                                                                                                                  col:meta::external::store::deephaven::metamodel::store::Column[1]|$col.name
                                                                                                                                                  // a:Alias[1]|$a.name
                                                                                                                                                ]);
                                                                                                                        $colName == $name || $colName == '"'+$name+'"';
                                                                                                                   )->first();
}

function meta::external::store::deephaven::pureToDeephaven::processVariableExpression(v: VariableExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'-- processing VE ' + $v->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  $operation;
}

function meta::external::store::deephaven::pureToDeephaven::processInstanceValue(i: InstanceValue[1], operation: DeephavenOperationElement[1], req: State[1]): DeephavenOperationElement[*]
{
  processValue($i.values, $operation, $req);
}

function meta::external::store::deephaven::pureToDeephaven::processValue(vals: Any[*], operation: DeephavenOperationElement[1], req: State[1]): DeephavenOperationElement[*]
{
  let res = if ($vals->isEmpty(), 
                | $req.dhQuery, 
                | let processedVals = $vals->map(v | $v->match([
                                                                s:String[1] | ^Literal(value=$s);,
                                                                i:Integer[1] | ^Literal(value=$i),
                                                                f:Float[1] | ^Literal(value=$f),
                                                                d:Decimal[1] | ^Literal(value=$d),
                                                                b:Boolean[1] | ^Literal(value=$b),
                                                                d:DateTime[1] | ^Literal(value=$d),
                                                                x:meta::pure::store::RelationStoreAccessor<Any>[1] | let relation = $x.sourceElement->cast(@Table);
                                                                                                                    ^DeephavenQuery(source = $relation, operations = ^SelectOperation(columns = $relation.columns));,
                                                                v:ValueSpecification[1] | $v->processValueSpecification($operation, $req)
                                                              ]));
                  $processedVals->match([
                    literal: Literal[1] | $literal,
                    literals: Literal[1..*] | ^LiteralList(values = $literals),
                    d: DeephavenOperationElement[*] | $d
                  ]);
            );
  $res;
}

///////////////////////////////////////////////////////////////////////////////////////// Boolean Operation Functions ///////////////////////////////////////////////////////////////////////////////////////////////////////

function meta::external::store::deephaven::pureToDeephaven::processEqual(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'-- processing equal ' + $vs->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  let debug = $initReq.debug;

  let leftSide = processValueSpecification($vs.parametersValues->at(0), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne();
  let rightSide = processValueSpecification($vs.parametersValues->at(1), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne();
  let mergedSQL = ^EqOperatorExpression(expressions=[$leftSide, $rightSide]);
  $mergedSQL;
}

function meta::external::store::deephaven::pureToDeephaven::processIn(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'-- processing in ' + $vs->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  let debug = $initReq.debug;

  let leftSide = $vs.parametersValues->at(0)->processValueSpecification($operation, $initReq)->toOne();
  let rightSide = $vs.parametersValues->at(1)->processValueSpecification($operation, $initReq)->cast(@LiteralList)->toOne();
  let mergedSQL = ^InOperatorExpression(expressions=[$leftSide, $rightSide]);
  $mergedSQL;
}

function meta::external::store::deephaven::pureToDeephaven::processAnd(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'-- processing and ' + $vs->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  let debug = $initReq.debug;

  let leftSide = $vs.parametersValues->at(0)->processFilterLambda($operation, $initReq);
  let rightSide = $vs.parametersValues->at(1)->processFilterLambda($operation, $initReq);
  let mergedSQL = ^AndOperatorExpression(expressions=[$leftSide, $rightSide]);
  $mergedSQL;
}


function meta::external::store::deephaven::pureToDeephaven::processOr(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'-- processing or ' + $vs->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  let debug = $initReq.debug;

  let leftSide = $vs.parametersValues->at(0)->processFilterLambda($operation, $initReq);
  let rightSide = $vs.parametersValues->at(1)->processFilterLambda($operation, $initReq);
  let mergedSQL = ^OrOperatorExpression(expressions=[$leftSide, $rightSide]);
  $mergedSQL;
}

function meta::external::store::deephaven::pureToDeephaven::processNot(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'-- processing not ' + $vs->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  let debug = $initReq.debug;

  let innerExpr = processValueSpecification($vs.parametersValues->at(0), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne();
  let mergedSQL = ^NotOperatorExpression(expression = $innerExpr->cast(@FilterExpression));
  $mergedSQL;
}

function meta::external::store::deephaven::pureToDeephaven::processGreaterThan(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'-- processing greater than ' + $vs->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  let debug = $initReq.debug;

  let leftSide = $vs.parametersValues->at(0)->processValueSpecification($operation, $initReq)->toOne();
  let rightSide = $vs.parametersValues->at(1)->processValueSpecification($operation, $initReq)->toOne();
  let mergedSQL = ^ComparisonOperatorExpression(expressions=[$leftSide, $rightSide]);
  $mergedSQL;
}

///////////////////////////////////////////////////////////////////////////////////////// Relation Operation Functions ///////////////////////////////////////////////////////////////////////////////////////////////////////

function meta::external::store::deephaven::pureToDeephaven::processTdsLambda(mapFn:ValueSpecification[1], operation: DeephavenOperationElement[1], initReq: State[1]): JoinCondition[1]
{
   $mapFn->match(
                  [
                     fx:FunctionExpression[1]| let f = $fx->meta::pure::functions::meta::removeAutomap()->cast(@FunctionExpression);
                                               let overrides = [^Pair<meta::pure::metamodel::function::Function<Any>, meta::pure::metamodel::function::Function<{->JoinCondition[1]}>>(first  = equal_Any_MANY__Any_MANY__Boolean_1_,
                                                                                                                                                                                       second = {| ^JoinCondition(
                                                                                                                                                                                                                    leftColumn  = $f.parametersValues->at(0)->cast(@SimpleFunctionExpression).func.name->toOne(),
                                                                                                                                                                                                                    rightColumn = $f.parametersValues->at(1)->cast(@SimpleFunctionExpression).func.name->toOne()
                                                                                                                                                                                                                 );
                                                                                                                                                                                                }
                                                                                                                                                                                      )
                                                               ];
                                               let override = $overrides->filter(o | $o.first == $f.func)->first();
                                               if($override->isNotEmpty(),
                                                    | $override->toOne().second->eval();,
                                                    | fail('function ' + $f.func.name->makeString() + ' is not yet supported');
                                                      ^JoinCondition(leftColumn  = '',rightColumn = '');
                                                 );
                  ]
                );
}

function meta::external::store::deephaven::pureToDeephaven::processSelect(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'Processing -> select');
  let debug = $initReq.debug;

  let currReq = processValueSpecification($vs.parametersValues->at(0), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')));
  let query = $currReq->cast(@DeephavenQuery)->toOne();
  ^$query(selectQueryExists = true);
}

function meta::external::store::deephaven::pureToDeephaven::processTdsRestrict(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'Processing -> select colSpec');
  let debug = $initReq.debug;

  let relAccessor = processValueSpecification($vs.parametersValues->at(0), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')));
  let projectColNames = $vs.parametersValues->at(1)->cast(@InstanceValue).values->match(
                              [
                                s:String[*]|$s,
                                c:meta::pure::metamodel::relation::ColSpecArray<Any>[1]|$c.names,
                                c:meta::pure::metamodel::relation::ColSpec<Any>[1]|$c.name
                              ]
                          );
  let projectAliasNames = $projectColNames;
  let origSelect = $relAccessor->cast(@DeephavenQuery)->toOne();
  let origColumnsByName = $origSelect.operations->filter(o | $o->instanceOf(SelectOperation))->toOne()->cast(@SelectOperation).columns->map(column|
         let name = $column->match([
               c:meta::external::store::deephaven::metamodel::store::Column[1]|$c.name
         ]);
         pair($name, $column);
      );
  let origColumnsByNameAsMap = $origColumnsByName->newMap();
  let newCols = $projectAliasNames->map(aliasName | let origCol = $origColumnsByNameAsMap->get($aliasName); 
                                                    assertNotEmpty($origCol, | 'Failed to find column ' + $aliasName + ' in ' + $origColumnsByNameAsMap->keys()->joinStrings('[', ',', ']')); 
                                                    $origCol->toOne();
                                       );
  let updatedSel = $origSelect.operations->map(o | if($o->instanceOf(SelectOperation),
                                                    | let selectOp = $o->cast(@SelectOperation);
                                                      ^$selectOp(columns = $newCols);,
                                                    | $o));
  ^$origSelect(operations = $updatedSel, selectQueryExists = true);
}

function meta::external::store::deephaven::pureToDeephaven::processFilter(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'Processing -> filter');
  let debug = $initReq.debug;

  let processStore = processValueSpecification($vs.parametersValues->at(0), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne()->cast(@DeephavenQuery);
  let withFilterReq = processFilterLambda($vs.parametersValues->at(1), $processStore, ^$initReq(inFilter = true));
  ^$processStore(operations = $processStore.operations->concatenate(^FilterOperation(condition = $withFilterReq->cast(@FilterExpression))));
}

function meta::external::store::deephaven::pureToDeephaven::processFilterLambda(vs : ValueSpecification[1], operation: DeephavenOperationElement[*], req: State[1]): DeephavenOperationElement[1]
{
  $req.debug(|'-- processing filter lambda ' + $vs->type()->toString() + ': ' + $vs->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  $vs->match([
                fr: FunctionRoutedValueSpecification[1] | $fr.value->processFilterLambda($operation, $req);,
                iv: InstanceValue[1] | $iv.values->match([
                                                          f: FunctionDefinition<Any>[1] | // $f.expressionSequence->at(0)->processFilterLambda($operation, $req);
                                                                                          $req.supportedFilterFunctions->findAndEvalSupportedFunction($f.expressionSequence->at(0)->cast(@FunctionExpression), $operation, $req);
                                                        ]),
                fe: FunctionExpression[1] | $req.supportedFilterFunctions->findAndEvalSupportedFunction($fe, $operation, $req);
  ]);
}

function meta::external::store::deephaven::pureToDeephaven::processSort(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'Processing -> sort');
  let debug = $initReq.debug;

  let processStore = processValueSpecification($vs.parametersValues->at(0), $operation, 
  ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne()->cast(@DeephavenQuery);
  
  let sortInfos = $vs.parametersValues->at(1)->cast(@InstanceValue).values->cast(@SortInfo<Any>);
  let sortColumns = $sortInfos->map(si | ^SortColumn(name = $si.column.name,
                                                     direction = if($si.direction->toString() == 'ASC',
                                                                      | meta::external::store::deephaven::metamodel::SortDirection.ASCENDING,
                                                                      | meta::external::store::deephaven::metamodel::SortDirection.DESCENDING)));
  ^$processStore(operations = $processStore.operations->concatenate(^SortOperation(columns = $sortColumns)));
}

function meta::external::store::deephaven::pureToDeephaven::processJoin(vs : FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'Processing -> join');
  let debug = $initReq.debug;

  let processStore = processValueSpecification($vs.parametersValues->at(0), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne()->cast(@DeephavenQuery);

  let rightTableQuery = processValueSpecification($vs.parametersValues->at(1), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne()->cast(@DeephavenQuery);
  let rightTable = $rightTableQuery.source->toOne();

  let jt = $vs.parametersValues->at(2)->cast(@FunctionExpression).parametersValues;
  let type = extractEnumValue($jt->at(0)->cast(@InstanceValue).values->toOne()->cast(@Enumeration<Any>), $jt->at(1)->cast(@InstanceValue).values->cast(@String)->toOne())->cast(@meta::pure::functions::relation::JoinKind);

  let funcDef = $vs->instanceValuesAtParameter(3, [], [])->cast(@FunctionDefinition<Any>)->toOne();
  let valueSpec = $funcDef.expressionSequence->at(0)->cast(@ValueSpecification);
  let joinConditions = processTdsLambda($valueSpec,$operation,$initReq);

  ^$processStore(operations = $processStore.operations->concatenate(^JoinOperation(
                                                                                    rightTable = $rightTable,
                                                                                    joinType = translateJoinKind($type),
                                                                                    conditions = $joinConditions)));
}

function meta::external::store::deephaven::pureToDeephaven::translateJoinKind(jk:  meta::pure::functions::relation::JoinKind[1]): meta::external::store::deephaven::metamodel::JoinKind[1]
{
  if($jk.name == 'INNER',
      | meta::external::store::deephaven::metamodel::JoinKind.JOIN,
      | if($jk.name == 'LEFT',
            | meta::external::store::deephaven::metamodel::JoinKind.LEFT,
            | if($jk.name == 'RIGHT',
                  | meta::external::store::deephaven::metamodel::JoinKind.RIGHT,
                  | meta::external::store::deephaven::metamodel::JoinKind.OUTER)))
}

///////////////////////////////////////////////////////////////////////////////////////// Numeric Operation Functions ///////////////////////////////////////////////////////////////////////////////////////////////////////

function meta::external::store::deephaven::pureToDeephaven::processNumericOperation(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1], pureFunctionName: String[1], deephavenMethodName: String[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'Processing -> ' + $pureFunctionName);
  let debug = $initReq.debug;

  let methodArguments = $vs.parametersValues->map(p | $p->processValueSpecification($operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t'))));
  ^NumericOperation(methodName = $deephavenMethodName, methodArguments = $methodArguments);
}

function meta::external::store::deephaven::pureToDeephaven::processLog(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'log', 'log');
}

function meta::external::store::deephaven::pureToDeephaven::processLog10(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'log10', 'log10');
}

function meta::external::store::deephaven::pureToDeephaven::processExp(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'exp', 'exp');
}

function meta::external::store::deephaven::pureToDeephaven::processAbs(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'abs', 'abs');
}

function meta::external::store::deephaven::pureToDeephaven::processMod(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'mod', 'floorMod');
}

function meta::external::store::deephaven::pureToDeephaven::processRem(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'rem', 'IEEEremainder');
}

function meta::external::store::deephaven::pureToDeephaven::processSign(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'sign', 'signum');
}

function meta::external::store::deephaven::pureToDeephaven::processCbrt(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'cbrt', 'cbrt');
}

function meta::external::store::deephaven::pureToDeephaven::processPow(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'pow', 'pow');
}

function meta::external::store::deephaven::pureToDeephaven::processSqrt(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'sqrt', 'sqrt');
}

function meta::external::store::deephaven::pureToDeephaven::processCeiling(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'ceiling', 'ceil');
}

function meta::external::store::deephaven::pureToDeephaven::processFloor(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'floor', 'floor');
}

function meta::external::store::deephaven::pureToDeephaven::processRound(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'round', 'round');
}

function meta::external::store::deephaven::pureToDeephaven::processRoundWithScale(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'Processing -> round with scale');
  let debug = $initReq.debug;

  let methodArguments = $vs.parametersValues->map(p | $p->processValueSpecification($operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t'))));
  ^RoundWithScaleOperation(methodArguments = $methodArguments);
}

function meta::external::store::deephaven::pureToDeephaven::processAcos(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'acos', 'acos');
}

function meta::external::store::deephaven::pureToDeephaven::processAsin(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'asin', 'asin');
}

function meta::external::store::deephaven::pureToDeephaven::processAtan(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'atan', 'atan');
}

function meta::external::store::deephaven::pureToDeephaven::processAtan2(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'atan2', 'atan2');
}

function meta::external::store::deephaven::pureToDeephaven::processCos(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'cos', 'cos');
}

function meta::external::store::deephaven::pureToDeephaven::processCot(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'cot', 'cot');
}

function meta::external::store::deephaven::pureToDeephaven::processSin(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'sin', 'sin');
}

function meta::external::store::deephaven::pureToDeephaven::processTan(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'tan', 'tan');
}

function meta::external::store::deephaven::pureToDeephaven::processCosh(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'cosh', 'cosh');
}

function meta::external::store::deephaven::pureToDeephaven::processSinh(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'sinh', 'sinh');
}

function meta::external::store::deephaven::pureToDeephaven::processTanh(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'tanh', 'tanh');
}

function meta::external::store::deephaven::pureToDeephaven::processToDegrees(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'toDegrees', 'toDegrees');
}

function meta::external::store::deephaven::pureToDeephaven::processToRadians(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'toRadians', 'toRadians');
}

function meta::external::store::deephaven::pureToDeephaven::processMedian(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'median', 'median');
}

function meta::external::store::deephaven::pureToDeephaven::processAverage(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'average', 'avg');
}

function meta::external::store::deephaven::pureToDeephaven::processSum(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'sum', 'sum');
}

function meta::external::store::deephaven::pureToDeephaven::processMax(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'max', 'max');
}

function meta::external::store::deephaven::pureToDeephaven::processMin(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'min', 'min');
}

function meta::external::store::deephaven::pureToDeephaven::processPercentile(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'percentile', 'percentile');
}

function meta::external::store::deephaven::pureToDeephaven::processWavg(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'wavg', 'wavg');
}

function meta::external::store::deephaven::pureToDeephaven::processCorr(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'corr', 'cor');
}

function meta::external::store::deephaven::pureToDeephaven::processVariance(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  let params = $vs.parametersValues;
  let isBiasCorrected = $params->at(1)->evaluateAndDeactivate()->cast(@InstanceValue).values->toOne()->cast(@Boolean);
  if($isBiasCorrected,
     | ^$vs(parametersValues = $params->init())->processNumericOperation($operation, $initReq, 'variance', 'var'),
     | fail('Variance population is not supported yet in Deephaven extension'); []->toOne(););
}

function meta::external::store::deephaven::pureToDeephaven::processVarianceSample(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'varianceSample', 'var');
}

function meta::external::store::deephaven::pureToDeephaven::processPlus(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'plus', 'sum');
}

function meta::external::store::deephaven::pureToDeephaven::processMinus(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  let inputSize = $vs.parametersValues->size();
  if([
       pair(| $inputSize == 1,
            | let debug = $initReq.debug;
              let methodArgument = $vs.parametersValues->toOne()->processValueSpecification($operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne();
              ^NegationOperation(methodArgument = $methodArgument);
       )
     ],
     | fail('Minus operations with more than 1 number are not supported yet in Deephaven extension!'); []->toOne();
    );
}

function meta::external::store::deephaven::pureToDeephaven::processTimes(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'times', 'product');
}

function meta::external::store::deephaven::pureToDeephaven::processRange(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $vs->processNumericOperation($operation, $initReq, 'range', 'sequence');
}

function meta::external::store::deephaven::pureToDeephaven::processEvaluate(vs: FunctionExpression[1], operation: DeephavenOperationElement[1], initReq: State[1]): DeephavenOperationElement[1]
{
  $initReq.debug(|'Processing -> evaluate');
  let debug = $initReq.debug;

  if($vs.parametersValues->size() == 1,
      | processValueSpecification($vs.parametersValues->at(0), $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne();,
      | let filterFunctionExpression = $vs.parametersValues->at(0)->byPassRouterInfo()->cast(@InstanceValue).values->at(0)->match(
          [
            f:FunctionDefinition<Any>[1]|
                $f.expressionSequence->at(0),
            n:NativeFunction<Any>[1]|
                ^FunctionExpression
                (
                    func = $n,
                    importGroup = ^ImportGroup(),
                    multiplicity=PureOne,
                    genericType=$n->functionReturnType(),
                    parametersValues = $vs.parametersValues->tail()->evaluateAndDeactivate()
                )->evaluateAndDeactivate();
          ]
        );
        processValueSpecification($filterFunctionExpression, $operation, ^$initReq(debug = ^$debug(space = $debug.space + '\t')))->toOne();
      );
}

///////////////////////////////////////////////////////////////////////////////////////// Supported Functions ///////////////////////////////////////////////////////////////////////////////////////////////////////

function meta::external::store::deephaven::pureToDeephaven::findAndEvalSupportedFunction<P, T | n, m>(funcs: Pair<LambdaFunction<{Function<Any>[1],State[0..1]->Boolean[1]}>, Function<{FunctionExpression[1], DeephavenOperationElement[1], P[n]->T[m]}>>[*], fe : FunctionExpression[1], req: P[n], state: State[1]): T[m]
{
   eval($funcs->filter(x|$x.first->eval($fe.func, $state))->first()->toOne('function not supported yet: ' + $fe.func->elementToPath()).second, $fe, $req, $state);
}

function meta::external::store::deephaven::pureToDeephaven::supportedRoutingFunctions():Pair<LambdaFunction<{Function<Any>[1],State[0..1]->Boolean[1]}>, Function<{FunctionExpression[1],DeephavenOperationElement[1],State[1]->DeephavenOperationElement[1]}>>[*]
{
  let supported = [
    pair(supportedIfEqual(meta::pure::functions::relation::select_Relation_1__Relation_1_),                  processSelect_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::relation::select_Relation_1__ColSpecArray_1__Relation_1_),  processTdsRestrict_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::relation::filter_Relation_1__Function_1__Relation_1_),      processFilter_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::relation::sort_Relation_1__SortInfo_MANY__Relation_1_),     processSort_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::relation::join_Relation_1__Relation_1__JoinKind_1__Function_1__Relation_1_),     processJoin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),

    // Eval functions
    pair(supportedIfEqual(meta::pure::functions::lang::eval_Function_1__T_n__U_p__V_m_),     processEvaluate_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::lang::eval_Function_1__T_n__V_m_),     processEvaluate_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::lang::eval_Function_1__V_m_),     processEvaluate_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),

    pair(supportedIfEqual(meta::pure::functions::math::log_Number_1__Float_1_),     processLog_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::log10_Number_1__Float_1_),     processLog10_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::exp_Number_1__Float_1_),     processExp_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::abs_Integer_1__Integer_1_),     processAbs_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::abs_Number_1__Number_1_),     processAbs_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::abs_Float_1__Float_1_),     processAbs_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::abs_Decimal_1__Decimal_1_),     processAbs_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::mod_Integer_1__Integer_1__Integer_1_),     processMod_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::rem_Number_1__Number_1__Number_1_),     processRem_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::sign_Number_1__Integer_1_),     processSign_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::cbrt_Number_1__Float_1_),     processCbrt_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::pow_Number_1__Number_1__Number_1_),     processPow_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::sqrt_Number_1__Float_1_),     processSqrt_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::ceiling_Number_1__Integer_1_),     processCeiling_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::floor_Number_1__Integer_1_),     processFloor_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::round_Number_1__Integer_1_),     processRound_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::round_Decimal_1__Integer_1__Decimal_1_),     processRoundWithScale_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle round with scale
    pair(supportedIfEqual(meta::pure::functions::math::round_Float_1__Integer_1__Float_1_),     processRoundWithScale_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle round with scale
    pair(supportedIfEqual(meta::pure::functions::math::acos_Number_1__Float_1_),     processAcos_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::asin_Number_1__Float_1_),     processAsin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::atan_Number_1__Float_1_),     processAtan_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::atan2_Number_1__Number_1__Float_1_),     processAtan2_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::cos_Number_1__Float_1_),     processCos_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::cot_Number_1__Float_1_),     processCot_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::sin_Number_1__Float_1_),     processSin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::tan_Number_1__Float_1_),     processTan_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::cosh_Number_1__Float_1_),     processCosh_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::sinh_Number_1__Float_1_),     processSinh_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::tanh_Number_1__Float_1_),     processTanh_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::toDegrees_Number_1__Float_1_),     processToDegrees_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::toRadians_Number_1__Float_1_),     processToRadians_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    // pair(supportedIfEqual(meta::pure::functions::math::pi_Number_1__Float_1_),     processPi_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Static variable in Numeric
    pair(supportedIfEqual(meta::pure::functions::math::median_Integer_MANY__Float_1_),     processMedian_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::median_Float_MANY__Float_1_),     processMedian_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::median_Number_MANY__Float_1_),     processMedian_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    // pair(supportedIfEqual(meta::pure::functions::math::mode_Integer_MANY__Float_1_),     processMode_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    // pair(supportedIfEqual(meta::pure::functions::math::mode_Float_MANY__Float_1_),     processMode_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    // pair(supportedIfEqual(meta::pure::functions::math::mode_Number_MANY__Float_1_),     processMode_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    pair(supportedIfEqual(meta::pure::functions::math::average_Integer_MANY__Float_1_),     processAverage_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::average_Float_MANY__Float_1_),     processAverage_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::average_Number_MANY__Float_1_),     processAverage_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::sum_Integer_MANY__Integer_1_),     processSum_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::sum_Float_MANY__Float_1_),     processSum_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::sum_Number_MANY__Number_1_),     processSum_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::max_Integer_MANY__Integer_$0_1$_),     processMax_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::max_Integer_$1_MANY$__Integer_1_),     processMax_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::max_Float_MANY__Float_$0_1$_),     processMax_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::max_Float_$1_MANY$__Float_1_),     processMax_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::max_Number_MANY__Number_$0_1$_),     processMax_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::max_Number_$1_MANY$__Number_1_),     processMax_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    // pair(supportedIfEqual(meta::pure::functions::math::maxBy_T_MANY__Number_MANY__T_$0_1$_),     processMaxBy_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    // pair(supportedIfEqual(meta::pure::functions::math::maxBy_T_MANY__Number_MANY__Integer_1__T_MANY_),     processMaxBy_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    // pair(supportedIfEqual(meta::pure::functions::math::maxBy_RowMapper_MANY__T_$0_1$_),     processMaxBy_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    // pair(supportedIfEqual(meta::pure::functions::math::maxBy_RowMapper_MANY__Integer_1__T_MANY_),     processMaxBy_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    pair(supportedIfEqual(meta::pure::functions::math::min_Integer_MANY__Integer_$0_1$_),     processMin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::min_Integer_$1_MANY$__Integer_1_),     processMin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::min_Float_MANY__Float_$0_1$_),     processMin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::min_Float_$1_MANY$__Float_1_),     processMin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::min_Number_MANY__Number_$0_1$_),     processMin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::min_Number_$1_MANY$__Number_1_),     processMin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    // pair(supportedIfEqual(meta::pure::functions::math::minBy_T_MANY__Number_MANY__T_$0_1$_),     processMinBy_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    // pair(supportedIfEqual(meta::pure::functions::math::minBy_T_MANY__Number_MANY__Integer_1__T_MANY_),     processMinBy_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    // pair(supportedIfEqual(meta::pure::functions::math::minBy_RowMapper_MANY__T_$0_1$_),     processMinBy_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    // pair(supportedIfEqual(meta::pure::functions::math::minBy_RowMapper_MANY__Integer_1__T_MANY_),     processMinBy_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    pair(supportedIfEqual(meta::pure::functions::math::percentile_Number_MANY__Float_1__Number_$0_1$_),     processPercentile_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    // pair(supportedIfEqual(meta::pure::functions::math::percentile_Number_MANY__Float_1__Boolean_1__Boolean_1__Number_$0_1$_),     processMin_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    pair(supportedIfEqual(meta::pure::functions::math::wavg_Number_MANY__Number_MANY__Float_1_),     processWavg_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    // pair(supportedIfEqual(meta::pure::functions::math::wavg_RowMapper_MANY__Float_1_),     processWavg_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    // pair(supportedIfEqual(meta::pure::functions::math::mathUtility::rowMapper_T_$0_1$__U_$0_1$__RowMapper_1_),     processWavg_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    // pair(supportedIfEqual(meta::pure::functions::math::wavgUtility::wavgRowMapper_Number_$0_1$__Number_$0_1$__WavgRowMapper_1_),     processWavg_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    pair(supportedIfEqual(meta::pure::functions::math::corr_Number_MANY__Number_MANY__Number_$0_1$_),     processCorr_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    // pair(supportedIfEqual(meta::pure::functions::math::corr_RowMapper_MANY__Number_$0_1$_),     processCorr_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    // pair(supportedIfEqual(meta::pure::functions::math::covarPopulation_Number_MANY__Number_MANY__Number_$0_1$_),     processCovarPopulation_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    // pair(supportedIfEqual(meta::pure::functions::math::covarPopulation_RowMapper_MANY__Number_$0_1$_),     processCovarPopulation_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    // pair(supportedIfEqual(meta::pure::functions::math::covarSample_Number_MANY__Number_MANY__Number_$0_1$_),     processCovarSample_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    // pair(supportedIfEqual(meta::pure::functions::math::covarSample_RowMapper_MANY__Number_$0_1$_),     processCovarSample_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Handle RowMapper
    // pair(supportedIfEqual(meta::pure::functions::math::stdDevSample_Number_MANY__Number_1_),     processStdDevSample_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not stopping routing at stdDevSample
    // pair(supportedIfEqual(meta::pure::functions::math::stdDevPopulation_Number_MANY__Number_1_),     processStdDevPopulation_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    pair(supportedIfEqual(meta::pure::functions::math::variance_Number_MANY__Boolean_1__Number_1_),     processVariance_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::varianceSample_Number_MANY__Number_1_),     processVarianceSample_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    // pair(supportedIfEqual(meta::pure::functions::math::variancePopulation_Number_MANY__Number_1_),     processCorr_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of Numeric
    pair(supportedIfEqual(meta::pure::functions::math::plus_Float_MANY__Float_1_),     processPlus_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::plus_Integer_MANY__Integer_1_),     processPlus_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::plus_Number_MANY__Number_1_),     processPlus_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::plus_Decimal_MANY__Decimal_1_),     processPlus_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::minus_Float_MANY__Float_1_),     processMinus_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::minus_Integer_MANY__Integer_1_),     processMinus_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::minus_Number_MANY__Number_1_),     processMinus_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::minus_Decimal_MANY__Decimal_1_),     processMinus_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::times_Float_MANY__Float_1_),     processTimes_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::times_Integer_MANY__Integer_1_),     processTimes_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::times_Number_MANY__Number_1_),     processTimes_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    pair(supportedIfEqual(meta::pure::functions::math::times_Decimal_MANY__Decimal_1_),     processTimes_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
    // pair(supportedIfEqual(meta::pure::functions::math::divide_Number_1__Number_1__Float_1_),     processTan_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of numeric
    // pair(supportedIfEqual(meta::pure::functions::math::divide_Decimal_1__Decimal_1__Integer_1__Decimal_1_),     processTan_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_), // TODO: Not part of numeric
    pair(supportedIfEqual(meta::pure::functions::collection::range_Integer_1__Integer_1__Integer_1__Integer_MANY_),     processRange_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_)
  ];
}

function meta::external::store::deephaven::pureToDeephaven::supportedFilterFunctions():Pair<LambdaFunction<{Function<Any>[1],State[1]->Boolean[1]}>, Function<{FunctionExpression[1],DeephavenOperationElement[1],State[1]->DeephavenOperationElement[1]}>>[*]
{
  let supported = [
     pair(supportedIfEqual(meta::pure::functions::boolean::equal_Any_MANY__Any_MANY__Boolean_1_),       processEqual_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
     pair(supportedIfEqual(meta::pure::functions::collection::in_Any_1__Any_MANY__Boolean_1_),          processIn_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
     pair(supportedIfEqual(meta::pure::functions::boolean::and_Boolean_1__Boolean_1__Boolean_1_),       processAnd_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
     pair(supportedIfEqual(meta::pure::functions::boolean::or_Boolean_1__Boolean_1__Boolean_1_),        processOr_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
     pair(supportedIfEqual(meta::pure::functions::boolean::not_Boolean_1__Boolean_1_),                  processNot_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
     pair(supportedIfEqual(meta::pure::functions::boolean::greaterThan_Number_1__Number_1__Boolean_1_), processGreaterThan_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_),
     pair(supportedIfEqual(meta::pure::functions::boolean::greaterThan_Date_1__Date_1__Boolean_1_),     processGreaterThan_FunctionExpression_1__DeephavenOperationElement_1__State_1__DeephavenOperationElement_1_)
  ]
}


///////////////////////////////////////////////////////////////////////////////////////// Helper Functions ///////////////////////////////////////////////////////////////////////////////////////////////////////

function meta::external::store::deephaven::pureToDeephaven::supportedIfEqual(func: Function<Any>[1]):LambdaFunction<{Function<Any>[1],State[0..1]->Boolean[1]}>[1]
{
  {x: Function<Any>[1], req: State[0..1] | $x == $func}
}

function meta::external::store::deephaven::pureToDeephaven::supportedSimpleValueFunctions(): Pair<LambdaFunction<{Function<Any>[1],  State[1]->Boolean[1]}>, Function<{FunctionExpression[1],  State[1]->Pair<List<Any>, State>[1]}>>[*]
{
  let supported = [
    pair({x: Function<Any>[1], req: State[1] | $req.inProject}, passthruForPainlessExpression_FunctionExpression_1__State_1__Pair_1_)
  ];
}

function meta::external::store::deephaven::pureToDeephaven::passthruForPainlessExpression(fe: FunctionExpression[1], req: State[1]): Pair<List<Any>, State>[1]
{
  $req.debug(|'Passthru for painless: ' + $fe->printValueSpecification(^meta::pure::metamodel::serialization::grammar::GContext(space='\n')));
  assert($req.inProject, |'Evaluation as runtime mapping expression only supported on project context');
  pair(list($fe), $req);
}