// Copyright 2026 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::store::*;
import meta::external::store::deephaven::grammar::serialization::*;

function meta::external::store::deephaven::grammar::serialization::printDeephavenStore(deephavenStore:meta::external::store::deephaven::metamodel::store::DeephavenStore[1]):String[1]
{
  'Deephaven ' + $deephavenStore->elementToPath() + '\n' +
  '(\n' +
    $deephavenStore.tables->map(t | $t->printDeephavenTable('  '))->joinStrings('\n') +
  ')\n';
}

function meta::external::store::deephaven::grammar::serialization::printDeephavenTable(deephavenTable:meta::external::store::deephaven::metamodel::store::Table[1], indent:String[1]):String[1]
{
  $indent + 'Table ' + escapeIdentifier($deephavenTable.name) + '\n' +
  $indent + '(\n' +
    $deephavenTable.columns->map(c | $c->printDeephavenColumn($indent + '  '))->joinStrings(',\n') + '\n' +
  $indent + ')\n';
}

function meta::external::store::deephaven::grammar::serialization::printDeephavenColumn(deephavenColumn:meta::external::store::deephaven::metamodel::store::Column[1], indent:String[1]):String[1]
{
  $indent + $deephavenColumn.name + ': ' + $deephavenColumn.type->deephavenTypeToSqlText()
}

function meta::external::store::deephaven::grammar::serialization::escapeIdentifier(name:String[1]):String[1]
{
  if ($name->contains(' ') && !$name->startsWith('"'), | '"' + $name + '"', | $name);
}

function meta::external::store::deephaven::grammar::serialization::deephavenTypeToSqlText(type:meta::external::store::deephaven::metamodel::type::Type[1]):String[1] // DeephavenTypeToString
{
  $type->match([
      b : meta::external::store::deephaven::metamodel::type::BooleanType[1] | 'Boolean',
      i : meta::external::store::deephaven::metamodel::type::IntType[1] | 'Integer',
      l : meta::external::store::deephaven::metamodel::type::LongType[1] | 'Integer',
      f : meta::external::store::deephaven::metamodel::type::FloatType[1] | 'Float',
      d : meta::external::store::deephaven::metamodel::type::DoubleType[1] | 'Float',
      s : meta::external::store::deephaven::metamodel::type::StringType[1] | 'String',
      d : meta::external::store::deephaven::metamodel::type::DateTimeType[1] | 'DateTime',
      t : meta::external::store::deephaven::metamodel::type::Type[1] | fail('Other types are not supported yet!'); '';
  ]);
}

function meta::external::store::deephaven::grammar::serialization::printDeephavenConnection(connection:meta::external::store::deephaven::metamodel::runtime::DeephavenConnection[1]):String[1]
{
  '^meta::external::store::deephaven::metamodel::runtime::DeephavenConnection(' +
  'authSpec = ' + $connection.authSpec->meta::pure::metamodel::serialization::grammar::printNew() + ',' +
  'sourceSpec = ' + $connection.sourceSpec->meta::pure::metamodel::serialization::grammar::printNew() +
  ')';
}

function meta::external::store::deephaven::grammar::serialization::deephavenGrammarExtension():meta::pure::metamodel::serialization::grammar::GrammarExtension[1]
{
    ^meta::pure::metamodel::serialization::grammar::GrammarExtension(
        extraConnectionHandlers =
          [
            x:meta::external::store::deephaven::metamodel::runtime::DeephavenConnection[0..1] |
                $x->toOne()->printDeephavenConnection();
          ],
        extraInstanceValueHandlers = 
          [
            x:RelationStoreAccessor<Any>[1]|
              let table = $x.sourceElement->cast(@meta::external::store::deephaven::metamodel::store::Table);  
              '#>{' + $x.store->elementToPath() + '.' + $table.name + '}#';
              
            // t:meta::pure::metamodel::relation::TDS<Any>[1]|'#TDS{\n'+$t.csv->regexpReplace('\n\\s+', '\n', true)->regexpReplace(',\\s*+', ',', true)+'}#';
          ],
        extraPackageableElementHandlers =
          [
            s:meta::external::store::deephaven::metamodel::store::DeephavenStore[1] |'###Deephaven\n' + $s->printDeephavenStore()
          ]
    );
}