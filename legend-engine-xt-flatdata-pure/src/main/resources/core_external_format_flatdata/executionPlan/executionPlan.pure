// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::format::flatdata::binding::validation::*;
import meta::external::format::flatdata::executionPlan::*;
import meta::external::format::flatdata::executionPlan::engine::*;
import meta::external::format::flatdata::metamodel::*;
import meta::external::format::flatdata::runtime::*;
import meta::external::language::java::factory::*;
import meta::external::language::java::factory::project::*;
import meta::external::language::java::metamodel::*;
import meta::external::language::java::metamodel::project::*;
import meta::external::language::java::transform::*;
import meta::external::shared::format::binding::*;
import meta::external::shared::format::binding::validation::*;
import meta::external::shared::format::executionPlan::*;
import meta::external::shared::format::executionPlan::engine::*;
import meta::external::shared::format::metamodel::*;
import meta::external::shared::runtime::*;
import meta::pure::executionPlan::*;
import meta::pure::executionPlan::engine::*;
import meta::pure::executionPlan::engine::java::*;
import meta::pure::executionPlan::engine::java::naming::*;
import meta::pure::executionPlan::engine::java::typeInfo::*;
import meta::pure::executionPlan::toString::*;
import meta::pure::graphFetch::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::extension::*;
import meta::pure::runtime::*;

Class meta::external::format::flatdata::executionPlan::FlatDataSerializeExecutionNode extends ExternalFormatSerializeExecutionNode
{
}

Class meta::external::format::flatdata::executionPlan::FlatDataDeserializeExecutionNode extends ExternalFormatDeserializeExecutionNode
{
   binding : Binding[1];
   tree    : RootGraphFetchTree<Any>[0..1]; 
}

function meta::external::format::flatdata::executionPlan::generateSerializeNode(checked:Boolean[1], binding:Binding[1], children:ExecutionNode[*]): ExternalFormatSerializeExecutionNode[1]
{
   ^FlatDataSerializeExecutionNode(
      resultType      = ^ResultType(type=String),
      resultSizeRange = PureOne,
      checked         = $checked,
      binding         = $binding,
      executionNodes  = $children
   );
}

function meta::external::format::flatdata::executionPlan::generateDeserializeNode(connection:Connection[1], children:ExecutionNode[1], tree:RootGraphFetchTree<Any>[0..1]): ExecutionNode[1]
{
   assert($tree->isNotEmpty(), 'Deserialization without Graph Fetch Tree not yet supported');
   let returnedClass = $tree.class->toOne();
   
   ^FlatDataDeserializeExecutionNode(
      resultType      = ^PartialClassResultType(
                           type=$returnedClass,
                           propertiesWithParameters = $tree.subTrees->cast(@PropertyGraphFetchTree)->map(x | $x->map(x | ^PropertyWithParameters(property = $x.property, parameters = $x.parameters)))
                        ),
      resultSizeRange = ZeroMany,
      tree            = $tree,
      binding         = $connection->cast(@ExternalFormatConnection).element->cast(@Binding),
      executionNodes  = $children
   );
}

function meta::external::format::flatdata::executionPlan::printPlanNodeToString(space:String[1], extensions:Extension[*]): Function<{Nil[1]->String[1]}>[*]
{
   [
      {node:FlatDataSerializeExecutionNode[1] |
         'FlatData_Serialize\n' + 
         $space + '(' + header($node, $space, $extensions) + '\n' +
         $space + '  checked = ' + $node.checked->toString() + '\n' +
         $space + '  binding = ' + $node.binding->elementToPath() + '\n' +
         $node->childrenToString($space+'  ', $extensions) + '\n' +
         $node.implementation->printImplementation('implementation', $space+'  ', $extensions) +
         $space + ')\n'
      },
      {node:FlatDataDeserializeExecutionNode[1] |
         'FlatData_Deserialize\n' + 
         $space + '(' + header($node, $space, $extensions) + '\n' +
         $space + '  binding = ' + $node.binding->elementToPath() + '\n' +
         $node->childrenToString($space+'  ', $extensions) + '\n' +
         $node.implementation->printImplementation('implementation', $space+'  ', $extensions) +
         $space + ')\n'
      }
   ]
}

function meta::external::format::flatdata::executionPlan::planJavaPrepare(path:String[1], context:GenerationContext[1], extensions:Extension[*], debug:DebugContext[1]): Function<{Nil[1]->GenerationContext[1]}>[*]
{
   [
      node:FlatDataSerializeExecutionNode[1]   | prepareForSerialize($node, $path, $context, $extensions, $debug),
      node:FlatDataDeserializeExecutionNode[1] | prepareForDeserialize($node, $path, $context, $extensions, $debug)
   ]
}

function meta::external::format::flatdata::executionPlan::planJavaGenerate(path:String[1], context:GenerationContext[1], extensions:Extension[*], debug:DebugContext[1]): Function<{Nil[1]->GeneratedCode[1]}>[*]
{
   [
       node:FlatDataSerializeExecutionNode[1]   | generateForSerialize($node, $path, $context, $extensions, $debug),
       node:FlatDataDeserializeExecutionNode[1] | generateForDeserialize($node, $path, $context, $extensions, $debug)
   ]
}

Class <<access.private>> meta::external::format::flatdata::executionPlan::SerializeData
{
   bindingDetail : FlatDataBindingDetail[1];
   classIn       : meta::pure::metamodel::type::Class<Any>[1];
}

function <<access.private>> meta::external::format::flatdata::executionPlan::prepareForSerialize(node:FlatDataSerializeExecutionNode[1], path:String[1], context:GenerationContext[1], extensions:Extension[*], debug:DebugContext[1]): GenerationContext[1]
{
   print(if($debug.debug,|$debug.space+'('+$path+') prepare FlatDataSerializeExecutionNode\n', |''));
   
   let bindingDetail = bindDetails($node.binding->cast(@Binding));
   assert($bindingDetail->instanceOf(FlatDataBindingDetail), | 'Detailed binding failed: ' + $bindingDetail->cast(@FailedBindingDetail).errorMessages->joinStrings('\n'));
   
   let classIn = $node.executionNodes.resultType->match([
      c:ClassResultType[1] | $c.setImplementations.class->toOne()
   ]);

   let newTypeInfos = $context.typeInfos->addForClasses($node.binding->cast(@Binding).modelUnit->meta::pure::model::unit::resolve().classes);

   let nodeInfo = ^NodeInfo(
      path            = $path, 
      returnType      = ^SimpleJavaType(pureType=String, javaType=javaString()), 
      data            = ^SerializeData(
                           bindingDetail = $bindingDetail->cast(@FlatDataBindingDetail),
                           classIn       = $classIn
                        )
   );
   
   $context
      ->setTypeInfos($newTypeInfos)
      ->addNodeInfo($nodeInfo);
}

function <<access.private>> meta::external::format::flatdata::executionPlan::prepareForDeserialize(node:FlatDataDeserializeExecutionNode[1], path:String[1], context:GenerationContext[1], extensions:Extension[*], debug:DebugContext[1]): GenerationContext[1]
{
   print(if($debug.debug,|$debug.space+'('+$path+') prepare FlatDataDeserializeExecutionNode\n', |''));

   let conventions   = $context.conventions;
   let bindingDetail = bindDetails($node.binding);
   assert($bindingDetail->instanceOf(FlatDataBindingDetail), | 'Detailed binding failed: ' + $bindingDetail->cast(@FailedBindingDetail).errorMessages->joinStrings('\n'));

   assert($node.tree->isNotEmpty(), |'Use case without graph fetch tree not yet supported');
   let class       = $node.tree->toOne().class;
   let simpleType  = ^SimpleJavaType(pureType=$class, javaType=$conventions->className($class));
   let returnType  = ^CheckedJavaType(checkedOf=$simpleType, source=^SimpleJavaType(pureType=RawFlatData, javaType=$conventions->className(RawFlatData)));
   
   let newTypeInfos = $context.typeInfos
                         ->addForGraphFetchTree($node.tree->toOne())
                         ->addForClassWithAllProperties(RawFlatData);

   let nodeInfo = ^NodeInfo(
      path            = $path, 
      returnType      = $returnType, 
      graphFetchTrees = #{RawFlatData {number, lineNumber, record, recordValues {address, rawValue}}}#,
      data            = $bindingDetail
   );

   
   $context
      ->setTypeInfos($newTypeInfos)
      ->addNodeInfo($nodeInfo);
}

function <<access.private>> meta::external::format::flatdata::executionPlan::generateForSerialize(node:FlatDataSerializeExecutionNode[1], path:String[1], context:GenerationContext[1], extensions:Extension[*], debug:DebugContext[1]): GeneratedCode[1]
{
   print(if($debug.debug,|$debug.space+'('+$path+') generate FlatDataSerializeExecutionNode\n', |''));

   let specificsClass  = createSerializeSpecificsClass($node, $path, $context);
   newProject()->addClasses($specificsClass)->generatedCode($specificsClass);
}

Class <<access.private>> meta::external::format::flatdata::executionPlan::ParsedFlatDataCodes
{
   hasStringValue     : Pair<Code,Code>[*];
   hasBooleanValue    : Pair<Code,Code>[*];
   hasLongValue       : Pair<Code,Code>[*];
   hasDoubleValue     : Pair<Code,Code>[*];
   hasBigDecimalValue : Pair<Code,Code>[*];
   hasLocalDateValue  : Pair<Code,Code>[*];
   hasInstantValue    : Pair<Code,Code>[*];
   getString          : Pair<Code,Code>[*];
   getBoolean         : Pair<Code,Code>[*];
   getLong            : Pair<Code,Code>[*];
   getDouble          : Pair<Code,Code>[*];
   getBigDecimal      : Pair<Code,Code>[*];
   getLocalDate       : Pair<Code,Code>[*];
   getInstant         : Pair<Code,Code>[*];
}

function <<access.private>> meta::external::format::flatdata::executionPlan::createSerializeSpecificsClass(node:FlatDataSerializeExecutionNode[1], path:String[1], context:GenerationContext[1]): meta::external::language::java::metamodel::Class[1]
{   
   let conventions   = $context.conventions;
   let serializeData = $context->nodeInfosForPath($path).data->toOne()->cast(@SerializeData);
   let rootInterface = $conventions->className($serializeData.classIn);
   let contextType   = javaParameterizedType($conventions->className(_FlatDataContext), $rootInterface);
   let factoryType   = javaParameterizedType($conventions->className(_ObjectToParsedFlatData), $rootInterface);
   let schemaSet     = $node.binding->cast(@Binding).schemaSet->toOne();
   let flatData      = $schemaSet.schemas->at(0).detail->cast(@FlatData);

   $context.conventions->planNodeClass('public', $path, 'FlatDataSerializeSpecifics')
      ->implements(javaParameterizedType($conventions->className(_IFlatDataSerializeExecutionNodeSpecifics), $rootInterface))
      ->addSectionMethods($flatData, $conventions)
      ->addMethods({cls|
         $flatData.sections->filter(s| $s.recordType->isNotEmpty())->map({section|
            /*
             * It may seem odd that the factory accepts a recordType when the recordType is already known.
             * This happens because the implementation passed at runtime can include driver-specific 
             * optimizations so when creating objects we use the driver-supplied record type details
             * to interrogate the parsed data values.
             */
            let recordTypeParam = j_parameter($conventions->className(_FlatDataRecordType), 'recordType');
            let fields          = $section.recordType.fields;
            let fieldVars       = createFieldVars($fields, $recordTypeParam, $conventions);
            let objectParam     = j_parameter($rootInterface, 'value');
            let fieldParam      = j_parameter($conventions->className(_FlatDataRecordField), 'field');
         
            let sectionBindingDetail = $serializeData.bindingDetail.sectionBindingDetails->filter(sc| $sc.section == $section)->toOne();
            let parsedFlatDataCodes  = $fields->toIndexed()->fold(
               {indexedField, codes|
                  let fieldVar     = $fieldVars->at($indexedField.first).first;
                  let property     = $sectionBindingDetail.details->filter(c| $c.field == $indexedField.second).property->toOne();
                  let propOptional = !$property.multiplicity->hasLowerBound();
                  let propType     = $property->functionReturnType().rawType->toOne();
                  let propJavaType = $conventions->pureTypeToJavaType($property);
                  let fieldTest    = $fieldParam->j_invoke('equals', $fieldVar);
                  let getter       = $objectParam->j_invoke($conventions->getterName($property), [], $propJavaType);

                  if($propType == String,
                     | ^$codes(
                         hasStringValue += pair($fieldTest, j_return(if($propOptional, |$getter->j_ne(j_null()), |j_true()))),
                         getString      += pair($fieldTest, j_return($getter))
                       ),
                     |
                  if($propType == Boolean,
                     | ^$codes(
                         hasBooleanValue += pair($fieldTest, j_return(if($propOptional, |$getter->j_ne(j_null()), |j_true()))),
                         getBoolean      += pair($fieldTest, j_return($getter))
                       ),
                     |
                  if($propType == Integer,
                     | ^$codes(
                         hasLongValue += pair($fieldTest, j_return(if($propOptional, |$getter->j_ne(j_null()), |j_true()))),
                         getLong      += pair($fieldTest, j_return($getter))
                       ),
                     | 
                  if($propType == Float,
                     | ^$codes(
                         hasDoubleValue += pair($fieldTest, j_return(if($propOptional, |$getter->j_ne(j_null()), |j_true()))),
                         getDouble      += pair($fieldTest, j_return($getter))
                       ),
                     | 
                  if($propType == Decimal,
                     | ^$codes(
                         hasBigDecimalValue += pair($fieldTest, j_return(if($propOptional, |$getter->j_ne(j_null()), |j_true()))),
                         getBigDecimal      += pair($fieldTest, j_return($getter))
                       ),
                     | 
                  if($propType == StrictDate,
                     | ^$codes(
                         hasLocalDateValue += pair($fieldTest, j_return(if($propOptional, |$getter->j_ne(j_null()), |j_true()))),
                         getLocalDate      += pair($fieldTest, j_return($getter->j_invoke('toLocalDate', [], javaLocalDate())))
                       ),
                     | 
                  if($propType == DateTime,
                     | ^$codes(
                         hasInstantValue += pair($fieldTest, j_return(if($propOptional, |$getter->j_ne(j_null()), |j_true()))),
                         getInstant      += pair($fieldTest, j_return($getter->j_invoke('toInstant', [], javaInstant())))
                       ),
                     | fail('Unknown type'); $codes;
                  )))))));
               },
               ^ParsedFlatDataCodes()
            );

            let anonParsedFlatData = j_newAnon($conventions->className(_ParsedFlatData), [], 
               [
                  j_method('public', javaBoolean(),    'hasStringValue',     $fieldParam, codeHasValue($parsedFlatDataCodes.hasStringValue)),
                  j_method('public', javaBoolean(),    'hasBooleanValue',    $fieldParam, codeHasValue($parsedFlatDataCodes.hasBooleanValue)),
                  j_method('public', javaBoolean(),    'hasLongValue',       $fieldParam, codeHasValue($parsedFlatDataCodes.hasLongValue)),
                  j_method('public', javaBoolean(),    'hasDoubleValue',     $fieldParam, codeHasValue($parsedFlatDataCodes.hasDoubleValue)),
                  j_method('public', javaBoolean(),    'hasBigDecimalValue', $fieldParam, codeHasValue($parsedFlatDataCodes.hasBigDecimalValue)),
                  j_method('public', javaBoolean(),    'hasLocalDateValue',  $fieldParam, codeHasValue($parsedFlatDataCodes.hasLocalDateValue)),
                  j_method('public', javaBoolean(),    'hasInstantValue',    $fieldParam, codeHasValue($parsedFlatDataCodes.hasInstantValue)),
                  j_method('public', javaString(),     'getString',          $fieldParam, codeGetValue($parsedFlatDataCodes.getString,     $fieldParam, 'String')),
                  j_method('public', javaBoolean(),    'getBoolean',         $fieldParam, codeGetValue($parsedFlatDataCodes.getBoolean,    $fieldParam, 'boolean')),
                  j_method('public', javaLong(),       'getLong',            $fieldParam, codeGetValue($parsedFlatDataCodes.getLong,       $fieldParam, 'long')),
                  j_method('public', javaDouble(),     'getDouble',          $fieldParam, codeGetValue($parsedFlatDataCodes.getDouble,     $fieldParam, 'double')),
                  j_method('public', javaBigDecimal(), 'getBigDecimal',      $fieldParam, codeGetValue($parsedFlatDataCodes.getBigDecimal, $fieldParam, 'BigDecimal')),
                  j_method('public', javaLocalDate(),  'getLocalDate',       $fieldParam, codeGetValue($parsedFlatDataCodes.getLocalDate,  $fieldParam, 'LocalDate')),
                  j_method('public', javaInstant(),    'getInstant',         $fieldParam, codeGetValue($parsedFlatDataCodes.getInstant,    $fieldParam, 'Instant'))
               ]
            );

            let anonFactory = j_newAnon($factoryType, [], 
               j_method('public', $conventions->className(_ParsedFlatData), 'make', $objectParam,
                  j_return($anonParsedFlatData)
               )
            );
         
            javaMethod('public', $factoryType, $section->sectionFactoryMethodName(), $recordTypeParam,                      
                $fieldVars.second->concatenate(j_return($anonFactory))
            );
         });
      })
      ->addMethod({cls |
         let schemaVar            = j_variable($conventions->className(_FlatData), 'schema');
         let newContext           = j_new($contextType, [$schemaVar, j_string($schemaSet->elementToPath())]);
         let contextWithFactories = $flatData.sections->fold(
                                       {section, code| 
                                          let factoryRef = j_this($cls)->j_methodReference($section->sectionFactoryMethodName(), javaFunctionType($conventions->className(_FlatDataRecordType), $conventions->className(_ParsedFlatDataToObject)));
                                          $code->j_invoke('withSectionFromObjectFactory', [j_string($section.name), $factoryRef]);
                                       }, 
                                       $newContext
                                    );
         
         javaMethod('public', $contextType, 'createContext', [], 
             [
                $schemaVar->j_declare($cls->createSchema($flatData, $conventions)),
                j_return($contextWithFactories)
             ]  
         );
      });
}

function <<access.private>> meta::external::format::flatdata::executionPlan::codeHasValue(clauses:Pair<Code,Code>[*]): Code[1]
{
   if($clauses->isEmpty(),
      | j_return(j_false()),
      | j_if(list($clauses), j_return(j_false()))
   );
}

function <<access.private>> meta::external::format::flatdata::executionPlan::codeGetValue(clauses:Pair<Code,Code>[*], fieldParam:Code[1], type:String[1]): Code[1]
{
   let throw = j_throw(j_new(javaIllegalArgumentException(), j_string('Cannot get ' + $type + ' value for field \'')->j_plus($fieldParam->j_invoke('getLabel', []))->j_plus(j_string('\''))));
   if($clauses->isEmpty(),
      | $throw,
      | j_if(list($clauses), $throw)
   );
}

function <<access.private>> meta::external::format::flatdata::executionPlan::generateForDeserialize(node:FlatDataDeserializeExecutionNode[1], path:String[1], context:GenerationContext[1], extensions:Extension[*], debug:DebugContext[1]): GeneratedCode[1]
{
   print(if($debug.debug,|$debug.space+'('+$path+') generate FlatDataDeserializeExecutionNode\n', |''));
   
   let bindingDetail   = $context->nodeInfosForPath($path).data->toOne()->cast(@FlatDataBindingDetail);
   let readableClasses = $bindingDetail.sectionBindingDetails.class;
   let project         = $readableClasses->createDataClassesProject($path, $context, $debug->indent());
   let schemaDataClass = $bindingDetail.schemaBindingDetail.class->map(c| $c->createSchemaDataClass($path, $context, $debug->indent()));
   let specificsClass  = createDeserializeSpecificsClass($node, $path, $context);

   $project
      ->addClasses($specificsClass)
      ->concatenate($schemaDataClass)
      ->toOneMany()->mergeProjects()
      ->generatedCode($specificsClass);
}

function <<access.private>> meta::external::format::flatdata::executionPlan::createDeserializeSpecificsClass(node:FlatDataDeserializeExecutionNode[1], path:String[1], context:GenerationContext[1]): meta::external::language::java::metamodel::Class[1]
{   
   let conventions             = $context.conventions;
   let bindingDetail           = $context->nodeInfosForPath($path).data->toOne()->cast(@FlatDataBindingDetail);
   let rootClass               = $node.tree->toOne().class;   
   let rootInterface           = $conventions->className($rootClass);
   let contextType             = javaParameterizedType($conventions->className(_FlatDataContext), $rootInterface);
   let factoryType             = javaParameterizedType($conventions->className(_ParsedFlatDataToObject), $rootInterface);
   let schemaSet               = $node.binding.schemaSet->toOne();
   let flatData                = $schemaSet.schemas->at(0).detail->cast(@FlatData);
   let maximumSchemaObjectSize = javaField('private', javaLong(), 'maximumSchemaObjectSize', j_long(0));

   $context.conventions->planNodeClass('public', $path, 'FlatDataDeserializeSpecifics')
      ->implements(javaParameterizedType($conventions->className(_IFlatDataDeserializeExecutionNodeSpecifics), $rootInterface))
      ->addField($maximumSchemaObjectSize)
      ->addMethod({cls|
         let param = j_parameter(javaLong(), 'maximumSchemaObjectSize');
         
         javaMethod('public', javaVoid(), 'setMaximumSchemaObjectSize', $param, j_this($cls)->j_field($maximumSchemaObjectSize)->j_assign($param));
      })
      ->addSectionMethods($flatData, $conventions)
      ->addMethods({cls|
         $flatData.sections->filter(s| $s.recordType->isNotEmpty())->map({section|
            /*
             * It may seem odd that the factory accepts a recordType when the recordType is already known.
             * This happens because the implementation passed at runtime can include driver-specific 
             * optimizations so when creating objects we use the driver-supplied record type details
             * to interrogate the parsed data values.
             */
            let recordTypeParam      = j_parameter($conventions->className(_FlatDataRecordType), 'recordType');         
            let sectionBindingDetail = $bindingDetail.sectionBindingDetails->filter(sc| $sc.section == $section)->toOne();
            let dataClass            = $conventions->dataClass($sectionBindingDetail.class, $path);
            let classTypeInfo        = $context.typeInfos->forClass($sectionBindingDetail.class);
            
            let fields               = $section.recordType.fields->filter(f| $classTypeInfo.properties->contains($sectionBindingDetail->propertyForField($f)));
            let fieldVars            = createFieldVars($fields, $recordTypeParam, $conventions);

            let adderVars            = $fields->toIndexed()->map({indexedField|
               let property  = $sectionBindingDetail.details->filter(c| $c.field == $indexedField.second).property->toOne();
               let propType  = $property->functionReturnType().rawType->toOne();
               let adderType = if($propType->instanceOf(meta::pure::metamodel::type::Enumeration),
                                  | javaParameterizedType($conventions->className(_ExternalDataObjectAdder), [$dataClass, $conventions->className($propType)]),
                                  |
                               if($propType == String,
                                  | javaParameterizedType($conventions->className(_ExternalDataObjectAdder), [$dataClass, javaString()]),
                                  |
                               if($propType == Boolean,
                                  | javaParameterizedType($conventions->className(_ExternalDataBooleanAdder), $dataClass),
                                  |
                               if($propType == Integer,
                                  | javaParameterizedType($conventions->className(_ExternalDataLongAdder), $dataClass),
                                  | 
                               if($propType == Float,
                                  | javaParameterizedType($conventions->className(_ExternalDataDoubleAdder), $dataClass),
                                  | 
                               if($propType == Decimal,
                                  | javaParameterizedType($conventions->className(_ExternalDataObjectAdder), [$dataClass, javaBigDecimal()]),
                                  | 
                               if($propType == StrictDate || $propType == DateTime,
                                  | javaParameterizedType($conventions->className(_ExternalDataObjectAdder), [$dataClass, javaTemporal()]),
                                  | fail('Unknown type'); javaVoid();
                               )))))));
               
               let var       = j_variable($adderType, 'adder' + $indexedField.first->toString());                                                            
               let declare   = $var->j_declare($dataClass->j_invoke('_getAdderForProperty', j_string($property.name->toOne()), $conventions->className(_ExternalDataAdder))->j_cast($adderType));
               pair($var, $declare);
            });
            
            let factoryType    = javaParameterizedType($conventions->className(_ParsedFlatDataToObject), $dataClass);
            let parsedFlatData = j_parameter($conventions->className(_ParsedFlatData), 'parsedFlatData');
            let resultVar      = j_variable($dataClass, 'result');
            let defects        = j_variable(javaList($conventions->defectClass()), 'defects');
            
            let addClauses     = $fields->toIndexed()->map({indexedField|
               let fieldVar  = $fieldVars->at($indexedField.first).first;
               let adderVar  = $adderVars->at($indexedField.first).first;               
               let property  = $sectionBindingDetail.details->filter(c| $c.field == $indexedField.second).property->toOne();
               let propType  = $property->functionReturnType().rawType->toOne();
               
               let ex      = j_parameter(javaException(),'e');
               let defectOnException = {code: Code[1]|
                  j_try(
                     $code,
                     j_catch($ex,
                        $defects->j_invoke('add', $conventions->newClassStructureDefect($ex->j_invoke('getMessage', []), j_string($sectionBindingDetail.class->elementToPath())))
                     )
                  )
               };
               
               if($propType->instanceOf(meta::pure::metamodel::type::Enumeration),
                  {| 
                     let javaType = $conventions->className($propType);
                     let all      = j_variable(javaEnumSet($javaType), 'allVs');
                     let text     = j_variable(javaString(), 'text');
                     let var      = j_variable(javaList($javaType), 'vs');
                     let v        = j_parameter($javaType, 'v');

                     let vName      = $v->j_invoke('name', []);
                     let vNameClean = $vName->j_invoke('replaceAll', [j_string('[^\\p{L}\\p{N}]'), j_string('')]);
                     let textClean   = $text->j_invoke('replaceAll', [j_string('[^\\p{L}\\p{N}]'), j_string('')]);
                     let compare1   = j_lambda($v, $vName     ->j_invoke('equals',           $text));
                     let compare2   = j_lambda($v, $vName     ->j_invoke('equalsIgnoreCase', $text));
                     let compare3   = j_lambda($v, $vNameClean->j_invoke('equals',           $textClean));
                     let compare4   = j_lambda($v, $vNameClean->j_invoke('equalsIgnoreCase', $textClean));

                     let findEnumAndAdd =[
                        $text->j_declare($parsedFlatData->j_invoke('getString', $fieldVar)),
                        $all->j_declare(javaEnumSet()->j_invoke('allOf', $javaType->j_field('class'), $all.type)),
                        $var->j_declare($all->j_streamOf()->js_filter($compare1)->js_resolve($var.type)),
                        j_if($var->j_invoke('isEmpty', []),
                           $var->j_assign($all->j_streamOf()->js_filter($compare2)->js_resolve($var.type))
                        ),
                        j_if($var->j_invoke('isEmpty', []),
                           $var->j_assign($all->j_streamOf()->js_filter($compare3)->js_resolve($var.type))
                        ),
                        j_if($var->j_invoke('isEmpty', []),
                           $var->j_assign($all->j_streamOf()->js_filter($compare4)->js_resolve($var.type))
                        ),
                        j_if($var->j_invoke('isEmpty', []),
                           j_throw(j_new(javaIllegalArgumentException(), $text->j_plus(j_string(' does not match to any value in ' + $propType.name->toOne()))))
                        ),
                        j_if($var->j_invoke('size', [])->j_gt(j_int(1)),
                           j_throw(j_new(javaIllegalArgumentException(), $text->j_plus(j_string(' ambiguously matches to values in ' + $propType.name->toOne()))))
                        ),
                        $adderVar->j_invoke('addTo', [$resultVar, $var->j_invoke('get', j_int(0))])
                     ]->j_block();
                   
                     j_if($parsedFlatData->j_invoke('hasStringValue', $fieldVar),
                        $defectOnException->eval($findEnumAndAdd)
                    );
                  },
                  |
               if($propType == String,
                  | j_if($parsedFlatData->j_invoke('hasStringValue', $fieldVar),
                       $defectOnException->eval($adderVar->j_invoke('addTo', [$resultVar, $parsedFlatData->j_invoke('getString', $fieldVar)]))
                    ),
                  |
               if($propType == Boolean,
                  | j_if($parsedFlatData->j_invoke('hasBooleanValue', $fieldVar),
                       $defectOnException->eval($adderVar->j_invoke('addTo', [$resultVar, $parsedFlatData->j_invoke('getBoolean', $fieldVar)]))
                    ),
                  |
               if($propType == Integer,
                  | j_if($parsedFlatData->j_invoke('hasLongValue', $fieldVar),
                       $defectOnException->eval($adderVar->j_invoke('addTo', [$resultVar, $parsedFlatData->j_invoke('getLong', $fieldVar)]))
                    ),
                  | 
               if($propType == Float,
                  | j_if($parsedFlatData->j_invoke('hasDoubleValue', $fieldVar),
                       $defectOnException->eval($adderVar->j_invoke('addTo', [$resultVar, $parsedFlatData->j_invoke('getDouble', $fieldVar)]))
                    ),
                  | 
               if($propType == Decimal,
                  | j_if($parsedFlatData->j_invoke('hasBigDecimalValue', $fieldVar),
                       $defectOnException->eval($adderVar->j_invoke('addTo', [$resultVar, $parsedFlatData->j_invoke('getBigDecimal', $fieldVar)]))
                    ),
                  | 
               if($propType == StrictDate,
                  | j_if($parsedFlatData->j_invoke('hasLocalDateValue', $fieldVar),
                       $defectOnException->eval($adderVar->j_invoke('addTo', [$resultVar, $parsedFlatData->j_invoke('getLocalDate', $fieldVar)]))
                    ),
                  | 
               if($propType == DateTime,
                  | j_if($parsedFlatData->j_invoke('hasInstantValue', $fieldVar),
                       $defectOnException->eval($adderVar->j_invoke('addTo', [$resultVar, $parsedFlatData->j_invoke('getInstant', $fieldVar)]))
                    ),
                  | fail('Unknown type'); j_null();
               ))))))));
            });

            let isReturnableMethod = j_method('public',javaBoolean(), 'isReturnable', [],
                                        j_return(if($sectionBindingDetail.class == $rootClass, |j_true(), |j_false()))
                                     );

            let checkedType        = javaParameterizedType($conventions->checkedClass(), $dataClass);
            let checked            = j_variable($checkedType, 'checked');
            let d                  = j_parameter($conventions->defectClass(), 'd');
            let makeMethod         = j_method('public', $dataClass, 'make', $parsedFlatData,
                                        [
                                           $checked->j_declare(j_this(anonymousNestedClass(1))->j_invoke('makeChecked', $parsedFlatData, $checked.type)),
                                           j_if($conventions->checkedGetDefects($checked)->j_streamOf()->js_anyMatch(j_lambda($d, $conventions->defectGetEnforcemetLevel($d)->j_eq($conventions->elCritical()))),
                                              j_throw(j_new(javaIllegalStateException(), $conventions->checkedGetDefects($checked)->j_streamOf()->js_map(j_lambda($d, $conventions->defectGetMessage($d)))->js_joining(j_string('\n'))))
                                           ),
                                           j_return($conventions->checkedGetValue($checked))
                                        ]
                                     );
                                                                         
            let declareDefects = $defects->j_declare(j_new(javaArrayList($conventions->defectClass()), []));
            let returnChecked  = j_return($conventions->dynamicChecked($defects, $parsedFlatData, $resultVar));
         
            if($bindingDetail.schemaBindingDetail->isNotEmpty(),
               {|
                  let schemaObjectClass = $conventions->dataClass($bindingDetail.schemaBindingDetail.class->toOne(), $path);
                  let schemaObject      = j_parameter($schemaObjectClass, 'schemaObject');
                  let sectionProperty   = $bindingDetail.schemaBindingDetail.details->filter(d| $d.section == $section).property->toOne();

                  let anonResult = j_newAnon($factoryType, [], 
                     [
                        $makeMethod,
                        j_method('public', $checkedType, 'makeChecked', $parsedFlatData,
                           $declareDefects
                              ->concatenate($resultVar->j_declare(j_new($dataClass, [])))
                              ->concatenate($addClauses)
                              ->concatenate($schemaObject->j_invoke('_'+$conventions->fieldName($sectionProperty)+'Add', $resultVar, javaVoid()))
                              ->concatenate($returnChecked)
                              ->j_block()
                        ),
                        $isReturnableMethod,
                        j_method('public', javaVoid(), 'finished', [],
                           $schemaObject->j_invoke('_'+$conventions->fieldName($sectionProperty)+'SectionFinished', [], javaVoid())
                        )
                     ]
                  );
                  
                  javaMethod('public', javaFunction($recordTypeParam.type, javaParameterizedType($conventions->className(_ParsedFlatDataToObject), javaWildcard())), $section->sectionFactoryMethodName(), $schemaObject, 
                     j_return(j_lambda($recordTypeParam, $fieldVars.second->concatenate($adderVars.second)->concatenate(j_return($anonResult))->j_block()))
                  );
               },
               {|
                  let anonResult = j_newAnon($factoryType, [], 
                     [
                        $makeMethod,
                        j_method('public', $checkedType, 'makeChecked', $parsedFlatData,
                           $declareDefects
                              ->concatenate($resultVar->j_declare(j_new($dataClass, [])))
                              ->concatenate($addClauses)
                              ->concatenate($returnChecked)
                              ->j_block()
                        ),
                        $isReturnableMethod
                     ]
                  );

                  javaMethod('public', $factoryType, $section->sectionFactoryMethodName(), $recordTypeParam, 
                     $fieldVars.second->concatenate($adderVars.second)->concatenate(j_return($anonResult))
                  );
               }
            );
         });
      })
      ->addMethod({cls |
         let schemaVar  = j_variable($conventions->className(_FlatData), 'schema');
         let newContext = j_new($contextType, [$schemaVar, j_string($schemaSet->elementToPath())]);
         let maxSize    = j_this($cls)->j_field($maximumSchemaObjectSize);
         let sectionsToProcess = $flatData.sections->filter(s | $s.recordType->isNotEmpty());

         let body = if($bindingDetail.schemaBindingDetail->isNotEmpty(),
            {|
               let schemaObjectClass = $conventions->dataClass($bindingDetail.schemaBindingDetail.class->toOne(), $path);
               let schemaObject      = j_variable($schemaObjectClass, 'schemaObject');

               let contextWithFactories = $sectionsToProcess->fold(
                  {section, code| 
                     let factoryRef = j_this($cls)->j_invoke($section->sectionFactoryMethodName(), $schemaObject);
                     $code->j_invoke('withSectionToObjectFactory', [j_string($section.name), $factoryRef], $contextType);
                     
                  }, 
                  $newContext
               );
               
               [
                  j_if($maxSize->j_eq(j_int(0)),
                     j_throw(j_new(javaIllegalStateException(), j_string('maximumSchemaObjectSize must be set before obtaining context')))
                  ),
                  $schemaObject->j_declare(j_new($schemaObjectClass, $maxSize)),
                  $schemaVar->j_declare($cls->createSchema($flatData, $conventions)),
                  j_return($contextWithFactories)
               ];
            },
            {|
               let contextWithFactories = $sectionsToProcess->fold(
                  {section, code| 
                     let factoryRef = j_this($cls)->j_methodReference($section->sectionFactoryMethodName(), javaFunctionType($conventions->className(_FlatDataRecordType), $conventions->className(_ParsedFlatDataToObject)));
                     $code->j_invoke('withSectionToObjectFactory', [j_string($section.name), $factoryRef], $contextType);
                     
                  }, 
                  $newContext
               );
               
               [
                  $schemaVar->j_declare($cls->createSchema($flatData, $conventions)),
                  j_return($contextWithFactories)
               ];
            }
         );
         
         javaMethod('public', $contextType, 'createContext', [], $body);
      });
}

function <<access.private>> meta::external::format::flatdata::executionPlan::propertyForField(bindingDetail:SectionBindingDetail[1], field:FlatDataRecordField[1]): AbstractProperty<Any>[1]
{
   $bindingDetail.details->filter(c| $c.field == $field).property->toOne();
}

function <<access.private>> meta::external::format::flatdata::executionPlan::createFieldVars(fields:FlatDataRecordField[*], recordTypeParam:Code[1], conventions:Conventions[1]): Pair<Code,Code>[*]
{
   $fields->toIndexed()->map({indexedField|
      let var     = j_variable($conventions->className(_FlatDataRecordField), 'field' + $indexedField.first->toString());
      let lParam  = j_parameter($conventions->className(_FlatDataRecordField), 'f');
      let lambda  = j_lambda($lParam, $lParam->j_invoke('getLabel', [])->j_invoke('equals', j_string($indexedField.second.label)));                                                            
      let declare = $var->j_declare($recordTypeParam->j_invoke('getFields', [])->j_streamOf()->js_filter($lambda)->js_findFirst()->jo_get());
      pair($var, $declare);
   });
}

function <<access.private>> meta::external::format::flatdata::executionPlan::createSchema(jClass:meta::external::language::java::metamodel::Class[1], flatData:FlatData[1], conventions:Conventions[1]): Code[1]
{   
   $flatData.sections->fold(
      {section, code| 
         $code->j_invoke('withSection', j_this($jClass)->j_invoke($section->sectionMethodName(), []), $conventions->className(_FlatData))
      }, 
      j_new($conventions->className(_FlatData), [])
   );
}

function <<access.private>> meta::external::format::flatdata::executionPlan::sectionMethodName(section:FlatDataSection[1]): String[1]
{   
   'flatDataSection_' + $section.name;
}

function <<access.private>> meta::external::format::flatdata::executionPlan::sectionFactoryMethodName(section:FlatDataSection[1]): String[1]
{   
   'flatDataSection_Factory_' + $section.name;
}

function <<access.private>> meta::external::format::flatdata::executionPlan::addSectionMethods(jClass:meta::external::language::java::metamodel::Class[1], flatData:FlatData[1], conventions:Conventions[1]): meta::external::language::java::metamodel::Class[1]
{   
   $jClass
      ->addMethods({cls|
         $flatData.sections->map({section|
            javaMethod('public', $conventions->className(_FlatDataSection), $section->sectionMethodName(), [],
               j_new($conventions->className(_FlatDataSection), [j_string($section.name), j_string($section.driverId)])
                  ->map({jSection|
                      $section.sectionProperties->fold(
                         {sp, code| 
                            let name  = j_string($sp.name);
                            let value = $sp.value->match([
                               i:Integer[1]  | j_long($i), 
                               s:String[1]   | j_string($s), 
                               b:Boolean[1]  | j_boolean($b),
                               is:Integer[*] | javaArrays()->j_invoke(javaLongBoxed(), 'asList', $is->map(i|j_long($i)), javaList(javaLongBoxed())),
                               ss:String[*]  | javaArrays()->j_invoke(javaString(), 'asList', $ss->map(s|j_string($s)), javaList(javaString()))
                            ]);
                            $code->j_invoke('withProperty', [$name, $value], $conventions->className(_FlatDataSection));
                         },
                         $jSection
                      );
                  })
                  ->map({jSection|
                     $section.recordType->match([
                        {none:FlatDataRecordType[0]| 
                           j_return($jSection)
                        },
                        {rt:FlatDataRecordType[1]|
                           let recordTypeVar = j_variable($conventions->className(_FlatDataRecordType), 'recordType');
                           let newRecordType = j_new($conventions->className(_FlatDataRecordType), []);
                           let withFields    = $rt.fields->fold({field, rType| $rType->codeWithField($field, $conventions)}, $newRecordType);
                           [
                              $recordTypeVar->j_declare($withFields),
                              j_return($jSection->j_invoke('withRecordType', $recordTypeVar))
                           ];
                        }
                     ])
                  })
            );            
         });
      });
}

function <<access.private>> meta::external::format::flatdata::executionPlan::codeWithField(recordType:Code[1], field:FlatDataRecordField[1], conventions:Conventions[1]): Code[1]
{
   let fieldLabel = j_string($field.label);
   let fieldType  = $field.type->codeFlatDataDatatype($conventions);

   $field.address->match([
      a0:String[0]| $recordType->j_invoke('withField', [$fieldLabel, $fieldType], $conventions->className(_FlatDataRecordType)),
      a :String[1]| $recordType->j_invoke('withField', [$fieldLabel, $fieldType, j_string($a)], $conventions->className(_FlatDataRecordType))
   ]);
}

function <<access.private>> meta::external::format::flatdata::executionPlan::codeFlatDataDatatype(type:FlatDataDataType[1], conventions:Conventions[1]): Code[1]
{   
   let optional = j_boolean($type.optional);
   
   $type->match([
      {str:FlatDataString[1]|
         j_new($conventions->className(_FlatDataString), $optional);
      },
      {bool:FlatDataBoolean[1]|
         j_new($conventions->className(_FlatDataBoolean), $optional)
            ->map(j| $bool.trueString->match([
                        t0:String[0]| $j,
                        t :String[1]| $j->j_invoke('withTrueString', j_string($t))
                     ])
            )
            ->map(j| $bool.falseString->match([
                        f0:String[0]| $j,
                        f :String[1]| $j->j_invoke('withFalseString', j_string($f))
                     ])
            );
      },
      {int:FlatDataInteger[1]|
         j_new($conventions->className(_FlatDataInteger), $optional)
            ->map(j| $int.format->match([
                        f0:String[0]| $j,
                        f :String[1]| $j->j_invoke('withFormat', j_string($f))
                     ])
            );
      },
      {dec:FlatDataDecimal[1]|
         j_new($conventions->className(_FlatDataDecimal), $optional)
            ->map(j| $dec.format->match([
                        f0:String[0]| $j,
                        f :String[1]| $j->j_invoke('withFormat', j_string($f))
                     ])
            );
      },
      {date:FlatDataDate[1]|
         $date.format->fold(
            {fmt, cde | $cde->j_invoke('addFormat', j_string($fmt))}, 
            j_new($conventions->className(_FlatDataDate), $optional)
         )
      },
      {dateTime:FlatDataDateTime[1]|
         $dateTime.format->fold(
            {fmt, cde | $cde->j_invoke('addFormat', j_string($fmt))}, 
            j_new($conventions->className(_FlatDataDateTime), $optional)
               ->map(j| $dateTime.timeZone->match([
                           z0:String[0]| $j,
                           z :String[1]| $j->j_invoke('withTimeZone', j_string($z))
                        ])
            )
         )
      }
   ]);
}

Class <<access.private>> meta::external::format::flatdata::executionPlan::SchemaPropertyDetails
{
   property          : AbstractProperty<Any>[1];
   fieldName         : String[1];
   stateFieldName    : String[1];
   sizeFieldName     : String[1];
   propType          : meta::pure::metamodel::type::Type[1];
   javaType          : meta::external::language::java::metamodel::Type[1];
   itemType          : meta::external::language::java::metamodel::Type[1];
   getterName        : String[1];
   adderName         : String[1];
   adderParam        : Code[1];
   finisherName      : String[1];
   
   name() {$this.property.name->toOne()}: String[1];
   isViaAssociation() {$this.property.owner->instanceOf(Association)}: Boolean[1];
}

function <<access.private>> meta::external::format::flatdata::executionPlan::createSchemaDataClass(class:meta::pure::metamodel::type::Class<Any>[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]): Project[1]
{
   print(if($debug.debug,|$debug.space+'('+$path+') createFileDataClass for '+$class->elementToPath()+'\n', |''));

   let conventions = $context.conventions;
   
   let stateNone     = javaField(['private', 'static'], javaInt(), 'STATE_NONE',      j_int(0));
   let stateBuilt    = javaField(['private', 'static'], javaInt(), 'STATE_BUILT',     j_int(1));
   let stateTooLarge = javaField(['private', 'static'], javaInt(), 'STATE_TOO_LARGE', j_int(2));

   let maxSize               = javaField(['private', 'final'], javaLong(), 'maxSize');
   let maxSizeParam          = j_parameter(javaLong(), 'maxSize');
   let buildingSize          = javaField('private', javaLong(), 'buildingSize', j_long(0));
   let builtSize             = javaField('private', javaLong(), 'builtSize',    j_long(0));

   let baseClass = $conventions->dataClass($class, $path)->addModifiers('public')
      ->implements($conventions->className($class))
      ->addFields([$stateNone, $stateBuilt, $stateTooLarge])
      ->addFields([$maxSize, $buildingSize, $builtSize])
      ->addConstructor(c| javaConstructor('public', $maxSizeParam, j_this($c)->j_field($maxSize)->j_assign($maxSizeParam)));   
   
   let properties = $context.typeInfos->allProperties($class)->map(p|
      let fieldName     = $conventions->fieldName($p);
      let javaType      = $conventions->pureTypeToJavaType($p);
      let propType      = $p->functionReturnType().rawType->toOne();
      let itemType      = if($javaType->isJavaList(), |$javaType->elementType(), |$javaType)->toUnboxed();
                                                                                                                                      
      ^SchemaPropertyDetails(
         property          = $p,
         fieldName         = $fieldName,
         stateFieldName    = $fieldName+'State',
         sizeFieldName     = $fieldName+'Size',
         propType          = $propType,
         javaType          = $javaType,
         itemType          = $itemType,
         getterName        = $conventions->getterName($p),
         adderName         = '_'+$fieldName+'Add',
         adderParam        = j_parameter($conventions->dataClass($propType->cast(@meta::pure::metamodel::type::Class<Any>), $path), 'value'),
         finisherName      = '_'+$fieldName+'SectionFinished'
      );
   );

   let withPropertyMethods = $properties->fold(
      {p, jc|
         let stBuilt    = j_this($jc)->j_field($stateBuilt);
         let stTooLarge = j_this($jc)->j_field($stateTooLarge);
         
         $jc->addField(if($p.javaType->isJavaList(), 
                          |javaField('private', $p.javaType, $p.fieldName, javaArrayList($p.itemType)->j_new([])),
                          |javaField('private', $p.javaType, $p.fieldName)
                       )
            )
            ->addField(javaField('private', javaLong(), $p.sizeFieldName, j_int(0)))
            ->addField(javaField('private', javaInt(), $p.stateFieldName, j_this($jc)->j_field($stateNone)))
            ->addMethod({c|
               let field = j_this($c)->j_field($p.fieldName);
               let state = j_this($c)->j_field($p.stateFieldName);
               
               javaMethod('public', $p.javaType, $p.getterName, [],
                  j_if(
                     list([
                        pair($state->j_bitwiseAnd($stBuilt)->j_ne($stBuilt), j_throw(j_new(javaIllegalStateException(), j_string('Cannot access ' + $p.name + ' before section is completed')))),
                        pair($state->j_bitwiseAnd($stTooLarge)->j_eq($stTooLarge), j_throw(j_new(javaIllegalStateException(), j_string('Cannot access ' + $p.name + ', data too large for in memory operation'))))
                     ]),
                     j_return($field)
                  )
               );
            })
            ->addMethod({c|
               let field      = j_this($c)->j_field($p.fieldName);
               let size       = j_this($c)->j_field($p.sizeFieldName);
               let state      = j_this($c)->j_field($p.stateFieldName);
               let bldingSize = j_this($c)->j_field($buildingSize);
               let bltSize    = j_this($c)->j_field($builtSize);
               let addValue   = if($p.javaType->isJavaList(), 
                                   | $field->j_invoke('add', $p.adderParam),
                                   | $field->j_assign($p.adderParam)
                                );
               
               javaMethod('public', javaVoid(), $p.adderName, $p.adderParam,
                  [
                     j_if($state->j_bitwiseAnd($stBuilt)->j_eq($stBuilt), 
                        j_throw(j_new(javaIllegalStateException(), j_string('Cannot add to ' + $p.name + ' because section is complete')))
                     ),
                     j_if($state->j_bitwiseAnd($stTooLarge)->j_ne($stTooLarge),
                        [
                           $bldingSize->j_assign($bldingSize->j_plus($p.adderParam->j_invoke($conventions->getterName(instanceSizeIdentifier()), [], javaInt()))),
                           j_if($bltSize->j_plus($bldingSize)->j_gt(j_this($c)->j_field($maxSize)),
                              [
                                 $state->j_assign($state->j_bitwiseOr($stTooLarge)),
                                 $bldingSize->j_assign(j_int(0)),
                                 if($p.javaType->isJavaList(), 
                                    | $field->j_invoke('clear', [], javaVoid()),
                                    | $field->j_assign(j_null())
                                 )
                              ]
                           )
                        ]
                     ),
                     j_if($state->j_bitwiseAnd($stTooLarge)->j_ne($stTooLarge), 
                        $addValue
                     ),
                     $size->j_inc()
                  ]->concatenate(
                     if($p.isViaAssociation(),
                        {|
                           let otherProperty = $p.property.owner->cast(@Association).properties->filter(x | $x != $p.property)->toOne();
                           let otherImplName = '_' + $conventions->fieldName($otherProperty) + 'AddImpl';
                           $p.adderParam->j_invoke($otherImplName, j_this($c), javaVoid());
                        },
                        | []
                     )
                  )
               );
            })
            ->addMethod({c|
               javaMethod('public', javaVoid(), $p.adderName+'Impl', $p.adderParam,
                  j_throw(j_new(javaIllegalStateException(), j_string('Associated data should be assigned via the schema class')))
               );
            })
            ->addMethod({c|
               let field      = j_this($c)->j_field($p.fieldName);
               let size       = j_this($c)->j_field($p.sizeFieldName);
               let state      = j_this($c)->j_field($p.stateFieldName);
               let bldingSize = j_this($c)->j_field($buildingSize);
               let bltSize    = j_this($c)->j_field($builtSize);
               
               let multiplicity       = $p.property.multiplicity;
               let occurs             = occursFromMultiplicity($multiplicity);
               let lowerBoundClause   = $size->j_lt($occurs.first);
               let upperBoundClause   = $size->j_gt($occurs.second);
               let throwMultException = j_throw(j_new(javaIllegalStateException(), j_string('Invalid multiplicity for '+$p.name->toOne()+': expected ['+$multiplicity->printMultiplicity()+'] found [')->j_plus($size)->j_plus(j_string(']'))));
               let multiplicityCheck  = if($multiplicity->hasLowerBound() && $multiplicity->hasUpperBound(),
                                           | j_if($lowerBoundClause->j_or($upperBoundClause), $throwMultException),
                                           |
                                        if($multiplicity->hasLowerBound(),
                                           | j_if($lowerBoundClause, $throwMultException),
                                           |
                                        if($multiplicity->hasUpperBound(),
                                           | j_if($upperBoundClause, $throwMultException),
                                           | []
                                        )));
               
               javaMethod('public', javaVoid(), $p.finisherName, [],
                  [
                     j_if($state->j_bitwiseAnd($stBuilt)->j_eq($stBuilt),
                        j_throw(j_new(javaIllegalStateException(), j_string($p.name + ' section is already completed')))
                     )
                  ]
                  ->concatenate($multiplicityCheck)
                  ->concatenate([
                     $state->j_assign($state->j_bitwiseOr($stBuilt)),
                     $bltSize->j_assign($bltSize->j_plus($bldingSize)),
                     $bldingSize->j_assign(j_int(0))
                  ])
               );
            });          
      }, 
      $baseClass      
   );
   
   let schemaClass = $withPropertyMethods->addAlloyStoreObjectReferenceMethodsForClass($context);
   mergeProjects([
      newProject()->addClass($schemaClass),
      $schemaClass->createConstraintCheckingForClass($class, $context, false, $debug)
   ]);
}

