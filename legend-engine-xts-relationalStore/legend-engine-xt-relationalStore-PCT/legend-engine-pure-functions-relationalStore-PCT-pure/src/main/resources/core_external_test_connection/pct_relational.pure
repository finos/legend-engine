// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::tests::pct::*;
import meta::json::*;
import meta::relational::mapping::*;
import meta::relational::metamodel::datatype::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::metamodel::execute::*;
import meta::relational::metamodel::relation::*;
import meta::relational::runtime::*;
import meta::external::store::relational::runtime::*;
import meta::core::runtime::*;
import meta::relational::metamodel::*;
import meta::pure::mapping::*;
import meta::pure::store::*;
import meta::pure::metamodel::relation::*;
import meta::relational::tests::pct::process::*;
import meta::pure::test::pct::*;

function <<PCT.adapter>> meta::relational::tests::pct::testAdapterForRelationalWithH2Execution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
  meta::relational::tests::pct::testAdapterForRelationalExecution(
      $f,
      meta::pure::testConnection::getTestConnection(DatabaseType.H2)
  )
}

function <<PCT.adapter>> meta::relational::tests::pct::testAdapterForRelationalWithDuckDBExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
  meta::relational::tests::pct::testAdapterForRelationalExecution(
      $f,
      meta::pure::testConnection::getTestConnection(DatabaseType.DuckDB)
  )
}

function <<PCT.adapter>> meta::relational::tests::pct::testAdapterForRelationalWithPostgresExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
  meta::relational::tests::pct::testAdapterForRelationalExecution(
      $f,
      meta::pure::testConnection::getTestConnection(DatabaseType.Postgres)
  )
}

function <<PCT.adapter>> meta::relational::tests::pct::testAdapterForRelationalWithSnowflakeExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
  meta::relational::tests::pct::testAdapterForRelationalExecution(
      $f,
      meta::pure::testConnection::getTestConnection(DatabaseType.Snowflake)
  )
}

function meta::relational::tests::pct::extractDependentFunctions(f:Any[1]):Function<Any>[*]
{
  $f->match([
    z:FunctionDefinition<Any>[1]|$z.expressionSequence->evaluateAndDeactivate()->map(x|$x->extractDependentFunctions()),
    x:SimpleFunctionExpression[1]|let res = $x.parametersValues->map(p|$p->extractDependentFunctions());
                                  $res->concatenate(if(!$x.func->hasStereotype('function', PCT),|$x.func,|[]));,
    a:Any[1]|[]
  ]);  
}

function meta::relational::tests::pct::testAdapterForRelationalExecution<X|o>(f:Function<{->X[o]}>[1], dbc:meta::external::store::relational::runtime::DatabaseConnection[1]):X[o]
{
    let debug = noDebug();

    let repocessed = $f->meta::relational::tests::pct::process::reprocess($dbc, $debug);
    let newFunction = $repocessed.first;

    let extensions =  meta::relational::extension::relationalExtensions();

    // ----

    let rawPlan = meta::pure::executionPlan::executionPlan($newFunction, ^meta::pure::runtime::ExecutionContext(), $extensions, $debug);

    let planBindToJava = $rawPlan->meta::pure::executionPlan::platformBinding::localBinding::bindTestPlanToPlatformLocallyWithClasspathExtensions('LegendJava');

    let plan = $planBindToJava->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformPlan($extensions);

    let planAsJson = $plan->meta::json::toJSON(1000, meta::json::config(false, false, true, true));

    let x = meta::legend::executePlanAsJSON($planAsJson, []);

    print(if($debug.debug,|'\nResult JSON:\n'+$x+'\n',|''));
    // ----
    
    let json = $x->meta::json::parseJSON();

    if ($json->cast(@JSONObject).keyValuePairs->filter(k|$k.key.value=='result').value->isEmpty(),
      | let res = $json->meta::json::fromJSON(meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalClassResult, ^meta::json::ExtendedJSONDeserializationConfig(typeKeyName='__TYPE', failOnUnknownProperties=true, nullReplacementInArray=TDSNull))->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalClassResult)->toOne();
        let x= meta::protocols::pure::vX_X_X::invocation::execution::execute::processRelationalClassResult($res, $repocessed.second.mapping->toOne(), $repocessed.second.runtime, [], $extensions);
        $x.first.values;,
      | let res = $json->meta::json::fromJSON(meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalTDSResult, ^meta::json::ExtendedJSONDeserializationConfig(typeKeyName='__TYPE', failOnUnknownProperties=true, nullReplacementInArray=TDSNull))->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalTDSResult)->toOne();
        // processResult
        let resultType = $f->functionReturnType().rawType;
        if ($resultType->toOne()->instanceOf(PrimitiveType),
          | let preResultFinal = $res.result.rows->at(0).values->at(0);
            let resultFinal = 
              if ([
                    pair(|$resultType->toOne()->subTypeOf(Date), |buildDate($preResultFinal->toString())),
                    pair(|$resultType->toOne()->subTypeOf(Decimal), |$preResultFinal->cast(@Number)->toDecimal()),
                    pair(|$resultType->toOne()->subTypeOf(Integer), |$preResultFinal->cast(@Number)->round()),
                    pair(|$resultType->toOne()->subTypeOf(Float), |$preResultFinal->cast(@Number)->toFloat())
                  ],
                | $preResultFinal->toOne()
              );
            print(if($debug.debug,|'\nResult Final:\n'+$resultFinal->makeString(','),|''));
            $resultFinal;,
          | let tdsString = $res.result.columns->joinStrings(',') + '\n' +
                            $res.result.rows->map(x|
                                range($x.values->size())->map(z | if($x.values->at($z) == TDSNull,
                                                                      |let type = $res.builder->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::TDSBuilder).columns->at($z).type;
                                                                        if ([
                                                                            pair(|$type == 'Integer', |-2147483648),
                                                                            pair(|$type == 'String', |'null')
                                                                            ],
                                                                            |fail();0;
                                                                        );,
                                                                      |$x.values->at($z)
                                                                  )
                                                          )->makeString(',')
                                )->joinStrings('\n');
              let resultFinal = $tdsString->stringToTDS();
              print(if($debug.debug,|'\nResult Final:\n'+$resultFinal->toString(),|''));
              $resultFinal;
        );
    )->cast(@X)->toMultiplicity(@[o]);
}

function meta::relational::tests::pct::process::buildDate(dateStr:String[1]):Date[1]
{
  // Need to find a better way...
  
  // Manage SubSecond
  let _dot = if ($dateStr->contains('.'),
    | let subPart = $dateStr->substring($dateStr->indexOf('.') + 1, $dateStr->lastIndexOf('+'));
      let x = '.'+$subPart;
      if ($subPart == '000000000',
        | $dateStr->substring(0, $dateStr->indexOf('.')) + '' + $dateStr->substring($dateStr->lastIndexOf('+')),
        | $dateStr->substring(0, $dateStr->indexOf('.')) + $x->parseFloat()->toString()->substring(1) + $dateStr->substring($dateStr->lastIndexOf('+'))
      );,
    | $dateStr
  );

  // Remove +
  let _plus = if ($_dot->startsWith('+'),
    |$_dot->substring(1),
    |$_dot
  );

  // StrictDate
  let _strict = if ($_plus->contains('T'),
    |let time = $_plus->substring($_plus->indexOf('T') + 1, $_plus->lastIndexOf('+'));
     if ($time == '00:00:00',
          | $_plus->substring(0, $_plus->indexOf('T')),
          | $_plus
        );,
    |$_plus
  );

  meta::pure::functions::string::parseDate($_strict);
}

function meta::relational::tests::pct::process::printDatabase(d:Database[1]):String[1]
{
  'Database '+$d->elementToPath()+
  '('+
   $d.schemas->map(
      s | 'Schema '+$s.name + '('+ $s.tables->map(x|
              'Table '+$x.name+'('+
                  $x.columns->map(z|let c = $z->cast(@meta::relational::metamodel::Column);
                                    if($c.name->contains(' '),|'"'+$c.name+'"',|$c.name) + ' ' + $c.type->match([
                                                          x : Varchar[1] | 'VARCHAR('+$x.size->toString()+')',
                                                          z : Any[1] | $z->type().name->toOne()
                                                        ]
                                                      ) + if ($x.primaryKey->contains($c),|' PRIMARY KEY',|'');
                                 )->joinStrings(',')+
              ')'
                  )->joinStrings(' ') + ')'
          )->joinStrings(';')+
    $d.joins->map(
      j | 'Join '+$j.name+'('+$j.operation->printRelationalOperationElement(false)+')'
    )->joinStrings(' ')+
  ')';
}

function meta::relational::tests::pct::process::printMapping(d:Mapping[1]):String[1]
{
  'Mapping '+$d->elementToPath()+
  '('+
    $d.classMappings->map(si|
      $si.class->elementToPath() + '['+$si.id+']:' + $si->match(
        [
          rs:RootRelationalInstanceSetImplementation[1] | 'Relational {'+
              $rs.propertyMappings->cast(@RelationalPropertyMapping)->map(pm|
                $pm.property.name->toOne() + if($pm.targetSetImplementationId == '',|'',|'['+$pm.targetSetImplementationId+']') + ':'+$pm.relationalOperationElement->printRelationalOperationElement(true))->joinStrings(', ')
          +'}'
        ]
      )
    )->joinStrings(' ')+
  ')';
}

function meta::relational::tests::pct::process::printRelationalOperationElement(d:RelationalOperationElement[1], forMapping:Boolean[1]):String[1]
{
  $d->match(
    [
      t:TableAliasColumn[1]|if($forMapping,|'['+$t.alias.database->toOne()->elementToPath()+']',|'')+$t.alias.relationalElement->cast(@Table).schema.name->toOne()+'.'+$t.alias.relationalElement->cast(@Table).name+'.'+$t.column.name,
      x:RelationalOperationElementWithJoin[1]|'['+$x.joinTreeNode.database->toOne()->elementToPath()+']@'+$x.joinTreeNode.joinName->toOne(),
      v:DynaFunction[1]|$v.name + '('+$v.parameters->map(p|$p->printRelationalOperationElement($forMapping))->joinStrings(',')+')'
    ]
  )
}

function meta::relational::tests::pct::process::reprocess(connection:meta::external::store::relational::runtime::RelationalDatabaseConnection[1]):String[1]
{
  '^meta::external::store::relational::runtime::RelationalDatabaseConnection('+
  'type='+$connection.type->meta::pure::metamodel::serialization::grammar::printValueSpecification([], '')+','+
  'authenticationStrategy = '+$connection.authenticationStrategy->printNew()+','+ //^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy(),'+
  'datasourceSpecification = '+$connection.datasourceSpecification->printNew()+ //^meta::pure::alloy::connections::alloy::specification::DuckDBDatasourceSpecification(path = \'\')'+
  ')'
}

function meta::relational::tests::pct::process::printNew(a:Any[1]):String[1]
{  
  $a->match(
    [
       i:Integer[1] | $i->toString(),
       x:String[1] | '\''+$x+'\'',
       a:Any[1] |
         let _type = $a->type()->cast(@Class<Any>);
         let properties = $_type->meta::pure::functions::meta::hierarchicalProperties();
         '^'+$a->type()->elementToPath()+'('+
          $properties->map(p| let value = $p->eval($a);
                              if ($value->isEmpty(),
                                |'',
                                |$p.name->toOne() + '=' + $value->map(w|$w->printNew())->joinStrings(',')
                              );
                       )->filter(v|$v != '')->joinStrings(',')+
        ')';
    ]
  );
}

function meta::relational::tests::pct::process::reprocess(f:Function<Any>[1], dbc:meta::external::store::relational::runtime::DatabaseConnection[1], debug: DebugContext[1]):Pair<FunctionDefinition<Any>,ProcessingState>[1]
{ 
  let otherFuncs = $f->cast(@FunctionDefinition<Any>)->meta::relational::tests::pct::extractDependentFunctions();

  let ext = ^meta::pure::metamodel::serialization::grammar::Configuration
            (
              fullPath = true,
              extensions =   ^meta::pure::metamodel::serialization::grammar::GrammarExtension(
                                extraConnectionHandlers =
                                  [
                                    x:RelationalDatabaseConnection[0..1] |
                                        $x->toOne()->reprocess(); 
                                  ],
                                extraInstanceValueHandlers = 
                                  [
                                    x:RelationStoreAccessor<Any>[1]|'#>{'+$x.store->elementToPath()+'.'+$x.sourceElement->cast(@Table).name->toOne()+'}#',
                                    t:meta::pure::metamodel::relation::TDS<Any>[1]|'#TDS\n'+$t.csv->replace(' ','')+'#'
                                  ]
                            )
            );
  $f->match(
    [
      z:FunctionDefinition<Any>[1]|
            print(if($debug.debug,|'BEFORE: ' + meta::pure::metamodel::serialization::grammar::printFunctionDefinition($z, $ext, '')+'\n',|''));

            // Init
            let initState = meta::relational::tests::pct::process::initState(
              $z->openVariableValues(),
              $dbc
            );
            let db = $initState.database;
            let schema = $initState.schema;
            let runtime = $initState.runtime;

            // Reprocess the function replacing values with Database elements
            let reprocessed = $z.expressionSequence->evaluateAndDeactivate()->map(z|$z->reprocess($initState));

            // Add 'from'
            let returnGenericType = $z.expressionSequence->evaluateAndDeactivate()->last().genericType->toOne();
            let returnMultiplicity = $z.expressionSequence->evaluateAndDeactivate()->last().multiplicity->toOne();
            let newFunction =   ^$z
                                (
                                  expressionSequence =  ^SimpleFunctionExpression
                                                        (
                                                          importGroup=system::imports::coreImport,
                                                          func = if($reprocessed.mapping->isEmpty(),|from_T_m__Runtime_1__T_m_,|from_T_m__Mapping_1__Runtime_1__T_m_),
                                                          functionName = 'from',
                                                          genericType = $returnGenericType,
                                                          multiplicity = $returnMultiplicity,                                                        
                                                          parametersValues = 
                                                                                $reprocessed.current->toOne()->cast(@ValueSpecification)
                                                                                ->concatenate(if ($reprocessed.mapping->isEmpty(),
                                                                                              |[],
                                                                                              |^InstanceValue
                                                                                               (
                                                                                                  genericType = ^GenericType(rawType=Mapping),
                                                                                                  multiplicity = PureOne,
                                                                                                  values = $reprocessed.mapping
                                                                                               )
                                                                                             ))
                                                                                ->concatenate(^InstanceValue
                                                                                              (
                                                                                                genericType = ^GenericType(rawType=Runtime),
                                                                                                multiplicity = PureOne,
                                                                                                values = $runtime
                                                                                              )
                                                                                )
                                                                            ,
                                                          resolvedMultiplicityParameters = $returnMultiplicity,
                                                          resolvedTypeParameters = $returnGenericType
                                                        )                                                                
                                );

            print(if($debug.debug,|'AFTER: ' + meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newFunction, $ext, '') + '\n',|''));

            // Update the database ------------
            let setUpSQLs = $reprocessed.csvs->joinStrings('\n-\n')->meta::alloy::service::execution::setUpDataSQLs($reprocessed.database->toOne(), $dbc.type);
            print(if($debug.debug,|'\n' + $setUpSQLs->joinStrings('\n') + '\n',|''));

            let updatePlan = ^meta::pure::executionPlan::ExecutionPlan
            (
                func = |'dummy',
                mapping = ^Mapping(package=meta::pure::executionPlan, name='dummy'),
                runtime = $reprocessed.runtime->toOne(),
                rootExecutionNode = ^meta::pure::executionPlan::SequenceExecutionNode(
                                      resultType = ^meta::pure::executionPlan::VoidResultType(type=meta::pure::router::store::routing::Void),
                                      executionNodes = $setUpSQLs->map(sql | meta::relational::mapping::generateSQLExecNode($sql, $reprocessed.runtime.connectionStores.connection->toOne()->cast(@meta::external::store::relational::runtime::DatabaseConnection)))
                                    ),
                authDependent = false
            );

            let plan = $updatePlan->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformPlan(meta::relational::extension::relationalExtensions());

            let planAsJson = $plan->meta::json::toJSON(1000, meta::json::config(false, false, true, true));

            meta::legend::executePlanAsJSON($planAsJson, []);
            // Update the database ------------

            let code =  '\n###Relational\n'+
                        $reprocessed.database->toOne()->printDatabase()+
                        if ($reprocessed.mapping->isEmpty(),
                          |'',
                          |'\n###Mapping\n' +
                          $reprocessed.mapping->toOne()->printMapping()
                        )+
                        '\n###Pure\n'+
                        $otherFuncs->filter(x|$x->instanceOf(FunctionDefinition))->map(o|'function '+$o->cast(@PackageableElement).package->toOne()->elementToPath()+'::'+$o->cast(@FunctionDefinition<Any>)->meta::pure::metamodel::serialization::grammar::printFunctionDefinition($ext, '');)->joinStrings('')+
                        'function test::lambdaContainer():Any[*]{\n'+
                        '  '+meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newFunction, $ext, '')+'\n'+
                        '}'
                        ;

            //println($code);

            let alloyCompiled = meta::legend::compile($code)->filter(x|$x.name == 'lambdaContainer__Any_MANY_')->cast(@FunctionDefinition<Any>).expressionSequence->cast(@InstanceValue)->evaluateAndDeactivate().values->toOne()->cast(@FunctionDefinition<Any>);

            //println($alloyCompiled.expressionSequence->at(0)->cast(@FunctionExpression)->evaluateAndDeactivate().parametersValues);

            //pair($newFunction, $reprocessed->toOne());
            pair($alloyCompiled, $reprocessed->toOne());
    ]
  );
}

Class meta::relational::tests::pct::process::ProcessingState
{
   database : Database[1];
   schema : Schema[1];
   runtime : Runtime[1];
   mapping : Mapping[0..1];
   current : Any[0..1];
   replaced : Pair<TDS<Any>, RelationStoreAccessor<Any>>[*];
   openVars : Map<String,Any>[0..1];
   csvs : String[*];
}

function meta::relational::tests::pct::process::merge(s1:ProcessingState[1], s2:ProcessingState[1]):ProcessingState[1]
{
  ^$s1
  (
    mapping += $s2.mapping,
    replaced += $s2.replaced,
    csvs += $s2.csvs,
    openVars = if($s1.openVars->isEmpty(),|$s1.openVars,|$s2.openVars)
  );
}

function meta::relational::tests::pct::process::initState(openVars:Map<String,Any>[0..1], connection:meta::external::store::relational::runtime::DatabaseConnection[1]):ProcessingState[1]
{
  let db = ^Database
  (
    name = 'MyDatabase',
    package = meta::relational::tests::pct::process
  );

  let schema = ^Schema
  (
    name='leSchema',
    database = $db
  );

  $db->mutateAdd('schemas', $schema);
  
  ^ProcessingState
  (
    database = $db,
    schema = $schema,
    openVars = $openVars,
    runtime =   ^Runtime
                (
                  connectionStores=^ConnectionStore
                                    (
                                      connection=$connection,
                                      element = $db
                                    )
                )
  );
}


###Pure
import meta::relational::metamodel::execute::*;
import meta::relational::functions::database::*;
import meta::external::store::relational::runtime::*;
import meta::pure::mapping::*;
import meta::core::runtime::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::*;
import meta::pure::metamodel::relation::*;
import  meta::relational::tests::pct::process::*;
import meta::pure::store::*;

function meta::relational::tests::pct::process::reprocess(a:Any[1], state:ProcessingState[1]):ProcessingState[1]
{
  $a->match(
    [
      z:FunctionExpression[1]| if($z.func == new_Class_1__String_1__KeyExpression_MANY__T_1_,
                                | meta::relational::tests::pct::process::reprocessNew($z->reactivate()->evaluateAndDeactivate(), $z.genericType.rawType->toOne()->cast(@Class<Any>), $state);,
                                | if (!$z.func->in(
                                              [
                                                  meta::pure::functions::relation::funcColSpecArray_FuncColSpec_MANY__P_1__FuncColSpecArray_1_,
                                                  meta::pure::functions::relation::funcColSpecArray2_FuncColSpec_MANY__P_1__FuncColSpecArray_1_,
                                                  meta::pure::functions::relation::funcColSpec_Function_1__String_1__T_1__FuncColSpec_1_,
                                                  meta::pure::functions::relation::funcColSpec2_Function_1__String_1__T_1__FuncColSpec_1_,
                                                  meta::pure::functions::relation::aggColSpecArray_AggColSpec_MANY__P_1__AggColSpecArray_1_,
                                                  meta::pure::functions::relation::aggColSpecArray2_AggColSpec_MANY__P_1__AggColSpecArray_1_,
                                                  meta::pure::functions::relation::aggColSpec_Function_1__Function_1__String_1__T_1__AggColSpec_1_,
                                                  meta::pure::functions::relation::aggColSpec2_Function_1__Function_1__String_1__T_1__AggColSpec_1_
                                              ]),
                                    | let repro = $z.parametersValues->evaluateAndDeactivate()->map(x|$x->reprocess($state));
                                      ^$state
                                      (
                                          current = ^$z(parametersValues = $repro.current->cast(@ValueSpecification))->evaluateAndDeactivate(),
                                          mapping = $repro.mapping->first(),
                                          replaced = $repro.replaced,
                                          csvs = $repro.csvs
                                      );,
                                    | ^$state
                                      (
                                        current = $z
                                      )
                                  )                                  
                               );,
      ix:InstanceValue[1]|
                          let i = $ix->evaluateAndDeactivate();
                          let type = $i.genericType.rawType->toOne();
                          let hasClass = $i.values->find(x|$x->instanceOf(Class))->isNotEmpty();                          
                          // Nil is for Empty Sets, Any is currently for collection of primitives of different types (may create an issue if we have classes of different types)
                          if ($type->instanceOf(Class) && $type != Any && $type != Nil && !$type->subTypeOf(Function) && $type != TDS && $type != Enumeration && $type != SortInfo,
                              |
                                // Process class
                                let values = $i.values->map(
                                    x|$x->match([
                                                  v:ValueSpecification[1]|$v->reactivate()->evaluateAndDeactivate(),
                                                  a:Any[1]|$a
                                                ]
                                          )
                                );
                                meta::relational::tests::pct::process::reprocessNew($values, $type->cast(@Class<Any>), $state);,
                              |
                                // Primitive pass through
                                let repro = $i.values->map(x|$x->reprocess($state));
                                ^$state
                                (
                                  current = ^$i
                                            (
                                              genericType = if($repro.current->genericType()->isEmpty(),|$i.genericType, |$repro.current->genericType()->first()->toOne()),
                                              values = $repro.current
                                            ),
                                  mapping = $repro.mapping->first(),
                                  replaced = $repro.replaced,
                                  csvs = $repro.csvs
                                );
                          );,
      z:LambdaFunction<Any>[1] | let repro = $z.expressionSequence->evaluateAndDeactivate()->map(z|$z->reprocess($state));
                                 ^$state
                                 (
                                    current=^$z(expressionSequence = $repro.current->cast(@ValueSpecification)->toOneMany()),
                                    mapping = $repro.mapping->first(),
                                    replaced=$repro.replaced,
                                    csvs = $repro.csvs
                                 );,
      v:VariableExpression[1] | let openVar = $state.openVars->toOne()->get($v.name);
                                if ($openVar->isEmpty(),
                                  |^$state
                                   (
                                      current = $v
                                   ),
                                  |reprocess( ^InstanceValue
                                              (
                                                genericType = $openVar->toOne()->cast(@List<Any>).values->at(0)->genericType()->toOne(),
                                                multiplicity = PureOne,
                                                values = $openVar->toOne()->cast(@List<Any>).values
                                              ), $state)
                                  );,
      x:TDS<Any>[1] | processTDS($x, $state),
      x:Any[1] |
              ^$state
                (
                current = $x
                );             
    ]
  );
}

function meta::relational::tests::pct::process::reprocessNew(values:Any[*], type:Class<Any>[1], state:ProcessingState[1]):ProcessingState[1]
{
    let newState = $state->merge(classesToDatabase($values, $state));      
    ^$newState
    (
        current = ^SimpleFunctionExpression
                  (
                    importGroup=system::imports::coreImport,
                    func = getAll_Class_1__T_MANY_,
                    functionName = 'getAll',
                    genericType = ^GenericType(rawType=$type),
                    multiplicity = ZeroMany,
                    parametersValues = [
                                          ^InstanceValue
                                          (
                                            genericType = ^GenericType(rawType=$type),
                                            multiplicity = PureOne,
                                            values = []
                                          )
                                      ]
                  )->evaluateAndDeactivate()
    );
}

function meta::relational::tests::pct::process::processTDS(tds:TDS<Any>[1], state:ProcessingState[1]):ProcessingState[1]
{
  let map = meta::relational::transform::fromPure::pureTypeToDataTypeMap();
  let rand = random() * 10000000;
  let table = ^Table
  (
    name = 'tb_' + $rand->floor()->toString() + '_' + now()->toEpochValue(DurationUnit.MILLISECONDS)->toString(),
    columns = $tds->columns()->map(c|
                    ^meta::relational::metamodel::Column(
                        name=$c.name->toOne(),
                        type=$map->meta::pure::functions::collection::get($c->genericType().typeArguments->at(1).rawType->toOne())->toOne()
                    )
                  ),
    schema = $state.schema
  );

  $state.schema->mutateAdd('tables', $table);

  let relAccessor = ^RelationStoreAccessor<Any>
  (
    store = $state.database,
    sourceElement = $table
  );

  // Create CSV out of TDS data
  let cols = $tds->columns();
  let csv = $state.schema.name+'\n' + 
            $relAccessor.sourceElement->cast(@Table).name + '\n' +
            $cols->map(x|$x.name)->joinStrings(',' ) + '\n' +
            $tds->map(x|$cols->map(c|$c->eval($x)->toOne()->toString())->joinStrings(','))
            ->joinStrings('\n');

  ^$state
  (
    current = $relAccessor,
    replaced = pair($tds, $relAccessor),
    csvs += $csv
  );
}




###Pure
import meta::relational::metamodel::execute::*;
import meta::relational::functions::database::*;
import meta::external::store::relational::runtime::*;
import meta::relational::tests::pct::process::tests::classToDB::*;
import meta::relational::tests::pct::process::*;
import meta::relational::metamodel::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::join::*;
import meta::relational::mapping::*;
import meta::pure::mapping::*;

function meta::relational::tests::pct::process::classesToDatabase(values:Any[*], givenState:ProcessingState[1]):ProcessingState[1]
{
  let _state = $givenState;
  let state = ^$_state(
                  mapping = ^Mapping
                            (
                              name = 'myMapping',
                              package = meta::relational::tests::pct::process
                            )
              );  

  if (!$values->isEmpty(),
    | // Scan types
      let rootType = $values->genericType().rawType->first()->toOne()->cast(@Class<Any>);
      if ($rootType != KeyExpression,
        | let allClasses = scanClass($rootType);

          // Build schema
          let tables = $allClasses->map(c|$c->classToTable($state.database, $state.schema, $state.mapping->toOne()));
          let joins = $allClasses->map(c|$c->buildJoins($tables, $state.database));

          $state.schema->mutateAdd('tables', $tables.table);
          $state.database->mutateAdd('joins', $joins.join);

          buildCSV($values, $rootType, [], 1, $tables);
          let csvs = $tables->map(k|$k.csv->joinStrings('\n'));
          $state.mapping->toOne()->mutateAdd('classMappings', $tables.classMapping);

          let runtime = $state.runtime;
          let mapping = $state.mapping->toOne();

          ^$state
          (
            csvs += $csvs
          );,
        |$state
      );,
    | $state
  );


}

function meta::relational::tests::pct::process::buildCSV(values:Any[*], class:Class<Any>[1], property:Property<Nil, Any|*>[0..1], parentId:Integer[1], maps:ClassTableMapping[*]):ClassTableMapping[*]
{
  let info = $maps->filter(c|$c.class == $class)->toOne();
  let header = $info.table.schema.name->toOne()+'\n'+
               $info.table.name+'\n'+
               $info.table.columns->cast(@Column).name->joinStrings(',');
  let rows = $values->map
  (
    v | let id = $values->indexOf($v) + $parentId*10;
        let r = $id
        ->concatenate($info.properties->map(p | let res = $p->eval($v); if($res->isEmpty(),|'',|$res);))
        ->concatenate($info.parentProperties->map(p | if($p == $property,|$parentId,|'-1')))
        ->makeString(',');

        let props = $class.properties->filter(p|!$p->isPrimitiveValueProperty());
        $props->map(p|
                      let vals = $p->eval($v);
                      buildCSV($vals, $p->functionReturnType().rawType->toOne()->cast(@Class<Any>), $p, $id, $maps);
                );

        $r;

  )->joinStrings('\n');

  $info->mutateAdd('csv', if($info.csv->isEmpty(),
      |$header+'\n'+$rows,
      |$rows
  ));

  $maps;
}

Class meta::relational::tests::pct::process::ClassTableMapping
{
  class : Class<Any>[1];
  table : Table[1];
  properties : Property<Nil,Any|*>[*];
  parentProperties : Property<Nil,Any|*>[*];
  classMapping: RootRelationalInstanceSetImplementation[1];
  csv : String[*];
}

Class meta::relational::tests::pct::process::PropertyColumnMapping
{
  property : Property<Nil,Any|*>[1];
  column : Column[1];
}

function meta::relational::tests::pct::process::classToTable(class:Class<Any>[1], db:Database[1], schema:Schema[1], mapping:Mapping[1]):ClassTableMapping[1]
{
  let map = meta::relational::transform::fromPure::pureTypeToDataTypeMap();
  let properties = $class.properties->filter(p|$p->isPrimitiveValueProperty());                
  let cols = $properties->map(p|^PropertyColumnMapping(property=$p, column=^Column(name=$p.name->toOne(), type=$map->get($p->functionReturnType().rawType->toOne())->toOne())));
  let idCol = ^Column(name='_pureId', type=^meta::relational::metamodel::datatype::Integer());
  let table = ^Table(name=$class.name->toOne(), schema=$schema, primaryKey=$idCol, columns=$idCol->concatenate($cols.column));
  let tableAlias = ^TableAlias(database=$db, name=$table.name, relationalElement = $table);


  let set = ^RootRelationalInstanceSetImplementation
            (
                id = $class.name->toOne(),
                root = true,
                userDefinedPrimaryKey = true,
                primaryKey = ^TableAliasColumn(alias=$tableAlias, column=$idCol),
                parent = $mapping,
                class = $class,
                mainTableAlias = $tableAlias                     
            );

  let pmappings = $cols->map(c |
                ^RelationalPropertyMapping
                (
                  property = $c.property,
                  sourceSetImplementationId = $class.name->toOne(),
                  targetSetImplementationId = '',
                  owner = $set,
                  relationalOperationElement = ^TableAliasColumn
                                                (
                                                  columnName = $c.column.name,
                                                  alias = $tableAlias,
                                                  column = $c.column
                                                )
                )

      );

  $set->mutateAdd('propertyMappings', $pmappings);

  ^ClassTableMapping
  (
    class = $class,
    table = $table,
    properties = $properties,
    classMapping = $set
  );  
}

Class meta::relational::tests::pct::process::JoinRes
{
  join : Join[1];
  property : Property<Nil,Any|*>[1];
  fk : Column[1];
  propertyMapping : RelationalPropertyMapping[1];
}

function meta::relational::tests::pct::process::buildJoins(class:Class<Any>[1], classTableMappings:ClassTableMapping[*], db:Database[1]):meta::relational::tests::pct::process::JoinRes[*]
{
  let src = $classTableMappings->filter(ctm|$ctm.class == $class)->toOne();
  let cols = $class.properties
                ->filter(p|!$p->isPrimitiveValueProperty())
                ->map(p|
                        let targetType = $p->functionReturnType().rawType->toOne();
                        let target = $classTableMappings->filter(ctm|$ctm.class == $targetType)->toOne();
                        let srcColumn = $src.table.columns->cast(@Column)->filter(c|$c.name == '_pureId')->toOne();
                        let fkColumn = ^Column(name='_'+$class.name->toOne()+'_'+$p.name->toOne(), type=^meta::relational::metamodel::datatype::Integer());
                        let targetTable = $target.table;                        
                        $targetTable->mutateAdd('columns', $fkColumn);
                        let srcAlias = ^TableAlias(database=$db, name='src', relationalElement=$src.table);
                        let targetAlias = ^TableAlias(database=$db, name=$targetTable.name, relationalElement=$targetTable);
                        let join =  ^Join
                                    (
                                      name = $class.name->toOne() + '_' + $p.name->toOne(),
                                      aliases = [pair($srcAlias,$targetAlias),pair($targetAlias,$srcAlias)],
                                      operation = ^DynaFunction
                                                  (
                                                    name = 'equal',
                                                    parameters = [
                                                      ^TableAliasColumn(alias=$srcAlias, column=$srcColumn),
                                                      ^TableAliasColumn(alias=$targetAlias, column=$fkColumn)
                                                    ]
                                                  )
                                    );
                        $target->mutateAdd('parentProperties', $p);
                        let res = ^JoinRes
                        (
                          join = $join,
                          property = $p,
                          fk = $fkColumn,
                          propertyMapping = ^RelationalPropertyMapping
                                            (
                                              property = $p,
                                              sourceSetImplementationId = $class.name->toOne(),
                                              targetSetImplementationId = $targetType.name->toOne(),
                                              relationalOperationElement = ^RelationalOperationElementWithJoin
                                                                           (
                                                                            joinTreeNode = ^JoinTreeNode
                                                                                           (
                                                                                              joinName = $join.name,
                                                                                              database = $db,
                                                                                              alias = $srcAlias,
                                                                                              join = $join
                                                                                           )
                                                                           )
                                            )
                        );
                        $res.propertyMapping->mutateAdd('owner', $src.classMapping);
                        $res;
                );
  $src.classMapping->mutateAdd('propertyMappings', $cols.propertyMapping);
  $cols;
}



function meta::relational::tests::pct::process::scanClass(a:Class<Any>[1]):Class<Any>[*]
{
  $a->scanClass([])->removeDuplicates();
}

function meta::relational::tests::pct::process::scanClass(a:Class<Any>[1], visited:Class<Any>[*]):Class<Any>[*]
{
  if ($a->in($visited),
    |[],
    | let newVisited = $visited->concatenate($a);
        $a
        ->concatenate(
          $a.properties->map(p|$p.genericType.rawType)->filter(c|$c->instanceOf(Class))->cast(@Class<Any>)->map(x|$x->scanClass($newVisited))
        )->concatenate(
          $a.generalizations.general.rawType->filter(x|$x != Any && $x->instanceOf(Class))->cast(@Class<Any>)->map(x|$x->scanClass($newVisited))
        );
  );
}







###Pure
import meta::relational::tests::pct::process::*;
import meta::relational::runtime::*;
import meta::relational::tests::pct::process::tests::functionReprocess::*;

Class meta::relational::tests::pct::process::tests::functionReprocess::SimpleClass
{
  value : String[1];
}


function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testConstantFunctionReprocess():Boolean[1]
{
  let newState = reprocess(|1+1, meta::pure::testConnection::getTestConnection(DatabaseType.H2), noDebug());
  assertEquals('{|(1 + 1)->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ''));
  assertEmpty($newState.second.mapping);
  assertEmpty($newState.second.database.schemas->at(0).tables);
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testTDSReprocess():Boolean[1]
{
  let newState = reprocess(|#TDS
                            col
                            value#->filter(x|$x.col == 'test'), meta::pure::testConnection::getTestConnection(DatabaseType.H2), noDebug());
  assertEquals('{|RelationElementAccessor(RelationStoreAccessor)->filter({x|(col == \'test\')})->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ''));
  assertEmpty($newState.second.mapping);
  assertEquals(1, $newState.second.database.schemas->at(0).tables->size());
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testClassReprocess():Boolean[1]
{
  let newState = reprocess(|[^SimpleClass(value='myValue'), ^SimpleClass(value='myValue2')]->filter(x|$x.value == 'test'), meta::pure::testConnection::getTestConnection(DatabaseType.H2), debug());
  assertEquals('{|meta::relational::tests::pct::process::tests::functionReprocess::SimpleClass.all()->filter({x|($x.value == \'test\')})->from(myMapping, Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ''));
  assertEquals(1, $newState.second.mapping->size());
  assertEquals(1, $newState.second.database.schemas->at(0).tables->size());
  assertEquals( 'leSchema\n'+
                'SimpleClass\n'+
                '_pureId,value\n'+
                '10,myValue\n'+
                '11,myValue2', $newState.second.csvs);
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testClassAsVariableReprocess():Boolean[1]
{
  let vals = [^SimpleClass(value='myValue'), ^SimpleClass(value='myValue2')];
  let newState = reprocess(|$vals->filter(x|$x.value == 'test'), meta::pure::testConnection::getTestConnection(DatabaseType.H2), debug());
  assertEquals('{|meta::relational::tests::pct::process::tests::functionReprocess::SimpleClass.all()->filter({x|($x.value == \'test\')})->from(myMapping, Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ''));
  assertEquals(1, $newState.second.mapping->size());
  assertEquals(1, $newState.second.database.schemas->at(0).tables->size());
  assertEquals( 'leSchema\n'+
                'SimpleClass\n'+
                '_pureId,value\n'+
                '10,myValue\n'+
                '11,myValue2', $newState.second.csvs);
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testPrimitiveListReprocess():Boolean[1]
{
  let newState = reprocess(|[1,2,3,4]->filter(x|$x > 1), meta::pure::testConnection::getTestConnection(DatabaseType.H2), debug());
  assertEquals('{|[1, 2, 3, 4]->filter({x|($x > 1)})->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ''));
  assertEmpty($newState.second.mapping);
  assertEmpty($newState.second.database.schemas->at(0).tables);
  assertEmpty($newState.second.csvs);
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testPrimitiveAnyReprocess():Boolean[1]
{
  let newState = reprocess(|[1,'a']->filter(x|$x == 1), meta::pure::testConnection::getTestConnection(DatabaseType.H2), debug());
  assertEquals('{|[1, \'a\']->filter({x|($x == 1)})->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ''));
  assertEmpty($newState.second.mapping);
  assertEmpty($newState.second.database.schemas->at(0).tables);
  assertEmpty($newState.second.csvs);
}


function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testEmptySetReprocess():Boolean[1]
{
  let newState = reprocess(|[]->filter(x|$x > 1), meta::pure::testConnection::getTestConnection(DatabaseType.H2), debug());
  assertEquals('{|[]->filter({x|($x > 1)})->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ''));
  assertEmpty($newState.second.mapping);
  assertEmpty($newState.second.database.schemas->at(0).tables);
  assertEmpty($newState.second.csvs);
}


###Pure
import meta::relational::mapping::*;
import meta::relational::tests::pct::process::tests::classToDB::*;

Class meta::relational::tests::pct::process::tests::classToDB::Firm
{
    legalName : String[1];
    employees : Person[*];
    address : Address[1];
}

Class meta::relational::tests::pct::process::tests::classToDB::Person
{
    firstName : String[0..1];
    lastName : String[1];
    addresses : Address[*];
}

Class meta::relational::tests::pct::process::tests::classToDB::Address
{
    zip : Integer[1];
}

function <<test.Test>> meta::relational::tests::pct::process::tests::classToDB::testClassToDB():Boolean[1]
{
  let res = meta::relational::tests::pct::process::classesToDatabase(
    ^Firm
    (
      legalName = 'Goldman',
      employees = [
        ^Person
        (
          firstName = 'john',
          lastName = 'doe',
          addresses = [^Address(zip=1), ^Address(zip=2)]
        ),
        ^Person
        (
          firstName = 'billy',
          lastName = 'bob',
          addresses = [^Address(zip=3), ^Address(zip=4)]
        )
      ],
      address = ^Address
                (
                  zip = 1999
                )
    ),
      meta::relational::tests::pct::process::initState(
        [],
        ^meta::external::store::relational::runtime::TestDatabaseConnection
        (
          type = meta::relational::runtime::DatabaseType.H2,
          timeZone = 'GMT'
        )
      )
  );

  assertEquals([
                'Firm',
                'Person',
                'Address'
               ], $res.schema.tables.name);

  assertEquals([
                'Firm_employees',
                'Firm_address',
                'Person_addresses'
               ], $res.database.joins.name);

  assertEquals([
                'Firm',
                'Person',
                'Address'
               ], $res.mapping.classMappings.class.name);

  assertEquals([
                'legalName',
                'employees',
                'address',
                'firstName',
                'lastName',
                'addresses',
                'zip'
               ], $res.mapping.classMappings->cast(@RootRelationalInstanceSetImplementation).propertyMappings.property.name);
}
