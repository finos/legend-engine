// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::functions::variant::convert::*;
import meta::pure::metamodel::variant::*;
import meta::relational::extension::*;
import meta::pure::extension::*;
import meta::relational::tests::pct::*;
import meta::json::*;
import meta::relational::mapping::*;
import meta::relational::metamodel::datatype::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::metamodel::execute::*;
import meta::relational::metamodel::relation::*;
import meta::relational::runtime::*;
import meta::external::store::relational::runtime::*;
import meta::core::runtime::*;
import meta::relational::metamodel::*;
import meta::pure::mapping::*;
import meta::pure::store::*;
import meta::pure::metamodel::relation::*;
import meta::relational::tests::pct::process::*;
import meta::pure::test::pct::*;

function <<PCT.adapter>> {PCT.adapterName='Databricks'} meta::relational::tests::pct::testAdapterForRelationalWithDatabricksExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
  meta::relational::tests::pct::testAdapterForRelationalExecution(
      $f,
      meta::pure::testConnection::getTestConnection(DatabaseType.Databricks)
  )
}

function <<PCT.adapter>> {PCT.adapterName='Spanner'} meta::relational::tests::pct::testAdapterForRelationalWithSpannerExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
  meta::relational::tests::pct::testAdapterForRelationalExecution(
      $f,
      meta::pure::testConnection::getTestConnection(DatabaseType.Spanner)
  )
}

function <<PCT.adapter>> {PCT.adapterName='MemSQL'} meta::relational::tests::pct::testAdapterForRelationalWithMemSQLExecution<X|o>(f:Function<{->X[o]}>[1]):X[o]
{
  meta::relational::tests::pct::testAdapterForRelationalExecution(
      $f,
      meta::pure::testConnection::getTestConnection(DatabaseType.MemSQL)
  )
}

function meta::relational::tests::pct::extractDependentFunctions(f:Any[1]):Function<Any>[*]
{
  $f->match([
    z:FunctionDefinition<Any>[1] |if(!$z->hasStereotype('function', PCT) && $z->instanceOf(PackageableElement) && $z->elementToPath()->contains('::tests::'),|$z,|[])->concatenate($z.expressionSequence->evaluateAndDeactivate()->map(x|$x->extractDependentFunctions()));,
    x:SimpleFunctionExpression[1]|let res = $x.parametersValues->map(p|$p->extractDependentFunctions());
                                  $res->concatenate($x.func->extractDependentFunctions());,
    i: InstanceValue[1] | $i.values->map(p|$p->extractDependentFunctions()),                                  
    a:Any[1] | []
  ]);  
}

function meta::relational::tests::pct::testAdapterForRelationalExecution<X|o>(f:Function<{->X[o]}>[1], dbc:meta::external::store::relational::runtime::DatabaseConnection[1]):X[o]
{
  testAdapterForRelationalExecution($f, $dbc, relationalExtensions());
}

function meta::relational::tests::pct::testAdapterForRelationalExecution<X|o>(f:Function<{->X[o]}>[1], dbc:meta::external::store::relational::runtime::DatabaseConnection[1], extensions:Extension[*]):X[o]
{
    let debug = noDebug();

    let repocessed = $f->meta::relational::tests::pct::process::reprocess($dbc, $debug);
    let newFunction = $repocessed.first;

    // ----

    let rawPlan = meta::pure::executionPlan::executionPlan($newFunction, ^meta::pure::runtime::ExecutionContext(), $extensions, $debug);

    let setup = meta::relational::tests::pct::process::setupDatabase($repocessed.second.csvs, $repocessed.second.database, $repocessed.second.runtime, $debug);

    let planWithTeardown = ^$rawPlan(rootExecutionNode =
        ^meta::pure::executionPlan::RelationalBlockExecutionNode(
            executionNodes = $setup->concatenate($rawPlan.rootExecutionNode),
            resultType = $rawPlan.rootExecutionNode.resultType,
            resultSizeRange =  $rawPlan.rootExecutionNode.resultSizeRange
        )
    );

    let planBindToJava = $planWithTeardown->meta::pure::executionPlan::platformBinding::localBinding::bindTestPlanToPlatformLocallyWithClasspathExtensions('LegendJava');

    let plan = $planBindToJava->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformPlan($extensions);

    let planAsJson = $plan->meta::json::toJSON(1000, meta::json::config(false, false, true, true));

    let x = meta::legend::executePlanAsJSON($planAsJson, []);

    print(if($debug.debug,|'\nResult JSON:\n'+$x+'\n',|''));
    // ----
    
    let resultType = $f->functionReturnType().rawType->toOne();
    let json = $x->meta::json::parseJSON();
    if (!$json->instanceOf(JSONObject),
      | $json->meta::json::fromJSON($resultType),
      | if ($json->cast(@JSONObject).keyValuePairs->filter(k|$k.key.value=='result').value->isEmpty(),
            | let res = $json->meta::json::fromJSON(meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalClassResult, ^meta::json::ExtendedJSONDeserializationConfig(typeKeyName='__TYPE', failOnUnknownProperties=true, nullReplacementInArray=TDSNull))->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalClassResult)->toOne();
              let x= meta::protocols::pure::vX_X_X::invocation::execution::execute::processRelationalClassResult($res, $repocessed.second.mapping->toOne(), $repocessed.second.runtime, [], $extensions);
              $x.first.values;,
            | let res = $json->meta::json::fromJSON(meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalTDSResult, ^meta::json::ExtendedJSONDeserializationConfig(typeKeyName='__TYPE', failOnUnknownProperties=true, nullReplacementInArray=TDSNull))->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalTDSResult)->toOne();
              // processResult
              if ($resultType->instanceOf(PrimitiveType) || $resultType->in([Variant, List, Map, Nil]),
                | let preResultFinal = $res.result.rows->head().values->head();

                  print(if($debug.debug,|'\nRaw Result:\n'+$preResultFinal->makeString('[',',',']'),|''));

                  let resultFinal = $preResultFinal->resultToType($f->functionReturnType(), $f->functionReturnMultiplicity());

                  print(if($debug.debug,|'\nResult Final:\n'+$resultFinal->makeString('[',',',']'),|''));
                  $resultFinal;,
                |
                    let tdsString = $res.builder->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::TDSBuilder).columns->map(c | $c.name + $c.type->map(t | ':' + $t)->orElse(''))->joinStrings(',') + '\n' +
                                  $res.result.rows->map(x|
                                        range($x.values->size())->map(z |
                                            $x.values->at($z)->match([
                                              s: String[1] | $s->meta::relational::tests::csv::escapeCSVString(),
                                              a: Any[1] | if($a == TDSNull, |'null', |$a->toString())
                                            ]);
                                        )->makeString(',')
                                      )->joinStrings('\n');
                    let resultFinal = $tdsString->stringToTDS();
                    print(if($debug.debug,|'\nResult Final:\n'+$resultFinal->toString(),|''));
                    $resultFinal;
              );
    ))->cast(@X)->toMultiplicity(@[o]);
}

function meta::relational::tests::pct::process::resultToType(preResultFinal: Any[0..1], type: GenericType[1], mult: Multiplicity[1]):Any[*]
{
  let resultType = $type.rawType->toOne();

  if ([
        pair(|$preResultFinal->isEmpty() || $preResultFinal == TDSNull, |[]),
        pair(|$preResultFinal->toOne()->instanceOf(String) && $mult->isToMany() && $preResultFinal->toOne()->cast(@String)->startsWith('[') && $preResultFinal->toOne()->cast(@String)->endsWith(']'), |$preResultFinal->toOne()->cast(@String)->fromJson()->toMany($type)),
        pair(|$resultType->subTypeOf(DateTime), |meta::pure::functions::string::parseDate($preResultFinal->toOne()->toString())),
        pair(|$resultType->subTypeOf(Date), |buildDate($preResultFinal->toOne()->toString())),
        pair(|$resultType->subTypeOf(Decimal), |$preResultFinal->toOne()->cast(@Number)->toDecimal()),
        pair(|$resultType->subTypeOf(Integer), |$preResultFinal->toOne()->cast(@Number)->round()),
        pair(|$resultType->subTypeOf(Float), |$preResultFinal->toOne()->cast(@Number)->toFloat()),
        pair(|$resultType->subTypeOf(Number), |$preResultFinal->toOne()->cast(@Number)),
        pair(|$resultType == Variant, |$preResultFinal->toOne()->cast(@String)->fromJson()),
        pair(|$resultType->in([List, Map]), |$preResultFinal->toOne()->cast(@String)->fromJson()->to($type))
      ],
    | $preResultFinal->toOne()
  );
}

function meta::relational::tests::pct::process::toMany(var: Variant[1], type: GenericType[1]):Any[*]
{
  // compile time has hard time doing dynamic toMany so this is to compensate
  if([
      pair(|$type.rawType == Integer, |$var->toMany(@Integer)),
      pair(|$type.rawType == Float, |$var->toMany(@Float)),
      pair(|$type.rawType == String, |$var->toMany(@String)),
      pair(|$type.rawType == StrictDate, |$var->toMany(@StrictDate)),
      pair(|$type.rawType == DateTime, |$var->toMany(@DateTime)),
      pair(|$type.rawType == Boolean, |$var->toMany(@Boolean)),
      pair(|$type.rawType == Variant, |$var->toMany(@Variant))
    ],
    | fail('Not supported: ' + $type->meta::pure::metamodel::serialization::grammar::printGenericType()); [];
  );
}

function meta::relational::tests::pct::process::to(var: Variant[1], type: GenericType[1]):Any[0..1]
{
  // compile time has hard time doing dynamic to so this is to compensate
  if([
      pair(|$type.rawType == Integer, |$var->to(@Integer)),
      pair(|$type.rawType == Float, |$var->to(@Float)),
      pair(|$type.rawType == String, |$var->to(@String)),
      pair(|$type.rawType == StrictDate, |$var->to(@StrictDate)),
      pair(|$type.rawType == DateTime, |$var->to(@DateTime)),
      pair(|$type.rawType == Boolean, |$var->to(@Boolean)),

      pair(|$type.rawType == List && $type.typeArguments->at(0).rawType == Integer, |$var->to(@List<Integer>)),
      pair(|$type.rawType == List && $type.typeArguments->at(0).rawType == Float, |$var->to(@List<Float>)),
      pair(|$type.rawType == List && $type.typeArguments->at(0).rawType == String, |$var->to(@List<String>)),
      pair(|$type.rawType == List && $type.typeArguments->at(0).rawType == StrictDate, |$var->to(@List<StrictDate>)),
      pair(|$type.rawType == List && $type.typeArguments->at(0).rawType == DateTime, |$var->to(@List<DateTime>)),
      pair(|$type.rawType == List && $type.typeArguments->at(0).rawType == Boolean, |$var->to(@List<Boolean>)),
      pair(|$type.rawType == List && $type.typeArguments->at(0).rawType == Variant, |$var->to(@List<Variant>)),

      pair(|$type.rawType == Map && $type.typeArguments->at(1).rawType == Integer, |$var->to(@Map<String,Integer>)),
      pair(|$type.rawType == Map && $type.typeArguments->at(1).rawType == Float, |$var->to(@Map<String,Float>)),
      pair(|$type.rawType == Map && $type.typeArguments->at(1).rawType == String, |$var->to(@Map<String,String>)),
      pair(|$type.rawType == Map && $type.typeArguments->at(1).rawType == StrictDate, |$var->to(@Map<String,StrictDate>)),
      pair(|$type.rawType == Map && $type.typeArguments->at(1).rawType == DateTime, |$var->to(@Map<String,DateTime>)),
      pair(|$type.rawType == Map && $type.typeArguments->at(1).rawType == Boolean, |$var->to(@Map<String,Boolean>)),
      pair(|$type.rawType == Map && $type.typeArguments->at(1).rawType == Variant, |$var->to(@Map<String,Variant>))
    ],
    | fail('Not supported: ' + $type->meta::pure::metamodel::serialization::grammar::printGenericType()); [];
  );
}

function meta::relational::tests::pct::process::buildDate(dateStr:String[1]):Date[1]
{
  // Need to find a better way...
  
  // Manage SubSecond
  let _dot = if ($dateStr->contains('.'),
    | let subPart = $dateStr->substring($dateStr->indexOf('.') + 1, $dateStr->lastIndexOf('+'));
      let x = '.'+$subPart;
      if ($subPart == '000000000',
        | $dateStr->substring(0, $dateStr->indexOf('.')) + '' + $dateStr->substring($dateStr->lastIndexOf('+')),
        | $dateStr->substring(0, $dateStr->indexOf('.')) + $x->parseFloat()->toString()->substring(1) + $dateStr->substring($dateStr->lastIndexOf('+'))
      );,
    | $dateStr
  );

  // Remove +
  let _plus = if ($_dot->startsWith('+'),
    |$_dot->substring(1),
    |$_dot
  );

  // StrictDate
  let _strict = if ($_plus->contains('T'),
    |let time = $_plus->substring($_plus->indexOf('T') + 1, $_plus->lastIndexOf('+'));
     if ($time == '00:00:00',
          | $_plus->substring(0, $_plus->indexOf('T')),
          | $_plus
        );,
    |$_plus
  );

  meta::pure::functions::string::parseDate($_strict);
}

function meta::relational::tests::pct::process::printDatabase(d:Database[1]):String[1]
{
  'Database ' + $d->elementToPath() + '\n' +
  '('+
   $d.schemas->map(
      s | '\n  Schema '+$s.name + '\n  ('+ $s.tables->map(x|
              '\n    Table '+$x.name+' ('+
                  $x.columns->map(z|let c = $z->cast(@meta::relational::metamodel::Column);
                                    if($c.name->contains(' '),|'"'+$c.name+'"',|$c.name) + ' ' + $c.type->match([
                                                          x : Varchar[1] | 'VARCHAR(' + $x.size->toString() + ')',
                                                          d : meta::relational::metamodel::datatype::Decimal[1] | 'DECIMAL(' + $d.precision->toString() + ',' + $d.scale->toString() + ')',
                                                          z : Any[1] | $z->type().name->toOne()
                                                        ]
                                                      ) + if ($x.primaryKey->contains($c),
                                                                |' PRIMARY KEY',
                                                                |if ($c.nullable->isNotEmpty() && $c.nullable->toOne(), |'', |' NOT NULL')
                                                          );
                                 )->joinStrings(', ')+
              ')'
                  )->joinStrings('') + '\n  )'
          )->joinStrings('')+
    $d.joins->map(
      j | 'Join '+$j.name+'('+$j.operation->printRelationalOperationElement(false)+')'
    )->joinStrings(' ')+
  '\n)';
}

function meta::relational::tests::pct::process::printMapping(d:Mapping[1]):String[1]
{
  'Mapping '+$d->elementToPath()+
  '('+
    $d.classMappings->map(si|
      $si.class->elementToPath() + '['+$si.id+']:' + $si->match(
        [
          rs:RootRelationalInstanceSetImplementation[1] | 'Relational {'+
              $rs.propertyMappings->cast(@RelationalPropertyMapping)->map(pm|
                $pm.property.name->toOne() + if($pm.targetSetImplementationId == '',|'',|'['+$pm.targetSetImplementationId+']') + ':'+$pm.relationalOperationElement->printRelationalOperationElement(true))->joinStrings(', ')
          +'}'
        ]
      )
    )->joinStrings(' ')+
  ')';
}

function meta::relational::tests::pct::process::printRelationalOperationElement(d:RelationalOperationElement[1], forMapping:Boolean[1]):String[1]
{
  $d->match(
    [
      t:TableAliasColumn[1]|if($forMapping,|'['+$t.alias.database->toOne()->elementToPath()+']',|'')+$t.alias.relationalElement->cast(@Table).schema.name->toOne()+'.'+$t.alias.relationalElement->cast(@Table).name+'.'+$t.column.name,
      x:RelationalOperationElementWithJoin[1]|'['+$x.joinTreeNode.database->toOne()->elementToPath()+']@'+$x.joinTreeNode.joinName->toOne(),
      v:DynaFunction[1]|$v.name + '('+$v.parameters->map(p|$p->printRelationalOperationElement($forMapping))->joinStrings(',')+')'
    ]
  )
}

function meta::relational::tests::pct::process::reprocess(connection:meta::external::store::relational::runtime::RelationalDatabaseConnection[1]):String[1]
{
  '^meta::external::store::relational::runtime::RelationalDatabaseConnection('+
  'type='+$connection.type->meta::pure::metamodel::serialization::grammar::printValueSpecification([], ^meta::pure::metamodel::serialization::grammar::GContext(space=''))+','+
  'authenticationStrategy = '+$connection.authenticationStrategy->printNew()+','+ //^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy(),'+
  'datasourceSpecification = '+$connection.datasourceSpecification->printNew()+ //^meta::pure::alloy::connections::alloy::specification::DuckDBDatasourceSpecification(path = \'\')'+
  ')'
}

function meta::relational::tests::pct::process::printNew(a:Any[1]):String[1]
{  
  $a->match(
    [
       i:Integer[1] | $i->toString(),
       x:String[1] | '\''+$x+'\'',
       a:Any[1] |
         let _type = $a->type()->cast(@Class<Any>);
         let properties = $_type->meta::pure::functions::meta::hierarchicalProperties();
         '^'+$a->type()->elementToPath()+'('+
          $properties->map(p| let value = $p->eval($a);
                              if ($value->isEmpty(),
                                |'',
                                |$p.name->toOne() + '=' + $value->map(w|$w->printNew())->joinStrings(',')
                              );
                       )->filter(v|$v != '')->joinStrings(',')+
        ')';
    ]
  );
}

function meta::relational::tests::pct::process::reprocess(f:Function<Any>[1], dbc:meta::external::store::relational::runtime::DatabaseConnection[1], debug: DebugContext[1]):Pair<FunctionDefinition<Any>,ProcessingState>[1]
{ 
  let ext = ^meta::pure::metamodel::serialization::grammar::Configuration
            (
              fullPath = true,
              extensions =   ^meta::pure::metamodel::serialization::grammar::GrammarExtension(
                                extraConnectionHandlers =
                                  [
                                    x:RelationalDatabaseConnection[0..1] |
                                        $x->toOne()->reprocess(); 
                                  ],
                                extraInstanceValueHandlers = 
                                  [
                                    x:RelationStoreAccessor<Any>[1]|
                                      let table = $x.sourceElement->cast(@Table);  
                                      let schema = $table.schema;
                                      let schemaName = if ($schema.name == 'default', |'', |$schema.name + '.');
                                      '#>{' + $x.store->elementToPath() + '.' + $schemaName + $table.name->toOne() + '}#';
                                      ,
                                    t:meta::pure::metamodel::relation::TDS<Any>[1]|'#TDS\n'+$t.csv->replace(' ','')+'#'
                                  ]
                            )
            );
  $f->match(
    [
      z:FunctionDefinition<Any>[1]|
            print(if($debug.debug,|'BEFORE: ' + meta::pure::metamodel::serialization::grammar::printFunctionDefinition($z, $ext, ^meta::pure::metamodel::serialization::grammar::GContext(space=''))+'\n',|''));

            // Init
            let initState = meta::relational::tests::pct::process::initState(
              $z->openVariableValues(),
              $dbc
            );
            let db = $initState.database;
            let schema = $initState.schema;
            let runtime = $initState.runtime;

            // Reprocess the function replacing values with Database elements
            let allReprocessed = $z.expressionSequence->evaluateAndDeactivate()->map(z|$z->reprocess($initState));

            let newFunction = ^$z(expressionSequence = $allReprocessed.current->cast(@ValueSpecification)->toOneMany())
                  ->addWith($allReprocessed.mapping, $runtime);

            print(if($debug.debug,|'AFTER: ' + meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newFunction, $ext, ^meta::pure::metamodel::serialization::grammar::GContext(space='')) + '\n',|''));

            let otherFuncs = $allReprocessed.current->map(r | $r->meta::relational::tests::pct::extractDependentFunctions())->distinct();
            let reprocessed = $allReprocessed->tail()->fold({prev, reproc |meta::relational::tests::pct::process::merge($prev, $reproc)}, $allReprocessed->head()->toOne());

            let code =  '\n###Relational\n'+
                        $reprocessed.database->toOne()->printDatabase()+
                        if ($reprocessed.mapping->isEmpty(),
                          |'',
                          |'\n###Mapping\n' +
                          $reprocessed.mapping->toOne()->printMapping()
                        )+
                        '\n###Pure\n'+
                        $otherFuncs->filter(x|$x->instanceOf(FunctionDefinition))->map(o|'function '+$o->cast(@PackageableElement).package->toOne()->elementToPath()+'::'+$o->cast(@FunctionDefinition<Any>)->meta::pure::metamodel::serialization::grammar::printFunctionDefinition($ext, ^meta::pure::metamodel::serialization::grammar::GContext(space=''));)->joinStrings('')+
                        'function test::lambdaContainer():Any[*]{\n'+
                        '  '+meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newFunction, $ext, ^meta::pure::metamodel::serialization::grammar::GContext(space=''))+'\n'+
                        '}'
                        ;
            //println($code);

            let alloyCompiled = meta::legend::compile($code)->filter(x|$x.name == 'lambdaContainer__Any_MANY_')->cast(@FunctionDefinition<Any>).expressionSequence->cast(@InstanceValue)->evaluateAndDeactivate().values->toOne()->cast(@FunctionDefinition<Any>);

            //println($alloyCompiled.expressionSequence->at(0)->cast(@FunctionExpression)->evaluateAndDeactivate().parametersValues);

            //pair($newFunction, $reprocessed->toOne());
            pair($alloyCompiled, $reprocessed);
    ]
  );
}

function meta::relational::tests::pct::process::addWith(func: FunctionDefinition<Any>[1], mapping: Mapping[*],runtime: Runtime[1]): FunctionDefinition<Any>[1]
{
  let returnGenericType = $func->functionReturnType();
  let returnMultiplicity = $func->functionReturnMultiplicity();

  assert($mapping->size() <= 1, 'Only one mapping supported');

  // for single expression keep in-line behavior of with
  // for multi, use the with that takes the whole function definition
  // the reason for this is that the latter preeval, invalidating many PCT test as preeval will evaluate constant values that PCT aims to push to DB
  $func.expressionSequence->evaluateAndDeactivate()->match([
    vs: ValueSpecification[1] |
      let withWith = ^SimpleFunctionExpression
      (
        importGroup=system::imports::coreImport,
        func = if($mapping->isEmpty(), |from_T_m__Runtime_1__T_m_, |from_T_m__Mapping_1__Runtime_1__T_m_),
        functionName = 'with',
        genericType = $returnGenericType,
        multiplicity = $returnMultiplicity,
        parametersValues =    $vs
                              ->concatenate(if ($mapping->isEmpty(),
                                            |[],
                                            |^InstanceValue
                                              (
                                                genericType = ^GenericType(rawType=Mapping),
                                                multiplicity = PureOne,
                                                values = $mapping->toOne()
                                              )
                                            ))
                              ->concatenate(^InstanceValue
                                            (
                                              genericType = ^GenericType(rawType=Runtime),
                                              multiplicity = PureOne,
                                              values = $runtime
                                            )
                              )
                          ,
        resolvedMultiplicityParameters = $returnMultiplicity,
        resolvedTypeParameters = $returnGenericType
      );
      ^$func(expressionSequence = $withWith);
    ,
    multi: ValueSpecification[1..*] |
      let withWith = ^SimpleFunctionExpression
      (
        importGroup=system::imports::coreImport,
        func = if($mapping->isEmpty(), |from_FunctionDefinition_1__Runtime_1__T_m_, |from_FunctionDefinition_1__Mapping_1__Runtime_1__T_m_),
        functionName = 'with',
        genericType = $returnGenericType,
        multiplicity = $returnMultiplicity,
        parametersValues =    ^InstanceValue(
                                              genericType = $func->genericType()->toOne(),
                                              multiplicity = PureOne,
                                              values = $func
                                            )
                              ->concatenate(if ($mapping->isEmpty(),
                                            |[],
                                            |^InstanceValue
                                              (
                                                genericType = ^GenericType(rawType=Mapping),
                                                multiplicity = PureOne,
                                                values = $mapping->toOne()
                                              )
                                            ))
                              ->concatenate(^InstanceValue
                                            (
                                              genericType = ^GenericType(rawType=Runtime),
                                              multiplicity = PureOne,
                                              values = $runtime
                                            )
                              )
                          ,
        resolvedMultiplicityParameters = $returnMultiplicity,
        resolvedTypeParameters = $returnGenericType
      );

      ^$func(expressionSequence = $withWith);,
      a: Any[*] | fail('not supported: ' + $a->type()->elementToPath() + ': ' + $a->size()->toString()); $func;
  ]);
}

function meta::relational::tests::pct::process::setupDatabase(csvs: String[*], database: Database[1], runtime: Runtime[1], debug: DebugContext[1]): meta::pure::executionPlan::SequenceExecutionNode[1]
{
  let dbc = $runtime.connectionByElement($database)->cast(@meta::external::store::relational::runtime::DatabaseConnection);

  // Update the database ------------
  let dbConfig =  meta::relational::functions::sqlQueryToString::createDbConfig($dbc.type);
  let originalExtension = $dbConfig.dbExtension;
  let originalTranslator = $originalExtension.ddlCommandsTranslator;

  let ddlTranslator = ^RelationalDDLCommandsTranslator(
    createSchema = $originalTranslator.createSchema,
    dropSchema =  {sql: DropSchemaSQL[1], c: DbConfig[1] | []->cast(@String)}, // wont drop schemas as best to reuse them between tests specially on shared (not in memory) resources
    dropTable = $originalTranslator.dropTable,
    createTable = {sql: CreateTableSQL[1], c: DbConfig[1] | $originalTranslator.createTable->map(f | $f->eval(^$sql(isTempTable = true), $c))}, // create temp table to best isolate tables on shared resources
    loadTable = $originalTranslator.loadTable,
    createView = $originalTranslator.createView
  );

  let pctDbConfig = ^$dbConfig(dbExtension = ^$originalExtension(ddlCommandsTranslator = $ddlTranslator));

  let setUpSQLs = $csvs->joinStrings('\n-\n')->meta::alloy::service::execution::setUpDataSQLs($database->toOne(), $pctDbConfig);
  print(if($debug.debug,|'\n' + $setUpSQLs->joinStrings('\n') + '\n',|''));

  let nodes = ^meta::pure::executionPlan::SequenceExecutionNode(
        resultType = ^meta::pure::executionPlan::VoidResultType(genericType=^GenericType(rawType=meta::pure::router::store::routing::Void)),
        executionNodes = $setUpSQLs->map(sql |
            let sqlNode = $sql->meta::relational::mapping::generateSQLExecNode($dbc);
            // todo better way to do this?
            if($sql->toLower()->startsWith('drop') && $sql->toLower()->contains('table') , |^$sqlNode(onConnectionCloseCommitQuery = $sql, onConnectionCloseRollbackQuery = $sql), |$sqlNode);
        )
  );
}

Class meta::relational::tests::pct::process::ProcessingState
{
   database : Database[1];
   schema : Schema[1];
   runtime : Runtime[1];
   mapping : Mapping[0..1];
   current : Any[0..1];
   replaced : Pair<TDS<Any>, RelationStoreAccessor<Any>>[*];
   openVars : Map<String,Any>[0..1];
   csvs : String[*];
}

function meta::relational::tests::pct::process::merge(s1:ProcessingState[1], s2:ProcessingState[1]):ProcessingState[1]
{
  ^$s1
  (
    mapping += $s2.mapping,
    replaced += $s2.replaced,
    csvs += $s2.csvs,
    openVars = if($s1.openVars->isEmpty(),|$s1.openVars,|$s2.openVars)
  );
}

function meta::relational::tests::pct::process::initState(openVars:Map<String,Any>[0..1], connection:meta::external::store::relational::runtime::DatabaseConnection[1]):ProcessingState[1]
{
  let db = ^Database
  (
    name = 'MyDatabase',
    package = meta::relational::tests::pct::process
  );

  let schema = ^Schema
  (
    name='leSchema',
    database = $db
  );

  $db->mutateAdd('schemas', $schema);
  
  ^ProcessingState
  (
    database = $db,
    schema = $schema,
    openVars = $openVars,
    runtime =   ^Runtime
                (
                  connectionStores=^ConnectionStore
                                    (
                                      connection=$connection,
                                      element = $db
                                    )
                )
  );
}


###Pure
import meta::pure::metamodel::variant::*;
import meta::relational::metamodel::execute::*;
import meta::relational::functions::database::*;
import meta::external::store::relational::runtime::*;
import meta::pure::mapping::*;
import meta::core::runtime::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::*;
import meta::pure::metamodel::relation::*;
import meta::relational::tests::pct::process::*;
import meta::pure::store::*;

function meta::relational::tests::pct::process::reprocess(a:Any[1], state:ProcessingState[1]):ProcessingState[1]
{
  $a->match(
    [
      z:FunctionExpression[1]| if($z.func == new_Class_1__String_1__KeyExpression_MANY__T_1_,
                                | meta::relational::tests::pct::process::reprocessNew($z->reactivate()->evaluateAndDeactivate(), $z.genericType.rawType->toOne()->cast(@Class<Any>), $state);,
                                | if (!$z.func->in(
                                              [
                                                  meta::pure::functions::relation::funcColSpecArray_FuncColSpec_MANY__P_1__FuncColSpecArray_1_,
                                                  meta::pure::functions::relation::funcColSpecArray2_FuncColSpec_MANY__P_1__FuncColSpecArray_1_,
                                                  meta::pure::functions::relation::funcColSpec_Function_1__String_1__T_1__FuncColSpec_1_,
                                                  meta::pure::functions::relation::funcColSpec2_Function_1__String_1__T_1__FuncColSpec_1_,
                                                  meta::pure::functions::relation::aggColSpecArray_AggColSpec_MANY__P_1__AggColSpecArray_1_,
                                                  meta::pure::functions::relation::aggColSpecArray2_AggColSpec_MANY__P_1__AggColSpecArray_1_,
                                                  meta::pure::functions::relation::aggColSpec_Function_1__Function_1__String_1__T_1__AggColSpec_1_,
                                                  meta::pure::functions::relation::aggColSpec2_Function_1__Function_1__String_1__T_1__AggColSpec_1_
                                              ]),
                                    | let repro = $z.parametersValues->evaluateAndDeactivate()->map(x|$x->reprocess($state));
                                      ^$state
                                      (
                                          current = ^$z(parametersValues = if ($z->cast(@FunctionExpression).func == write_Relation_1__RelationElementAccessor_1__Integer_1_,
                                                                              | let reproCurrent = $repro.current->cast(@ValueSpecification);
                                                                                let tds = $reproCurrent->at(1)->cast(@FunctionExpression).parametersValues->at(0);
                                                                                $reproCurrent->at(0)->concatenate($tds);,
                                                                              | $repro.current->cast(@ValueSpecification))
                                                       )->evaluateAndDeactivate(),
                                          mapping = $repro.mapping->first(),
                                          replaced = $repro.replaced,
                                          csvs = $repro.csvs
                                      );,
                                    | ^$state
                                      (
                                        current = $z
                                      )
                                  )                                  
                               );,
      ix:InstanceValue[1]|
                          let i = $ix->evaluateAndDeactivate();
                          let type = $i.genericType.rawType->toOne();
                          let hasClass = $i.values->find(x|$x->instanceOf(Class))->isNotEmpty();
                          // Nil is for Empty Sets, Any is currently for collection of primitives of different types (may create an issue if we have classes of different types)
                          if ($type->instanceOf(Class) && !$type->subTypeOf(Function) && !$type->in([Any, Nil, TDS, Enumeration, SortInfo, Map, List, Pair, Variant, meta::pure::metamodel::relation::Relation]),
                              |
                                // Process class
                                let values = $i.values->map(
                                    x|$x->match([
                                                  v:ValueSpecification[1]|$v->reactivate()->evaluateAndDeactivate(),
                                                  a:Any[1]|$a
                                                ]
                                          )
                                );
                                meta::relational::tests::pct::process::reprocessNew($values, $type->cast(@Class<Any>), $state);,
                              |
                                // Primitive pass through
                                let repro = $i.values->map(x|$x->reprocess($state));
                                ^$state
                                (
                                  current = ^$i
                                            (
                                              genericType = if($repro.current->isEmpty(),|$i.genericType, |$repro.current->genericType()),
                                              values = $repro.current
                                            ),
                                  mapping = $repro.mapping->first(),
                                  replaced = $repro.replaced,
                                  csvs = $repro.csvs
                                );
                          );,
      z:LambdaFunction<Any>[1] | let repro = $z.expressionSequence->evaluateAndDeactivate()->map(z|$z->reprocess($state));
                                 ^$state
                                 (
                                    current=^$z(expressionSequence = $repro.current->cast(@ValueSpecification)->toOneMany()),
                                    mapping = $repro.mapping->first(),
                                    replaced=$repro.replaced,
                                    csvs = $repro.csvs
                                 );,
      v:VariableExpression[1] | let openVar = $state.openVars->toOne()->get($v.name);
                                if ($openVar->isEmpty(),
                                  |^$state
                                   (
                                      current = $v
                                   ),
                                  |reprocess( ^InstanceValue
                                              (
                                                genericType = $openVar->toOne()->cast(@List<Any>).values->at(0)->genericType()->toOne(),
                                                multiplicity = PureOne,
                                                values = $openVar->toOne()->cast(@List<Any>).values
                                              ), $state)
                                  );,
      x:TDS<Any>[1] | processTDS($x, $state),
      x:Any[1] |
              ^$state
                (
                current = $x
                );             
    ]
  );
}

function meta::relational::tests::pct::process::reprocessNew(values:Any[*], type:Class<Any>[1], state:ProcessingState[1]):ProcessingState[1]
{
    let newState = $state->merge(classesToDatabase($values, $state));
    let sfe = ^SimpleFunctionExpression
                  (
                    importGroup=system::imports::coreImport,
                    func = getAll_Class_1__T_MANY_,
                    functionName = 'getAll',
                    genericType = ^GenericType(rawType=$type),
                    multiplicity = ZeroMany,
                    parametersValues = [
                                          ^InstanceValue
                                          (
                                            genericType = ^GenericType(rawType=$type),
                                            multiplicity = PureOne,
                                            values = []
                                          )
                                      ]
                  )->evaluateAndDeactivate();
    let currentSfe = $values->match([
      noValue:Any[0]|^SimpleFunctionExpression
                          (
                            importGroup=system::imports::coreImport,
                            func = meta::pure::functions::multiplicity::toOne_T_MANY__T_1_,
                            functionName = 'toOne',
                            genericType = ^GenericType(rawType=$type),
                            multiplicity = PureOne,
                            parametersValues = $sfe
                          )->evaluateAndDeactivate();,
      singleValue:Any[1]|^SimpleFunctionExpression
                          (
                            importGroup=system::imports::coreImport,
                            func = meta::pure::functions::multiplicity::toOne_T_MANY__T_1_,
                            functionName = 'toOne',
                            genericType = ^GenericType(rawType=$type),
                            multiplicity = PureOne,
                            parametersValues = $sfe
                          )->evaluateAndDeactivate();,
      multipleValues:Any[*]|$sfe
    ]);
    ^$newState
    (
        current = $currentSfe
    );
}

function meta::relational::tests::pct::process::processTDS(tds:TDS<Any>[1], state:ProcessingState[1]):ProcessingState[1]
{
  let map = meta::relational::transform::fromPure::pureTypeToDataTypeMap();
  let rand = random() * 10000000;
  let table = ^Table
  (
    name = 'tb_' + $rand->floor()->toString() + '_' + now()->toEpochValue(DurationUnit.MILLISECONDS)->toString(),
    columns = $tds->columns()->map(c|
                    ^meta::relational::metamodel::Column(
                        name=$c.name->toOne(),
                        type=$map->meta::pure::functions::collection::get($c->genericType().typeArguments->at(1).rawType->toOne())->toOne()
                    )
                  ),
    schema = $state.schema
  );

  $state.schema->mutateAdd('tables', $table);

  let relAccessor = ^RelationStoreAccessor<Any>
  (
    store = $state.database,
    sourceElement = $table
  );

  // Create CSV out of TDS data
  let cols = $tds->columns();
  let csv = $state.schema.name+'\n' +
            $relAccessor.sourceElement->cast(@Table).name + '\n' +
            $cols->map(x|$x.name)->joinStrings(',' ) + '\n' +
            $tds->map(
              x | $cols->map(c| let val = $c->eval($x);
                                if ($val == [],
                                  | 'null',
                                  | $val->toOne()->match(
                                      [
                                        x : Date[1] | format('%t{yyyy-MM-dd"T"HH:mm:ss.SSSSSSSSS}', $x),
                                        s : Variant[1] | '"' + $s->toString() + '"',
                                        z : Any[1] | $z->toString()
                                      ]
                                    )
                                );
              )->joinStrings(',')
            )->joinStrings('\n');

  ^$state
  (
    current = $relAccessor,
    replaced = pair($tds, $relAccessor),
    csvs += $csv
  );
}




###Pure
import meta::relational::metamodel::execute::*;
import meta::relational::functions::database::*;
import meta::external::store::relational::runtime::*;
import meta::relational::tests::pct::process::tests::classToDB::*;
import meta::relational::tests::pct::process::*;
import meta::relational::metamodel::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::join::*;
import meta::relational::mapping::*;
import meta::pure::mapping::*;

function meta::relational::tests::pct::process::classesToDatabase(values:Any[*], givenState:ProcessingState[1]):ProcessingState[1]
{
  let _state = $givenState;
  let state = ^$_state(
                  mapping = ^Mapping
                            (
                              name = 'myMapping',
                              package = meta::relational::tests::pct::process
                            )
              );  

  if (!$values->isEmpty(),
    | // Scan types
      let rootType = $values->genericType().rawType->first()->toOne()->cast(@Class<Any>);
      if ($rootType != KeyExpression,
        | let allClasses = scanClass($rootType);

          // Build schema
          let tables = $allClasses->map(c|$c->classToTable($state.database, $state.schema, $state.mapping->toOne()));
          let joins = $allClasses->map(c|$c->buildJoins($tables, $state.database));

          $state.schema->mutateAdd('tables', $tables.table);
          $state.database->mutateAdd('joins', $joins.join);

          buildCSV($values, $rootType, [], 1, $tables);
          let csvs = $tables->map(k|$k.csv->joinStrings('\n'));
          $state.mapping->toOne()->mutateAdd('classMappings', $tables.classMapping);

          let runtime = $state.runtime;
          let mapping = $state.mapping->toOne();

          ^$state
          (
            csvs += $csvs
          );,
        |$state
      );,
    | $state
  );


}

function meta::relational::tests::pct::process::buildCSV(values:Any[*], class:Class<Any>[1], property:Property<Nil, Any|*>[0..1], parentId:Integer[1], maps:ClassTableMapping[*]):ClassTableMapping[*]
{
  let info = $maps->filter(c|$c.class == $class)->toOne();
  let header = $info.table.schema.name->toOne()+'\n'+
               $info.table.name+'\n'+
               $info.table.columns->cast(@Column).name->joinStrings(',');
  let rows = $values->map
  (
    v | let id = $values->indexOf($v) + $parentId*10;
        let r = $id
        ->concatenate($info.properties->map(p | let res = $p->eval($v); if($res->isEmpty(),|'',|$res);))
        ->concatenate($info.parentProperties->map(p | if($p == $property,|$parentId,|'-1')))
        ->makeString(',');

        let props = $class.properties->filter(p|!$p->isPrimitiveValueProperty());
        $props->map(p|
                      let vals = $p->eval($v);
                      buildCSV($vals, $p->functionReturnType().rawType->toOne()->cast(@Class<Any>), $p, $id, $maps);
                );

        $r;

  )->joinStrings('\n');

  $info->mutateAdd('csv', if($info.csv->isEmpty(),
      |$header+'\n'+$rows,
      |$rows
  ));

  $maps;
}

Class meta::relational::tests::pct::process::ClassTableMapping
{
  class : Class<Any>[1];
  table : Table[1];
  properties : Property<Nil,Any|*>[*];
  parentProperties : Property<Nil,Any|*>[*];
  classMapping: RootRelationalInstanceSetImplementation[1];
  csv : String[*];
}

Class meta::relational::tests::pct::process::PropertyColumnMapping
{
  property : Property<Nil,Any|*>[1];
  column : Column[1];
}

function meta::relational::tests::pct::process::classToTable(class:Class<Any>[1], db:Database[1], schema:Schema[1], mapping:Mapping[1]):ClassTableMapping[1]
{
  let rand = random() * 10000000;
  let tableName = $class.name->toOne() + $rand->floor()->toString() + '_' + now()->toEpochValue(DurationUnit.MILLISECONDS)->toString();

  let map = meta::relational::transform::fromPure::pureTypeToDataTypeMap();
  let properties = $class.properties->filter(p|$p->isPrimitiveValueProperty());                
  let cols = $properties->map(p|^PropertyColumnMapping(property=$p, column=^Column(name=$p.name->toOne(), type=$map->get($p->functionReturnType().rawType->toOne())->toOne())));
  let idCol = ^Column(name='_pureId', type=^meta::relational::metamodel::datatype::Integer());
  let table = ^Table(name=$tableName, schema=$schema, primaryKey=$idCol, columns=$idCol->concatenate($cols.column));
  let tableAlias = ^TableAlias(database=$db, name=$class.name->toOne(), relationalElement = $table);


  let set = ^RootRelationalInstanceSetImplementation
            (
                id = $class.name->toOne(),
                root = true,
                userDefinedPrimaryKey = true,
                primaryKey = ^TableAliasColumn(alias=$tableAlias, column=$idCol),
                parent = $mapping,
                class = $class,
                mainTableAlias = $tableAlias                     
            );

  let pmappings = $cols->map(c |
                ^RelationalPropertyMapping
                (
                  property = $c.property,
                  sourceSetImplementationId = $class.name->toOne(),
                  targetSetImplementationId = '',
                  owner = $set,
                  relationalOperationElement = ^TableAliasColumn
                                                (
                                                  columnName = $c.column.name,
                                                  alias = $tableAlias,
                                                  column = $c.column
                                                )
                )

      );

  $set->mutateAdd('propertyMappings', $pmappings);

  ^ClassTableMapping
  (
    class = $class,
    table = $table,
    properties = $properties,
    classMapping = $set
  );  
}

Class meta::relational::tests::pct::process::JoinRes
{
  join : Join[1];
  property : Property<Nil,Any|*>[1];
  fk : Column[1];
  propertyMapping : RelationalPropertyMapping[1];
}

function meta::relational::tests::pct::process::buildJoins(class:Class<Any>[1], classTableMappings:ClassTableMapping[*], db:Database[1]):meta::relational::tests::pct::process::JoinRes[*]
{
  let src = $classTableMappings->filter(ctm|$ctm.class == $class)->toOne();
  let cols = $class.properties
                ->filter(p|!$p->isPrimitiveValueProperty())
                ->map(p|
                        let targetType = $p->functionReturnType().rawType->toOne();
                        let target = $classTableMappings->filter(ctm|$ctm.class == $targetType)->toOne();
                        let srcColumn = $src.table.columns->cast(@Column)->filter(c|$c.name == '_pureId')->toOne();
                        let fkColumn = ^Column(name='_'+$class.name->toOne()+'_'+$p.name->toOne(), type=^meta::relational::metamodel::datatype::Integer());
                        let targetTable = $target.table;                        
                        $targetTable->mutateAdd('columns', $fkColumn);
                        let srcAlias = ^TableAlias(database=$db, name='src', relationalElement=$src.table);
                        let targetAlias = ^TableAlias(database=$db, name=$targetTable.name, relationalElement=$targetTable);
                        let join =  ^Join
                                    (
                                      name = $class.name->toOne() + '_' + $p.name->toOne(),
                                      aliases = [pair($srcAlias,$targetAlias),pair($targetAlias,$srcAlias)],
                                      operation = ^DynaFunction
                                                  (
                                                    name = 'equal',
                                                    parameters = [
                                                      ^TableAliasColumn(alias=$srcAlias, column=$srcColumn),
                                                      ^TableAliasColumn(alias=$targetAlias, column=$fkColumn)
                                                    ]
                                                  )
                                    );
                        $target->mutateAdd('parentProperties', $p);
                        let res = ^JoinRes
                        (
                          join = $join,
                          property = $p,
                          fk = $fkColumn,
                          propertyMapping = ^RelationalPropertyMapping
                                            (
                                              property = $p,
                                              sourceSetImplementationId = $class.name->toOne(),
                                              targetSetImplementationId = $targetType.name->toOne(),
                                              relationalOperationElement = ^RelationalOperationElementWithJoin
                                                                           (
                                                                            joinTreeNode = ^JoinTreeNode
                                                                                           (
                                                                                              joinName = $join.name,
                                                                                              database = $db,
                                                                                              alias = $srcAlias,
                                                                                              join = $join
                                                                                           )
                                                                           )
                                            )
                        );
                        $res.propertyMapping->mutateAdd('owner', $src.classMapping);
                        $res;
                );
  $src.classMapping->mutateAdd('propertyMappings', $cols.propertyMapping);
  $cols;
}



function meta::relational::tests::pct::process::scanClass(a:Class<Any>[1]):Class<Any>[*]
{
  $a->scanClass([])->removeDuplicates();
}

function meta::relational::tests::pct::process::scanClass(a:Class<Any>[1], visited:Class<Any>[*]):Class<Any>[*]
{
  if ($a->in($visited),
    |[],
    | let newVisited = $visited->concatenate($a);
        $a
        ->concatenate(
          $a.properties->map(p|$p.genericType.rawType)->filter(c|$c->instanceOf(Class))->cast(@Class<Any>)->map(x|$x->scanClass($newVisited))
        )->concatenate(
          $a.generalizations.general.rawType->filter(x|$x != Any && $x->instanceOf(Class))->cast(@Class<Any>)->map(x|$x->scanClass($newVisited))
        );
  );
}







###Pure
import meta::relational::tests::pct::process::*;
import meta::relational::runtime::*;
import meta::relational::tests::pct::process::tests::functionReprocess::*;

Class meta::relational::tests::pct::process::tests::functionReprocess::SimpleClass
{
  value : String[1];
}


function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testConstantFunctionReprocess():Boolean[1]
{
  let newState = reprocess(|1+1, meta::pure::testConnection::getTestConnection(DatabaseType.H2), noDebug());
  assertEquals('{|(1 + 1)->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ^meta::pure::metamodel::serialization::grammar::GContext(space='')));
  assertEmpty($newState.second.mapping);
  assertEmpty($newState.second.database.schemas->at(0).tables);
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testTDSReprocess():Boolean[1]
{
  let newState = reprocess(|#TDS
                            col
                            value#->filter(x|$x.col == 'test'), meta::pure::testConnection::getTestConnection(DatabaseType.H2), noDebug());
  assertEquals('{|RelationElementAccessor(RelationStoreAccessor)->filter({x|(col == \'test\')})->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ^meta::pure::metamodel::serialization::grammar::GContext(space='')));
  assertEmpty($newState.second.mapping);
  assertEquals(1, $newState.second.database.schemas->at(0).tables->size());
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testClassReprocess():Boolean[1]
{
  let newState = reprocess(|[^SimpleClass(value='myValue'), ^SimpleClass(value='myValue2')]->filter(x|$x.value == 'test'), meta::pure::testConnection::getTestConnection(DatabaseType.H2), noDebug());
  assertEquals('{|meta::relational::tests::pct::process::tests::functionReprocess::SimpleClass.all()->filter({x|($x.value == \'test\')})->from(myMapping, Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ^meta::pure::metamodel::serialization::grammar::GContext(space='')));
  assertEquals(1, $newState.second.mapping->size());
  assertEquals(1, $newState.second.database.schemas->at(0).tables->size());
  assertEquals( 'leSchema\n'+
                'SimpleClass\n'+
                '_pureId,value\n'+
                '10,myValue\n'+
                '11,myValue2', $newState.second.csvs);
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testClassAsVariableReprocess():Boolean[1]
{
  let vals = [^SimpleClass(value='myValue'), ^SimpleClass(value='myValue2')];
  let newState = reprocess(|$vals->filter(x|$x.value == 'test'), meta::pure::testConnection::getTestConnection(DatabaseType.H2), noDebug());
  assertEquals('{|meta::relational::tests::pct::process::tests::functionReprocess::SimpleClass.all()->filter({x|($x.value == \'test\')})->from(myMapping, Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ^meta::pure::metamodel::serialization::grammar::GContext(space='')));
  assertEquals(1, $newState.second.mapping->size());
  assertEquals(1, $newState.second.database.schemas->at(0).tables->size());
  assertEquals( 'leSchema\n'+
                'SimpleClass\n'+
                '_pureId,value\n'+
                '10,myValue\n'+
                '11,myValue2', $newState.second.csvs);
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testPrimitiveListReprocess():Boolean[1]
{
  let newState = reprocess(|[1,2,3,4]->filter(x|$x > 1), meta::pure::testConnection::getTestConnection(DatabaseType.H2), noDebug());
  assertEquals('{|[1, 2, 3, 4]->filter({x|($x > 1)})->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ^meta::pure::metamodel::serialization::grammar::GContext(space='')));
  assertEmpty($newState.second.mapping);
  assertEmpty($newState.second.database.schemas->at(0).tables);
  assertEmpty($newState.second.csvs);
}

function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testPrimitiveAnyReprocess():Boolean[1]
{
  let newState = reprocess(|[1,'a']->filter(x|$x == 1), meta::pure::testConnection::getTestConnection(DatabaseType.H2), noDebug());
  assertEquals('{|[1, \'a\']->filter({x|($x == 1)})->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ^meta::pure::metamodel::serialization::grammar::GContext(space='')));
  assertEmpty($newState.second.mapping);
  assertEmpty($newState.second.database.schemas->at(0).tables);
  assertEmpty($newState.second.csvs);
}


function <<test.Test>> meta::relational::tests::pct::process::tests::functionReprocess::testEmptySetReprocess():Boolean[1]
{
  let newState = reprocess(|[]->filter(x|$x > 1), meta::pure::testConnection::getTestConnection(DatabaseType.H2), noDebug());
  assertEquals('{|[]->filter({x|($x > 1)})->from(Runtime(MyDatabase))}', meta::pure::metamodel::serialization::grammar::printFunctionDefinition($newState.first, ^meta::pure::metamodel::serialization::grammar::GContext(space='')));
  assertEmpty($newState.second.mapping);
  assertEmpty($newState.second.database.schemas->at(0).tables);
  assertEmpty($newState.second.csvs);
}


###Pure
import meta::relational::mapping::*;
import meta::relational::tests::pct::process::tests::classToDB::*;

Class meta::relational::tests::pct::process::tests::classToDB::Firm
{
    legalName : String[1];
    employees : Person[*];
    address : Address[1];
}

Class meta::relational::tests::pct::process::tests::classToDB::Person
{
    firstName : String[0..1];
    lastName : String[1];
    addresses : Address[*];
}

Class meta::relational::tests::pct::process::tests::classToDB::Address
{
    zip : Integer[1];
}

function <<test.Test>> meta::relational::tests::pct::process::tests::classToDB::testClassToDB():Boolean[1]
{
  let res = meta::relational::tests::pct::process::classesToDatabase(
    ^Firm
    (
      legalName = 'Goldman',
      employees = [
        ^Person
        (
          firstName = 'john',
          lastName = 'doe',
          addresses = [^Address(zip=1), ^Address(zip=2)]
        ),
        ^Person
        (
          firstName = 'billy',
          lastName = 'bob',
          addresses = [^Address(zip=3), ^Address(zip=4)]
        )
      ],
      address = ^Address
                (
                  zip = 1999
                )
    ),
      meta::relational::tests::pct::process::initState(
        [],
        ^meta::external::store::relational::runtime::TestDatabaseConnection
        (
          type = meta::relational::runtime::DatabaseType.H2,
          timeZone = 'GMT'
        )
      )
  );

  assertEquals([
                'Firm',
                'Person',
                'Address'
               ], $res.schema.tables.name);

  assertEquals([
                'Firm_employees',
                'Firm_address',
                'Person_addresses'
               ], $res.database.joins.name);

  assertEquals([
                'Firm',
                'Person',
                'Address'
               ], $res.mapping.classMappings.class.name);

  assertEquals([
                'legalName',
                'employees',
                'address',
                'firstName',
                'lastName',
                'addresses',
                'zip'
               ], $res.mapping.classMappings->cast(@RootRelationalInstanceSetImplementation).propertyMappings.property.name);
}
