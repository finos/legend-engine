// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numericFunctions::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::postgres::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::boolean::*;
import meta::external::query::sql::metamodel::*;
import meta::external::store::relational::sqlDialectTranslation::*;
import meta::external::store::relational::sqlDialectTranslation::defaults::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::boolean::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::h2::*;
import meta::external::store::relational::sqlDialectTranslation::sqlTyping::typeInference::*;
import meta::external::store::relational::sqlDialectTranslation::utils::*;
import meta::pure::extension::*;

function meta::external::store::relational::sqlDialectTranslation::h2::h2SqlDialect(): SqlDialect[1]
{
  ^SqlDialect
  (
    dbType = 'H2',
    quoteConfig = h2QuoteConfiguration(),
    nodeProcessors = h2DialectNodeProcessors(),
    identifierProcessor = h2IdentifierProcessor(),
    expressionPrecedenceComparator = h2ExpressionPrecedenceComparator(),
    keywords = h2Keywords(),
    functionProcessorDispatch = meta::external::store::relational::sqlDialectTranslation::h2::functionProcessorMap_SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__Map_1_
  )
}

function meta::external::store::relational::sqlDialectTranslation::h2::h2SqlDialectExtension(): Extension[1]
{
  ^Extension
  (
    type = 'H2SqlDialectExtension',
    moduleExtensions = [
      ^SqlDialectTranslationModuleExtension
      (
        module = sqlDialectTranslationModuleExtensionName(),
        extraSqlDialects = h2SqlDialect()
      )
    ]
  )
}

function meta::external::store::relational::sqlDialectTranslation::h2::h2FunctionTestsExpectedErrors(): Map<String, String>[1]
{
  [
  
   
    
  
  ]->newMap()->cast(@Map<String, String>)
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2QuoteConfiguration(): QuoteConfiguration[1]
{
  ^QuoteConfiguration
  (
    start = '"',
    end = '"',
    escape = '""'
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2DialectNodeProcessors(): Map<Class<Node>, NodeProcessor<Node>>[1]
{
  newMap(
    h2DialectStatementProcessors()
    ->concatenate(
      h2DialectRelationProcessors()
    )
    ->concatenate(
      h2DialectExpressionProcessors()
    )
    ->concatenate(
      h2DialectLiteralProcessors()
    )
    ->concatenate(
      h2DialectSelectItemProcessors()
    )
    ->concatenate(
      h2DialectOtherNodeProcessors()
    )
    ->map(n | pair($n.nodeType, $n))
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2DialectStatementProcessors(): NodeProcessor<Statement>[*]
{
  [
    queryProcessor_default(),
    windowProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2DialectRelationProcessors(): NodeProcessor<Relation>[*]
{
  [
    tableProcessor_default(),
    aliasedRelationProcessor_default(),
    joinProcessor_default(),
    querySpecificationProcessor_default(),
    unionProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2DialectExpressionProcessors(): NodeProcessor<meta::external::query::sql::metamodel::Expression>[*]
{
  [
    comparisonExpressionNodeProcessor_default(),
    logicalBinaryExpressionNodeProcessor_default(),
    notExpressionNodeProcessor_default(),
    arithmeticExpressionNodeProcessor_h2(),
    columnTypeProcessor_default(),
    castProcessor_default(),
    negativeNodeProcessor_default(),
    functionCallProcessor_default(),
    whenClauseNodeProcessor_default(),
    searchedCaseExpressionNodeProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2DialectLiteralProcessors(): NodeProcessor<Literal>[*]
{
  [
    integerLiteralNodeProcessor_default(),
    stringLiteralNodeProcessor_default(),
    booleanLiteralNodeProcessor_default(),
    longLiteralNodeProcessor_default(),
    doubleLiteralNodeProcessor_default(),
    nullLiteralNodeProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2DialectSelectItemProcessors(): NodeProcessor<SelectItem>[*]
{
  [
    allColumnsNodeProcessor_default(),
    singleColumnNodeProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2DialectOtherNodeProcessors(): NodeProcessor<Node>[*]
{
  [
    sortItemProcessor_default(),
    selectProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2IdentifierProcessor(): IdentifierProcessor[1]
{
  identifierProcessor_default()
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2ExpressionPrecedenceComparator(): ExpressionPrecedenceComparator[1]
{
  ^ExpressionPrecedenceComparator(
    findOperatorType = findOperatorType_default_Expression_1__String_1_,
    operatorPrecedence = operatorPrecedence_default()
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::h2Keywords(): String[*]
{
  [ 
    
'ALL',
'AND',
'ANY',
'ARRAY',
'AS',
'ASYMMETRIC',
'AUTHORIZATION',
'BETWEEN',
'BOTH',
'CASE',
'CAST',
'CHECK',
'CONSTRAINT',
'CROSS',
'CURRENT_CATALOG',
'CURRENT_DATE',
'CURRENT_PATH',
'CURRENT_ROLE',
'CURRENT_SCHEMA',
'CURRENT_TIME',
'CURRENT_TIMESTAMP',
'CURRENT_USER',
'DAY',
'DEFAULT',
'DISTINCT',
'ELSE',
'END',
'EXCEPT',
'EXISTS',
'FALSE',
'FETCH',
'FOR',
'FOREIGN',
'FROM',
'FULL',
'GROUP',
'GROUPS',
'HAVING',
'HOUR',
'IF',
'ILIKE',
'IN',
'INNER',
'INTERSECT',
'INTERVAL',
'IS',
'JOIN',
'KEY',
'LEADING',
'LEFT',
'LIKE',
'LIMIT',
'LOCALTIME',
'LOCALTIMESTAMP',
'MINUS',
'MINUTE',
'MONTH',
'NATURAL',
'NOT',
'NULL',
'OFFSET',
'ON',
'OR',
'ORDER',
'OVER',
'PARTITION',
'PRIMARY',
'QUALIFY',
'RANGE',
'REGEXP',
'RIGHT',
'ROW',
'ROWNUM',
'ROWS',
'SECOND',
'SELECT',
'SESSION_USER',
'SET',
'SOME',
'SYMMETRIC',
'SYSTEM_USER',
'TABLE',
'TO',
'TOP',
'TRAILING',
'TRUE',
'UESCAPE',
'UNION',
'UNIQUE',
'UNKNOWN',
'USER',
'USING',
'VALUE',
'VALUES',
'WHEN',
'WHERE',
'WINDOW',
'WITH',
'YEAR'  
   
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::h2::arithmeticExpressionNodeProcessor_h2(): NodeProcessor<ArithmeticExpression>[1]
{
  nodeProcessor(
    ArithmeticExpression,
    {sqlDialect, a, state, config |
      let leftExpr = $sqlDialect->executeNodeProcessor($a.left, $a, $state, $config);
      let rightExpr = $sqlDialect->executeNodeProcessor($a.right, $a, $state, $config);
      let operator = if(
        [
          pair(|$a.type == ArithmeticType.ADD, | '+'),
          pair(|$a.type == ArithmeticType.SUBTRACT, | '-'),
          pair(|$a.type == ArithmeticType.MULTIPLY, | '*'),
          pair(|$a.type == ArithmeticType.DIVIDE, | '/'),
          pair(|$a.type == ArithmeticType.MODULUS, | '%'),
          pair(|$a.type == ArithmeticType.POWER, | '^')
        ],
        | failWithMessage('Unhandled arithmetic operator type: ' + $a.type->toString())
      );

      $leftExpr + ' ' + $operator + ' ' + $rightExpr;
    }
  )
}

function meta::external::store::relational::sqlDialectTranslation::h2::functionProcessorMap(sqlDialect: SqlDialect[1], state: SqlDialectTranslationState[1], config: SqlDialectTranslationConfig[1]): Map<Class<SqlFunction>, FunctionProcessor>[1]
{
  newMap([
    // Numeric
    pair(Abs, simpleFunctionProcessor('abs')),
    pair(Cbrt, argTransformFunctionProcessor('cbrt','power(%s,1.0/3)')),
    pair(Ceil, argTransformFunctionProcessor('ceil','cast(ceil(%s) as float)')),
    pair(Ceiling, argTransformFunctionProcessor('ceiling','cast(ceiling(%s) as float)')),
    pair(Degrees, simpleFunctionProcessor('degrees')),
    pair(Exp, simpleFunctionProcessor('exp')),
    pair(Ln, simpleFunctionProcessor('ln')),
    pair(Log, argTransformFunctionProcessor('log','log(%s,%s)',{p:String[*]| if($p->size()==1,|['10',$p->at(0)],|$p)})),
    pair(Log10, simpleFunctionProcessor('log10')),
    pair(Sqrt, simpleFunctionProcessor('sqrt')),
    pair(Acos, simpleFunctionProcessor('acos')),
    pair(Asin, simpleFunctionProcessor('asin')),
    pair(Atan, simpleFunctionProcessor('atan')),
    pair(Atan2, simpleFunctionProcessor('atan2')),
    pair(Cos, simpleFunctionProcessor('cos')),
    pair(Cot, simpleFunctionProcessor('cot')),
    pair(Sin, simpleFunctionProcessor('sin')),
    pair(Tan, simpleFunctionProcessor('tan')),
    pair(Power, simpleFunctionProcessor('power')),
    pair(Sign, argTransformFunctionProcessor('sign','cast(sign(%s) as float)')),
    pair(Mod,simpleFunctionProcessor('mod')),
    pair(Round,simpleFunctionProcessor('round')),


    // String
    pair(Lpad, argTransformFunctionProcessor('lpad', 'lpad(%s)', {p:String[*]| if($p->size() == 2, |$p->concatenate('\' \''), |$p)->joinStrings(', ')})),
    pair(Rpad, argTransformFunctionProcessor('rpad', 'rpad(%s)', {p:String[*]| if($p->size() == 2, |$p->concatenate('\' \''), |$p)->joinStrings(', ')})),
    pair(Ltrim, argTransformFunctionProcessor('ltrim','regexp_replace(%s,\'^[%s]+\',\'\')',{p:String[*]| if($p->size()==1,|[$p->at(0),' '],| [$p->at(0),$p->at(1)->replace('\'','')] ) } )),
    pair(Rtrim, argTransformFunctionProcessor('rtrim','regexp_replace(%s,\'[%s]+$\',\'\')',{p:String[*]| if($p->size()==1,|[$p->at(0),' '],| [$p->at(0),$p->at(1)->replace('\'','')] ) } )),
    pair(Ascii, simpleFunctionProcessor('ascii')),
    pair( meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::Trim, argTransformFunctionProcessor('trim','%s',{p:String[*]| if($p->size()==1,|'trim('+$p->at(0)+')',| $p->trimHandlerForH2() ) } )),
    pair(Lower, simpleFunctionProcessor('lower')),
    pair(Upper, simpleFunctionProcessor('upper')),
    pair(Repeat,simpleFunctionProcessor('repeat')),
    pair(Replace,simpleFunctionProcessor('replace')),
    pair(Left,argTransformFunctionProcessor('left','%s',{p:String[*]| if($p->at(1)->parseInteger()<0,|'left('+$p->at(0)+',LENGTH('+$p->at(0)+')+'+$p->at(1)+')',|'left('+$p->at(0)+','+$p->at(1)+')')})),
    pair(Right,argTransformFunctionProcessor('right','%s',{p:String[*]| if($p->at(1)->parseInteger()<0,|'right('+$p->at(0)+',LENGTH('+$p->at(0)+')+'+$p->at(1)+')',|'right('+$p->at(0)+','+$p->at(1)+')')})),
    pair(Md5,argTransformFunctionProcessor('md5','hash(\'MD5\',%s)')),
    pair(Char_length,simpleFunctionProcessor('char_length')),
    pair(Chr,argTransformFunctionProcessor('chr','char(%s)')),
    pair(Strpos,argTransformFunctionProcessor('strpos','locate(%s,%s)',{p:String[*]|[$p->at(1),$p->at(0)]})),
    pair(Concat,simpleFunctionProcessor('concat')),
    pair(Coalesce,argTransformFunctionProcessor('coalesce','coalesce(%s,%s,%s,%s)',{p:String[*]|$p->concatArgumentHandlerForH2()->map(e|if($e->replace('\'','')=='null',|$e->replace('\'',''),|$e)) })),


    // Boolean
    pair(RegexpLike, argTransformFunctionProcessor('regexp_like', regexpPattern('~'), {p:String[*]|$p->transformRegexpParams()})),

    // Temporal
    pair(DateTrunc, argTransformFunctionProcessor('date_trunc', 'cast(date_trunc(%s, %s) as timestamp)')),
    pair(DatePart, argTransformFunctionProcessor('date_part','extract(%s)',{p:String[*]|$p->at(0)+' from '+$p->at(1) })),
    pair(Now, simpleFunctionProcessor('now')),
    pair(ToDate, argTransformFunctionProcessor('to_date', 'cast(parsedatetime(%s, %s) as date)', {p:String[*]|$p->at(0)->concatenate($p->at(1)->dateFormatSpecifierForH2())})),
    pair(ToTimestamp, argTransformFunctionProcessor('to_timestamp', '%s', {p:String[*]|$p->toTimestampForH2()}))
  ])
}

function meta::external::store::relational::sqlDialectTranslation::h2::toTimestampForH2(p:String[*]): String[1]
{
  if($p->size() == 1,
    | 'cast(dateadd(\'MILLISECOND\',cast(' + $p->at(0) + ' as bigint) * 1000,TIMESTAMP \'1970-01-01 00:00:00\') as TIMESTAMP(3))', //explicit casting needed as milliseconds are not shown if zero
    | 'parsedatetime(' + $p->at(0) + ', ' + $p->at(1)->dateFormatSpecifierForH2() + ')'
  )
}

function meta::external::store::relational::sqlDialectTranslation::h2::trimHandlerForH2(p:String[*]): String[1]
{
  
  let trimString=$p->at(2);
  let trimSeq=$p->at(1)->replace('\'','');
  println($p->at(0)->replace('\'',''));
  if($p->at(0)->replace('\'','')->equal('both'),|
     'regexp_replace('+$trimString+',\'^['+$trimSeq+']+|['+$trimSeq+']+$\',\'\')',|
     if($p->at(0)->replace('\'','')->equal('leading'),|
     'regexp_replace('+$trimString+',\'^['+$trimSeq+']+\',\'\')',|
     'regexp_replace('+$trimString+',\'['+$trimSeq+']+$\',\'\')'
     )
  );
}

function meta::external::store::relational::sqlDialectTranslation::h2::concatArgumentHandlerForH2(p:String[*]): String[*]
{
 if($p->size()==2,|
   $p->concatenate('null')->concatenate('null'),|
   if($p->size()==3,|
   $p->concatenate('null'),|
   $p
   )
 );
}


function meta::external::store::relational::sqlDialectTranslation::h2::dateFormatSpecifierForH2(f:String[1]): String[1]
{
  let formatSubs = [
    pair('YYYY', 'yyyy'),
    pair('MM', 'MM'),
    pair('DD', 'dd'),
    pair('Mon', 'MMM'),
    pair('HH24', 'HH'),
    pair('HH12', 'hh'),
    pair('HH', 'HH'),
    pair('MI','mm'),
    pair('SS', 'ss'),
    pair('MS', 'SSS'),
    pair('US', 'SSSSSS')
    // TODO: Handle more format specifiers
  ];

  $formatSubs->fold({i,a|$a->replace($i.first, $i.second)}, $f);
}

// --------------------------------------------------------------------------