// Copyright 2025 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::query::sql::metamodel::extension::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::misc::*;
import meta::external::store::relational::sqlDialectTranslation::*;
import meta::external::store::relational::sqlDialectTranslation::defaults::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::aggregate::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::boolean::aggregate::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::misc::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numeric::aggregate::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::aggregate::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::window::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::conditional::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::snowflake::*;
import meta::external::store::relational::sqlDialectTranslation::sqlTyping::typeInference::*;
import meta::external::query::sql::metamodel::extension::tests::*;
import meta::external::store::relational::sqlDialectTranslation::utils::*;
import meta::external::query::sql::metamodel::*;
import meta::pure::extension::*;

function meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeSqlDialect(): SqlDialect[1]
{
  ^SqlDialect
  (
    dbType = 'Snowflake',
    identifierQuoteConfig = snowflakeIdentifierQuoteConfiguration(),
    literalQuoteConfig = snowflakeLiteralQuoteConfiguration(),
    nodeProcessors = snowflakeDialectNodeProcessors(),
    identifierProcessor = snowflakeIdentifierProcessor(),
    expressionPrecedenceComparator = snowflakeExpressionPrecedenceComparator(),
    keywords = snowflakeKeywords(),
    functionProcessorMap = snowflakeFunctionProcessorMap(),
    variablePlaceholderPrefixSuffixMap = snowflakeVariablePlaceholderPrefixSuffixMap(),

    // For testing
    initSqlStatementsForTests = [
      'USE SCHEMA DEMO_DB.PUBLIC'
    ],
    expectedSqlDialectTestErrors = snowflakeExpectedSqlDialectTestErrors()
  )
}

function meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeSqlDialectExtension(): Extension[1]
{
  ^Extension
  (
    type = 'SnowflakeSqlDialectExtension',
    moduleExtensions = [
      ^SqlDialectTranslationModuleExtension
      (
        module = sqlDialectTranslationModuleExtensionName(),
        extraSqlDialects = snowflakeSqlDialect()
      )
    ]
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeExpectedSqlDialectTestErrors(): Map<String, String>[1]
{
  [
    pair(
      // https://docs.snowflake.com/en/sql-reference/functions-date-time#supported-date-and-time-parts
      'FuncTests - date_part(6/6)',
      'Snowflake doesn\'t support millisecond extraction in date_part'
    ),
    pair(
      // Snowflake returns integer when scale is 0 (which is not standard)
      'FuncTests - round(2/3)',
      'Expected - {"columnNames":["result"],"rows":[{"values":[3.0]}]}\n' +
      'Actual - {"columnNames":["result"],"rows":[{"values":[3]}]}'
    ),
    pair(
      // Snowflake returns integer when scale is 0 (which is not standard)
      'FuncTests - round(3/3)',
      'Expected - {"columnNames":["result"],"rows":[{"values":[2.0]}]}\n' +
      'Actual - {"columnNames":["result"],"rows":[{"values":[2]}]}'
    ),
    pair(
      // Snowflake always does floating point division (unlike other dbs)
      'NumberArithmetic - divide integer',
      'Expected - {"columnNames":["result"],"rows":[{"values":[0]}]}\n' +
      'Actual - {"columnNames":["result"],"rows":[{"values":[0.5]}]}'
    ),
    pair(
      // Snowflake returns empty string for no rows (which is not standard)
      'FuncTests - string_agg(0/0)',
      'Expected - {"columnNames":["age","result"],"rows":[{"values":[18,"Anthony,John"]},{"values":[20,"Fabrice"]},{"values":[{"key":[]},"Oliver"]},{"values":[30,{"key":[]}]}]}\n' +
      'Actual - {"columnNames":["age","result"],"rows":[{"values":[30,""]},{"values":[18,"Anthony,John"]},{"values":[20,"Fabrice"]},{"values":[{"key":[]},"Oliver"]}]}'
    ),
    pair(
      // Snowflake differs from ANSI standard for default frame (https://docs.snowflake.com/en/sql-reference/functions-window-syntax#usage-notes-for-window-frames)
      // Also, it doesn't support the default frame (RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
      'FuncTests - nth_value(0/1)',
      'Expected - {"columnNames":["student","dept","score","result"],"rows":[{"values":["Bob","Science",88,"Bob"]},{"values":["Charlie","Science",85,"Bob"]},{"values":["David","Science",80,"Bob"]},{"values":["Frank","Arts",85,"Frank"]},{"values":["Grace","Arts",84,"Frank"]},{"values":["Hannah","Arts",80,"Frank"]},{"values":["Alice","Science",90,{"key":[]}]},{"values":["Eve","Arts",88,{"key":[]}]}]}\n' +
      'Actual - {"columnNames":["student","dept","score","result"],"rows":[{"values":["Alice","Science",90,"Bob"]},{"values":["Bob","Science",88,"Bob"]},{"values":["Charlie","Science",85,"Bob"]},{"values":["David","Science",80,"Bob"]},{"values":["Eve","Arts",88,"Frank"]},{"values":["Frank","Arts",85,"Frank"]},{"values":["Grace","Arts",84,"Frank"]},{"values":["Hannah","Arts",80,"Frank"]}]}'
    ),
    pair(
      // Snowflake differs from ANSI standard for default frame (https://docs.snowflake.com/en/sql-reference/functions-window-syntax#usage-notes-for-window-frames)
      // Also, it doesn't support the default frame (RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
      'FuncTests - last_value(0/1)',
      'Expected - {"columnNames":["student","dept","score","result"],"rows":[{"values":["Alice","Science",90,"Alice"]},{"values":["Bob","Science",88,"Bob"]},{"values":["Charlie","Science",85,"Charlie"]},{"values":["David","Science",80,"David"]},{"values":["Eve","Arts",88,"Eve"]},{"values":["Frank","Arts",85,"Frank"]},{"values":["Grace","Arts",84,"Grace"]},{"values":["Hannah","Arts",80,"Hannah"]}]}\n' +
      'Actual - {"columnNames":["student","dept","score","result"],"rows":[{"values":["Alice","Science",90,"David"]},{"values":["Bob","Science",88,"David"]},{"values":["Charlie","Science",85,"David"]},{"values":["David","Science",80,"David"]},{"values":["Eve","Arts",88,"Hannah"]},{"values":["Frank","Arts",85,"Hannah"]},{"values":["Grace","Arts",84,"Hannah"]},{"values":["Hannah","Arts",80,"Hannah"]}]}'
    ),
    pair(
      'FuncTests - average_rank(0/0)',
      'Snowflake SQL Dialect does not support the function - average_rank'
    ),
    pair(
      // Snowflake picks randomly if 2 values tie for most frequent occurrences. Postgres implements mode as an ordered set aggregate function and picks the first one based on ordering.
      'FuncTests - mode(0/1)',
      'Expected - {"columnNames":["result"],"rows":[{"values":[88]}]}\n' +
      'Actual - {"columnNames":["result"],"rows":[{"values":[80]}]}'
    )
  ]->newMap()->cast(@Map<String, String>)
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeIdentifierQuoteConfiguration(): QuoteConfiguration[1]
{
  ^QuoteConfiguration
  (
    start = '"',
    end = '"',
    escape = '""'
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeLiteralQuoteConfiguration(): QuoteConfiguration[1]
{
  ^QuoteConfiguration
  (
    start = '\'',
    end = '\'',
    escape = '\'\''
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeDialectNodeProcessors(): Map<Class<Node>, NodeProcessor<Node>>[1]
{
  newMap(
    snowflakeDialectStatementProcessors()
    ->concatenate(
      snowflakeDialectRelationProcessors()
    )
    ->concatenate(
      snowflakeDialectExpressionProcessors()
    )
    ->concatenate(
      snowflakeDialectLiteralProcessors()
    )
    ->concatenate(
      snowflakeDialectSelectItemProcessors()
    )
    ->concatenate(
      snowflakeDialectOtherNodeProcessors()
    )
    ->concatenate(
      snowflakeDialectDDLProcessors()
    )
    ->map(n | pair($n.nodeType, $n))
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeDialectStatementProcessors(): NodeProcessor<Statement>[*]
{
  [
    queryProcessor_default(),
    windowProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeDialectRelationProcessors(): NodeProcessor<Relation>[*]
{
  [
    tableProcessor_default(),
    aliasedRelationProcessor_default(),
    joinProcessor_default(),
    querySpecificationProcessor_default(),
    unionProcessor_default(),
    tableSubqueryProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeDialectExpressionProcessors(): NodeProcessor<meta::external::query::sql::metamodel::Expression>[*]
{
  [
    comparisonExpressionNodeProcessor_default(),
    logicalBinaryExpressionNodeProcessor_default(),
    notExpressionNodeProcessor_default(),
    arithmeticExpressionNodeProcessor_snowflake(),
    qualifiedNameReferenceNodeProcessor_default(),
    isNullPredicateNodeProcessor_default(),
    isNotNullPredicateNodeProcessor_default(),
    negativeNodeProcessor_default(),
    currentTimeNodeProcessor_default(),
    whenClauseNodeProcessor_default(),
    searchedCaseExpressionNodeProcessor_default(),
    columnTypeProcessor_default(),
    castProcessor_default(),
    inListExpressionProcessor_default(),
    inPredicateProcessor_default(),
    extractProcessor_default(),
    betweenPredicateProcessor_default(),
    functionCallProcessor_default(),
    subQueryExpressionProcessor_default(),
    trimProcessor_default(),
    bitwiseBinaryExpressionNodeProcessorForSnowflake(),
    bitwiseNotExpressionNodeProcessorForSnowflake(),
    bitwiseShiftExpressionNodeProcessorForSnowflake()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeDialectLiteralProcessors(): NodeProcessor<Literal>[*]
{
  [
    integerLiteralNodeProcessor_default(),
    stringLiteralNodeProcessor_default(),
    booleanLiteralNodeProcessor_default(),
    longLiteralNodeProcessor_default(),
    doubleLiteralNodeProcessor_default(),
    dateLiteralNodeProcessor_default(),
    timestampLiteralNodeProcessor_default(),
    nullLiteralNodeProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeDialectSelectItemProcessors(): NodeProcessor<SelectItem>[*]
{
  [
    allColumnsNodeProcessor_default(),
    singleColumnNodeProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeDialectOtherNodeProcessors(): NodeProcessor<Node>[*]
{
  [
    sortItemProcessor_default(),
    selectProcessor_default(),
    withQueryProcessor_default(),
    windowFrameProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeDialectDDLProcessors(): NodeProcessor<Node>[*]
{
  [
    createTestTableProcessor_default(),
    dropTestTableProcessor_default(),
    insertIntoTestTableProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeIdentifierProcessor(): IdentifierProcessor[1]
{
  identifierProcessor_default()
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeExpressionPrecedenceComparator(): ExpressionPrecedenceComparator[1]
{
  ^ExpressionPrecedenceComparator(
    findOperatorType = findOperatorType_default_Expression_1__String_1_,
    operatorPrecedence = operatorPrecedence_default()
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeKeywords(): String[*]
{
  // Based on https://docs.snowflake.com/en/sql-reference/reserved-keywords
  [ 
    'account',
    'all',
    'alter',
    'and',
    'any',
    'as',
    'between',
    'by',
    'case',
    'cast',
    'check',
    'column',
    'connect',
    'connection',
    'constraint',
    'create',
    'cross',
    'current',
    'current_date',
    'current_time',
    'current_timestamp',
    'current_user',
    'database',
    'delete',
    'distinct',
    'drop',
    'else',
    'exists',
    'false',
    'following',
    'for',
    'from',
    'full',
    'grant',
    'group',
    'gscluster',
    'having',
    'ilike',
    'in',
    'increment',
    'inner',
    'insert',
    'intersect',
    'into',
    'is',
    'issue',
    'join',
    'lateral',
    'left',
    'like',
    'localtime',
    'localtimestamp',
    'minus',
    'natural',
    'not',
    'null',
    'of',
    'on',
    'or',
    'order',
    'organization',
    'qualify',
    'regexp',
    'revoke',
    'right',
    'rlike',
    'row',
    'rows',
    'sample',
    'schema',
    'select',
    'set',
    'some',
    'start',
    'table',
    'tablesample',
    'then',
    'to',
    'trigger',
    'true',
    'try_cast',
    'union',
    'unique',
    'update',
    'using',
    'values',
    'view',
    'when',
    'whenever',
    'where',
    'window',
    'with'
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::arithmeticExpressionNodeProcessor_snowflake(): NodeProcessor<ArithmeticExpression>[1]
{
  nodeProcessor(
    ArithmeticExpression,
    {sqlDialect, a, state, config |
      let leftExpr = $sqlDialect->executeNodeProcessor($a.left, $a, $state, $config);
      let rightExpr = $sqlDialect->executeNodeProcessor($a.right, $a, $state, $config);
      if ($a.type == ArithmeticType.POWER,
          | $sqlDialect->generateFunctionCallWithArgs('power', [$leftExpr, $rightExpr], [], $state, $config),
          | let operator = if(
              [
                pair(|$a.type == ArithmeticType.ADD, | '+'),
                pair(|$a.type == ArithmeticType.SUBTRACT, | '-'),
                pair(|$a.type == ArithmeticType.MULTIPLY, | '*'),
                pair(|$a.type == ArithmeticType.DIVIDE, | '/'),
                pair(|$a.type == ArithmeticType.MODULUS, | '%')
              ],
              | failWithMessage('Unhandled arithmetic operator type: ' + $a.type->toString())
            );
            $leftExpr + ' ' + $operator + ' ' + $rightExpr;
      );
    }
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeFunctionProcessorMap(): Map<Class<SqlFunction>, FunctionProcessor>[1]
{
  newMap([
    // Postgres Native Functions
    // Numeric
    pair(Abs, simpleFunctionProcessor('abs')),
    pair(Acos, simpleFunctionProcessor('acos')),
    pair(Asin, simpleFunctionProcessor('asin')),
    pair(Atan, simpleFunctionProcessor('atan')),
    pair(Atan2, simpleFunctionProcessor('atan2')),
    pair(Cbrt, simpleFunctionProcessor('cbrt')),
    pair(Ceil, customFunctionProcessor(processorForCeil_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Ceiling, customFunctionProcessor(processorForCeil_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Cos, simpleFunctionProcessor('cos')),
    pair(Cot, simpleFunctionProcessor('cot')),
    pair(Degrees, simpleFunctionProcessor('degrees')),
    pair(Exp, simpleFunctionProcessor('exp')),
    pair(Floor, customFunctionProcessor(processorForFloor_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Ln, simpleFunctionProcessor('ln')),
    pair(Log, argTransformFunctionProcessor('log', {n:Node[*]| if($n->size() == 1, | literal(10)->concatenate($n), | $n)})),
    pair(Mod, simpleFunctionProcessor('mod')),
    pair(Power, simpleFunctionProcessor('power')),
    pair(Round, simpleFunctionProcessor('round')),
    pair(Sign, simpleFunctionProcessor('sign')),
    pair(Sin, simpleFunctionProcessor('sin')),
    pair(Sinh, simpleFunctionProcessor('sinh')),    
    pair(Sqrt, simpleFunctionProcessor('sqrt')),
    pair(Tan, simpleFunctionProcessor('tan')),
    pair(Tanh, simpleFunctionProcessor('tanh')),
    
    // Numeric Aggregate
    pair(Average, simpleFunctionProcessor('avg')),
    pair(Sum, simpleFunctionProcessor('sum')),
    pair(Correlation, simpleFunctionProcessor('corr')),
    pair(CovarianceSample, simpleFunctionProcessor('covar_samp')),
    pair(CovariancePopulation, simpleFunctionProcessor('covar_pop')),
    pair(VariancePopulation, simpleFunctionProcessor('var_pop')),
    pair(VarianceSample, simpleFunctionProcessor('var_samp')),
    pair(StdDevSample, simpleFunctionProcessor('stddev_samp')),
    pair(StdDevPopulation, simpleFunctionProcessor('stddev_pop')),    
    pair(PercentileContinuous, simpleFunctionProcessor('percentile_cont')),
    pair(PercentileDiscrete, simpleFunctionProcessor('percentile_disc')),    

    // String
    pair(Ascii, simpleFunctionProcessor('ascii')),
    pair(CharLength, simpleFunctionProcessor('length')),
    pair(Chr, simpleFunctionProcessor('chr')),
    pair(Concat, customFunctionProcessor(processorForConcat_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Left, customFunctionProcessor({f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]  | processorForDirectionalIndex('left', $f, $sqlDialect, $state, $config)})), // Custom handling to handle negative index
    pair(Lower, simpleFunctionProcessor('lower')),
    pair(Lpad, simpleFunctionProcessor('lpad')),
    pair(Ltrim, simpleFunctionProcessor('ltrim')),
    pair(Md5, simpleFunctionProcessor('md5')),
    pair(Repeat, simpleFunctionProcessor('repeat')),
    pair(Replace, simpleFunctionProcessor('replace')),
    pair(Reverse, simpleFunctionProcessor('reverse')),
    pair(Right, customFunctionProcessor({f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1] | processorForDirectionalIndex('right', $f, $sqlDialect, $state, $config)})), // Custom handling to handle negative index
    pair(Rpad, simpleFunctionProcessor('rpad')),
    pair(Rtrim, simpleFunctionProcessor('rtrim')),
    pair(SplitPart, simpleFunctionProcessor('split_part')),
    pair(StrPos, argTransformFunctionProcessor('position', {n:Node[*]| $n->reverse()})),
    pair(Substring, simpleFunctionProcessor('substring')),
    pair(Upper, simpleFunctionProcessor('upper')),
    pair(Greatest, simpleFunctionProcessor('greatest')),
    pair(Least, simpleFunctionProcessor('least')),   

    // String Aggregate
    pair(StringAgg, simpleFunctionProcessor('listagg')),

    // Boolean Aggregate
    pair(BoolAnd, simpleFunctionProcessor('booland_agg')),
    pair(BoolOr, simpleFunctionProcessor('boolor_agg')),

    // Temporal
    pair(DatePart, customFunctionProcessor(processorForDatePart_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(DateTrunc, customFunctionProcessor(processorForDateTrunc_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Now, simpleFunctionProcessor('current_timestamp')),
    pair(ToDate, customFunctionProcessor(processorForToDate_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(ToTimestamp, customFunctionProcessor(processorForToTimestamp_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::temporal::Date, simpleFunctionProcessor('date')),

    // Miscellaneous
    pair(Coalesce, simpleFunctionProcessor('coalesce')),

    // Aggregate
    pair(Count, simpleFunctionProcessor('count')),
    pair(Max, simpleFunctionProcessor('max')),
    pair(Min, simpleFunctionProcessor('min')),
    pair(Mode, customFunctionProcessor(processorForMode_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Window
    pair(CumulativeDistribution, simpleFunctionProcessor('cume_dist')),
    pair(DenseRank, simpleFunctionProcessor('dense_rank')),
    pair(FirstValue, simpleFunctionProcessor('first_value')),
    pair(PercentRank, simpleFunctionProcessor('percent_rank')),
    pair(Lag, simpleFunctionProcessor('lag')),
    pair(LastValue, simpleFunctionProcessor('last_value')),
    pair(Lead, simpleFunctionProcessor('lead')),
    pair(NthValue, simpleFunctionProcessor('nth_value')),
    pair(Ntile, simpleFunctionProcessor('ntile')),
    pair(Rank, simpleFunctionProcessor('rank')),
    pair(RowNumber, simpleFunctionProcessor('row_number')),

    // Extension functions
    // Numeric
    pair(Log10, argTransformFunctionProcessor('log', {n:Node[*]| literal(10)->concatenate($n)})),
    pair(Cosh, simpleFunctionProcessor('cosh')),

    // String
    pair(RegexpLike, customFunctionProcessor(processorForRegExpLikeSnowflake_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Sha1, simpleFunctionProcessor('sha1')),
    pair(Sha256, argTransformFunctionProcessor('sha2', {n:Node[*] | $n->concatenate(literal(256))})),
    pair(Contains, simpleFunctionProcessor('contains')),
    pair(EncodeBase64, simpleFunctionProcessor('base64_encode')),
    pair(DecodeBase64, simpleFunctionProcessor('base64_decode_string')),
    pair(EditDistance, simpleFunctionProcessor('editdistance')),
    pair(JaroWinklerSimilarity, customFunctionProcessor(processorForJaroWinklerSimilarity_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(StartsWith, simpleFunctionProcessor('startswith')),
    pair(EndsWith, simpleFunctionProcessor('endswith')),
    pair(ToChar, customFunctionProcessor(processorForToChar_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(UuidV4, simpleFunctionProcessor('uuid_string')),

    // Temporal
    pair(MakeDate, simpleFunctionProcessor('date_from_parts')),
    pair(MakeTimestamp,customFunctionProcessor(processorForMakeTimestamp_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(DateDiff, customFunctionProcessor(processorForDateDiff_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(DateAdd, customFunctionProcessor(processorForDateAdd_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(ConvertTimeZone, customFunctionProcessor(processorForConvertTimeZone_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(TimeBucket, customFunctionProcessor(processorForTimeBucket_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Miscellaneous
    pair(ParseJson, simpleFunctionProcessor('parse_json'))
  ])
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForCeil(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let ceilCall = simpleFunctionProcessor('ceil').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($ceilCall, 'NUMERIC(37,1)', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForFloor(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let floorCall = simpleFunctionProcessor('floor').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($floorCall, 'NUMERIC(37,1)', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForMode(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  // Snowflake doesn't support mode() in a WITHIN GROUP clause.
  let newFunction = if($f.arguments->isEmpty() && $f.group->isNotEmpty(),
    | ^$f(arguments = $f.group.orderBy.sortKey, group = []),
    | $f
  );
  simpleFunctionProcessor('mode').processFunction->toOne()->eval($sqlDialect, $newFunction, $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForConcat(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config)->map({arg |
    'coalesce(to_char(' + $arg + '), \'\')'
  });
  $sqlDialect->generateFunctionCallWithArgs('concat', $processedArgs, [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForRegExpLikeSnowflake(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let patternParam = '\'^' + $processedArgs->at(1)->removeQuotes($sqlDialect) + '$\'';
  $sqlDialect->generateFunctionCallWithArgs('regexp_like', [$processedArgs->at(0), $patternParam], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForDatePart(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  if($processedArgs->at(0)->toLower()->removeQuotes($sqlDialect)->in(['millisecond', 'milliseconds']),
     | // Snowflake doesn't support millisecond in date_part (https://docs.snowflake.com/en/sql-reference/functions-date-time#label-supported-date-time-parts)
       fail('Snowflake doesn\'t support millisecond extraction in date_part'); '';,
     | $sqlDialect->generateFunctionCallWithArgs('date_part', $processedArgs, [], $state, $config)
  );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForDateTrunc(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let dateTruncCall = simpleFunctionProcessor('date_trunc').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($dateTruncCall, 'TIMESTAMP', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForMakeTimestamp(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let secondsParam = $processedArgs->at(5)->parseDecimal();
  let seconds = $secondsParam->floor();
  let nanoseconds = ($secondsParam - $seconds) * 1000000000;
  $sqlDialect->generateFunctionCallWithArgs('timestamp_from_parts', $processedArgs->take(5)->concatenate([$seconds->toString(), $nanoseconds->toString()]), [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForToDate(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('to_date', [$processedArgs->at(0), $processedArgs->at(1)->dateFormatSpecifierForSnowflake()], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForToTimestamp(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('to_timestamp', [$processedArgs->at(0)]->concatenate(if($processedArgs->size() == 1, | [] , | $processedArgs->at(1)->dateFormatSpecifierForSnowflake())), [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForJaroWinklerSimilarity(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  '(' + $sqlDialect->generateFunctionCallWithArgs('jarowinkler_similarity', $processedArgs, [], $state, $config) + '/100)';
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForToChar(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let formattedUnit = $processedArgs->at(1)->dateFormatSpecifierForSnowflake();
  generateFunctionCallWithArgs($sqlDialect, 'to_char', $processedArgs->at(0)->concatenate($formattedUnit), $f, $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForDateDiff(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  if($processedArgs->at(0)->mapToDBUnitType($sqlDialect)->removeQuotes($sqlDialect)=='week',
   |$sqlDialect->generateCast(generateFunctionCallWithArgs($sqlDialect, 'floor', generateFunctionCallWithArgs($sqlDialect, 'datediff', ['\'day\'',$processedArgs->at(1), $processedArgs->at(2)], [], $state, $config)+'/7', [], $state , $config), 'integer', $state, $config), 
   |generateFunctionCallWithArgs($sqlDialect, 'datediff', [$processedArgs->at(0)->mapToDBUnitType($sqlDialect),$processedArgs->at(1), $processedArgs->at(2)], [], $state, $config));
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForDateAdd(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  generateFunctionCallWithArgs($sqlDialect, 'dateadd', [$processedArgs->at(2)->mapToDBUnitType($sqlDialect), $processedArgs->at(1), $processedArgs->at(0)], $f, $state, $config) ;
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForConvertTimeZone(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let params = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let srcTimeZone = '\''+ if($config.dbConfig.dbTimeZone->isEmpty(), | 'GMT', |  $config.dbConfig.dbTimeZone->toOne()) + '\'';
  generateFunctionCallWithArgs($sqlDialect, 'to_char', [generateFunctionCallWithArgs($sqlDialect, 'convert_timezone', [$srcTimeZone, $params->at(1), $params->at(0)], $f, $state, $config), $params->at(2)->dateFormatSpecifierForSnowflake()], $f, $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::processorForTimeBucket(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let params = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $sqlDialect->generateCast(generateFunctionCallWithArgs($sqlDialect, 'time_slice', $params, $f, $state, $config), 'timestamp', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::bitwiseBinaryExpressionNodeProcessorForSnowflake(): NodeProcessor<BitwiseBinaryExpression>[1]
{
  nodeProcessor(
    BitwiseBinaryExpression,
    {sqlDialect, b, state, config |
      let leftExpr = $sqlDialect->executeNodeProcessor($b.left, $b, $state, $config);
      let rightExpr = $sqlDialect->executeNodeProcessor($b.right, $b, $state, $config);
      let func = if(
        [
          pair(| $b.operator == BitwiseBinaryOperator.AND, | 'bitand'),
          pair(| $b.operator == BitwiseBinaryOperator.OR, | 'bitor'),
          pair(| $b.operator == BitwiseBinaryOperator.XOR, | 'bitxor')
        ],
        | failWithMessage('Unhandled bitwise binary operator type: ' + $b.operator->toString())
      );
      generateFunctionCallWithArgs($sqlDialect, $func, [$leftExpr, $rightExpr], $state, $config);
    }
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::bitwiseNotExpressionNodeProcessorForSnowflake(): NodeProcessor<BitwiseNotExpression>[1]
{
  nodeProcessor(
    BitwiseNotExpression,
    {sqlDialect, b, state, config |
      let expr =  $sqlDialect->executeNodeProcessor($b.expression, $b, $state, $config);
      generateFunctionCallWithArgs($sqlDialect, 'bitnot', [$expr], $state, $config);
    }
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::bitwiseShiftExpressionNodeProcessorForSnowflake(): NodeProcessor<BitwiseShiftExpression>[1]
{
  nodeProcessor(
    BitwiseShiftExpression,
    {sqlDialect, b, state, config |
      let value = $sqlDialect->executeNodeProcessor($b.value, $b, $state, $config);
      let shiftUnits = $sqlDialect->executeNodeProcessor($b.shift, $b, $state, $config);
      let func = if(
        [
          pair(| $b.direction == BitwiseShiftDirection.LEFT, | 'bitshiftleft'),
          pair(| $b.direction == BitwiseShiftDirection.RIGHT, | 'bitshiftright')
        ],
        | failWithMessage('Unhandled bitwise shift direction: ' + $b.direction->toString())
      );
      generateFunctionCallWithArgs($sqlDialect, $func, [$value, $shiftUnits], $state, $config);
    }
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::dateFormatSpecifierForSnowflake(f:String[1]): String[1]
{
  let formatSubs = [
    pair('Month', 'MONMON'),
    pair('Mon', 'MON'),
    pair('MS', 'FF3'),
    pair('US', 'FF6'),
    pair('YYYY', 'YYYY'),
    pair('MM', 'MM'),
    pair('DD', 'DD'),
    pair('HH24', 'HH24'),
    pair('HH12', 'HH12'),
    pair('HH', 'HH'),
    pair('MI', 'MI'),
    pair('SS', 'SS'),
    pair('Day', 'DYDY')    
    // TODO: Handle more format specifiers
  ];

  $formatSubs->fold({i, a|$a->replace($i.first, $i.second)}, $f);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::snowflake::snowflakeVariablePlaceholderPrefixSuffixMap(): Map<String, Pair<String, String>>[1]
{
  [
    pair('String',      pair('\'', '\'')),
    pair('Integer',     pair('', '')),
    pair('Decimal',     pair('', '')),
    pair('Number',      pair('', '')),
    pair('SQLNull',     pair('', '')),
    pair('Float',       pair('', '')),
    pair('StrictDate',  pair('DATE \'', '\'')),
    pair('DateTime',    pair('TIMESTAMP \'', '\'')),
    pair('Date',        pair('TIMESTAMP \'', '\'')),
    pair('Boolean',     pair('', '')),
    pair('Enum',        pair('', ''))
  ]->newMap();
}

// --------------------------------------------------------------------------
