// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::functions::pureToSqlQuery::metamodel::*;
import meta::relational::metamodel::join::*;
import meta::pure::alloy::connections::*;
import meta::external::store::relational::runtime::*;
import meta::relational::functions::sqlQueryToString::snowflake::*;
import meta::relational::functions::sqlQueryToString::default::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::metamodel::operation::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::*;
import meta::external::store::relational::runtime::*;
import meta::relational::runtime::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::pure::alloy::connections::alloy::specification::*;

function <<db.ExtensionLoader>> meta::relational::functions::sqlQueryToString::snowflake::dbExtensionLoaderForSnowflake():DbExtensionLoader[1]
{
  ^DbExtensionLoader(dbType = DatabaseType.Snowflake, loader = createDbExtensionForSnowflake__DbExtension_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::createDbExtensionForSnowflake():DbExtension[1]
{
   let reservedWords = snowflakeReservedWords();
   let literalProcessors = getDefaultLiteralProcessors()->putAll(getLiteralProcessorsForSnowflake());
   let literalProcessor = {type:Type[1]| $literalProcessors->get(if($type->instanceOf(Enumeration), | Enum, | $type))->toOne()};
   let dynaFuncDispatch = getDynaFunctionToSqlDefault($literalProcessor)->groupBy(d| $d.funcName)->putAll(
     getDynaFunctionToSqlForSnowflake()->groupBy(d| $d.funcName))->getDynaFunctionDispatcher();

   ^DbExtension(
      isBooleanLiteralSupported = true,
      collectionThresholdLimit = 16348,
      extraTempTableCreationLogicSupplierForIn = {varName:String[1] | 'instanceOf(' + $varName + ', "StreamingResult")'},
      aliasLimit = 255,
      isDbReservedIdentifier = {str:String[1]| $str->toLower()->in($reservedWords)},
      literalProcessor = $literalProcessor,
      windowColumnProcessor = processWindowColumnForSnowflake_WindowColumn_1__SqlGenerationContext_1__String_1_,
      semiStructuredElementProcessor = processSemiStructuredElementForSnowflake_RelationalOperationElement_1__SqlGenerationContext_1__String_1_,
      tableFunctionParamProcessor = processTableFunctionParamPlaceHolder_RelationalOperationElement_1__SqlGenerationContext_1__String_1_,
      tabularFunctionProcessor = meta::relational::functions::sqlQueryToString::snowflake::tabularFunctionProcessor_String_1__String_1__FunctionParameter_MANY__String_1_,
      variableDeclarationProcessor = variableDeclarationProcessor_VariableDeclaration_1__SqlGenerationContext_1__String_1_,
      lateralJoinProcessor = processJoinTreeNodeWithLateralJoinForSnowflake_JoinTreeNode_1__DbConfig_1__Format_1__Extension_MANY__String_1_,
      joinProcessor = meta::relational::functions::sqlQueryToString::snowflake::processJoinForSnowflake_JoinTreeNode_1__DbConfig_1__Format_1__Extension_MANY__String_1_,
      joinStringsProcessor = processJoinStringsOperationForSnowflake_JoinStrings_1__SqlGenerationContext_1__String_1_,
      selectSQLQueryProcessor = processSelectSQLQueryForSnowflake_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_,
      commonTableExpressionsProcessor = processCommonTableExpressionsProcessorDefault_CommonTableExpression_MANY__SqlGenerationContext_1__Boolean_1__String_1_,
      schemaIdentifierToString = meta::relational::functions::sqlQueryToString::snowflake::schemaIdentifierToString_String_1__DbConfig_1__String_1_,
      identifierProcessor = processIdentifierWithDoubleQuotes_String_1__DbConfig_1__String_1_,
      dynaFuncDispatch = $dynaFuncDispatch,
      preAndFinallyExecutionSQLQuery = preAndFinallyExecutionSQLQueryForSnowflake_DbConfig_1__DatabaseConnection_1__PreAndFinallyExecutionSQLQuery_MANY_,
      ddlCommandsTranslator = getDDLCommandsTranslator(),
      processTempTableName = processTempTableNameSnowflake_String_1__DatabaseConnection_1__String_1_ ,

      dataTypeToSqlText = meta::relational::functions::typeConversion::snowflake::dataTypeToSqlTextSnowflake_DataType_1__String_1_,
      pureTypeToDatabaseTypeConverter = meta::relational::functions::typeConversion::snowflake::convert_GenericType_1__DataType_1_,
      buildDummyConnection = meta::relational::functions::sqlQueryToString::snowflake::buildDummyConnection__RelationalDatabaseConnection_1_,

      lambdaParameterProcessor = buildLambdaParameter_RelationalLambdaParameter_1__SqlGenerationContext_1__String_1_,
      lambdaProcessor = buildLambda_RelationalLambda_1__SqlGenerationContext_1__String_1_

   );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processFrameValueForSnowflake(frameValue:meta::relational::metamodel::FrameValue[1], sgc:SqlGenerationContext[1]):String[1]
{
   $frameValue->match([
                        u: meta::relational::metamodel::UnboundedFrameValue[1] | 'UNBOUNDED ' + $u.direction->processFrameValueDirection(),
                        c: meta::relational::metamodel::FrameCurrentRowValue[1] | 'CURRENT ROW',
                        i: meta::relational::metamodel::FrameIntervalValue[1] | 'INTERVAL \'' + $i.value->processOperation($sgc) + ' ' + $i.durationUnit->toString() + '\' ' + $i.direction->processFrameValueDirection(),
                        l: meta::relational::metamodel::FrameLiteralValue[1] | $l.value->processOperation($sgc) + ' ' + $l.direction->processFrameValueDirection()
                      ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processWindowFrameForSnowflake(frame:meta::relational::metamodel::Frame[1], sgc:SqlGenerationContext[1]):String[1]
{
   let frameType = if($frame.frameType == meta::relational::metamodel::FrameType.ROWS, | 'ROWS BETWEEN', | 'RANGE BETWEEN');
   let offsetFrom = $frame.offsetFrom->processFrameValueForSnowflake($sgc);
   let offsetTo = $frame.offsetTo->processFrameValueForSnowflake($sgc);
   $frameType + ' ' + $offsetFrom + ' AND ' + $offsetTo;
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processWindowColumnForSnowflake(w:WindowColumn[1], sgc:SqlGenerationContext[1]):String[1]
{
   let partitionTranslation = if($w.window.partition->isNotEmpty(),
        |'Partition By ' + $w.window.partition->map(f|$f->processOperation($sgc))->joinStrings(','),
        |'');
   let orderByTranslation = if($w.window.sortBy->isNotEmpty(),
        |'Order By '+ $w.window.sortBy->map(s|$s.sortByElement->toOne()->processOperation($sgc) + if($s.sortDirection->isNotEmpty(), | ' ' +$s.sortDirection->toOne().name + if($s.sortDirection == meta::relational::metamodel::SortDirection.ASC, | ' NULLS LAST', | ' NULLS FIRST'), | ''))->joinStrings(', '),
        |'');
   let windowFrameTranslation = if($w.window.frame->isNotEmpty(),
        |$w.window.frame->toOne()->processWindowFrameForSnowflake($sgc),
        |'');
   let withinGroupTranslation = if($w.func.name->equal('joinStrings') && $w.window.sortBy->isNotEmpty() && $w.window.frame->isNotEmpty() && $w.window.frame->toOne().offsetFrom->instanceOf(meta::relational::metamodel::UnboundedFrameValue) && $w.window.frame->toOne().offsetTo->instanceOf(meta::relational::metamodel::UnboundedFrameValue),
        | ' WITHIN GROUP(' + $orderByTranslation + ')',
        | '');
        
   $w.func->processOperation($sgc)
   + $withinGroupTranslation
   + ' OVER ('
   + [$partitionTranslation, $orderByTranslation, $windowFrameTranslation]->filter(s | $s != '')->joinStrings(' ') +
   + ')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processJoinForSnowflake(j:JoinTreeNode[1], dbConfig : DbConfig[1], format:Format[1], extensions:Extension[*]):String[1]
{
    $j.join->match(
      [
        join : AsOfJoin[1] | assert($join.operation->instanceOf(DynaFunction), |'Error the "asof join" operation is not a dynaFunction');
                             let dFunc = $join.operation->cast(@DynaFunction);
                             'asof join ' + $j.alias->map(a|^$a(name = '"' + $a.name + '"'))->toOne()->processOperation($dbConfig, $format->indent(), $extensions) +
                             $format.separator() +
                             if (
                                [
                                  pair(
                                    |['lessThan', 'lessThanEqual', 'greaterThan', 'greaterThanEqual']->contains($dFunc.name),
                                    |'MATCH_CONDITION (' + processOperation($dFunc, $dbConfig, $format->indent(), ^Config(), $extensions) + ')'
                                  ),
                                  pair(
                                    |$dFunc.name == 'and',
                                    |'MATCH_CONDITION (' + processOperation($dFunc.parameters->at(0), $dbConfig, $format->indent(), ^Config(), $extensions) + ')' +
                                     'ON ('+ processOperation($dFunc.parameters->at(1), $dbConfig, $format->indent(), ^Config(), $extensions) +')'
                                  )
                                ],
                                | fail('The operation '+$dFunc.name+' is not supported in asOf joins'); '';
                             );
                             ,
        join : Join[1] |
                $j.joinType->map(jt|$jt->processJoinType($dbConfig, $format, $extensions))->orElse('')
                        + $j.alias->map(a|^$a(name = '"' + $a.name + '"'))
                            ->toOne()->processOperation($dbConfig, $format->indent(), $extensions) + $format.separator()
                        + ' ' + 'on (' + processOperation($j.join.operation, $dbConfig, $format->indent(), ^Config(), $extensions) + ')'
      ]
    );
}

function meta::relational::functions::sqlQueryToString::snowflake::tabularFunctionProcessor(schema:String[1], functionName: String[1], params: FunctionParameter[*]):String[1]
{
   'table('+ if($schema=='', | $functionName,| $schema+'.'+$functionName) + '('+ $params->map(p|$p.name)->joinStrings(', ')+ '))';
}

function meta::relational::functions::sqlQueryToString::snowflake::schemaIdentifierToString(identifier:String[1], dbConfig: DbConfig[1]):String[1]
{
   $identifier->split('.')->map(s|$s->processIdentifierWithQuoteChar('"', $dbConfig))->joinStrings('.');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::getLiteralProcessorsForSnowflake():Map<Type,LiteralProcessor>[1]
{
   let literalReplacementPairForString = ^LiteralReplacement(old = '\'', new = '\'\'');
   newMap([
      pair(StrictDate, ^LiteralProcessor(format = '\'%s\'::date', transform = {d:StrictDate[1], dbTimeZone:String[0..1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,   ^LiteralProcessor(format = '\'%s\'::timestamp', transform = {d:DateTime[1], dbTimeZone:String[0..1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,       ^LiteralProcessor(format = '\'%s\'::timestamp', transform = {d:Date[1], dbTimeZone:String[0..1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Boolean,    ^LiteralProcessor(format = '%s', transform = toString_Any_1__String_1_->literalTransform())),
      pair(String,     ^LiteralProcessor(format = '\'%s\'', transform = convertStringToSnowflakeSQLString($literalReplacementPairForString)->literalTransform(), literalReplacements = $literalReplacementPairForString))
   ]);
}

function meta::relational::functions::sqlQueryToString::snowflake::convertStringToSnowflakeSQLString(literalReplacements:LiteralReplacement[*]):meta::pure::metamodel::function::Function<{String[1] -> String[1]}>[1]
{
   let updatedLiteralReplacements = $literalReplacements->concatenate(^LiteralReplacement(old='\@@',new='\''))->concatenate(^LiteralReplacement(old='\\',new='\\\\'));
   {s:String[1] | $updatedLiteralReplacements->fold({replacement, input | if(($replacement.old=='\\' && $input->matches('^\\\\+$')) || $replacement.old!='\\', | $input->replace($replacement.old, $replacement.new), | $input)}, $s)};
}


function meta::relational::functions::sqlQueryToString::snowflake::getDDLCommandsTranslator(): RelationalDDLCommandsTranslator[1]
{
  ^RelationalDDLCommandsTranslator(
                createSchema = translateCreateSchemaStatementForSnowflake_CreateSchemaSQL_1__DbConfig_1__String_$0_1$_,
                dropSchema =  translateDropSchemaStatementDefault_DropSchemaSQL_1__DbConfig_1__String_1_,
                createTable = translateCreateTableStatementForSnowflake_CreateTableSQL_1__DbConfig_1__String_1_,
                dropTable = translateDropTableStatementForSnowflake_DropTableSQL_1__DbConfig_1__String_1_,
                loadTable = loadValuesToDbTableForSnowflake_LoadTableSQL_1__DbConfig_1__String_MANY_,
                createView = createView_CreateViewSQL_1__DbConfig_1__Extension_MANY__String_1_,
                createProcedure = createProcedure_CreateProcedureSQL_1__DbConfig_1__Extension_MANY__String_1_ ,             
                 createFunction = createFunction_CreateFunctionSQL_1__DbConfig_1__Extension_MANY__String_1_              
                );
}

function meta::relational::functions::sqlQueryToString::snowflake::processTempTableNameSnowflake(tempTableName: String[1], dc: meta::external::store::relational::runtime::DatabaseConnection[1]): String[1]
{
   let dataSourceSpec = if($dc->instanceOf(RelationalDatabaseConnection),| $dc->cast(@RelationalDatabaseConnection).datasourceSpecification->cast(@SnowflakeDatasourceSpecification),| []);
   let dbConfig = meta::relational::functions::sqlQueryToString::createDbConfig($dc);

   if($dataSourceSpec->isNotEmpty() &&
      $dataSourceSpec.tempTableDb->isNotEmpty() &&
      $dataSourceSpec.tempTableSchema->isNotEmpty(),
   |
    $dbConfig.identifierProcessor($dataSourceSpec.tempTableDb->toOne()) + '.' + $dbConfig.identifierProcessor($dataSourceSpec.tempTableSchema->toOne()) + '.' + $dbConfig.identifierProcessor($tempTableName);,
   |
    assert($dataSourceSpec.tempTableDb->isEmpty() && $dataSourceSpec.tempTableSchema->isEmpty(), 'One of Database name and schema name for temp tables is missing. Please specify both.');
    $dbConfig.identifierProcessor('LEGEND_TEMP_DB') +'.' + $dbConfig.identifierProcessor('LEGEND_TEMP_SCHEMA') + '.' + $dbConfig.identifierProcessor($tempTableName);
   );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::translateCreateSchemaStatementForSnowflake(createSchemaSQL:CreateSchemaSQL[1], dbConfig:DbConfig[1]) : String[0..1]
{
   if($createSchemaSQL.schema.name == 'default', 
    | [], 
    | 'Create Schema if not exists ' + $createSchemaSQL.schema.name);
}

function meta::relational::functions::sqlQueryToString::snowflake::translateCreateTableStatementForSnowflake(c:CreateTableSQL[1], dbConfig: DbConfig[1]): String[1]
{
   if($c.isTempTable->isTrue(),| 'CREATE TEMPORARY TABLE ' + $c.table->tableToString($dbConfig) + '('+ $c.table.columns->map(r|$r->match([c:Column[1]| $c.name->processColumnName($dbConfig) + ' ' + getColumnTypeSqlTextSnowflake($c.type),
                                                                                                                                          r:RelationalOperationElement[1]| fail('Only \'Column\' types are supported when creating temporary tables, found: '+$r->type()->toOne()->elementToPath());'';]))->joinStrings(',') + ');'
                              ,| $c->meta::relational::functions::sqlQueryToString::default::translateCreateTableStatementDefault($dbConfig))

}

function meta::relational::functions::sqlQueryToString::snowflake::loadValuesToDbTableForSnowflake(l:LoadTableSQL[1], dbConfig: DbConfig[1]): String[*]
{
  if($l.absolutePathToFile->isNotEmpty(),|
                                 let createStage = 'CREATE OR REPLACE TEMPORARY STAGE LEGEND_TEMP_DB.LEGEND_TEMP_SCHEMA.LEGEND_TEMP_STAGE';
                                 let loadTempTableCommand = 'PUT file://'+$l.absolutePathToFile->toOne()->processOperation($dbConfig.dbType, []) + ' @LEGEND_TEMP_DB.LEGEND_TEMP_SCHEMA.LEGEND_TEMP_STAGE' + $l.absolutePathToFile->toOne()->processOperation($dbConfig.dbType, []) +  ' PARALLEL= 16 AUTO_COMPRESS=TRUE;';
                                 let copyIntoCommand = 'COPY INTO ' + $l.table->tableToString($dbConfig)->toOne() + ' FROM @LEGEND_TEMP_DB.LEGEND_TEMP_SCHEMA.LEGEND_TEMP_STAGE' + $l.absolutePathToFile->toOne()->processOperation($dbConfig.dbType, []) + ' file_format = (type= CSV field_optionally_enclosed_by= \'"\');';
                                 let dropStage = 'DROP STAGE LEGEND_TEMP_DB.LEGEND_TEMP_SCHEMA.LEGEND_TEMP_STAGE';
                                 [$createStage, $loadTempTableCommand, $copyIntoCommand, $dropStage];
                              ,| $l->insertValuesToDbTableForSnowflake($dbConfig))
}

function meta::relational::functions::sqlQueryToString::snowflake::insertValuesToDbTableForSnowflake(loadTableSQL:LoadTableSQL[1] , dbConfig: DbConfig[1]) : String[*]
{
  if($loadTableSQL.parsedData.values->isEmpty(),
    |[],
    |
      let insertStatement = 'insert into ' + if($loadTableSQL.table.schema.name=='default', |'' ,|$loadTableSQL.table.schema.name + '.') + $loadTableSQL.table.name + ' ('
              + $loadTableSQL.columnsToLoad.name->map(colName | $colName->processColumnName($dbConfig))->joinStrings(',')
              +')\n';
      $loadTableSQL.parsedData.values->map(row | 'select ' + $row.values->convertValuesToCsvForSnowflake($loadTableSQL.columnsToLoad.type))->joinStrings($insertStatement, '\nUNION ALL\n', '\n;');
  );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::convertValuesToCsvForSnowflake(strs : String[*], types : Any[*]): String[1]
{
  range($types->size())->map(x |
    let literalStr = $strs->at($x)->meta::relational::functions::database::testDataSQLgeneration::convertValuesToCsv($types->at($x));
    $types->at($x)->match([
      s:meta::relational::metamodel::datatype::SemiStructured[*] | 'PARSE_JSON(%s)'->format($literalStr),
      a:Any[1] | $literalStr
    ]);)->makeString(', ');
}

function meta::relational::functions::sqlQueryToString::snowflake::translateDropTableStatementForSnowflake(d:DropTableSQL[1], dbConfig: DbConfig[1]) : String[1]
{
  'Drop table if exists ' + $d.table->tableToString($dbConfig) + ';';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::getDynaFunctionToSqlForSnowflake(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('array_max',              $allStates,            ^ToSql(format='array_max(%s)')),
    dynaFnToSql('array_min',              $allStates,            ^ToSql(format='array_min(%s)')),
    dynaFnToSql('array_sum',              $allStates,            ^ToSql(format='reduce(%s, 0::DOUBLE, (acc, x) -> acc + x)')),
    dynaFnToSql('array_sort',             $allStates,            ^ToSql(format='array_sort(%s)')),
    dynaFnToSql('array_reverse',          $allStates,            ^ToSql(format='array_reverse(%s)')),
    dynaFnToSql('array_size',             $allStates,            ^ToSql(format='ifnull(array_size(%s), 0)')),
    dynaFnToSql('array_append',           $allStates,            ^ToSql(format='array_append(%s, %s)')),
    dynaFnToSql('array_position',         $allStates,            ^ToSql(format='ifnull(array_position(%s, %s), -1)', transform= {vals:String[*] | $vals->reverse()})),
    dynaFnToSql('array_slice',            $allStates,            ^ToSql(format='array_slice(%s, greatest(%s, 0), greatest(%s, 0))')),
    dynaFnToSql('array_contains',         $allStates,            ^ToSql(format='ifnull(array_contains(%s, %s), false)', transform= {vals:String[*] | $vals->reverse()})),
    dynaFnToSql('array_distinct',         $allStates,            ^ToSql(format='array_distinct(%s)')),
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='dateadd(%s)', transform={p:String[3] | $p->at(2)->mapToDBUnitType() + ', ' + $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('bitAnd',                 $allStates,            ^ToSql(format='BITAND(%s, %s)')),
    dynaFnToSql('bitNot',                 $allStates,            ^ToSql(format='BITNOT(%s)')),
    dynaFnToSql('bitOr',                  $allStates,            ^ToSql(format='BITOR(%s, %s)')),
    dynaFnToSql('bitShiftLeft',           $allStates,            ^ToSql(format='BITSHIFTLEFT(%s, %s)')),
    dynaFnToSql('bitShiftRight',          $allStates,            ^ToSql(format='BITSHIFTRIGHT(%s, %s)')),
    dynaFnToSql('bitXor',                 $allStates,            ^ToSql(format='BITXOR(%s, %s)')),
    dynaFnToSql('booland',                $allStates,            ^ToSql(format='booland(%s)')),
    dynaFnToSql('boolor',                 $allStates,            ^ToSql(format='boolor(%s)')),    
    dynaFnToSql('ceiling',                $allStates,            ^ToSql(format='ceil(%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='concat%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('convertDate',            $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDateSnowflake()})),
    dynaFnToSql('convertDateTime',        $allStates,            ^ToSql(format='%s' , transform={p:String[*] | $p->convertToDateTimeSnowflake()})),
    dynaFnToSql('convertVarchar128',      $allStates,            ^ToSql(format='to_char(%s)')),
    dynaFnToSql('contains',               $allStates,            ^ToSql(format='contains(%s,%s)', transform={p:String[2]|$p})),
    dynaFnToSql('currentUserId',          $allStates,            ^ToSql(format='COALESCE( SYS_CONTEXT(\'SNOWFLAKE$ORGANIZATION_SESSION\',\'PRINCIPAL_NAME\'), SYS_CONTEXT(\'SNOWFLAKE$SESSION\',\'PRINCIPAL_NAME\')) ')),
    dynaFnToSql('date',                   $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->transformDateConstructionForSnowflake()})),
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='datediff(%s,%s,%s)', transform={p:String[*]|[$p->at(2)->replace('\'', '')->processDateDiffDurationUnitForSnowflake(),$p->at(0),$p->at(1)]})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='Date(%s)')),
    dynaFnToSql('dayOfMonth',             $allStates,            ^ToSql(format='DAYOFMONTH(%s)')),
    dynaFnToSql('dayOfWeek',              $allStates,            ^ToSql(format='to_char(%s, \'DYDY\')')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='DAYOFWEEKISO(%s)')),
    dynaFnToSql('dayOfYear',              $allStates,            ^ToSql(format='DAYOFYEAR(%s)')),
    dynaFnToSql('endsWith',               $allStates,            ^ToSql(format='endswith(%s,%s)', transform={p:String[2]|$p})),
    dynaFnToSql('decodeBase64',           $allStates,            ^ToSql(format='BASE64_DECODE_STRING(%s)')),
    dynaFnToSql('encodeBase64',           $allStates,            ^ToSql(format='BASE64_ENCODE(%s)')),
    dynaFnToSql('extractFromSemiStructured', $allStates,         ^ToSql(format='%s', transform={p:String[3]|$p->processExtractFromSemiStructuredParamsForSnowflake()})),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='DATE_TRUNC(\'MONTH\', %s)')),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='DATE_TRUNC(\'QUARTER\', %s)')),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='DATE_TRUNC(\'MONTH\', CURRENT_DATE)%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='DATE_TRUNC(\'QUARTER\', CURRENT_DATE)%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='DATE_TRUNC(\'YEAR\', CURRENT_DATE)%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfWeek',         $allStates,            ^ToSql(format='DATE_TRUNC(\'WEEK\', %s)')),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='DATE_TRUNC(\'YEAR\', %s)')),
    dynaFnToSql('firstHourOfDay',         $allStates,            ^ToSql(format='DATE_TRUNC(\'DAY\', %s)')),
    dynaFnToSql('firstMillisecondOfSecond', $allStates,          ^ToSql(format='DATE_TRUNC(\'SECOND\', %s)')),
    dynaFnToSql('firstMinuteOfHour',      $allStates,            ^ToSql(format='DATE_TRUNC(\'HOUR\', %s)')),
    dynaFnToSql('generateGuid',           $allStates,            ^ToSql(format='UUID_STRING()')),
    dynaFnToSql('firstSecondOfMinute',    $allStates,            ^ToSql(format='DATE_TRUNC(\'MINUTE\', %s)')),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='date_part(\'hour\', %s)')),
    dynaFnToSql('hashAgg',                $allStates,            ^ToSql(format='HASH_AGG(%s)')),
    dynaFnToSql('hashCode',               $allStates,            ^ToSql(format='hash(%s)', transform={p:String[*] | $p->joinStrings(', ')})),
    dynaFnToSql('indexOf',                $allStates,            ^ToSql(format='CHARINDEX(%s)', transform={p:String[2] | $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('isAlphaNumeric',         $allStates,            ^ToSql(format=regexpPattern('%s'), transform={p:String[1]|$p->transformAlphaNumericParamsDefault()})),
    dynaFnToSql('jaroWinklerSimilarity',  $allStates,            ^ToSql(format='(jarowinkler_similarity(%s, %s)/100)')),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='listagg(%s, %s)')),
    dynaFnToSql('log10',                  $allStates,            ^ToSql(format='log(10, %s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='length(%s)')),
    dynaFnToSql('levenshteinDistance',    $allStates,            ^ToSql(format='editdistance(%s, %s)')),
    dynaFnToSql('matches',                $allStates,            ^ToSql(format=regexpPattern('%s'), transform={p:String[2]|$p->transformRegexpParams()})),
    dynaFnToSql('maxBy',                  $allStates,            ^ToSql(format='MAX_BY(%s)', transform={p:String[*] | $p->joinStrings(', ')})),
    dynaFnToSql('minBy',                  $allStates,            ^ToSql(format='MIN_BY(%s)', transform={p:String[*] | $p->joinStrings(', ')})),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='MONTH(%s)')),
    dynaFnToSql('monthName',              $allStates,            ^ToSql(format='to_char(%s, \'MMMM\')')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='MONTH(%s)')),
    dynaFnToSql('mostRecentDayOfWeek',    $allStates,            ^ToSql(format='DATE_TRUNC(\'WEEK\', CURRENT_DATE)%s', transform={p:String[*] | ''})),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='current_timestamp')),
    dynaFnToSql('parseDate',              $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDateSnowflake()})),
    dynaFnToSql('parseDecimal',           $allStates,            ^ToSql(format='%s', transform={p:String[*] |$p->transformParseDecimal()})),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('parseJson',              $allStates,            ^ToSql(format='parse_json(%s)')),
    dynaFnToSql('toJson',                 $allStates,            ^ToSql(format='to_json(%s)')),
    dynaFnToSql('toVariant',              $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->toVariantForSnowflake()})),
    dynaFnToSql('toVariantList',          $allStates,            ^ToSql(format='array_construct(%s)', transform={p:String[*] | $p->joinStrings(',')})),
    dynaFnToSql('toVariantObject',        $allStates,            ^ToSql(format='{%s}', transform={p:String[*] | range(0, $p->size(), 2)->map(i | $p->at($i) + ': ' + $p->at($i + 1))->joinStrings(', ')})),
    dynaFnToSql('keys',                   $allStates,            ^ToSql(format='map_keys(%s)')),
    dynaFnToSql('values',                 $allStates,            ^ToSql(format='transform(map_keys(%s), k -> GET(%s, k))', transform = {p:String[1] | $p->concatenate($p)})),
    dynaFnToSql('mapConcatenate',         $allStates,            ^ToSql(format='map_cat(%s, %s)')), 
    dynaFnToSql('parseBoolean',           $allStates,            ^ToSql(format='to_boolean(%s)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='position(%s in %s)')),
    dynaFnToSql('previousDayOfWeek',      $allStates,            ^ToSql(format='dateadd(DAY, case when %s - DAYOFWEEK(%s) +1  >= 0 then %s  - DAYOFWEEK(%s) -1 - 7 else %s - DAYOFWEEK(%s) -1 end, %s)', transform={p:String[1..2] | $p->formatMostRecentSnowflake('current_date')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('startsWith',             $allStates,            ^ToSql(format='startswith(%s,%s)', transform={p:String[2]|$p})),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('sha256',                 $allStates,            ^ToSql(format='sha2(%s, 256)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('splitPart',              $allStates,            ^ToSql(format='split_part(%s, %s, %s)')),
    dynaFnToSql('timeBucket',             $allStates,            ^ToSql(format='TIME_SLICE(%s)', transform={p:String[3]|$p->at(0) + ', ' + constructInterval($p->at(2), $p->at(1))})),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='current_date')),
    dynaFnToSql('toDecimal',              $allStates,            ^ToSql(format='%s', transform={p:String[1]|$p->transformToDecimalSnowflake()})),
    dynaFnToSql('toFloat',                $allStates,            ^ToSql(format='to_double(%s)')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar)')),
    dynaFnToSql('toTimestamp',            $allStates,            ^ToSql(format='%s' , transform={p:String[2] | $p->transformToTimestampSnowflake()})),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='WEEKOFYEAR(%s)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='year(%s)')),
    dynaFnToSql('convertTimeZone',        $allStates,            ^ToSql(format='%s', contextAwareTransform={p:String[3],s:SqlGenerationContext[1] | $p->transformConvertTimeZone($s)}))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::toVariantForSnowflake(params: String[*]):String[1]
{
  if($params->size() == 1,
    |
      'ifnull(%s::VARIANT, PARSE_JSON(\'null\'))'->format($params->toOne()); // when single parameter, and is sql null, we need json null
    ,
    |
       '%s::VARIANT'->format($params->joinStrings('[', ',', ']'));
  ); 
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processExtractFromSemiStructuredParamsForSnowflake(params:String[3]):String[1]
{
  let baseRelationalOp = $params->at(0);
  let pathNavigation = $params->at(1);
  let returnType = $params->at(2);

  // https://docs.snowflake.com/en/sql-reference/functions/get_path
  let elementAccess = format('get_path(%s, \'%s\')', [$baseRelationalOp, $pathNavigation]);

  if ($returnType->in(['CHAR', 'VARCHAR', 'STRING']), | 'to_varchar(' + $elementAccess + ')', |
  if ($returnType->in(['DATETIME', 'TIMESTAMP']), | 'to_timestamp(' + $elementAccess + ')', |
  if ($returnType == 'DATE', | 'to_date(' + $elementAccess + ')', |
  if ($returnType == 'BOOLEAN', | 'to_boolean(' + $elementAccess + ')', |
  if ($returnType == 'FLOAT', | 'to_double(' + $elementAccess + ')', |
  if ($returnType == 'INTEGER', | 'to_number(' + $elementAccess + ')', |
  $elementAccess))))));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::convertToDateSnowflake(params:String[*]):String[1]
{
   assert(2 - $params->size()  >= 0,'Incorrect number of parameters for convertDate: convertDate(column,[dateformat])');
   assert($params->size()==1 || dateFormatsSnowFlake()->contains($params->at(1)->replace('\'', '')) , | $params->at(1) +' not supported ');
   let dateFormat = if( $params->size() == 1 ,|'\'YYYY-MM-DD\'',
                                              |//DDMMMYYYY is the same format as DDMONYYYY aligned with SybaseIQ, need to be removed and find better way for format translation
                                               if($params->at(1) == '\'ddMMMyyyy\'',| '\'ddMONyyyy\'',| $params->at(1));
                                              );
   //https://docs.snowflake.net/manuals/sql-reference/data-types-datetime.html
   'to_date('+$params->at(0)+','+$dateFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::convertToDateTimeSnowflake(params:String[*]):String[1]
{
   assert(2 - $params->size()  >= 0,'Incorrect number of parameters for convertDateTime: convertDateTime(column,[dateTimeformat])');
   let supportedDateTimeFormat = if($params->size() == 2, |dateTimeFormatsSnowFlake()->get($params->at(1)->replace('\'', '')), |[]);
   assert($params->size() == 1 || $supportedDateTimeFormat->size() == 1 , | $params->at(1) +' not supported ');
   let dateTimeFormat = if( $params->size() == 1,|'\'YYYY-MM-DD HH24:MI:SS\'',| $params->at(1));
   //https://docs.snowflake.net/manuals/sql-reference/data-types-datetime.html
   'to_timestamp('+$params->at(0)+','+$dateTimeFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::transformToTimestampSnowflake(params:String[2]):String[1]
{
  //Standardizing the format as per Postgres specification, will include mappings for the formats in future.
   assert($params->at(1)->replace('\'', '') == 'YYYY-MM-DD HH24:MI:SS', | $params->at(1) +' not supported ');
   let timestampFormat = $params->at(1);
   'to_timestamp('+$params->at(0)+','+$timestampFormat+')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::transformDateConstructionForSnowflake(params:String[*]):String[1]
{
   let paramsSize = $params->size();
   assert($paramsSize != 3 || $paramsSize != 6,'Incorrect number of parameters for date construction! The correct usage is either date(<year>, <month>, <day>) or date(<year>, <month>, <day>, <hour>, <minute>, <second>)');
   if ($paramsSize == 3,
      |'DATE_FROM_PARTS(' + $params->joinStrings(',') + ')',
      |let secondParam = $params->at(5)->parseDecimal();
       let second = $secondParam->floor();
       let nanoseconds = ($secondParam - $second) * 1000000000;
       'TIMESTAMP_FROM_PARTS(' + $params->take(5)->joinStrings(',') + ',' + $second->toString() + ',' + $nanoseconds->toString() + ')';);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::dateFormatsSnowFlake():String[*]
{
   ['yyyy-MM-dd', 'MMMyyyy', 'yyyyMMdd', 'ddMMMyyyy', 'ddMONyyyy', 'DD/MM/YYYY', 'YYYY/MM/DD'];
}


function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::dateTimeFormatsSnowFlake():Map<String,Integer>[1]
{
   newMap([pair('yyyy-mm-dd hh:mi:ss',120),
           pair('yyyy-MM-dd hh:mm:ss',120),
           pair('yyyy-MM-dd hh:mm:ss.mmm',121),
           pair('YYYY-MM-DDTHH:MI:SS',120),
           pair('YYYY-MM-DDTHH:MI:SS.FF', 121)]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processDateDiffDurationUnitForSnowflake(durationUnit:String[1]):String[1]
{
   let durationEnumNames = [DurationUnit.YEARS,DurationUnit.MONTHS,DurationUnit.WEEKS,DurationUnit.DAYS,DurationUnit.HOURS,DurationUnit.MINUTES,DurationUnit.SECONDS,DurationUnit.MILLISECONDS]->map(e|$e->toString());
   let durationDbNames = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second','millisecond'];
   $durationEnumNames->zip($durationDbNames)->filter(h | $h.first == $durationUnit).second->toOne();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::formatMostRecentSnowflake(p:String[1..2], defaultDay:String[1]):String[*]
{
   let day = $p->last()->toOne()->mapToDBDayOfWeekNumber()->toString();
   let current = if ($p->size() == 2, | $p->first()->toOne(), | $defaultDay);
   [$day, $current, $day, $current, $day, $current, $current];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processSemiStructuredElementForSnowflake(s:RelationalOperationElement[1], sgc:SqlGenerationContext[1]): String[1]
{
   $s->match([
      o:SemiStructuredObjectNavigation[1] | $o->processSemiStructuredObjectNavigationForSnowflake($sgc),
      a:SemiStructuredArrayFlatten[1] | $a->processSemiStructuredArrayFlattenForSnowflake($sgc),
      a:SemiStructuredArrayFlattenOutput[1] | $a->processSemiStructuredArrayFlattenOutputForSnowflake($sgc),
      a:SemiStructuredArrayFlattenRelation[1]| $a->processSemiStructuredArrayFlattenRelationForSnowflake($sgc)
   ])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processTableFunctionParamPlaceHolder(r:RelationalOperationElement[1], sgc: SqlGenerationContext[1]): String[1]
{
  $r->match([
    t: TableFunctionParamPlaceHolder[1] | $t.var->replaceVarPlaceHolderForAppGeneration($sgc),
    t: ProcedureVariablePlaceHolder[1] | $t.var->replaceProcedurevariable($sgc),
    r: RelationalOperationElement[1] | 'sqlQueryToString for relational element ' + $r->type().name->toOne() + ' has not been implemented yet for snowflake'
   ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::variableDeclarationProcessor(v:VariableDeclaration[1], sgc: SqlGenerationContext[1]): String[1]
{
  $v.name + ' := (' + $v.value->match([
                        l: Literal[1] | $l.value,
                        r: RelationalOperationElement[1]| $r->processOperation($sgc)
                      ])->cast(@String) + ')'
}

function <<access.private>>  meta::relational::functions::sqlQueryToString::snowflake::replaceVarPlaceHolderForAppGeneration(v:VarPlaceHolder[1], sgc:SqlGenerationContext[1]): String[1]
{
  assertEmpty($v.propertyPath, 'processing for variable with propertyPath access is not implemented');
  $v.name;
}

function <<access.private>>  meta::relational::functions::sqlQueryToString::snowflake::replaceProcedurevariable(v:VarPlaceHolder[1], sgc:SqlGenerationContext[1]): String[1]
{
  assertEmpty($v.propertyPath, 'processing for variable with propertyPath access is not implemented');
  ':'+$v.name;
}


function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processSemiStructuredObjectNavigationForSnowflake(s:SemiStructuredObjectNavigation[1], sgc:SqlGenerationContext[1]): String[1]
{
   // https://docs.snowflake.com/en/user-guide/querying-semistructured.html

   let processedOperand = $s.operand->processOperation($sgc);

   let elementAccess = $processedOperand + $s->match([
      p: SemiStructuredPropertyAccess[1]     | '[\'' + $p.property->cast(@Literal).value->cast(@String) + '\']' + if($p.index->isEmpty(),|'',|'['+ $p.index->toOne()->cast(@Literal).value->toString()+']'),
      a: SemiStructuredArrayElementAccess[1] | '[' + $a.index->cast(@Literal).value->toString() + ']'
   ]);

   if($s.avoidCastIfPrimitive == true, | $elementAccess, | $elementAccess + castSuffixForSnowflakeSemiStructuredData($s.returnType));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processSemiStructuredArrayFlattenForSnowflake(s:SemiStructuredArrayFlatten[1], sgc:SqlGenerationContext[1]): String[1]
{
   // https://docs.snowflake.com/en/sql-reference/functions/flatten.html

   let processedNavigation = $s.navigation->processOperation($sgc);
   'flatten(input => ' + $processedNavigation + ', outer => true, recursive => false, mode => \'array\')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processSemiStructuredArrayFlattenRelationForSnowflake(s:SemiStructuredArrayFlattenRelation[1], sgc:SqlGenerationContext[1]): String[1]
{
   let processedNavigation = $s.navigation->processOperation($sgc);
   'Table(Flatten(input => ' + $processedNavigation + '))';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processSemiStructuredArrayFlattenOutputForSnowflake(s:SemiStructuredArrayFlattenOutput[1], sgc:SqlGenerationContext[1]): String[1]
{
   // https://docs.snowflake.com/en/sql-reference/functions/flatten.html

   let doubleQuote = if($sgc.config.useQuotesForTableAliasColumn == false, |'', |'"');
   let processedIdentifier = $sgc.dbConfig.identifierProcessor($doubleQuote + $s.tableAliasColumn.alias.name->toOne() + $doubleQuote);
   $processedIdentifier + '.' + processColumnName('VALUE', $sgc.dbConfig) + castSuffixForSnowflakeSemiStructuredData($s.returnType);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::castSuffixForSnowflakeSemiStructuredData(type:Type[0..1]): String[1]
{
   if($type == String, | '::varchar', |
   if($type == StrictDate, | '::date', |
   if($type == Integer, | '::number', |
   if($type == Float, | '::float', |
   if($type == Boolean, | '::boolean', |
   if($type->isNotEmpty() && $type->toOne()->_subTypeOf(Date), | '::timestamp', |
   if($type->isNotEmpty() && $type->toOne()->instanceOf(Enumeration), | '::varchar', |
   '')))))));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processJoinStringsOperationForSnowflake(js:JoinStrings[1], sgc:SqlGenerationContext[1]): String[1]
{
   processJoinStringsOperation($js, $sgc, {col, sep| 'listagg(' + $col + if($sep == '\'\'', |'', |', ' + $sep) + ')'},
    {strs, sep| $strs->joinStrings('concat(', if('\'\'' == $sep, |', ', |', ' + $sep + ', ') , ')')});
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processSelectSQLQueryForSnowflake(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForSnowflake($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processSelectSQLQueryForSnowflake(s:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:Extension[*]):String[1]
{
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let qualifyStr = if($s.qualifyOperation->isEmpty(), |'', |$s.qualifyOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));

  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), true, $extensions) +
  if ($s.data == [],
    |'',
    | if ($s.pivot->isEmpty(),
      | ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions),
      | let p = $s.pivot;
        let from = $s.data->toOne();
        let fromStr = ' ' + $format.separator + 'from ' + $from->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions);
        $fromStr + processPivotForSnowflake($s.pivot->toOne(), $dbConfig, $format, ^$config(useUnqualifiedColumnNameInPivot = true), $extensions);
      )
  ) +

  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), true, $extensions)->makeString(',')) +
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if (eq($qualifyStr, ''), |'', | ' ' + $format.separator + 'qualify ' + $qualifyStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(',')) +
  processLimit($s, $dbConfig, $format, $extensions, processTakeDefault_SelectSQLQuery_1__Format_1__DbConfig_1__Extension_MANY__String_1_, processSliceOrDropForSnowflake_SelectSQLQuery_1__Format_1__DbConfig_1__Extension_MANY__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processPivotForSnowflake(p:Pivot[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], extensions:Extension[*]):String[1]
{
  let pivotColumnName = $dbConfig.identifierProcessor($p.pivotColumns->toOne()->cast(@ColumnName).name);
  let aggregateColumn = processSelectColumns($p.aggColumns->toOne(), $dbConfig, $format->indent(), $config, true, $extensions);
  ' ' + $format.separator + 'pivot (' + $aggregateColumn +
  ' ' + $format.separator + 'for ' +  $pivotColumnName +
  ' ' + $format.separator + 'in (ANY ORDER BY ' + $pivotColumnName + '))';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processJoinTreeNodeWithLateralJoinForSnowflake(j:JoinTreeNode[1], dbConfig : DbConfig[1], format:Format[1], extensions:Extension[*]):String[1]
{
   // https://docs.snowflake.com/release-notes/bcr-bundles/2023_04/bcr-1057
   // https://docs.snowflake.com/en/sql-reference/constructs/join-lateral#usage-notes
   ' ' + $format.separator() + 'inner join lateral '
   + $j.alias
         ->map(a|^$a(name = '"' + $a.name + '"'))
         ->toOne()->processOperation($dbConfig, $format->indent(), $extensions) + $format.separator();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::processSliceOrDropForSnowflake(s:SelectSQLQuery[1], format:Format[1],dbConfig : DbConfig[1], extensions:Extension[*], size:Any[1]):String[1]
{
   if ($s.fromRow->isNotEmpty(),
       | if ($size == -1,
             | '%s limit \'\' offset %s'->format([$format.separator, $s.fromRow->toOne()->getValueForTake($format, $dbConfig, $extensions)]),
             | '%s limit %s offset %s'->format([$format.separator, $size, $s.fromRow->toOne()->getValueForTake($format, $dbConfig, $extensions)])),
       | '%s limit %s'->format($size));
}

function meta::relational::functions::sqlQueryToString::snowflake::preAndFinallyExecutionSQLQueryForSnowflake(dbConfig:DbConfig[1], dc: DatabaseConnection[1]): meta::relational::mapping::PreAndFinallyExecutionSQLQuery[*]
{
  if(!($dc->instanceOf(RelationalDatabaseConnection) && (($dc->cast(@RelationalDatabaseConnection).datasourceSpecification->instanceOf(SnowflakeDatasourceSpecification) && $dc->cast(@RelationalDatabaseConnection).datasourceSpecification->cast(@SnowflakeDatasourceSpecification).enableQueryTags == false) || !($dc->cast(@RelationalDatabaseConnection).datasourceSpecification->instanceOf(SnowflakeDatasourceSpecification)))),
    | let set = ^AlterSQL(object = ^Session(), operation = [^SetOperation(propertyName = 'QUERY_TAG', propertyValue = ^Literal(value = '{"executionTraceID" : "${execID}", "engineUser" : "${userId}", "referer" : "${referer}"}'))]);
      let setSQL =  $set.object->match([
                          s:Session[1] | 'ALTER SESSION SET ' + $set.operation->map(o | $o->cast(@SetOperation).propertyName + ' = ' + $o->cast(@SetOperation).propertyValue.value->processLiteralValue($dbConfig))->makeString('',', ', ';')
                      ]);

      let unset = ^AlterSQL(object = ^Session(), operation = [^UnSetOperation(propertyName = 'QUERY_TAG')]);
      let unsetSQL =  $unset.object->match([
                          s:Session[1] | 'ALTER SESSION UNSET ' + $unset.operation->map(o | $o->cast(@UnSetOperation).propertyName)->makeString('',', ', ';')
                      ]);

      ^meta::relational::mapping::PreAndFinallyExecutionSQLQuery(preQueryExecutionSQLQuery = $setSQL, finallyQueryExecutionSQLQuery = $unsetSQL);,
    | []
  );
}


function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::transformConvertTimeZone(params:String[3],context:SqlGenerationContext[1]):String[1]
{
  //https://docs.snowflake.com/en/sql-reference/functions/convert_timezone
  let unWrappedfmt =  $params->at(2)->substring(1, $params->at(2)->length()-1);
  assert($unWrappedfmt->validateDateTimeFormat(),'Found an invalid date format');
  let formatpairs = meta::relational::functions::sqlQueryToString::default::defaultJavaToSQLTimeParts();
  let format = $formatpairs->fold( {sub, date|  $date->toOne()->replace($sub.first,$sub.second)},$params->at(2));
  format('TO_CHAR(CONVERT_TIMEZONE(%s,%s),%s)',[$params->at(1),$params->at(0),$format]);
}

function meta::relational::functions::sqlQueryToString::snowflake::constructInterval(unit:String[1], i:String[1]):String[1]
{
   let unitWithoutQuotes = $unit->removeQuotesIfExist();

   let interval= [
      pair(DurationUnit.YEARS->toString(), '\'YEAR\''),
      pair(DurationUnit.MONTHS->toString(), '\'MONTH\''),
      pair(DurationUnit.WEEKS->toString(), '\'WEEK\''),
      pair(DurationUnit.DAYS->toString(), '\'DAY\''),
      pair(DurationUnit.HOURS->toString(), '\'HOUR\''),
      pair(DurationUnit.MINUTES->toString(), '\'MINUTE\''),
      pair(DurationUnit.SECONDS->toString(), '\'SECOND\'')
   ]->filter(p | $p.first == $unitWithoutQuotes).second->toOne('Unit not supported: ' + $unitWithoutQuotes);

   $i + ', ' + $interval;
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::transformToDecimalSnowflake(param:String[1]):String[1]
{
  // https://docs.snowflake.com/en/sql-reference/functions/to_decimal
  let parts = $param->split('.');
  if ($parts->at(0)->isDigit(),
      | if ($parts->size() == 1,
        | format('to_decimal(%s)', [$param]);,
        | let scale = max(0, min(37 - $parts->at(0)->length(), $parts->at(1)->length()));
          format('to_decimal(%s,%s,%s)', [$param,38,$scale]);
      ),
      | format('to_decimal(%s, 38, 19)', [$param]);
  );
}



function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::snowflakeReservedWords():String[*]
{
  // Based on https://docs.snowflake.com/en/sql-reference/reserved-keywords
  [
    'alter',
    'and',
    'any',
    'as',
    'between',
    'by',
    'case',
    'cast',
    'check',
    'column',
    'connect',
    'constraint',
    'create',
    'cross',
    'current',
    'current_date',
    'current_time',
    'current_timestamp',
    'current_user',
    'database',
    'delete',
    'distinct',
    'drop',
    'else',
    'exists',
    'false',
    'following',
    'for',
    'from',
    'full',
    'grant',
    'group',
    'having',
    'ilike',
    'in',
    'increment',
    'inner',
    'insert',
    'intersect',
    'into',
    'is',
    'join',
    'lateral',
    'left',
    'like',
    'localtime',
    'localtimestamp',
    'minus',
    'natural',
    'not',
    'null',
    'of',
    'on',
    'or',
    'order',
    'qualify',
    'regexp',
    'revoke',
    'right',
    'rlike',
    'row',
    'rows',
    'sample',
    'select',
    'set',
    'some',
    'start',
    'table',
    'tablesample',
    'then',
    'to',
    'trigger',
    'true',
    'try_cast',
    'union',
    'unique',
    'update',
    'using',
    'values',
    'when',
    'whenever',
    'where',
    'with'
  ]
}

function meta::relational::functions::sqlQueryToString::snowflake::getColumnTypeSqlTextSnowflake(type: meta::relational::metamodel::datatype::DataType[1]):String[1]
{
    $type->match([
       s : meta::relational::metamodel::datatype::SemiStructured[1] | 'VARIANT',
       a : meta::relational::metamodel::datatype::DataType[1] | $a->getColumnTypeSqlTextDefault()
    ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::buildLambdaParameter(param: RelationalLambdaParameter[1], sgc: SqlGenerationContext[1]): String[1]
{
  '"%s"'->format($param.name);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::buildLambda(lambda: RelationalLambda[1], sgc: SqlGenerationContext[1]): String[1]
{
  $lambda->match([
    fold: FoldRelationalLambda[1] | buildFoldLambda($fold, $sgc),
    map: MapRelationalLambda[1] | buildMapLambda($map, $sgc),
    filter: FilterRelationalLambda[1] | buildFilterLambda($filter, $sgc)
  ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::buildFoldLambda(lambda: FoldRelationalLambda[1], sgc: SqlGenerationContext[1]): String[1]
{
  'reduce(%s, %s, ("%s" %s, "%s" %s) -> %s)'->format([
    $lambda.parameters->at(0).value->processOperation($sgc),
    $lambda.parameters->at(1).value->processOperation($sgc),
    $lambda.parameters->at(1).name,
    $sgc.dbConfig.dataTypeToSqlText($lambda.parameters->at(1).type),
    $lambda.parameters->at(0).name,
    $sgc.dbConfig.dataTypeToSqlText($lambda.parameters->at(0).type),
    $lambda.body->processOperation($sgc)
  ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::buildMapLambda(lambda: MapRelationalLambda[1], sgc: SqlGenerationContext[1]): String[1]
{
  'transform(%s, ("%s" %s) -> %s)'->format([
      $lambda.parameters->at(0).value->processOperation($sgc),
      $lambda.parameters->at(0).name,
      $sgc.dbConfig.dataTypeToSqlText($lambda.parameters->at(0).type),
      $lambda.body->processOperation($sgc)
   ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::snowflake::buildFilterLambda(lambda: FilterRelationalLambda[1], sgc: SqlGenerationContext[1]): String[1]
{
  'filter(%s, ("%s" %s) -> %s)'->format([
      $lambda.parameters->at(0).value->processOperation($sgc),
      $lambda.parameters->at(0).name,
      $sgc.dbConfig.dataTypeToSqlText($lambda.parameters->at(0).type),
      $lambda.body->processOperation($sgc)
   ]);
}
