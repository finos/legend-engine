// Copyright 2025 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::window::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::misc::*;
import meta::external::query::sql::metamodel::extension::tests::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::boolean::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::misc::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::window::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::temporal::*;
import meta::external::query::sql::metamodel::*;
import meta::external::store::relational::sqlDialectTranslation::*;
import meta::external::store::relational::sqlDialectTranslation::defaults::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::aggregate::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numeric::aggregate::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::aggregate::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::boolean::aggregate::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::conditional::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::athena::*;
import meta::external::store::relational::sqlDialectTranslation::sqlTyping::typeInference::*;
import meta::external::store::relational::sqlDialectTranslation::utils::*;
import meta::pure::extension::*;
import meta::external::query::sql::metamodel::extension::*;

function meta::external::store::relational::sqlDialectTranslation::athena::athenaSqlDialect(): SqlDialect[1]
{
  ^SqlDialect
  (
    dbType = 'Athena',
    identifierQuoteConfig = athenaIdentifierQuoteConfiguration(),
    literalQuoteConfig = athenaLiteralQuoteConfiguration(),
    nodeProcessors = athenaDialectNodeProcessors(),
    identifierProcessor = athenaIdentifierProcessor(),
    expressionPrecedenceComparator = athenaExpressionPrecedenceComparator(),
    keywords = athenaKeywords(),
    functionProcessorMap = athenaFunctionProcessorMap(),
    variablePlaceholderPrefixSuffixMap = athenaVariablePlaceholderPrefixSuffixMap(),
    expectedSqlDialectTestErrors = athenaFunctionTestsExpectedErrors()
  )
}

function meta::external::store::relational::sqlDialectTranslation::athena::athenaSqlDialectExtension(): Extension[1]
{
  ^Extension
  (
    type = 'AthenaSqlDialectExtension',
    moduleExtensions = [
      ^SqlDialectTranslationModuleExtension
      (
        module = sqlDialectTranslationModuleExtensionName(),
        extraSqlDialects = athenaSqlDialect()
      )
    ]
  )
}

function meta::external::store::relational::sqlDialectTranslation::athena::athenaFunctionTestsExpectedErrors(): Map<String, String>[1]
{
  [
    pair(
      'FuncTests - corr(0/0)',
      'Expected - {"columnNames":["result"],"rows":[{"values":[0.52164053]}]}\n' +
      'Actual - {"columnNames":["result"],"rows":[{"values":[0.52164054]}]}'
    ),
    pair(
      'FuncTests - covar_samp(0/0)',
      'Expected - {"columnNames":["result"],"rows":[{"values":[66.66666667]}]}\n' +
      'Actual - {"columnNames":["result"],"rows":[{"values":[66.66666412]}]}'
    ),
    pair('FuncTests - percentile_cont(0/0)', 'Athena SQL Dialect does not support the function - percentile_cont'),
    pair('FuncTests - percentile_disc(0/0)', 'Athena SQL Dialect does not support the function - percentile_disc'),
    pair('FuncTests - jarowinkler_similarity(0/2)', 'Athena SQL Dialect does not support the function - jarowinkler_similarity'),
    pair('FuncTests - jarowinkler_similarity(1/2)', 'Athena SQL Dialect does not support the function - jarowinkler_similarity'),
    pair('FuncTests - jarowinkler_similarity(2/2)', 'Athena SQL Dialect does not support the function - jarowinkler_similarity'),
    pair(
      'FuncTests - parseJson(0/0)',
      'Expected - {"columnNames":["result"],"rows":[{"values":["{\\n  \\\"foo\\\": \\\"bar\\\"\\n}"]}]}\n' +
      'Actual - {"columnNames":["result"],"rows":[{"values":["{\"foo\":\"bar\"}"]}]}"'
    ),
    pair('FuncTests - mode(0/1)','Athena SQL Dialect does not support the function - mode'),
    pair('FuncTests - mode(1/1)', 'Athena SQL Dialect does not support the function - mode'),
    pair('FuncTests - dateadd(1/3)', 'Athena SQL Dialect does not support adding microsecond to date'),
    pair('FuncTests - time_bucket(0/1)', 'Athena SQL Dialect does not support the function - time_bucket'),
    pair('FuncTests - time_bucket(1/1)', 'Athena SQL Dialect does not support the function - time_bucket'),
    pair('SQLStructureTests - Qualify', 'Athena SQL Dialect does not support Qualify!'),
    pair('SQLStructureTests - AsOfJoin', 'Athena SQL Dialect does not support AsOfJoin!')        
  ]->newMap()->cast(@Map<String, String>)
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaIdentifierQuoteConfiguration(): QuoteConfiguration[1]
{
  ^QuoteConfiguration
  (
    start = '"',
    end = '"',
    escape = '""'
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaChangeQuoteIndentifierForCreateStatement(identifier: String[1]): String[1]
{
  let unquotedIdentifier = if($identifier->startsWith('"') && $identifier->endsWith('"'), | '`' + $identifier->substring(1, $identifier->length()-1)->replace('`', '`') + '`', | $identifier->replace('`', '`'));
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaLiteralQuoteConfiguration(): QuoteConfiguration[1]
{
  ^QuoteConfiguration
  (
    start = '\'',
    end = '\'',
    escape = '\'\''
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaDialectNodeProcessors(): Map<Class<Node>, NodeProcessor<Node>>[1]
{
  newMap(
    athenaDialectStatementProcessors()
    ->concatenate(
      athenaDialectRelationProcessors()
    )
    ->concatenate(
      athenaDialectExpressionProcessors()
    )
    ->concatenate(
      athenaDialectLiteralProcessors()
    )
    ->concatenate(
      athenaDialectSelectItemProcessors()
    )
    ->concatenate(
      athenaDialectOtherNodeProcessors()
    )
    ->concatenate(
      athenaDialectDDLProcessors()
    )
    ->map(n | pair($n.nodeType, $n))
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaDialectStatementProcessors(): NodeProcessor<Statement>[*]
{
  [
    queryProcessor_default(),
    windowProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaDialectRelationProcessors(): NodeProcessor<Relation>[*]
{
  [
    tableProcessor_default(),
    aliasedRelationProcessor_default(),
    joinProcessor_default(),
    asOfJoinProcessorForAthena(),
    querySpecificationProcessor_athena(),
    unionProcessor_default(),
    tableSubqueryProcessor_default(),
    tablePlaceholderProcessor_default(),
    extendedQuerySpecificationProcessor_athena()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaDialectExpressionProcessors(): NodeProcessor<meta::external::query::sql::metamodel::Expression>[*]
{
  [
    comparisonExpressionNodeProcessor_default(),
    logicalBinaryExpressionNodeProcessor_default(),
    notExpressionNodeProcessor_default(),
    arithmeticExpressionNodeProcessor_default(),
    qualifiedNameReferenceNodeProcessor_default(),
    isNullPredicateNodeProcessor_default(),
    isNotNullPredicateNodeProcessor_default(),
    negativeNodeProcessor_default(),
    currentTimeNodeProcessor_default(),
    whenClauseNodeProcessor_default(),
    searchedCaseExpressionNodeProcessor_default(),
    columnTypeProcessor_default(),
    castProcessorForAthena(),
    inListExpressionProcessor_default(),
    inPredicateProcessor_default(),
    existsPredicateProcessor_default(),
    extractProcessor_default(),
    betweenPredicateProcessor_default(),
    functionCallProcessor_default(),
    subQueryExpressionProcessor_default(),
    trimProcessor_default(),
    likePredicateProcessor_athena(),
    allColumnsReferenceNodeProcessor_default(),
    inClauseVariablePlaceholderProcessor_default(),
    variablePlaceholderProcessor_default(),
    freeMarkerOperationProcessor_default(),
    bitwiseBinaryExpressionNodeProcessorForAthena(),
    bitwiseNotExpressionNodeProcessorForAthena(),
    bitwiseShiftExpressionNodeProcessorForAthena()
  ]
}

function meta::external::store::relational::sqlDialectTranslation::athena::likePredicateProcessor_athena(): NodeProcessor<LikePredicate>[1]
{
  nodeProcessor(
    LikePredicate,
    {sqlDialect, l, state, config |
      if($l.ignoreCase,
      | 'lower' + '(' + $sqlDialect->executeNodeProcessor($l.value, $state, $config) + ')' + ' '  +  $sqlDialect->keyword('like', $state, $config) + ' ' + 'lower' + '(' + $sqlDialect->executeNodeProcessor($l.pattern, $state, $config) + ')',
      | $sqlDialect->executeNodeProcessor($l.value, $state, $config) + ' '  + $sqlDialect->keyword('like', $state, $config) + ' ' + $sqlDialect->executeNodeProcessor($l.pattern, $state, $config)
      ) +
      $l.escape->executeIfNotEmptyElseReturnEmptyString({|
        ' '  + $sqlDialect->keyword('escape', $state, $config) + ' ' + $sqlDialect->executeNodeProcessor($l.escape->toOne(), $l, $state, $config)
      })
    },
    {n | true}
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::bitwiseBinaryExpressionNodeProcessorForAthena(): NodeProcessor<BitwiseBinaryExpression>[1]
{
  nodeProcessor(
    BitwiseBinaryExpression,
    {sqlDialect, b, state, config |
      let leftExpr = $sqlDialect->executeNodeProcessor($b.left, $b, $state, $config);
      let rightExpr = $sqlDialect->executeNodeProcessor($b.right, $b, $state, $config);
      let operatorFunction = if(
        [
          pair(| $b.operator == BitwiseBinaryOperator.AND, | 'bitwise_and'),
          pair(| $b.operator == BitwiseBinaryOperator.OR, | 'bitwise_or'),
          pair(| $b.operator == BitwiseBinaryOperator.XOR, | 'bitwise_xor')
        ],
        | failWithMessage('Unhandled bitwise binary operator type: ' + $b.operator->toString())
      );
      $sqlDialect->generateFunctionCallWithArgs($operatorFunction, [$leftExpr, $rightExpr], [], $state, $config);
    }
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::bitwiseNotExpressionNodeProcessorForAthena(): NodeProcessor<BitwiseNotExpression>[1]
{
  nodeProcessor(
    BitwiseNotExpression,
    {sqlDialect, b, state, config |
      let processedArgs = $sqlDialect->executeNodeProcessor($b.expression, $b, $state, $config);
      $sqlDialect->generateFunctionCallWithArgs('bitwise_not', $processedArgs, [], $state, $config);
    }
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::bitwiseShiftExpressionNodeProcessorForAthena(): NodeProcessor<BitwiseShiftExpression>[1]
{
  nodeProcessor(
    BitwiseShiftExpression,
    {sqlDialect, b, state, config |
      let value = $sqlDialect->executeNodeProcessor($b.value, $b, $state, $config);
      let shiftUnits = $sqlDialect->executeNodeProcessor($b.shift, $b, $state, $config);
      let operatorFunction = if(
        [
          pair(| $b.direction == BitwiseShiftDirection.LEFT, | 'bitwise_left_shift'),
          pair(| $b.direction == BitwiseShiftDirection.RIGHT, | 'bitwise_right_shift')
        ],
        | failWithMessage('Unhandled bitwise binary shift direction: ' + $b.direction->toString())
      );
      $sqlDialect->generateFunctionCallWithArgs($operatorFunction, [$value, $shiftUnits], [], $state, $config);
    }
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::castProcessorForAthena(): NodeProcessor<Cast>[1]
{
  // MemSQL supports casting only into limited data types.
  // https://docs.singlestore.com/cloud/reference/sql-reference/conditional-functions/cast-or-convert/
  let castTypes = newMap([
    
    pair('float', 'double'),
    pair('float4', 'double'),
    pair('float8', 'double'),
    pair('int2', 'integer'),
    pair('int4', 'integer'),
    pair('int8', 'integer'),
    pair('numeric', 'double'),
    pair('character', 'varchar'),
    pair('character varying', 'varchar'),
    pair('semistructured', 'string'),
    pair('bool', 'boolean') 

  ]);  

  nodeProcessor(
    Cast,
    {sqlDialect, c, state, config | 
      generateCast(
        $sqlDialect,
        $sqlDialect->executeNodeProcessor($c.expression, [], $state, $config),
        $sqlDialect->executeNodeProcessor(^ColumnType(name = $castTypes->get($c.type.name->toLower())->orElse($c.type.name), parameters = $c.type.parameters), [], $state, $config),  
        $state,
        $config
      )
    },
    {n | true}
  );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaDialectLiteralProcessors(): NodeProcessor<Literal>[*]
{
  [
    integerLiteralNodeProcessor_default(),
    stringLiteralNodeProcessor_default(),
    booleanLiteralNodeProcessor_default(),
    longLiteralNodeProcessor_default(),
    doubleLiteralNodeProcessor_default(),
    decimalLiteralNodeProcessor_default(),
    dateLiteralNodeProcessor_default(),
    timestampLiteralNodeProcessor_default(),
    nullLiteralNodeProcessor_default(),
    partialDateLiteralNodeProcessorForAthena()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::partialDateLiteralNodeProcessorForAthena(): NodeProcessor<PartialDateLiteral>[1]
{
  nodeProcessor(
    PartialDateLiteral,
    {sqlDialect, d, state, config |
      'DATE \'' + $d.value->convertDateToSqlString($config.dbConfig.dbTimeZone) + '\''
    },
    {n | true}
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaDialectSelectItemProcessors(): NodeProcessor<SelectItem>[*]
{
  [
    allColumnsNodeProcessor_default(),
    singleColumnNodeProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaDialectOtherNodeProcessors(): NodeProcessor<Node>[*]
{
  [
    sortItemProcessor_default(),
    selectProcessor_default(),
    withQueryProcessor_default(),
    windowFrameProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaDialectDDLProcessors(): NodeProcessor<Node>[*]
{
  [
    createTestTableProcessorAthena(),
    dropTestTableProcessor_default(),
    insertIntoTestTableProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::createTestTableProcessorAthena(): NodeProcessor<CreateTestTable>[1]
{
  let supportedTypes = newMap([
    pair('varchar', 'string'),
    pair('double precision', 'double')
  ]);
  nodeProcessor(
    CreateTestTable,
    {sqlDialect, c, state, config |
      let currentTimeKey = meta::pure::functions::date::now()->toString()->chunk(1)->filter(x | $x->matches('[0-9]'))->makeString();
      let tableKey = $c.tableName->chunk(1)->filter(x | $x->matches('[a-zA-Z0-9]'))->makeString();
      let tableLocationKey = $tableKey + $currentTimeKey;
      $sqlDialect->keyword('create', $state, $config) + ' ' +
      $sqlDialect->keyword('external', $state, $config) + ' ' +
      $sqlDialect->keyword('table', $state, $config) + ' ' +
      $sqlDialect->executeIdentifierProcessor($c.tableName, $config.dbConfig.quoteIdentifiers, $state, $config) +
      ' (' + $state.separatorIfPretty(1, $config) +
      $c.columns->map(c|athenaChangeQuoteIndentifierForCreateStatement($sqlDialect->executeIdentifierProcessor($c.first, $config.dbConfig.quoteIdentifiers, $state, $config)) + ' ' + $supportedTypes->get($c.second.name)->orElse($c.second.name);)->joinStrings(',' + $state.separator(1, $config)) + $state.separatorIfPretty(0, $config) +
      ') Location \'s3://legend-athena-query-results/' + $tableLocationKey + '/\'';
    }
  );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::querySpecificationProcessorHelper_athena(sqlDialect:SqlDialect[1], querySpec:QuerySpecification[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let sep0 = $state.separator(0, $config);
  let sep1 = $state.separator(1, $config);

  // Select
  $sqlDialect->executeNodeProcessor($querySpec.select, $state, $config) +

  // From
  $querySpec.from->executeIfNotEmptyElseReturnEmptyString({|
    $sep0 + $sqlDialect->keyword('from', $state, $config) +
    $sep1 + $querySpec.from->map(r | $sqlDialect->executeNodeProcessor($r, $state->increaseLevel(), $config))->joinStrings(',' + $sep1)
  }) +

  // Where
  $querySpec.where->executeIfNotEmptyElseReturnEmptyString({|
    $sep0 + $sqlDialect->keyword('where', $state, $config) +
    $sep1 + $sqlDialect->executeNodeProcessor($querySpec.where->toOne(), $state->increaseLevel(), $config)
  }) +

  // Group By
  $querySpec.groupBy->executeIfNotEmptyElseReturnEmptyString({|
    $sep0 + $sqlDialect->keyword('group by', $state, $config) +
    $sep1 + $querySpec.groupBy->map(r | $sqlDialect->executeNodeProcessor($r, $state->increaseLevel(), $config))->joinStrings(',' + $sep1)
  }) +

  // Having
  $querySpec.having->executeIfNotEmptyElseReturnEmptyString({|
    $sep0 + $sqlDialect->keyword('having', $state, $config) +
    $sep1 + $querySpec.having->map(r | $sqlDialect->executeNodeProcessor($r, $state->increaseLevel(), $config))->joinStrings(',' + $sep1)
  }) +

  // Qualify
  if (renderQualify($sqlDialect, $querySpec, $state, $config, $sep0, $sep1) == '',
  | '',
  | failWithMessage('Athena SQL Dialect does not support Qualify!')
  ) +

  // Order By
  $querySpec.orderBy->executeIfNotEmptyElseReturnEmptyString({|
    $sep0 + $sqlDialect->keyword('order by', $state, $config) +
    $sep1 + $querySpec.orderBy->map(r | $sqlDialect->executeNodeProcessor($r, $state->increaseLevel(), $config))->joinStrings(',' + $sep1)
  }) +


  // Offset
  $querySpec.offset->executeIfNotEmptyElseReturnEmptyString({|
    $sep0 + $sqlDialect->keyword('offset', $state, $config) + ' ' + $sqlDialect->executeNodeProcessor($querySpec.offset->toOne(), $state->increaseLevel(), $config)
  }) +

  // Limit
  $querySpec.limit->executeIfNotEmptyElseReturnEmptyString({|
    $sep0 + $sqlDialect->keyword('limit', $state, $config) + ' ' + $sqlDialect->executeNodeProcessor($querySpec.limit->toOne(), $state->increaseLevel(), $config)
  });
}

function meta::external::store::relational::sqlDialectTranslation::athena::querySpecificationProcessor_athena(): NodeProcessor<QuerySpecification>[1]
{
  nodeProcessor(
    QuerySpecification,
    {sqlDialect, querySpec, state, config | querySpecificationProcessorHelper_athena($sqlDialect, $querySpec, $state, $config);}
  )
}

function meta::external::store::relational::sqlDialectTranslation::athena::extendedQuerySpecificationProcessor_athena(): NodeProcessor<ExtendedQuerySpecification>[1]
{
  nodeProcessor(
    ExtendedQuerySpecification,
    {sqlDialect, querySpec, state, config | querySpecificationProcessorHelper_athena($sqlDialect, $querySpec, $state, $config)}
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaKeywords(): String[*]
{
  // Based on https://trino.io/docs/current/language/reserved.html
  [ 
    'alter',
    'and',
    'as',
    'auto',
    'between',
    'by',
    'case',
    'cast',
    'constraint',
    'create',
    'cross',
    'cube',
    'current_catalog',
    'current_date',
    'current_path',
    'current_role',
    'current_schema',
    'current_time',
    'current_timestamp',
    'current_user',
    'deallocate',
    'delete',
    'describe',
    'distinct',
    'drop',
    'else',
    'end',
    'escape',
    'except',
    'exists',
    'extract',
    'false',
    'for',
    'from',
    'full',
    'group',
    'grouping',
    'having',
    'in',
    'inner',
    'insert',
    'intersect',
    'into',
    'is',
    'join',
    'json_array',
    'json_exists',
    'json_object',
    'json_query',
    'json_table',
    'json_value',
    'lateral',
    'left',
    'like',
    'listagg',
    'localtime',
    'localtimestamp',
    'natural',
    'normalize',
    'not',
    'null',
    'on',
    'or',
    'order',
    'outer',
    'prepare',
    'recursive',
    'right',
    'rollup',
    'select',
    'skip',
    'table',
    'then',
    'trim',
    'true',
    'unescape',
    'union',
    'unnest',
    'using',
    'values',
    'view',
    'when',
    'where',
    'with'
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaIdentifierProcessor(): IdentifierProcessor[1]
{
  identifierProcessor_default()
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaExpressionPrecedenceComparator(): ExpressionPrecedenceComparator[1]
{
  ^ExpressionPrecedenceComparator(
    findOperatorType = findOperatorType_default_Expression_1__String_1_,
    operatorPrecedence = operatorPrecedence_default()
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::asOfJoinProcessorForAthena(): NodeProcessor<AsOfJoin>[1]
{
  nodeProcessor(
    AsOfJoin,
    {sqlDialect, j, state, config |
      failWithMessage('Athena SQL Dialect does not support AsOfJoin!');
    },
    {n: AsOfJoin[1] | true}
  );
}


function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaFunctionProcessorMap(): Map<Class<SqlFunction>, FunctionProcessor>[1]
{
  newMap([
    // Postgres Native Functions
    // Numeric
    pair(Abs, simpleFunctionProcessor('abs')),
    pair(Acos, simpleFunctionProcessor('acos')),
    pair(Asin, simpleFunctionProcessor('asin')),
    pair(Atan, simpleFunctionProcessor('atan')),
    pair(Atan2, simpleFunctionProcessor('atan2')),
    pair(Cbrt, simpleFunctionProcessor('cbrt')),
    pair(Ceil, customFunctionProcessor(processorForCeil_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Ceiling,  customFunctionProcessor(processorForCeil_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Cos, simpleFunctionProcessor('cos')),
    pair(Cot, customFunctionProcessor(processorForCot_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Degrees, simpleFunctionProcessor('degrees')),
    pair(Exp, simpleFunctionProcessor('exp')),
    pair(Floor, customFunctionProcessor(processorForFloor_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Ln, simpleFunctionProcessor('ln')),
    pair(Log, argTransformFunctionProcessor('log', {n:Node[*]| if($n->size() == 1, | literal(10)->concatenate($n), | $n)})),
    pair(Mod, simpleFunctionProcessor('mod')),
    pair(Power, simpleFunctionProcessor('power')),
    pair(Round, simpleFunctionProcessor('round')),
    pair(Sign, customFunctionProcessor(processorForSign_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Sin, simpleFunctionProcessor('sin')),
    pair(Sinh, simpleFunctionProcessor('sinh')),
    pair(Sqrt, simpleFunctionProcessor('sqrt')),
    pair(Tan, simpleFunctionProcessor('tan')),
    pair(Tanh, simpleFunctionProcessor('tanh')),

    // Numeric Aggregate
    pair(Average, simpleFunctionProcessor('avg')),
    pair(Sum, simpleFunctionProcessor('sum')),
    pair(Correlation, simpleFunctionProcessor('corr')),
    pair(CovarianceSample, simpleFunctionProcessor('covar_samp')),
    pair(CovariancePopulation, simpleFunctionProcessor('covar_pop')),
    pair(VariancePopulation, simpleFunctionProcessor('var_pop')),
    pair(VarianceSample, simpleFunctionProcessor('var_samp')),
    pair(StdDevSample, simpleFunctionProcessor('stddev_samp')),
    pair(StdDevPopulation, simpleFunctionProcessor('stddev_pop')),

    // String
    pair(Ascii, customFunctionProcessor(processorForAscii_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(CharLength, simpleFunctionProcessor('length')),
    pair(Chr, simpleFunctionProcessor('chr')),
    pair(Concat, customFunctionProcessor(processorForConcat_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Left, customFunctionProcessor(processorForLeft_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)), // Custom handling to handle negative index
    pair(Lower, simpleFunctionProcessor('lower')),
    pair(Lpad, customFunctionProcessor(processorForLpad_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Ltrim, simpleFunctionProcessor('ltrim')),
    pair(Md5, customFunctionProcessor(processorForMd5_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Repeat, customFunctionProcessor(processorForRepeat_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Replace, simpleFunctionProcessor('replace')),
    pair(Reverse, simpleFunctionProcessor('reverse')),
    pair(Right, customFunctionProcessor(processorForRight_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)), // Custom handling to handle negative index
    pair(Rpad, customFunctionProcessor(processorForRpad_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Rtrim, simpleFunctionProcessor('rtrim')),
    pair(SplitPart, customFunctionProcessor(processorForSplitPart_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(StrPos, argTransformFunctionProcessor('strpos', {n:Node[*]| $n->concatenate(literal(1))})),
    pair(Substring, customFunctionProcessor(processorForSubstring_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Upper, simpleFunctionProcessor('upper')),
    pair(Greatest, simpleFunctionProcessor('greatest')),
    pair(Least, simpleFunctionProcessor('least')),

    // String Aggregate
    pair(StringAgg, customFunctionProcessor(processorForStringAgg_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Boolean Aggregate
    pair(BoolAnd, simpleFunctionProcessor('bool_and')),
    pair(BoolOr, simpleFunctionProcessor('bool_or')),

    // Temporal
    pair(DatePart, customFunctionProcessor(processorForDatePart_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(DateTrunc, customFunctionProcessor(processorForDateTrunc_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Now, simpleFunctionProcessor('now')),
    pair(ToDate, customFunctionProcessor(processorForToDate_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(ToTimestamp, customFunctionProcessor(processorForToTimestamp_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::temporal::Date, simpleFunctionProcessor('date')),

    // Miscellaneous
    pair(Coalesce, simpleFunctionProcessor('coalesce')),

    // Aggregate
    pair(Count, simpleFunctionProcessor('count')),
    pair(Max, simpleFunctionProcessor('max')),
    pair(Min, simpleFunctionProcessor('min')),

    // Window
    pair(CumulativeDistribution, simpleFunctionProcessor('cume_dist')),
    pair(DenseRank, simpleFunctionProcessor('dense_rank')),
    pair(FirstValue, simpleFunctionProcessor('first_value')),
    pair(PercentRank, simpleFunctionProcessor('percent_rank')),
    pair(Lag, simpleFunctionProcessor('lag')),
    pair(LastValue, simpleFunctionProcessor('last_value')),
    pair(Lead, simpleFunctionProcessor('lead')),
    pair(NthValue, simpleFunctionProcessor('nth_value')),
    pair(Ntile, simpleFunctionProcessor('ntile')),
    pair(Rank, simpleFunctionProcessor('rank')),
    pair(RowNumber, simpleFunctionProcessor('row_number')),
    pair(AverageRank, customFunctionProcessor(processorForAverageRank_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Extension functions
    // Numeric
    pair(Log10, argTransformFunctionProcessor('log', {n:Node[*]| literal(10)->concatenate($n)})),
    pair(Cosh, simpleFunctionProcessor('cosh')),

    // String
    pair(RegexpLike, customFunctionProcessor(processorForRegexpLikeAthena_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Sha1, customFunctionProcessor(processorForSha1_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Sha256, customFunctionProcessor(processorForSha256_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Contains, customFunctionProcessor(processorForContainsAthena_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(EncodeBase64, customFunctionProcessor(processorForEncodeBase64_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(DecodeBase64, customFunctionProcessor(processorForDecodeBase64_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(EditDistance, simpleFunctionProcessor('levenshtein_distance')),
    pair(StartsWith, simpleFunctionProcessor('starts_with')),
    pair(EndsWith, customFunctionProcessor(processorForEndsWithAthena_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(ToChar, customFunctionProcessor(processorForToChar_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(UuidV4, customFunctionProcessor(processorForToUuidV4_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Temporal
    pair(MakeDate, customFunctionProcessor(processorForMakeDate_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(MakeTimestamp, customFunctionProcessor(processorForMakeTimestamp_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(DateDiff, customFunctionProcessor(processorForDateDiff_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(DateAdd, customFunctionProcessor(processorForDateAdd_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(ConvertTimeZone, customFunctionProcessor(processorForConvertTimeZone_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Miscellaneous
    pair(ParseJson, simpleFunctionProcessor('json_parse')) // fail
  ])
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForCeil(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let ceilCall = simpleFunctionProcessor('ceil').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($ceilCall, 'DECIMAL(37, 1)', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForCot(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  '(1/' + $sqlDialect->generateFunctionCallWithArgs('tan', $processedArgs, [], $state, $config) + ')';
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForFloor(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let ceilCall = simpleFunctionProcessor('floor').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($ceilCall, 'DECIMAL(37, 1)', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForSign(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let ceilCall = simpleFunctionProcessor('sign').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($ceilCall, 'INTEGER', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForAscii(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config)->at(0)->removeQuotes($sqlDialect);
  if ($processedArgs->meta::pure::functions::string::length() == 0,
      | '0',
      | $sqlDialect->generateFunctionCallWithArgs('codepoint', $processedArgs->substring(0, 1)->addQuotes($sqlDialect), [], $state, $config)
      );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForConcat(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config)->map({arg | let generatedCast = $sqlDialect->generateCast($arg, 'VARCHAR', $state, $config);
    $sqlDialect->generateFunctionCallWithArgs('coalesce', [$generatedCast, '\'\''], $state, $config);
  });
  $sqlDialect->generateFunctionCallWithArgs('concat', $processedArgs, [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForLeft(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let index = $processedArgs->at(1)->parseInteger();
  if($index<0,
  | $sqlDialect->generateFunctionCallWithArgs('substring', [$processedArgs->at(0), '1', ($sqlDialect->generateFunctionCallWithArgs('length', [$processedArgs->at(0)], [], $state, $config) + $index->toString())], [], $state, $config),
  | $sqlDialect->generateFunctionCallWithArgs('substring', [$processedArgs->at(0), '1', $index->toString()], [], $state, $config)
  );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForLpad(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  if($processedArgs->size()==2,
  | $sqlDialect->generateFunctionCallWithArgs('lpad', [$processedArgs->at(0), $processedArgs->at(1), '\' \''], [], $state, $config),
  | if ($processedArgs->at(2) == '\'\'', 
        | $processedArgs->at(0),
        | $sqlDialect->generateFunctionCallWithArgs('lpad', [$processedArgs->at(0), $processedArgs->at(1), $processedArgs->at(2)], [], $state, $config)
       )
  );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForMd5(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let md5Call = $sqlDialect->generateFunctionCallWithArgs('md5', [$sqlDialect->generateFunctionCallWithArgs('to_utf8', $processedArgs, [], $state, $config)], [], $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('lower', [$sqlDialect->generateFunctionCallWithArgs('to_hex', $md5Call, [], $state, $config)], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForRepeat(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let lengthToRepeat = generateFunctionCallWithArgs($sqlDialect, 'length', [$processedArgs->at(0)], $state, $config) + ' * ' +$processedArgs->at(1);
  if ($processedArgs->at(0) == '\'\'',
      | $processedArgs->at(0),
      | generateFunctionCallWithArgs($sqlDialect, 'rpad', ['\'\'', $lengthToRepeat, $processedArgs->at(0)], $state, $config)
      );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForRpad(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  if($processedArgs->size()<3,
  | $sqlDialect->generateFunctionCallWithArgs('rpad', [$processedArgs->at(0), $processedArgs->at(1), '\' \''], [], $state, $config),
  | if ($processedArgs->at(2) == '\'\'', 
        | $processedArgs->at(0),
        | $sqlDialect->generateFunctionCallWithArgs('rpad', [$processedArgs->at(0), $processedArgs->at(1), $processedArgs->at(2)], [], $state, $config)
       )
  );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForSplitPart(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  if ($processedArgs->at(1) == '\'\'', 
      | $processedArgs->at(0), 
      | $sqlDialect->generateFunctionCallWithArgs('split_part', [$processedArgs->at(0), $processedArgs->at(1), $processedArgs->at(2)], [], $state, $config)
     );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForSubstring(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  if ($processedArgs->size() == 2,
      | $sqlDialect->generateFunctionCallWithArgs('substring', [$processedArgs->at(0), ($processedArgs->at(1) + '+' + '1')], [], $state, $config),
      | $sqlDialect->generateFunctionCallWithArgs('substring', [$processedArgs->at(0), ($processedArgs->at(1) + '+' + '1'), $processedArgs->at(2)], [], $state, $config)
     );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForAverageRank(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let rankCall = simpleFunctionProcessor('rank').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  let denseRankCall = simpleFunctionProcessor('dense_rank').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  '(' + $rankCall + '+' + $denseRankCall + ') / 2';
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForRegexpLikeAthena(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('regexp_like', [$processedArgs->at(0), ('\'^' + $processedArgs->at(1)->removeQuotes($sqlDialect) + '$\'')] , [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForSha1(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let md5Call = $sqlDialect->generateFunctionCallWithArgs('sha1', [$sqlDialect->generateFunctionCallWithArgs('to_utf8', $processedArgs, [], $state, $config)], [], $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('lower', [$sqlDialect->generateFunctionCallWithArgs('to_hex', $md5Call, [], $state, $config)], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForSha256(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let md5Call = $sqlDialect->generateFunctionCallWithArgs('sha256', [$sqlDialect->generateFunctionCallWithArgs('to_utf8', $processedArgs, [], $state, $config)], [], $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('lower', [$sqlDialect->generateFunctionCallWithArgs('to_hex', $md5Call, [], $state, $config)], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForContainsAthena(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let strposCall = simpleFunctionProcessor('strpos').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($strposCall, 'BOOLEAN', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForEncodeBase64(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('to_base64', [$sqlDialect->generateFunctionCallWithArgs('to_utf8', $processedArgs, [], $state, $config)], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForDecodeBase64(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('from_utf8', [$sqlDialect->generateFunctionCallWithArgs('from_base64', $processedArgs, [], $state, $config)], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForToUuidV4(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let ceilCall = simpleFunctionProcessor('uuid').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($ceilCall, 'VARCHAR', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForEndsWithAthena(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('starts_with', [$sqlDialect->generateFunctionCallWithArgs('reverse', $processedArgs->at(0), [], $state, $config), $sqlDialect->generateFunctionCallWithArgs('reverse', $processedArgs->at(1), [], $state, $config)], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForRight(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let reverseInput = $sqlDialect->generateFunctionCallWithArgs('reverse', [$processedArgs->at(0)], [], $state, $config);
  let index = $processedArgs->at(1)->parseInteger();
  let reverseInputLtrimmed = if($index<0,
                                | $sqlDialect->generateFunctionCallWithArgs('substring', [$reverseInput, '1', ($sqlDialect->generateFunctionCallWithArgs('length', [$processedArgs->at(0)], [], $state, $config) + $index->toString())], [], $state, $config),
                                | $sqlDialect->generateFunctionCallWithArgs('substring', [$reverseInput, '1', $index->toString()], [], $state, $config)
                                );
  $sqlDialect->generateFunctionCallWithArgs('reverse', [$reverseInputLtrimmed], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForStringAgg(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  generateFunctionCallWithArgs($sqlDialect, 'listagg', $processedArgs, $state, $config) + 'within group (order by ' + $processedArgs->at(0) + ' )';
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForDatePart(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let datePart = $processedArgs->at(0)->toString()->removeQuotes($sqlDialect);
  if($datePart->toLower() == 'millisecond',
    | let seconds = generateFunctionCallWithArgs($sqlDialect, 'second', [$processedArgs->at(1)], [], $state, $config) + '* 1000';
        $seconds + ' + ' + generateFunctionCallWithArgs($sqlDialect, 'millisecond', [$processedArgs->at(1)], [], $state, $config);,
    | let inputText = $datePart + ' ' + $sqlDialect->keyword('from', $state, $config) + ' ' + $processedArgs->at(1);
      generateFunctionCallWithArgs($sqlDialect, $datePart->toLower(), [$processedArgs->at(1)], [], $state, $config);
  );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForDateTrunc(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let dateTrunc = generateFunctionCallWithArgs($sqlDialect, 'date_trunc', [$processedArgs->at(0), $processedArgs->at(1)], [], $state, $config);
  $sqlDialect->generateCast($dateTrunc, 'TIMESTAMP', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForToDate(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let parsedDateTime = generateFunctionCallWithArgs($sqlDialect, 'date_parse', [$processedArgs->at(0), $processedArgs->at(1)->dateFormatSpecifierForAthena()], [], $state, $config);
  generateFunctionCallWithArgs($sqlDialect, 'date', [$parsedDateTime], [], $state, $config);

}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForToTimestamp(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  if($processedArgs->size() == 1,
    | generateFunctionCallWithArgs($sqlDialect, 'from_unixtime', [$processedArgs->at(0)], [], $state, $config),
    | generateFunctionCallWithArgs($sqlDialect, 'date_parse', [$processedArgs->at(0), $processedArgs->at(1)->dateFormatSpecifierForAthena()], [], $state, $config);
  );
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForMakeDate(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  generateFunctionCallWithArgs($sqlDialect, 'date', [('\'' + $processedArgs->at(0) + '-' + $processedArgs->at(1) + '-' + $processedArgs->at(2) + '\'')], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForMakeTimestamp(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $sqlDialect->generateCast(('\'' + $processedArgs->at(0) + '-' + $processedArgs->at(1) + '-' + $processedArgs->at(2) + ' ' + $processedArgs->at(3) + ':' + $processedArgs->at(4) + ':' + $processedArgs->at(5) + '\''), 'TIMESTAMP', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForDateDiff(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $processedArgs->dateDiffHandlerForAthena($sqlDialect);
}

function meta::external::store::relational::sqlDialectTranslation::athena::dateDiffHandlerForAthena(p: String[*], sqlDialect:SqlDialect[1]): String[1]
{
  let timeUnits = ['year', 'month', 'day', 'week', 'hour', 'minute', 'second', 'millisecond'];
  let indexOfUnit = $timeUnits->indexOf($p->at(0)->removeQuotes($sqlDialect)->toLower());
  let unitFunctionsList = [

    { | format('(%s)', [
        'date_diff(\'year\', date_trunc(\'year\',%s), date_trunc(\'year\',%s))'
     ])},

    { | format('(%s)', [
        'date_diff(\'month\', date_trunc(\'month\',%s), date_trunc(\'month\',%s))'
     ])},

    { | format('(%s)', [
        'date_diff(\'day\', date_trunc(\'day\',%s), date_trunc(\'day\',%s))'
     ])},

    { | format('(cast(%s / 7 as integer))', [
        ['day', '%s', '%s']->dateDiffHandlerForAthena($sqlDialect)
     ])},

    { | format('(%s)', [
        'date_diff(\'hour\', date_trunc(\'hour\',%s), date_trunc(\'hour\',%s))'
     ])},

    { | format('(%s)', [
        'date_diff(\'minute\', date_trunc(\'minute\',%s), date_trunc(\'minute\',%s))'
     ])},

    { | format('(%s)', [
        'date_diff(\'second\', date_trunc(\'second\',%s), date_trunc(\'second\',%s))'
     ])},

    { | format('(%s)', [
        'date_diff(\'millisecond\', date_trunc(\'millisecond\',%s), date_trunc(\'millisecond\',%s))'
     ])}

  ];

  format($unitFunctionsList->at($indexOfUnit)->eval(), [$p->at(1), $p->at(2)]);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForDateAdd(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{ 
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let timeUnit = $processedArgs->at(2)->toLower();
  if ($timeUnit == '\'microsecond\'',
      |failWithMessage('Athena SQL Dialect does not support adding microsecond to date'),
      |generateFunctionCallWithArgs($sqlDialect, 'date_add', [$timeUnit, $processedArgs->at(1), $processedArgs->at(0)], [], $state, $config)
     ); 
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForConvertTimeZone(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let convertedTime = generateFunctionCallWithArgs($sqlDialect, 'at_timezone', [$processedArgs->at(0), $processedArgs->at(1)], [], $state, $config);
  generateFunctionCallWithArgs($sqlDialect, 'date_format', [$convertedTime, $processedArgs->at(2)->dateFormatSpecifierForAthena()], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::processorForToChar(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  generateFunctionCallWithArgs($sqlDialect, 'date_format', [$processedArgs->at(0), $processedArgs->at(1)->dateFormatSpecifierForAthena()], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::dateFormatSpecifierForAthena(f:String[1]): String[1]
{
  let formatSubs = [
    pair('Month', '%M'),
    pair('Day', '%W'),
    pair('YYYY', '%Y'),
    pair('MM', '%m'),
    pair('DD', '%d'),
    pair('Mon', '%b'),
    pair('HH24', '%H'),
    pair('HH12', '%h'),
    pair('HH', '%h'),
    pair('MI', '%i'),
    pair('SS', '%s'),
    pair('MS', '%f')
    // TODO: Handle more format specifiers
  ];

  $formatSubs->fold({i, a|$a->replace($i.first, $i.second)}, $f);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::athena::athenaVariablePlaceholderPrefixSuffixMap(): Map<String, Pair<String, String>>[1]
{
  [
    pair('String',      pair('\'', '\'')),
    pair('Integer',     pair('', '')),
    pair('Decimal',     pair('', '')),
    pair('Number',      pair('', '')),
    pair('SQLNull',     pair('', '')),
    pair('Float',       pair('', '')),
    pair('StrictDate',  pair('DATE \'', '\'')),
    pair('DateTime',    pair('TIMESTAMP \'', '\'')),
    pair('Date',        pair('TIMESTAMP \'', '\'')),
    pair('Boolean',     pair('', '')),
    pair('Enum',        pair('', ''))
  ]->newMap();
}