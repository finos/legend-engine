// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::metamodel::execute::tests::*;
import meta::external::store::relational::runtime::*;
import meta::relational::translation::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::relational::runtime::*;
import meta::relational::tests::csv::*;
import meta::relational::metamodel::execute::*;
import meta::relational::metamodel::*;
import meta::pure::mapping::*;
import meta::pure::functions::relation::*;

function meta::relational::tests::exec::getTestConnection(dbType: DatabaseType[1]): meta::external::store::relational::runtime::RelationalDatabaseConnection[1]
{
  let fStr = 'meta::pure::testConnection::getTestConnectionBridge_DatabaseType_1__RelationalDatabaseConnection_1_';
  let func = $fStr->pathToElement()->cast(@Function<{DatabaseType[1]->RelationalDatabaseConnection[1]}>);
  $func->eval($dbType);
}

function <<test.Test>> meta::relational::tests::exec::testS3Execution() : Boolean[1]
{
    let conn = meta::relational::tests::exec::getTestConnection(DatabaseType.DuckDB);

    let runtime = ^meta::core::runtime::Runtime(
            connectionStores = ^meta::core::runtime::ConnectionStore(
                element = meta::relational::tests::exec::S3Database,
                connection = $conn
            )
    );

    // todo relation accessor does not support schema yet
    // let func = |#>{meta::relational::tests::exec::S3Database.nyc.taxis}#->select()->from($runtime);
    let func = |#>{meta::relational::tests::exec::S3Database.taxis}#->select()->from($runtime);

    let resultJson = meta::legend::executeLegendQuery($func, [], meta::relational::extension::relationalExtensions());

    let result = meta::protocols::pure::vX_X_X::invocation::execution::execute::legendBuildResultFromJSON(
        $resultJson,
        @TabularDataSet,
         meta::relational::tests::exec::EmptyMapping,
        $runtime,
        [],
        meta::relational::extension::relationalExtensions()
    );

    let values = $result.values->cast(@TabularDataSet)->toOne();

    meta::relational::functions::asserts::assertSameSQL('select "taxis_0".vendor_id as "vendor_id", "taxis_0".trip_id as "trip_id", "taxis_0".store_and_fwd_flag as "store_and_fwd_flag" from (select * from iceberg_scan(\'s3://warehouse/wh/nyc/taxis\', allow_moved_paths = true) as "iceberg_scan_taxis") as "taxis_0"', $result);
    assertSameElements( [
        '1|1000371|N',
        '1|1000374|Y',
        '2|1000372|N',
        '2|1000373|N'
    ], $values.rows->map(r|$r.values->makeString('|')));
}

###Mapping
Mapping  meta::relational::tests::exec::EmptyMapping()


###Relational
Database meta::relational::tests::exec::S3Database
(
    // todo relation accessor does not support other types yet - only INT, INTEGER, and VARCHAR are supported?
    Table taxis
    (
        vendor_id INTEGER,
        trip_id INTEGER,
        store_and_fwd_flag VARCHAR(1000)
    )

    Schema nyc
    (
        Table taxis
        (
            vendor_id BIGINT,
            trip_id BIGINT,
            trip_distance FLOAT,
            fare_amount FLOAT,
            store_and_fwd_flag VARCHAR(1000)

        )
    )
)
