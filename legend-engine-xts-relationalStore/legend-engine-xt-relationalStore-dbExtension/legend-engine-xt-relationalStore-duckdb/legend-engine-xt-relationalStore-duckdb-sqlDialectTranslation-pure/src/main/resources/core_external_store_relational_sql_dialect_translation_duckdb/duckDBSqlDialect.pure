// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::postgres::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::boolean::*;
import meta::external::query::sql::metamodel::*;
import meta::external::store::relational::sqlDialectTranslation::*;
import meta::external::store::relational::sqlDialectTranslation::defaults::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::boolean::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::duckDB::*;
import meta::external::store::relational::sqlDialectTranslation::sqlTyping::typeInference::*;
import meta::external::store::relational::sqlDialectTranslation::utils::*;
import meta::pure::extension::*;

function meta::external::store::relational::sqlDialectTranslation::duckDB::duckDBSqlDialect(): SqlDialect[1]
{
  ^SqlDialect
  (
    dbType = 'DuckDB',
    quoteConfig = doubleQuotesConfiguration_default(),
    nodeProcessors = duckDBDialectNodeProcessors(),
    identifierProcessor = identifierProcessor_default(),
    expressionPrecedenceComparator = expressionPrecedenceComparator_default(),
    keywords = duckDBKeywords(),
    functionProcessorDispatch = meta::external::store::relational::sqlDialectTranslation::duckDB::functionProcessorMap_SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__Map_1_
  )
}

function meta::external::store::relational::sqlDialectTranslation::duckDB::duckDBSqlDialectExtension(): Extension[1]
{
  ^Extension
  (
    type = 'DuckDBSqlDialectExtension',
    moduleExtensions = [
      ^SqlDialectTranslationModuleExtension
      (
        module = sqlDialectTranslationModuleExtensionName(),
        extraSqlDialects = duckDBSqlDialect()
      )
    ]
  )
}

function meta::external::store::relational::sqlDialectTranslation::duckDB::duckDBFunctionTestsExpectedErrors(): Map<String, String>[1]
{
  [
   
  ]->newMap()->cast(@Map<String, String>)
}


function <<access.private>> meta::external::store::relational::sqlDialectTranslation::duckDB::duckDBDialectNodeProcessors(): Map<Class<Node>, NodeProcessor<Node>>[1]
{
  newMap(
    dialectStatementProcessors_default()
    ->concatenate(
      dialectRelationProcessors_default()
    )
    ->concatenate(
      duckDBDialectExpressionProcessors()
    )
    ->concatenate(
      dialectLiteralProcessors_default()
    )
    ->concatenate(
      dialectSelectItemProcessors_default()
    )
    ->concatenate(
      dialectOtherNodeProcessors_default()
    )
    ->map(n | pair($n.nodeType, $n))
  )
}



function <<access.private>> meta::external::store::relational::sqlDialectTranslation::duckDB::duckDBDialectExpressionProcessors(): NodeProcessor<meta::external::query::sql::metamodel::Expression>[*]
{
  [
    comparisonExpressionNodeProcessor_default(),
    logicalBinaryExpressionNodeProcessor_default(),
    notExpressionNodeProcessor_default(),
    arithmeticExpressionNodeProcessor_duckDB(),
    qualifiedNameReferenceNodeProcessor_default(),
    isNullPredicateNodeProcessor_default(),
    isNotNullPredicateNodeProcessor_default(),
    negativeNodeProcessor_default(),
    currentTimeNodeProcessor_default(),
    whenClauseNodeProcessor_default(),
    searchedCaseExpressionNodeProcessor_default(),
    columnTypeProcessor_default(),
    castProcessor_default(),
    inListExpressionProcessor_default(),
    inPredicateProcessor_default(),
    extractProcessor_default(),
    betweenPredicateProcessor_default(),
    functionCallProcessor_default(),
    subQueryExpressionProcessor_default(),
    trimProcessor_default()
  ]
}



function <<access.private>> meta::external::store::relational::sqlDialectTranslation::duckDB::duckDBKeywords(): String[*]
{
  [ 
    'ALL',
    'ANALYSE',
    'ANALYZE',
    'AND',
    'ANY',
    'ARRAY',
    'AS',
    'ASC_P',
    'ASYMMETRIC',
    'BOTH',
    'CASE',
    'CAST',
    'CHECK_P',
    'COLLATE',
    'COLUMN',
    'CONSTRAINT',
    'CREATE_P',
    'DEFAULT',
    'DEFERRABLE',
    'DESC_P',
    'DESCRIBE',
    'DISTINCT',
    'DO',
    'ELSE',
    'END_P',
    'EXCEPT',
    'FALSE_P',
    'FETCH',
    'FOR',
    'FOREIGN',
    'FROM',
    'GRANT',
    'GROUP_P',
    'HAVING',
    'QUALIFY',
    'IN_P',
    'INITIALLY',
    'INTERSECT',
    'INTO',
    'LATERAL_P',
    'LEADING',
    'LIMIT',
    'NOT',
    'NULL_P',
    'OFFSET',
    'ON',
    'ONLY',
    'OR',
    'ORDER',
    'PIVOT',
    'PIVOT_WIDER',
    'PIVOT_LONGER',
    'PLACING',
    'PRIMARY',
    'REFERENCES',
    'RETURNING',
    'SELECT',
    'SHOW',
    'SOME',
    'SUMMARIZE',
    'SYMMETRIC',
    'TABLE',
    'THEN',
    'TO',
    'TRAILING',
    'TRUE_P',
    'UNION',
    'UNIQUE',
    'UNPIVOT',
    'USING',
    'VARIADIC',
    'WHEN',
    'WHERE',
    'WINDOW',
    'WITH' 
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::duckDB::arithmeticExpressionNodeProcessor_duckDB(): NodeProcessor<ArithmeticExpression>[1]
{
  nodeProcessor(
    ArithmeticExpression,
    {sqlDialect, a, state, config |
      let leftExpr = $sqlDialect->executeNodeProcessor($a.left, $a, $state, $config);
      let rightExpr = $sqlDialect->executeNodeProcessor($a.right, $a, $state, $config);
      let operator = if(
        [
          pair(|$a.type == ArithmeticType.ADD, | '+'),
          pair(|$a.type == ArithmeticType.SUBTRACT, | '-'),
          pair(|$a.type == ArithmeticType.MULTIPLY, | '*'),
          pair(|$a.type == ArithmeticType.DIVIDE, | '//'),
          pair(|$a.type == ArithmeticType.MODULUS, | '%'),
          pair(|$a.type == ArithmeticType.POWER, | '^')
        ],
        | failWithMessage('Unhandled arithmetic operator type: ' + $a.type->toString())
      );

      $leftExpr + ' ' + $operator + ' ' + $rightExpr;
    }
  )
}

function meta::external::store::relational::sqlDialectTranslation::duckDB::functionProcessorMap(sqlDialect: SqlDialect[1], state: SqlDialectTranslationState[1], config: SqlDialectTranslationConfig[1]): Map<Class<SqlFunction>, FunctionProcessor>[1]
{
  newMap([
    // Numeric
    pair(Abs, simpleFunctionProcessor('abs')),
    pair(Cbrt, simpleFunctionProcessor('cbrt')),
    pair(Ceil, simpleFunctionProcessor('ceil')),
    pair(Ceiling, simpleFunctionProcessor('ceiling')),
    pair(Degrees, simpleFunctionProcessor('degrees')),
    pair(Exp, simpleFunctionProcessor('exp')),
    pair(Ln, simpleFunctionProcessor('ln')),
    pair(Log, simpleFunctionProcessor('log')),
    pair(Log10, simpleFunctionProcessor('log10')),
    pair(Sqrt, simpleFunctionProcessor('sqrt')),
    pair(Acos, simpleFunctionProcessor('acos')),
    pair(Asin, simpleFunctionProcessor('asin')),
    pair(Atan, simpleFunctionProcessor('atan')),
    pair(Atan2, simpleFunctionProcessor('atan2')),
    pair(Cos, simpleFunctionProcessor('cos')),
    pair(Cot, simpleFunctionProcessor('cot')),
    pair(Sin, simpleFunctionProcessor('sin')),
    pair(Tan, simpleFunctionProcessor('tan')),
    pair(Power, simpleFunctionProcessor('power')),
    pair(Sign, simpleFunctionProcessor('sign')),
    pair(Mod, simpleFunctionProcessor('mod')),
    pair(Round,simpleFunctionProcessor('round')),
    pair(Greatest, simpleFunctionProcessor('greatest')),
    pair(Least, simpleFunctionProcessor('least')),


    // String
    pair(Lpad, argTransformFunctionProcessor('lpad', 'lpad(%s)', {p:String[*]| if($p->size() == 2, |$p->concatenate('\' \''), |$p)->joinStrings(', ')})),
    pair(Rpad, argTransformFunctionProcessor('rpad', 'rpad(%s)', {p:String[*]| if($p->size() == 2, |$p->concatenate('\' \''), |$p)->joinStrings(', ')})),
    pair(Ltrim, simpleFunctionProcessor('ltrim')),
    pair(Rtrim, simpleFunctionProcessor('rtrim')),
    pair(Ascii, simpleFunctionProcessor('ascii')),
    pair(Lower, simpleFunctionProcessor('lower')),
    pair(Upper, simpleFunctionProcessor('upper')),
    pair(Repeat, simpleFunctionProcessor('repeat')),
    pair(Replace, simpleFunctionProcessor('replace')),
    pair(Md5, simpleFunctionProcessor('md5')),
    pair(CharLength, argTransformFunctionProcessor('char_length','length(%s)')),
    pair(Chr, simpleFunctionProcessor('chr')),
    pair(Left, simpleFunctionProcessor('left')),
    pair(Right, simpleFunctionProcessor('right')),
    pair(StrPos, simpleFunctionProcessor('strpos')),
    pair(Concat, simpleFunctionProcessor('concat')),
    pair(Coalesce, simpleFunctionProcessor('coalesce')),

    // Boolean
    pair(RegexpLike, argTransformFunctionProcessor('regexp_like', regexpPattern('~'), {p:String[*]|$p->transformRegexpParams()})),

    // Temporal
    pair(DateTrunc, argTransformFunctionProcessor('date_trunc', 'cast(date_trunc(%s, %s) as timestamp)')),
    pair(DatePart, simpleFunctionProcessor('date_part')),
    pair(Now, simpleFunctionProcessor('now')),
    pair(ToDate, argTransformFunctionProcessor('to_date', 'cast(strptime(%s, %s) as date)', {p:String[*]|$p->at(0)->concatenate($p->at(1)->dateFormatSpecifierForDuckDB())})),
    pair(ToTimestamp, argTransformFunctionProcessor('to_timestamp', '%s', {p:String[*]|$p->toTimestampForDuckDB()})),
    pair(ToChar, argTransformFunctionProcessor('to_char', 'strftime(%s, %s)', {p:String[*]|$p->at(0)->concatenate($p->at(1)->dateFormatSpecifierForDuckDB())}))

  ])
}

function meta::external::store::relational::sqlDialectTranslation::duckDB::toTimestampForDuckDB(p:String[*]): String[1]
{
  if($p->size() == 1,
    | 'epoch_ms(cast(' + $p->at(0) + ' as bigint) * 1000)',
    | 'strptime(' + $p->at(0) + ', ' + $p->at(1)->dateFormatSpecifierForDuckDB() + ')'
  )
}



function meta::external::store::relational::sqlDialectTranslation::duckDB::dateFormatSpecifierForDuckDB(f:String[1]): String[1]
{
  let formatSubs = [
    pair('Month', '%B'),
    pair('Day', '%A'),
    pair('YYYY', '%Y'),
    pair('MM', '%m'),
    pair('DD', '%d'),
    pair('Mon', '%b'),
    pair('HH24', '%H'),
    pair('HH12', '%I'),
    pair('HH', '%I'),
    pair('MI','%M'),
    pair('SS', '%S'),
    pair('MS', '%g'),
    pair('US', '%f')
    // TODO: Handle more format specifiers
  ];

  $formatSubs->fold({i,a|$a->replace($i.first, $i.second)}, $f);
}

// --------------------------------------------------------------------------