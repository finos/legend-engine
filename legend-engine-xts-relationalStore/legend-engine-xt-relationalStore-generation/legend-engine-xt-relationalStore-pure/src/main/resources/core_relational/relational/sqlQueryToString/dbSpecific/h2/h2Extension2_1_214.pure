import meta::relational::functions::pureToSqlQuery::*;
import meta::relational::metamodel::relation::*;
import meta::pure::extension::*;
import meta::relational::functions::pureToSqlQuery::metamodel::*;
import meta::relational::functions::sqlQueryToString::default::*;
import meta::external::store::relational::runtime::*;
import meta::relational::runtime::*;
import meta::relational::metamodel::join::*;
import meta::pure::extension::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::operation::*;
import meta::relational::metamodel::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::functions::sqlQueryToString::h2::v2_1_214::*;

function meta::relational::functions::sqlQueryToString::h2::v2_1_214::createDbExtensionForH2():DbExtension[1]
{
   let reservedWords = h2ReservedWords();
   let literalProcessors = getDefaultLiteralProcessors()->putAll(getLiteralProcessorsForH2());
   let literalProcessor = {type:Type[1]| $literalProcessors->get(if($type->instanceOf(Enumeration), | Enum, | $type))->toOne()};
   let dynaFuncDispatch = getDynaFunctionToSqlDefault($literalProcessor)->groupBy(d| $d.funcName)->putAll(
     getDynaFunctionToSqlForH2()->groupBy(d| $d.funcName))->getDynaFunctionDispatcher();

   ^DbExtension(
      isBooleanLiteralSupported = true,
      aliasLimit = 256,
      isDbReservedIdentifier = {str:String[1]| $str->toLower()->in($reservedWords)},
      literalProcessor = $literalProcessor,
      windowColumnProcessor = processWindowColumn_WindowColumn_1__SqlGenerationContext_1__String_1_,
      lateralJoinProcessor = processJoinTreeNodeWithLateralJoinForH2_JoinTreeNode_1__DbConfig_1__Format_1__Extension_MANY__String_1_,
      semiStructuredElementProcessor = processSemiStructuredElementForH2_RelationalOperationElement_1__SqlGenerationContext_1__String_1_,
      joinStringsProcessor = processJoinStringsOperationForH2_JoinStrings_1__SqlGenerationContext_1__String_1_,
      selectSQLQueryProcessor = processSelectSQLQueryForH2_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_,
      upsertSQLQueryProcessor = processUpsertSQLQueryForH2_UpsertSQLQuery_1__SqlGenerationContext_1__String_1_,
      identifierProcessor = processIdentifierWithDoubleQuotes_String_1__DbConfig_1__String_1_,
      dynaFuncDispatch = $dynaFuncDispatch,
      ddlCommandsTranslator = getDDLCommandsTranslator(),
      processTempTableName = processTempTableNameDefault_String_1__String_1_
   );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::getDDLCommandsTranslator(): RelationalDDLCommandsTranslator[1]
{
  ^RelationalDDLCommandsTranslator(
                createSchema = translateCreateSchemaStatementDefault_CreateSchemaSQL_1__DbConfig_1__String_1_,
                dropSchema = translateDropSchemaStatementDefault_DropSchemaSQL_1__DbConfig_1__String_1_,
                createTable = translateCreateTableStatementForH2_CreateTableSQL_1__DbConfig_1__String_1_,
                dropTable = translateDropTableStatementDefault_DropTableSQL_1__DbConfig_1__String_1_,
                loadTable = loadValuesToDbTableForH2_LoadTableSQL_1__DbConfig_1__String_MANY_
              );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::translateCreateTableStatementForH2(c:CreateTableSQL[1], dbConfig: DbConfig[1]): String[1]
{
  if($c.isTempTable->isTrue(),
    | 'CREATE LOCAL TEMPORARY TABLE ' + $c.table->tableToString($dbConfig)
      + '('
      + $c.table.columns->map(r| $r->match([
        c: Column[1]                     | $c.name->processColumnName($dbConfig) + ' ' + getColumnTypeSqlTextH2($c.type),
        r: RelationalOperationElement[1] | fail('Only \'Column\' types are supported when creating temporary tables, found: '+$r->type()->toOne()->elementToPath());'';
      ]))->joinStrings(',')
      + ');',
    | $c->translateCreateTableStatementH2($dbConfig)
  )
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::getColumnTypeSqlTextH2(columnType: meta::relational::metamodel::datatype::DataType[1]): String[1]
{
  $columnType->match([
    s : meta::relational::metamodel::datatype::SemiStructured[1] | 'VARCHAR(4000)',
    a : Any[*] | dataTypeToSqlTextH2($columnType)
  ])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::translateCreateTableStatementH2(createTableSQL:CreateTableSQL[1], dbConfig:DbConfig[1]): String[1]
{
  let t= $createTableSQL.table;
  let applyConstraints = $createTableSQL.applyConstraints;
  'Create Table '+if($t.schema.name == 'default',|'',|$t.schema.name+'.')+$t.name+
  + '('
  + $t.columns->cast(@meta::relational::metamodel::Column)
      ->map(c | $c.name->processColumnName($dbConfig) + ' ' + getColumnTypeSqlTextH2($c.type) + if($c.nullable->isEmpty() || $applyConstraints == false, | '', | if($c.nullable == true , | ' NULL', | ' NOT NULL')))
      ->joinStrings(',')
  + if ($t.primaryKey->isEmpty() || $applyConstraints == false, | '', | ', PRIMARY KEY(' + $t.primaryKey->map(c | $c.name)->joinStrings(',') + ')')
  +');';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::loadValuesToDbTableForH2(l:LoadTableSQL[1], dbConfig: DbConfig[1]): String[*]
{
  if($l.absolutePathToFile->isNotEmpty(),
    | 'INSERT INTO ' + $l.table->tableToString($dbConfig) + ' SELECT * FROM CSVREAD(\''+$l.absolutePathToFile->toOne()->processOperation($dbConfig.dbType, []) + '\');',
    | $l->meta::relational::functions::sqlQueryToString::h2::v2_1_214::loadValuesToDbTableH2($dbConfig)
  )
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::loadValuesToDbTableH2(loadTableSQL: LoadTableSQL[1], dbConfig: DbConfig[1]): String[*]
{
  $loadTableSQL.parsedData.values->map(row| let sql =
    'insert into ' + if($loadTableSQL.table.schema.name == 'default', | '' , | $loadTableSQL.table.schema.name + '.') + $loadTableSQL.table.name
    + ' ('
    + $loadTableSQL.columnsToLoad.name->map(colName | $colName->processColumnName($dbConfig))->joinStrings(',')
    +') '
    + 'values ('
    + $row.values->meta::relational::functions::sqlQueryToString::h2::v2_1_214::convertValuesToCsvH2($loadTableSQL.columnsToLoad.type)
    + ');';
  );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::convertValuesToCsvH2(str: String[*], types: Any[*]): String[1]
{
  let stringToken = map(range($types->size()), {x| if($str->at($x) == '' || $str->at($x) == '---null---', |'null', |$types->at($x)->match([
    s: meta::relational::metamodel::datatype::Varchar[*]        | '\'' + $str->at($x)->replace('\'', '\'\'') + '\'',
    s: meta::relational::metamodel::datatype::SemiStructured[*] | '\'' + $str->at($x)->replace('\'', '\'\'') + '\'',
    s: meta::relational::metamodel::datatype::Char[*]           | '\'' + $str->at($x)->replace('\'', '\'\'') + '\'',
    d: meta::relational::metamodel::datatype::Date[*]           | '\'' + $str->at($x) + '\'',
    t: meta::relational::metamodel::datatype::Timestamp[*]      | '\'' + if($str->at($x)->length() > 10, |$str->at($x), |$str->at($x)) + '\'',
    b: meta::relational::metamodel::datatype::Bit[1]            | bitValueFromString($str->at($x)),
    a: Any[*]                                                   | $str->at($x)
  ]))})->joinStrings(',');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::bitValueFromString(s: String[1]): String[1]
{
  let truesList = ['y', '1', 'true'];
  let falsesList = ['n', '0', 'false'];
  let bitStr = $s->trim()->toLower();

  let bitVal = if($bitStr->in($truesList),
    | 'true',
    | if($bitStr->in($falsesList),
        | 'false',
        | $s
      )
  );

  $bitVal;
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::getLiteralProcessorsForH2():Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(Boolean,    ^LiteralProcessor(format = '%s',                transform = toString_Any_1__String_1_->literalTransform())),
      pair(Float,      ^LiteralProcessor(format = 'CAST(%s AS FLOAT)', transform = toString_Any_1__String_1_->literalTransform())),
      pair(StrictDate, ^LiteralProcessor(format = 'DATE\'%s\'',        transform = {d:StrictDate[1], dbTimeZone:String[0..1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,   ^LiteralProcessor(format = 'TIMESTAMP\'%s\'',   transform = {d:DateTime[1], dbTimeZone:String[0..1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,       ^LiteralProcessor(format = 'TIMESTAMP\'%s\'',   transform = {d:Date[1], dbTimeZone:String[0..1] | $d->convertDateToSqlString($dbTimeZone)}))
   ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::dataTypeToSqlTextH2(type: meta::relational::metamodel::datatype::DataType[1]):String[1]
{
  let MAX_CHAR_LENGTH = 1000000000;
  let MIN_CHAR_LENGTH = 1;
  let MIN_PRECISION = 1;

  $type->match([
    v : meta::relational::metamodel::datatype::Varchar[1]  | format('VARCHAR(%d)', max([$MIN_CHAR_LENGTH, min([$v.size, $MAX_CHAR_LENGTH])])),
    c : meta::relational::metamodel::datatype::Char[1]     | format('CHAR(%d)', max([$MIN_CHAR_LENGTH, min([$c.size, $MAX_CHAR_LENGTH])])),  // H2 now pads characters to hit stated size
    //b : meta::relational::metamodel::datatype::Bit[1]      | 'TINYINT',  // allows comparisons to Booleans with new H2
    n : meta::relational::metamodel::datatype::Numeric[1]  | format('NUMERIC(%d, %d)', [max([$n.precision, $MIN_PRECISION]), $n.scale]),
    d : meta::relational::metamodel::datatype::DataType[1] | getColumnTypeSqlTextDefault($d)
  ]);
}

// words found in ParserUtil.KEYWORDS of h2database EXCEPT for anything listed explicitly as NON_KEYWORD for compatibility
function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::h2ReservedWords():String[*]
{
   [
      'all','and','array','as','between','case','check','constraint','cross','current_catalog',
      'current_date','current_schema','current_time','current_timestamp','current_user','distinct',
      'except','exists','false','fetch','for','foreign','from','full','group','having','if','in',
      'inner','intersect','interval','is','join','left','like','limit','localtime','localtimestamp',
      'minus','natural','not','null','offset','on','or','order','primary','qualify','row','rownum',
      'select','table','true','union','unique','unknown','using','values','where','window','with',
      '_rowid_','both','groups','ilike','leading','over','partition','range','regexp','rows','top',
      'trailing'
   ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::getDynaFunctionToSqlForH2(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='dateadd(%s)', transform={p:String[3] | $p->at(2)->mapToDBUnitType() + ', ' + $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('booland',                $allStates,            ^ToSql(format='every(%s)')),
    dynaFnToSql('boolor',                 $allStates,            ^ToSql(format='any(%s)')),        
    dynaFnToSql('char',                   $allStates,            ^ToSql(format='char(%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='concat%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('convertDate',            $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDateH2()})),
    dynaFnToSql('castBoolean',            $allStates,            ^ToSql(format='cast(%s as boolean)')),
    dynaFnToSql('convertDateTime',        $allStates,            ^ToSql(format='%s' , transform={p:String[*] | $p->convertToDateTimeH2()})),
    dynaFnToSql('convertVarchar128',      $allStates,            ^ToSql(format='convert(%s, VARCHAR(128))')),
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='datediff(%s,%s,%s)', transform={p:String[*]|[$p->at(2)->replace('\'', '')->processDateDiffDurationUnitForH2(),$p->at(0),$p->at(1)]})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='cast(truncate(%s) as date)')),
    dynaFnToSql('dayOfMonth',             $allStates,            ^ToSql(format='DAY_OF_MONTH(%s)')),
    dynaFnToSql('dayOfWeek',              $allStates,            ^ToSql(format='dayname(%s)')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='%s',transform={p:String[1..2]| if($p->size()==1,| 'DAY_OF_WEEK('+$p->at(0)+')',|$p->dayOfWeekNumberH2());})),
    dynaFnToSql('dayOfYear',              $allStates,            ^ToSql(format='DAY_OF_YEAR(%s)')),
    dynaFnToSql('decodeBase64',           $allStates,            ^ToSql(format='legend_h2_extension_base64_decode(%s)')),
    dynaFnToSql('encodeBase64',           $allStates,            ^ToSql(format='legend_h2_extension_base64_encode(%s)')),
    dynaFnToSql('extractFromSemiStructured', $allStates,         ^ToSql(format='%s', transform={p:String[3]|$p->processExtractFromSemiStructuredParamsForH2()})),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='dateadd(DAY, -(dayofmonth(%s) - 1), %s)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='dateadd(MONTH, 3 * quarter(%s) - 3, dateadd(DAY, -(dayofyear(%s) - 1), %s))', transform={p:String[1] | $p->repeat(3)})),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='dateadd(DAY, -(dayofmonth(current_date()) - 1), current_date())')),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='dateadd(MONTH, 3 * quarter(current_date) - 3, dateadd(DAY, -(dayofyear(current_date()) - 1), current_date()))')),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='dateadd(DAY, -(dayofyear(current_date()) - 1), current_date())')),
    dynaFnToSql('firstDayOfWeek',         $allStates,            ^ToSql(format='dateadd(DAY, -(mod(dayofweek(%s)+5, 7)), %s)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='dateadd(DAY, -(dayofyear(%s) - 1), %s)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstHourOfDay',         $allStates,            ^ToSql(format='date_trunc(\'day\', %s)')),
    dynaFnToSql('firstMillisecondOfSecond', $allStates,          ^ToSql(format='date_trunc(\'second\', %s)')),
    dynaFnToSql('firstMinuteOfHour',      $allStates,            ^ToSql(format='date_trunc(\'hour\', %s)')),
    dynaFnToSql('firstSecondOfMinute',    $allStates,            ^ToSql(format='date_trunc(\'minute\', %s)')),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='hour(%s)')),
    dynaFnToSql('indexOf',                $allStates,            ^ToSql(format='LOCATE(%s)', transform={p:String[2] | $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('isNumeric',              $allStates,            ^ToSql(format='(lower(%s) = upper(%s))')),
    dynaFnToSql('isAlphaNumeric',         $allStates,            ^ToSql(format=regexpPattern('%s'), transform={p:String[1]|$p->transformAlphaNumericParamsDefault()})),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='group_concat(%s separator %s)')),
    dynaFnToSql('left',                   $allStates,            ^ToSql(format='left(%s,%s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='char_length(%s)')),
    dynaFnToSql('matches',                $allStates,            ^ToSql(format=regexpPattern('%s'), transform={p:String[2]|$p->transformRegexpParams()})),
    dynaFnToSql('md5',                    $allStates,            ^ToSql(format='rawtohex(hash(\'MD5\', %s))')),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('monthName',              $allStates,            ^ToSql(format='monthname(%s)')),
    dynaFnToSql('mostRecentDayOfWeek',    $allStates,            ^ToSql(format='dateadd(DAY, case when %s - DAY_OF_WEEK(%s) > 0 then %s - DAY_OF_WEEK(%s) - 7 else %s - DAY_OF_WEEK(%s) end, %s)', transform={p:String[1..2] | $p->formatMostRecentH2('current_date()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='current_timestamp()')),
    dynaFnToSql('parseDate',              $allStates,            ^ToSql(format='cast(parsedatetime(%s,%s) as timestamp)')),
    dynaFnToSql('parseDecimal',           $allStates,            ^ToSql(format='cast(%s as decimal)')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('parseJson',              $allStates,            ^ToSql(format='legend_h2_extension_json_parse(%s)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='position(%s, %s)')),
    dynaFnToSql('previousDayOfWeek',      $allStates,            ^ToSql(format='dateadd(DAY, case when %s - DAY_OF_WEEK(%s) >= 0 then %s - DAY_OF_WEEK(%s) - 7 else %s - DAY_OF_WEEK(%s) end, %s)', transform={p:String[1..2] | $p->formatMostRecentH2('current_date()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('reverseString',          $allStates,            ^ToSql(format='legend_h2_extension_reverse_string(%s)')),
    dynaFnToSql('right',                  $allStates,            ^ToSql(format='right(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('sha1',                   $allStates,            ^ToSql(format='rawtohex(hash(\'SHA-1\', %s))')),
    dynaFnToSql('sha256',                 $allStates,            ^ToSql(format='rawtohex(hash(\'SHA-256\', %s))')),
    dynaFnToSql('splitPart',              $allStates,            ^ToSql(format='legend_h2_extension_split_part(%s, %s, %s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='current_date()')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar)')),
    dynaFnToSql('toDecimal',              $allStates,            ^ToSql(format='cast(%s as decimal)')),
    dynaFnToSql('toFloat',                $allStates,            ^ToSql(format='cast(%s as double precision)')),
    dynaFnToSql('toTimestamp',            $allStates,            ^ToSql(format='%s', transform={p:String[2] | $p->transformToTimestampH2()})),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='week(%s)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='year(%s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processUpsertSQLQueryForH2(upsertQuery: UpsertSQLQuery[1], sgc: SqlGenerationContext[1]): String[1]
{
  // Map of Column to Literals of VarPlaceHolder
  let keyValues = $upsertQuery.equalityStatements->keyValues()->sortBy(kv | $kv.first);
  let columnNames = $keyValues->map(kv | $kv.first)->joinStrings(', ');
  let literalValues = $keyValues->map(kv | meta::relational::functions::sqlQueryToString::processLiteralValue($kv.second.value, $sgc.dbConfig))->joinStrings(', ');

  'merge into ' + $upsertQuery.data.name + ' (' + $columnNames + ') values (' + $literalValues + ')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processJoinTreeNodeWithLateralJoinForH2(j:JoinTreeNode[1], dbConfig : DbConfig[1], format:Format[1], extensions:Extension[*]):String[1]
{
  // keeping consistent with snowflake
  assert(processOperation($j.join.operation, $dbConfig, $format->indent(), ^Config(), $extensions) == '1 = 1', | 'Filter in column projections is not supported. Use a Post Filter if filtering is necessary');

  assert($j.alias.relationalElement->instanceOf(SemiStructuredArrayFlatten), | 'Lateral join in H2 should be followed by flatten operation');

  let lhs = ^TableAliasColumn(column = ^Column(name = '__INPUT__', type = ^meta::relational::metamodel::datatype::SemiStructured()),alias = $j.alias);
  let rhs = $j.alias.relationalElement->cast(@SemiStructuredArrayFlatten).navigation->cast(@SemiStructuredObjectNavigation);
  let joinOperation = ^DynaFunction(name= 'equal', parameters = [$lhs, ^$rhs(returnType=String)]);

  ' ' + $format.separator() + 'left outer join '
  + $j.alias
        ->map(a|^$a(name = '"' + $a.name + '"'))
        ->toOne()->processOperation($dbConfig, $format->indent(), $extensions) + $format.separator()
        + ' ' + 'on (' + processOperation($joinOperation, $dbConfig, $format->indent(), ^Config(), $extensions) + ')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processExtractFromSemiStructuredParamsForH2(params:String[3]):String[1]
{
  let baseRelationalOp = $params->at(0);
  let pathNavigation = $params->at(1);
  let returnType = $params->at(2);

  let parsedPathNavigation = $pathNavigation->parseSemiStructuredPathNavigation();
  let relationalPropertyAccess = $parsedPathNavigation->fold({property,relational | $relational->semiStructuredPathAccessForH2($property)}, $baseRelationalOp);

  let castTo = if ($returnType->in(['CHAR', 'VARCHAR', 'STRING']), | 'varchar', |
  if ($returnType->in(['DATETIME', 'TIMESTAMP']), | 'timestamp', |
  if ($returnType == 'DATE', | 'date', |
  if ($returnType == 'BOOLEAN', | 'boolean', |
  if ($returnType == 'FLOAT', | 'float', |
  if ($returnType == 'INTEGER', | 'integer', |
  $returnType))))));

  format('cast(%s as %s)', [$relationalPropertyAccess, $castTo]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::semiStructuredPathAccessForH2(elementAccess: String[1], property: String[1]): String[1]
{
  if($property->isDigit(), | $elementAccess->semiStructuredArrayElementAccessForH2($property), | $elementAccess->semiStructuredPropertyAccessForH2($property->substring(1, $property->length()-1))); // remove double quotes
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::semiStructuredPropertyAccessForH2(elementAccess: String[1], property: String[1]): String[1]
{
  format('legend_h2_extension_json_navigate(%s, \'%s\', null)', [$elementAccess, $property]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::semiStructuredArrayElementAccessForH2(elementAccess: String[1], index: String[1]): String[1]
{
  format('legend_h2_extension_json_navigate(%s, null, %s)', [$elementAccess, $index]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processSemiStructuredElementForH2(s:RelationalOperationElement[1], sgc:SqlGenerationContext[1]): String[1]
{
   $s->match([
      o:SemiStructuredObjectNavigation[1] | $o->processSemiStructuredObjectNavigationForH2($sgc),
      a:SemiStructuredArrayFlatten[1] | $a->processSemiStructuredArrayFlattenForH2($sgc),
      a:SemiStructuredArrayFlattenOutput[1] | $a->processSemiStructuredArrayFlattenOutputForH2($sgc)
   ])
}

/*
* returns property accesses to extract the semi structured property starting from root
*/
function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::propertyAccessForSemiStructuredObjectNavigationH2(z:SemiStructuredObjectNavigation[1], sgc:SqlGenerationContext[1]): String[*]
{
  let elementAccess = $z->match([
    p: SemiStructuredPropertyAccess[1] |
        let propertyAccess = '"' + $p.property->cast(@Literal).value->cast(@String) + '"';
        if ($p.index->isNotEmpty(),
            | $propertyAccess->concatenate($p.index->toOne()->cast(@Literal).value->toString()),
            | $propertyAccess
        );,
    a: SemiStructuredArrayElementAccess[1] | $a.index->toOne()->cast(@Literal).value->toString()
  ]);
  $z.operand->match([
    s: SemiStructuredObjectNavigation[1] | $s->propertyAccessForSemiStructuredObjectNavigationH2($sgc),
    a: SemiStructuredArrayFlatten[1] | $a.navigation->cast(@SemiStructuredObjectNavigation)->propertyAccessForSemiStructuredObjectNavigationH2($sgc)->concatenate('"*"'),
    s: SemiStructuredArrayFlattenOutput[1] | let flattening = $s.tableAliasColumn.alias.relationalElement->cast(@SemiStructuredArrayFlatten);
                                             $flattening.navigation->cast(@SemiStructuredObjectNavigation)->propertyAccessForSemiStructuredObjectNavigationH2($sgc)->concatenate('"*"');,
    a: Any[1] | []
  ])->concatenate($elementAccess);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processSemiStructuredArrayFlattenForH2(s:SemiStructuredArrayFlatten[1], sgc:SqlGenerationContext[1]): String[1]
{
  let rootTableAndColumnName = $s->meta::relational::functions::pureToSqlQuery::findTableForColumnInAlias([]);

  let jsonPaths = $s.navigation->match([  // assumes input to ssaf is always sson
    s: SemiStructuredObjectNavigation[1] | $s->propertyAccessForSemiStructuredObjectNavigationH2($sgc)
  ]);

  let schema = $rootTableAndColumnName.first.schema.name;

  let processedNavigation = $s.navigation->processOperation($sgc);
  'legend_h2_extension_flatten_array(' + '\'' + $rootTableAndColumnName.first->processOperation($sgc) + '\',\'' + $rootTableAndColumnName.second->processColumnName($sgc.dbConfig) + '\',ARRAY[\'' + $jsonPaths->joinStrings('\',\'') + '\'])';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processSemiStructuredArrayFlattenOutputForH2(s:SemiStructuredArrayFlattenOutput[1], sgc:SqlGenerationContext[1]): String[1]
{
   let doubleQuote = if($sgc.config.useQuotesForTableAliasColumn == false, |'', |'"');
   let processedIdentifier = $sgc.dbConfig.identifierProcessor($doubleQuote + $s.tableAliasColumn.alias.name->toOne() + $doubleQuote);
   let elementAccess = $processedIdentifier + '.' + processColumnName('VALUE', $sgc.dbConfig);
   $elementAccess->castToReturnTypeForSemiStructuredData($s.returnType);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::castToReturnTypeForSemiStructuredData(elementAccess:String[1], returnType:Type[0..1]): String[1]
{
  if ($returnType == String, | 'cast(' + $elementAccess + ' as varchar)', |
  if ($returnType == Boolean, | 'cast(' + $elementAccess + ' as boolean)', |
  if ($returnType == Float, | 'cast(' + $elementAccess + ' as float)', |
  if ($returnType == Integer, | 'cast(' + $elementAccess + ' as integer)', |
  if ($returnType == StrictDate, | 'cast(' + $elementAccess + ' as date)', |
  if ($returnType->isNotEmpty() && $returnType->toOne()->_subTypeOf(Date), | 'cast(' + $elementAccess + ' as timestamp)', |
  if ($returnType->isNotEmpty() && $returnType->toOne()->instanceOf(Enumeration), | 'cast(' + $elementAccess + ' as varchar)', |
  $elementAccess)))))));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processSemiStructuredObjectNavigationForH2(s:SemiStructuredObjectNavigation[1], sgc:SqlGenerationContext[1]): String[1]
{
   // Use a user defined function for H2 (testing purpose)

   let processedOperand = $s.operand->processOperation($sgc);

   let udfName = 'legend_h2_extension_json_navigate';

   let elementAccess = $s->match([
      p: SemiStructuredPropertyAccess[1] |
         let propertyAccess = semiStructuredPropertyAccessForH2($processedOperand,  $p.property->cast(@Literal).value->cast(@String));
         if ($p.index->isNotEmpty(),
             | semiStructuredArrayElementAccessForH2($propertyAccess, $p.index->toOne()->cast(@Literal).value->toString()),
             | $propertyAccess
         );,

      a: SemiStructuredArrayElementAccess[1] | semiStructuredArrayElementAccessForH2($processedOperand, $a.index->cast(@Literal).value->toString())
   ]);

  $elementAccess->castToReturnTypeForSemiStructuredData($s.returnType);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processJoinStringsOperationForH2(js:JoinStrings[1], sgc:SqlGenerationContext[1]): String[1]
{
   processJoinStringsOperation($js, $sgc, {col, sep| 'group_concat(' + $col + if($sep == '\'\'', |'', |' separator ' + $sep) + ' )'},
    {strs, sep| $strs->joinStrings('concat(', if('\'\'' == $sep, |', ', |',' + $sep + ',') , ')')});
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::convertToDateH2(params:String[*]):String[1]
{

      assert( 2 - $params->size()  >= 0,'Incorrect number of parameters for convertDate: convertDate(column,[dateformat])');
      let dateFormat = if( $params->size() == 1,|'\'yyyy-MM-dd\'' ,| let normalizedFormat = $params->at(1)->normalizeH2DateFormat();
                                                                     assert(dateFormatsH2()->contains($normalizedFormat->replace('\'', '')), $normalizedFormat +' not supported ');
                                                                     $normalizedFormat;
                                                                     );
      // FIXME: we currently allow MMMyyyy as a dateformat which requires the following hack similar to IQ
      if($dateFormat == '\'MMMyyyy\'',
      | 'cast( parseDateTime(concat(\'01\', %s), \'%s\') as date)'->format([
          $params->at(0),
          joinStrings(['dd', $dateFormat->replace('\'', '')])
        ]),
      | 'cast( parseDateTime('+$params->at(0)+','+$dateFormat +') as date)'
      );

}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::normalizeH2DateFormat(params:String[1]):String[1]
{
   [
    pair('YYYY', 'yyyy'),
    pair('DD', 'dd')
   ]->fold({e, a| $a->replace($e.first,$e.second)}, $params);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::dateFormatsH2():String[*]
{
   ['yyyy-MM-dd', 'MMMyyyy', 'yyyyMMdd'];
}

// Overrides convertToDateTime acceptable formats
function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::convertToDateTimeH2(params:String[*]):String[1]
{
   $params->convertDateTimeFunctionHasCorrectParamsH2();

   let dateTimeFormat = if( $params->size() == 1,
     |'\'yyyy-MM-dd HH:mm:ss[.SSSSSSSSS][.SSSSSSSS][.SSSSSSS][.SSSSSS][.SSSSS][.SSSS][.SSS][.SS][.S]\'',
     | $params->at(1)
   );
   'parseDateTime('+$params->at(0)+','+$dateTimeFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::convertDateTimeFunctionHasCorrectParamsH2(params:String[*]):Boolean[1]
{
   assert( 2 - $params->size()  >= 0,'Incorrect number of parameters for convertDateTime: convertDateTime(column,[dateTimeformat])');

   let supportedDateTimeFormat = if($params->size() == 2,
     | let userFormat = $params->at(1);
       dateTimeFormatsH2()->get($userFormat->normalizeH2DateTimeFormat()->replace('\'', ''));,
     | []
   );
   assert($params->size() ==1 || $supportedDateTimeFormat->size() == 1 , | $params->at(1) +' not supported ');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::normalizeH2DateTimeFormat(userFormat: String[1]): String[1]
{
  $userFormat->normalizeH2DateFormat()->normalizeH2TimeFormat()
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::normalizeH2TimeFormat(userFormat: String[1]): String[1]
{
  [pair('hh', 'HH')]->fold({e, a| $a->replace($e.first,$e.second)}, $userFormat)
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::dateTimeFormatsH2():Map<String,Integer>[1]
{
   newMap([
     pair('yyyy-MM-dd HH:mm:ss',120),  // no decimal use-case compatibility
     pair('yyyy-MM-dd HH:mm:ss[.SSSSSSSSS][.SSSSSSSS][.SSSSSSS][.SSSSSS][.SSSSS][.SSSS][.SSS][.SS][.S]',121)
   ]);
}

// FIXME: Are datetime and timestamp not treated the same in the backend (because parsedatetime always returns TIMESTAMP_WITH_TIMEZONE)?
// If so, this and the above logic (convertToDateTimeH2) should be identical
function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::transformToTimestampH2(params:String[2]):String[1]
{
  // Standardizing the format as per Postgres specification, will include mappings for the formats in future.
   assert($params->at(1)->replace('\'', '') == 'YYYY-MM-DD HH24:MI:SS', | $params->at(1) +' not supported ');
   let timestampFormat = '\'yyyy-MM-dd HH:mm:ss[.SSSSSSSSS][.SSSSSSSS][.SSSSSSS][.SSSSSS][.SSSSS][.SSSS][.SSS][.SS][.S]\'';
   'cast(parsedatetime('+$params->at(0)+','+ $timestampFormat+') as timestamp)';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processDateDiffDurationUnitForH2(durationUnit:String[1]):String[1]
{
   let durationEnumNames = [DurationUnit.YEARS,DurationUnit.MONTHS,DurationUnit.WEEKS,DurationUnit.DAYS,DurationUnit.HOURS,DurationUnit.MINUTES,DurationUnit.SECONDS,DurationUnit.MILLISECONDS]->map(e|$e->toString());
   let durationDbNames = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
   $durationEnumNames->zip($durationDbNames)->filter(h | $h.first == $durationUnit).second->toOne();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::formatMostRecentH2(p:String[1..2], defaultDay:String[1]):String[*]
{
   let day = $p->last()->toOne()->mapToDBDayOfWeekNumber()->toString();
   let current = if ($p->size() == 2, | $p->first()->toOne(), | $defaultDay);
   [$day, $current, $day, $current, $day, $current, $current];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::dayOfWeekNumberH2(dayOfWeek: String[*]):String[1]
{
   assert(or($dayOfWeek->at(1)=='Sunday',$dayOfWeek->at(1)=='Monday'),'DayOfWeekNumber Function requires either Sunday or Monday as First Day of Week');
   if($dayOfWeek->at(1)=='Sunday',|'DAY_OF_WEEK('+$dayOfWeek->at(0)+')',|'ISO_DAY_OF_WEEK('+$dayOfWeek->at(0)+')');
}

// Need to override how limit is processed
function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processSelectSQLQueryForH2(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForH2($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processSelectSQLQueryForH2(
  s:SelectSQLQuery[1],
  dbConfig : DbConfig[1],
  format:Format[1],
  config:Config[1],
  isSubSelect : Boolean[1],
  extensions:Extension[*]
): String[1]
{
  if($s.data.childrenData->match([jtn:JoinTreeNode[1]|$jtn.joinType == JoinType.FULL_OUTER, a:Any[*]|false]) ,
    |
        // H2 doesn't support FULL_OUTER join, so we need to convert/emulate it so people can write unit tests...
        $s->meta::relational::functions::sqlQueryToString::default::convertFullOuterJoinToLeftRightOuter()->processOperation($dbConfig, $format->indent(), $extensions);
    ,
    |
      let opStr =
        if($s.filteringOperation->isEmpty(),
          | '',
          | $s.filteringOperation->map(s | $s->wrapH2Boolean($extensions)->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> ')
      );
      let havingStr =
        if($s.havingOperation->isEmpty(),
          | '',
          | $s.havingOperation->map(s|$s->wrapH2Boolean($extensions)->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> ')
      );

      $format.separator + 'select ' + processTop($s, $format, $dbConfig, $extensions) + if($s.distinct == true,|'distinct ',|'') +
      processSelectColumnsH2($s.columns, $dbConfig, $format->indent(), true, $extensions) +
      if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNodeH2([], $dbConfig, $format->indent(), [], $extensions)) +
      if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
      if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), true, $extensions)->makeString(','))+
      if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
      if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
      + processLimit($s, $dbConfig, $format,  $extensions, [], processSliceOrDropForH2_SelectSQLQuery_1__Format_1__DbConfig_1__Extension_MANY__Any_1__String_1_);
    );
}

/*
* ifs in column creation gets translated to cases and so should also be candidates for wrapping
*/
function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processSelectColumnsH2(
  s: RelationalOperationElement[*],
  dbConfig: DbConfig[1],
  format: Format[1],
  conditionalExprAllowed: Boolean[1],
  extensions: Extension[*]
): String[1]
{
  if($s->size() == 0,
    |'*',
    | $format.separator + $s->map(r| $r->match([
        a: Alias[1] |
          let shouldWrapWithCase = $a.relationalElement->isBooleanOperation($extensions) && !$conditionalExprAllowed;
          if($shouldWrapWithCase,
            | 'case when ('
              + $a.relationalElement->wrapH2Boolean($extensions)->processOperation($dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Select, withinWhenClause = true), $extensions)
              + ') then \'true\' else \'false\' end as ' + $a.name,
            | $r->wrapH2Boolean($extensions)->processOperation($dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Select, withinWhenClause = false), $extensions)
          );,

        z: RelationalOperationElement[1] | $z->wrapH2Boolean($extensions)->processOperation($dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Select, withinWhenClause = false), $extensions)
      ]))->joinStrings(', ' + $format.separator);
  );
}

/*
TODO:
- what to do with freemarker placeholder operations? They are also RelationalOpElements
*/
// To be used to wrap filter conditions and their arguments to compare boolean to boolean
function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::wrapH2Boolean(
  op: RelationalOperationElement[1], extensions: Extension[*]
): RelationalOperationElement[1]
{
  // Base case: at an equals sign whose children are case and a booleanExpr OR we are a solitary case node
  // Tail recurse: if we are at oneOf ['and', 'or', 'not', 'group'] or a optional placeholder, then recurse left and right
  $op->match([
    d: DynaFunction[1]                | if(isCastableDyna($d),
                                          | ^DynaFunction(name='castBoolean', parameters=[$d]),
                                          | if(isEqualComparingCastableDynaAndBoolean($d),
                                              | ^$d(parameters=$d.parameters->map(p| ^DynaFunction(name='castBoolean', parameters=[$p]))),
                                              | if(atRecursibleOperation($d),
                                                  | ^$d(parameters=$d.parameters->map(p| $p->wrapH2Boolean($extensions))),
                                                  | $d
                                                )
                                            )
                                        ),
    // Casting alias is required for wrapping logic within projections
    a: Alias[1]                       | ^$a(relationalElement = wrapH2Boolean($a.relationalElement, $extensions)),
    f: FreeMarkerOperationHolder[1]   | if($f.name->in(['optionalVarPlaceHolderOpSelector']),
                                          | ^$f(parameters=$f.parameters->map(p| $p->wrapH2Boolean($extensions))),
                                          | $f
                                        ),
    e: RelationalOperationElement[1]  | $e
  ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::isEqualComparingCastableDynaAndBoolean(
  d: DynaFunction[1]
): Boolean[1]
{
  $d.name == 'equal' && $d.parameters->at(0)->isCastableDyna() && $d.parameters->at(1)->isBooleanExpr();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::isCastableDyna(
  op: RelationalOperationElement[1]
): Boolean[1]
{
  // if and case both get converted to case in SQL
  $op->instanceOf(DynaFunction) &&
    (cast($op, @DynaFunction).name->in(['case', 'if']))
    && cast($op, @DynaFunction).parameters->slice(1,3)->filter(x| $x->isTrueFalseString())->isNotEmpty()
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::isTrueFalseString(
  op: RelationalOperationElement[1]
): Boolean[1]
{
  $op->instanceOf(Literal) && cast($op, @Literal).value->match([
    s: String[1] | $s->toLower()->in(['false','true']),
    o: Any[1]    | false
  ])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::atRecursibleOperation(
  op: DynaFunction[1]
): Boolean[1]
{
  $op.name->in(['and', 'or', 'not', 'group', 'if'])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::isBooleanExpr(op: RelationalOperationElement[1]): Boolean[1]
{
  $op->instanceOf(Literal) && cast($op, @Literal).value->match([
    b: Boolean[1]        | true,
    v: VarPlaceHolder[1] | $v.type == Boolean,
    a: Any[1]            | false
  ])
}

// Required so that any join conditions also have correct wrapping
function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processJoinTreeNodeH2(
  joinTreeNode:RelationalTreeNode[1],
  parent:TableAlias[0..1],
  dbConfig : DbConfig[1],
  format:Format[1],
  joinOrder:JoinType[*],
  extensions:Extension[*]
):String[1]
{
   let tableAlias = $joinTreeNode->match(
                                    [
                                       r:RootJoinTreeNode[1] | $r.alias,
                                       j:JoinTreeNode[1] | $j.join->otherTableFromAlias($parent->toOne());
                                    ]
                                    );

   let val = $joinTreeNode->match(
                                    [
                                       r:RootJoinTreeNode[1] |
                                             $tableAlias->toOne()
                                                ->map(a|^$a(name = '"' + $a.name + '"')) //Not sure why this is necessary, but it's retained to keep the generated SQL the same as previously (and does no real harm)
                                                ->processOperation($dbConfig, $format->indent(), $extensions),
                                       j:JoinTreeNode[1] |
                                          if($j.joinType == JoinType.FULL_OUTER,
                                            |
                                                // This should have been converted earlier to avoid a FULL_OUTER reaching this point
                                                fail($j.joinType->toOne()->toString() + ' join not supported in H2'); '';
                                            ,
                                            |
                                           if($j.lateral == true,
                                            | $dbConfig.lateralJoinProcessor($j, $dbConfig, $format, $extensions),
                                            |
                                              $j.joinType->map(jt|$jt->meta::relational::functions::sqlQueryToString::default::processJoinType($dbConfig, $format, $extensions))->orElse('')
                                                + $j.alias
                                                    ->map(a|^$a(name = '"' + $a.name + '"')) //Not sure why this is necessary, but it's retained to keep the generated SQL the same as previously (and does no real harm)
                                                    ->toOne()->processOperation($dbConfig, $format->indent(), $extensions) + $format.separator()
                                                + ' ' + 'on (' + $j.join.operation->wrapH2Boolean($extensions)->processOperation($dbConfig, $format->indent(), ^Config(), $extensions) + ')';
                                            )),
                                       a:Any[1] | ''
                                    ]
                                    );
   let children = if($joinOrder->isNotEmpty(),
                     |$joinTreeNode->children()->sortBy({node | if($node.joinType->isEmpty(), |2, |$joinOrder->indexOf($node.joinType->toOne()))}),
                     |$joinTreeNode->children());
   $children->map(child | processJoinTreeNodeH2($child, $tableAlias->cast(@TableAlias), $dbConfig, $format, $joinOrder, $extensions))->joinStrings($val, '', '');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::processSliceOrDropForH2(s:SelectSQLQuery[1], format:Format[1], dbConfig: DbConfig[1], extensions:Extension[*], size:Any[1]):String[1]
{
   '%s offset %s rows'->format([$format.separator, $s.fromRow->toOne()->getValueForTake($format, $dbConfig, $extensions)]) + if ($size == -1, | '', | ' fetch next %s rows only'->format($size));
}


/* Test:
  "root".RG_FUNCTION_ID = 2
  and ((case when "root".MEMBERSHIP_SOURCE = 'CUSTOM' then 'true' else 'false' end = true and
        case when "root".IS_CATCH_ALL_GROUP = 1 then 'true' else 'false' end = false) and "root".STATUS = 'A')
  and "root".IN_Z <= DATE '8888-01-01'
  and "root".OUT_Z > DATE '8888-01-01'
*/

function <<test.Test>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::testSomeAST_thenIsWrapped(): Boolean[1]
{
  let inner = ^DynaFunction(name='group', parameters=[
    ^DynaFunction(name='and', parameters=[
      ^DynaFunction(name='group', parameters=[
        ^DynaFunction(name='and', parameters=[
          ^DynaFunction(name='equal', parameters=[
            ^DynaFunction(name='if', parameters=[
              ^DynaFunction(name='equal', parameters=[^Literal(value='CUSTOM'), ^Literal(value='CUSTOM')]),
              ^Literal(value='true'),
              ^Literal(value='false')
            ]),
            ^Literal(value=true)
          ]),
          ^DynaFunction(name='equal', parameters=[
            ^DynaFunction(name='if', parameters=[
              ^DynaFunction(name='equal', parameters=[^Literal(value=1), ^Literal(value=2)]),
              ^Literal(value='true'),
              ^Literal(value='false')
            ]),
            ^Literal(value=false)
          ])
        ])
      ]),
      ^DynaFunction(name='equal', parameters=[^Literal(value='A'), ^Literal(value='A')])
    ])
  ]);

  let op = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(name='and', parameters=[
      ^DynaFunction(name='and', parameters=[
        ^DynaFunction(name='equal', parameters=[^Literal(value=2), ^Literal(value=2)]),
        $inner
      ]),
      ^DynaFunction(name='lessThanEqual', parameters=[^Literal(value='8888-01-01'), ^Literal(value='8888-01-01')])
    ]),
    ^DynaFunction(name='greaterThan', parameters=[^Literal(value='8888-01-02'), ^Literal(value='8888-01-01')])
  ]);

  let castedInner = ^DynaFunction(name='group', parameters=[
    ^DynaFunction(name='and', parameters=[
      ^DynaFunction(name='group', parameters=[
        ^DynaFunction(name='and', parameters=[
          ^DynaFunction(name='equal', parameters=[
            ^DynaFunction(name='castBoolean', parameters=[
              ^DynaFunction(name='if', parameters=[
                ^DynaFunction(name='equal', parameters=[^Literal(value='CUSTOM'), ^Literal(value='CUSTOM')]),
                ^Literal(value='true'),
                ^Literal(value='false')
              ])
            ]),
            ^DynaFunction(name='castBoolean', parameters=[^Literal(value=true)])
          ]),
          ^DynaFunction(name='equal', parameters=[
            ^DynaFunction(name='castBoolean', parameters=[
              ^DynaFunction(name='if', parameters=[
                ^DynaFunction(name='equal', parameters=[^Literal(value=1), ^Literal(value=2)]),
                ^Literal(value='true'),
                ^Literal(value='false')
              ])
            ]),
            ^DynaFunction(name='castBoolean', parameters=[^Literal(value=false)])
          ])
        ])
      ]),
      ^DynaFunction(name='equal', parameters=[^Literal(value='A'), ^Literal(value='A')])
    ])
  ]);

  let expected = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(name='and', parameters=[
      ^DynaFunction(name='and', parameters=[
        ^DynaFunction(name='equal', parameters=[^Literal(value=2), ^Literal(value=2)]),
        $castedInner
      ]),
      ^DynaFunction(name='lessThanEqual', parameters=[^Literal(value='8888-01-01'), ^Literal(value='8888-01-01')])
    ]),
    ^DynaFunction(name='greaterThan', parameters=[^Literal(value='8888-01-02'), ^Literal(value='8888-01-01')])
  ]);

  let wrappedOp = wrapH2Boolean($op, []);
  print($wrappedOp);
  assertEquals($expected, $wrappedOp);
}

function <<test.Test>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::testWhenJustCase_thenIsWrapped(): Boolean[1]
{
  let op = ^DynaFunction(
    name='case',
    parameters=[
      ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
      ^Literal(value='true'),
      ^Literal(value='false')
    ]
  );

  let expected = ^DynaFunction(
    name= 'castBoolean',
    parameters=[
      ^DynaFunction(
        name='case',
        parameters=[
          ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
          ^Literal(value='true'),
          ^Literal(value='false')
        ]
      )
    ]
  );
  let wrappedOp = wrapH2Boolean($op, []);
  assertEquals($expected, $wrappedOp);
}

function <<test.Test>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::testWhenCaseNestedByAnd_thenIsWrapped(): Boolean[1]
{
  let op = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(
      name='case',
      parameters=[
        ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
        ^Literal(value='true'),
        ^Literal(value='false')
      ]
    ),
    ^DynaFunction(
      name='equal',
      parameters=[^Literal(value=1), ^Literal(value=1)]
    )
  ]);

  let expected = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(
      name= 'castBoolean',
      parameters=[
        ^DynaFunction(
          name='case',
          parameters=[
            ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
            ^Literal(value='true'),
            ^Literal(value='false')
          ]
        )
      ]
    ),
    ^DynaFunction(
      name='equal',
      parameters=[^Literal(value=1), ^Literal(value=1)]
    )
  ]);

  let wrappedOp = wrapH2Boolean($op, []);
  assertEquals($expected, $wrappedOp);
}

function <<test.Test>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::testWhenCaseEqualBooleanLit_thenBothWrapped(): Boolean[1]
{
  let op = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name='case',
          parameters=[
            ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
            ^Literal(value='true'),
            ^Literal(value='false')
          ]
        ),
        ^Literal(value=true)
      ]
    ),
    ^DynaFunction(
      name='equal',
      parameters=[^Literal(value=1), ^Literal(value=1)]
    )
  ]);

  let expected = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name= 'castBoolean',
          parameters=[
            ^DynaFunction(
              name='case',
              parameters=[
                ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
                ^Literal(value='true'),
                ^Literal(value='false')
              ]
            )
          ]
        ),
        ^DynaFunction(name= 'castBoolean', parameters=[^Literal(value=true)])
      ]
    ),
    ^DynaFunction(name='equal', parameters=[^Literal(value=1), ^Literal(value=1)])
  ]);

  let wrappedOp = wrapH2Boolean($op, []);
  assertEquals($expected, $wrappedOp);
}

function <<test.Test>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::testWhenCaseEqualTrue_thenNoOp(): Boolean[1]
{
  let op = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name='case',
          parameters=[
            ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
            ^Literal(value='true'),
            ^Literal(value='false')
          ]
        ),
        ^Literal(value='true')
      ]
    ),
    ^DynaFunction(
      name='equal',
      parameters=[^Literal(value=1), ^Literal(value=1)]
    )
  ]);

  let expected = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name='case',
          parameters=[
            ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
            ^Literal(value='true'),
            ^Literal(value='false')
          ]
        ),
        ^Literal(value='true')
      ]
    ),
    ^DynaFunction(
      name='equal',
      parameters=[^Literal(value=1), ^Literal(value=1)]
    )
  ]);

  let wrappedOp = wrapH2Boolean($op, []);
  assertEquals($expected, $wrappedOp);
}

function <<test.Test>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::testWhenCaseEqualYesNoLit_thenNoOp(): Boolean[1]
{
  let op = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name='case',
          parameters=[
            ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
            ^Literal(value='true'),
            ^Literal(value='false')
          ]
        ),
        ^Literal(value='Y')
      ]
    ),
    ^DynaFunction(
      name='equal',
      parameters=[^Literal(value=1), ^Literal(value=1)]
    )
  ]);

  let expected = ^DynaFunction(name='and', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name='case',
          parameters=[
            ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
            ^Literal(value='true'),
            ^Literal(value='false')
          ]
        ),
        ^Literal(value='Y')
      ]
    ),
    ^DynaFunction(
      name='equal',
      parameters=[^Literal(value=1), ^Literal(value=1)]
    )
  ]);

  let wrappedOp = wrapH2Boolean($op, []);
  assertEquals($expected, $wrappedOp);
}

function <<test.Test>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::testWhenCaseNestedByNot_thenIsWrapped(): Boolean[1]
{
  let op = ^DynaFunction(name='not', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name='case',
          parameters=[
            ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
            ^Literal(value='true'),
            ^Literal(value='false')
          ]
        ),
        ^Literal(value=true)
      ]
    )
  ]);

  let expected = ^DynaFunction(name='not', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name='castBoolean',
          parameters=[
            ^DynaFunction(
              name='case',
              parameters=[
                ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
                ^Literal(value='true'),
                ^Literal(value='false')
              ]
            )
          ]
        ),
        ^DynaFunction(name= 'castBoolean', parameters=[^Literal(value=true)])
      ]
    )
  ]);

  let wrappedOp = wrapH2Boolean($op, []);
  assertEquals($expected, $wrappedOp);
}

function <<test.Test>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::testWhenCaseNestedByOr_thenIsWrapped(): Boolean[1]
{
  let op = ^DynaFunction(name='or', parameters=[
    ^DynaFunction(
      name='case',
      parameters=[
        ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
        ^Literal(value='true'),
        ^Literal(value='false')
      ]
    ),
    ^DynaFunction(
      name='equal',
      parameters=[^Literal(value=1), ^Literal(value=1)]
    )
  ]);

  let expected = ^DynaFunction(name='or', parameters=[
    ^DynaFunction(
      name= 'castBoolean',
      parameters=[
        ^DynaFunction(
          name='case',
          parameters=[
            ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
            ^Literal(value='true'),
            ^Literal(value='false')
          ]
        )
      ]
    ),
    ^DynaFunction(
      name='equal',
      parameters=[^Literal(value=1), ^Literal(value=1)]
    )
  ]);

  let wrappedOp = wrapH2Boolean($op, []);
  assertEquals($expected, $wrappedOp);
}

function <<test.Test>> meta::relational::functions::sqlQueryToString::h2::v2_1_214::testWhenCaseNestedByGroup_thenIsWrapped(): Boolean[1]
{
  let op = ^DynaFunction(name='group', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name='case',
          parameters=[
            ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
            ^Literal(value='true'),
            ^Literal(value='false')
          ]
        ),
        ^Literal(value=true)
      ]
    )
  ]);

  let expected = ^DynaFunction(name='group', parameters=[
    ^DynaFunction(
      name='equal',
      parameters=[
        ^DynaFunction(
          name='castBoolean',
          parameters=[
            ^DynaFunction(
              name='case',
              parameters=[
                ^DynaFunction(name='equal', parameters=[^Literal(value='Y'), ^Literal(value='Y')]),
                ^Literal(value='true'),
                ^Literal(value='false')
              ]
            )
          ]
        ),
        ^DynaFunction(name='castBoolean', parameters=[^Literal(value=true)])
      ]
    )
  ]);

  let wrappedOp = wrapH2Boolean($op, []);
  assertEquals($expected, $wrappedOp);
}
