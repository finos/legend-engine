###Pure
import meta::pure::mapping::*;
import meta::pure::milestoning::*;
import meta::pure::graphFetch::tests::m2m2r::milestoning::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::alloy::connections::alloy::specification::*;
import meta::pure::alloy::connections::alloy::authentication::*;
import meta::relational::runtime::*;
import meta::pure::runtime::*;

function <<test.Test, test.AlloyOnly>> meta::pure::graphFetch::tests::m2m2r::milestoning::toMilestonedTargetProperty::testToMilestonedTargetProperty_hardcodedDate():Boolean[1]
{
  let mapping =meta::relational::tests::m2m2r::milestoning::toMilestonedTargetProperty::TargetToModelMappingWithMilestonedComplexProperty;
  let runtime=  getModelChainRuntime($mapping);

   let query={|meta::relational::tests::milestoning::TargetProduct1.all(%2023-10-15T00:00:00)->graphFetch(
      #{
        meta::relational::tests::milestoning::TargetProduct1{
          id,
          name,
          synonyms(%2020-10-15T00:00:00)
          {synonym}
        }
      }#
    )->serialize(
      #{
        meta::relational::tests::milestoning::TargetProduct1{
          id,
          name,
          synonyms(%2020-10-15T00:00:00)
          {synonym}
        }
      }#
    )
    ->meta::pure::mapping::from($mapping,$runtime)
    };
   let result = meta::legend::executeLegendQuery($query, [], ^meta::pure::runtime::ExecutionContext(), meta::relational::extension::relationalExtensions());
   assertJsonStringsEqual('{"builder":{"_type":"json"},"values":[{"id":2,"name":"ProductName2","synonyms(2020-10-15T00:00:00+0000)":[{"synonym":"GS-Mod-S1"},{"synonym":"GS-Mod-S3"}]},{"id":3,"name":"ProductName3","synonyms(2020-10-15T00:00:00+0000)":[{"synonym":"GS-Mod-S3"}]}]}', $result);
}

function <<test.Test, test.AlloyOnly, test.ToFix>>  meta::pure::graphFetch::tests::m2m2r::milestoning::toMilestonedTargetProperty::testToMilestonedTargetProperty_variableDate():Boolean[1]
{
  let mapping =meta::relational::tests::m2m2r::milestoning::toMilestonedTargetProperty::TargetToModelMappingWithMilestonedComplexProperty;
  let runtime=  getModelChainRuntime($mapping);

   let query={bdate:DateTime[1]|meta::relational::tests::milestoning::TargetProduct1.all($bdate)->graphFetch(
      #{
        meta::relational::tests::milestoning::TargetProduct1{
          id,
          name,
          synonyms($bdate)
          {synonym}
        }
      }#
    )->serialize(
      #{
        meta::relational::tests::milestoning::TargetProduct1{
          id,
          name,
          synonyms($bdate)
          {synonym}
        }
      }#
    )
    ->meta::pure::mapping::from($mapping,$runtime)
    };
   let result = meta::legend::executeLegendQuery($query,  [pair('bdate', '2023-10-15T00:00:00')], ^meta::pure::runtime::ExecutionContext(), meta::relational::extension::relationalExtensions());
   assertJsonStringsEqual('{"builder":{"_type":"json"},"values":[{"id":2,"name":"ProductName2","synonyms($bdate)":[{"synonym":"GS-Mod-S1"},{"synonym":"GS-Mod-S3"}]},{"id":3,"name":"ProductName3","synonyms($bdate)":[{"synonym":"GS-Mod-S3"}]}]}', $result);
}

function <<test.Test, test.AlloyOnly>> meta::pure::graphFetch::tests::m2m2r::milestoning::toNonMilestonedTargetProperty::testToNonMilestonedTargetProperty_AsNoArg():Boolean[1]
{
  let mapping=meta::pure::graphFetch::tests::m2m2r::milestoning::toNonMilestonedTargetProperty::getNoArgMapping();  
  let runtime=  getModelChainRuntime($mapping);

   let query={bdate:DateTime[1]|meta::relational::tests::milestoning::TargetProductFlattened.all($bdate)->graphFetch(
      #{
        meta::relational::tests::milestoning::TargetProductFlattened{
          id,
          name,
          synonymNames
        }
      }#
    )->serialize(
      #{
        meta::relational::tests::milestoning::TargetProductFlattened{
          id,
          name,
          synonymNames
        }
      }#
    )
    ->meta::pure::mapping::from($mapping,$runtime)
    };
   let result = meta::legend::executeLegendQuery($query,  [pair('bdate', '2023-10-15T00:00:00')], ^meta::pure::runtime::ExecutionContext(), meta::relational::extension::relationalExtensions());
   assertJsonStringsEqual('{"builder":{"_type":"json"},"values":[{"id":2,"name":"ProductName2","synonymNames":["GS-Mod-S1","GS-Mod-S3"]},{"id":3,"name":"ProductName3","synonymNames":["GS-Mod-S3"]}]}', $result);
}

//milestoned property without args is not supported by pure ide compiler but works with engine
function meta::pure::graphFetch::tests::m2m2r::milestoning::toNonMilestonedTargetProperty::getNoArgMapping():meta::pure::mapping::Mapping[1]
{
  let mappingStr =  '###Mapping\n' +
                    'Mapping meta::relational::tests::m2m2r::milestoning::toNonMilestonedTargetProperty::TargetToModelMappingWithMilestonedComplexPropertyFlattened_WithNoArg\n'+
                    '(\n'+
                    '  *meta::relational::tests::milestoning::TargetProductFlattened: Pure\n'+
                    '  {\n'+
                    '    ~src meta::relational::tests::milestoning::Product\n'+
                    '    id: $src.id,\n'+
                    '    name: $src.name,\n'+
                    '    synonymNames:$src.synonyms.synonym\n'+
                    '  }\n' + 
                    ')';

let mapping = meta::legend::compileLegendGrammar($mappingStr)->at(0)->cast(@Mapping);

let newMapping = ^$mapping(includes = ^MappingInclude(included=meta::relational::tests::milestoning::milestoningmap,                    // fix legend compile to allow mapping reference in include
                                                      owner = $mapping)
                          );
}

function <<test.Test, test.AlloyOnly>> meta::pure::graphFetch::tests::m2m2r::milestoning::toNonMilestonedTargetProperty::testToNonMilestonedTargetProperty_AllVersions():Boolean[1]
{
  let mapping =meta::relational::tests::m2m2r::milestoning::toNonMilestonedTargetProperty::TargetToModelMappingWithMilestonedComplexPropertyFlattened_AllVersions;
  let runtime=  getModelChainRuntime($mapping);

   let query={bdate:DateTime[1]|meta::relational::tests::milestoning::TargetProductFlattened.all($bdate)->graphFetch(
      #{
        meta::relational::tests::milestoning::TargetProductFlattened{
          id,
          name,
          synonymNames
        }
      }#
    )->serialize(
      #{
        meta::relational::tests::milestoning::TargetProductFlattened{
          id,
          name,
          synonymNames
        }
      }#
    )
    ->meta::pure::mapping::from($mapping,$runtime)
    };
   let result = meta::legend::executeLegendQuery($query, [pair('bdate', '2023-10-15T00:00:00')], ^meta::pure::runtime::ExecutionContext(), meta::relational::extension::relationalExtensions());
   assertJsonStringsEqual('{"builder":{"_type":"json"},"values":[{"id":2,"name":"ProductName2","synonymNames":["GS-Mod-S0","GS-Mod-S1","GS-Mod-S2","GS-Mod-S3"]},{"id":3,"name":"ProductName3","synonymNames":["GS-Mod-S2","GS-Mod-S3"]}]}', $result);
}

function meta::pure::graphFetch::tests::m2m2r::milestoning::getModelChainRuntime(m2m:meta::pure::mapping::Mapping[1]):Runtime[1]
{
 ^meta::pure::runtime::Runtime(
      connections=[
        meta::pure::graphFetch::tests::milestoning::getAlloyTestH2Connection(),
        ^meta::pure::mapping::modelToModel::ModelChainConnection(element = ^meta::pure::mapping::modelToModel::ModelStore(), mappings = [$m2m])
      ]
  );
}

Class <<temporal.businesstemporal>> meta::relational::tests::milestoning::TargetProduct1
{
  id: Integer[1];
  name: String[1];
  type: String[1];
  synonyms: meta::relational::tests::milestoning::TargetProductSynonym[*];
}


Class <<temporal.businesstemporal>> meta::relational::tests::milestoning::TargetProductSynonym
{
  synonym: String[1];
}

Class <<temporal.businesstemporal>> meta::relational::tests::milestoning::TargetProductFlattened
{
  id: Integer[1];
  name: String[1];
  type: String[1];
  synonymNames: String[*];
}

###Mapping
Mapping meta::relational::tests::m2m2r::milestoning::toMilestonedTargetProperty::TargetToModelMappingWithMilestonedComplexProperty
(
  include meta::relational::tests::milestoning::milestoningmap

  *meta::relational::tests::milestoning::TargetProduct1: Pure
  {
    ~src meta::relational::tests::milestoning::Product
    id: $src.id,
    name: $src.name,
    synonymsAllVersions: $src.synonymsAllVersions
  }
  
  *meta::relational::tests::milestoning::TargetProductSynonym: Pure
  {
    ~src meta::relational::tests::milestoning::ProductSynonym
    synonym: $src.synonym
  }
)

Mapping meta::relational::tests::m2m2r::milestoning::toNonMilestonedTargetProperty::TargetToModelMappingWithMilestonedComplexPropertyFlattened_AllVersions
(
  include meta::relational::tests::milestoning::milestoningmap

  *meta::relational::tests::milestoning::TargetProductFlattened: Pure
  {
    ~src meta::relational::tests::milestoning::Product
    id: $src.id,
    name: $src.name,
    synonymNames:$src.synonymsAllVersions.synonym
  }
)
