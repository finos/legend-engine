// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::boolean::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numeric::*;
import meta::external::query::sql::metamodel::*;
import meta::external::store::relational::sqlDialectTranslation::*;
import meta::external::store::relational::sqlDialectTranslation::defaults::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::*;
import meta::external::store::relational::sqlDialectTranslation::postgres::*;
import meta::external::store::relational::sqlDialectTranslation::sqlTyping::typeInference::*;
import meta::external::store::relational::sqlDialectTranslation::utils::*;
import meta::pure::extension::*;

function meta::external::store::relational::sqlDialectTranslation::postgres::postgresSqlDialect(): SqlDialect[1]
{
  ^SqlDialect
  (
    dbType = 'Postgres',
    quoteConfig = doubleQuotesConfiguration_default(),
    nodeProcessors = postgresDialectNodeProcessors(),
    identifierProcessor = identifierProcessor_default(),
    expressionPrecedenceComparator = expressionPrecedenceComparator_default(),
    keywords = postgresKeywords(),
    functionProcessorDispatch = meta::external::store::relational::sqlDialectTranslation::postgres::functionProcessorMap_SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__Map_1_
  )
}

function meta::external::store::relational::sqlDialectTranslation::postgres::postgresSqlDialectExtension(): Extension[1]
{
  ^Extension
  (
    type = 'PostgresSqlDialectExtension',
    moduleExtensions = [
      ^SqlDialectTranslationModuleExtension
      (
        module = sqlDialectTranslationModuleExtensionName(),
        extraSqlDialects = postgresSqlDialect()
      )
    ]
  )
}

function meta::external::store::relational::sqlDialectTranslation::postgres::postgresFunctionTestsExpectedErrors(): Map<String, String>[1]
{
  [

  ]->newMap()->cast(@Map<String, String>)
}



function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresDialectNodeProcessors(): Map<Class<Node>, NodeProcessor<Node>>[1]
{
  newMap(
    dialectStatementProcessors_default()
    ->concatenate(
      dialectRelationProcessors_default()
    )
    ->concatenate(
      dialectExpressionProcessors_default()
    )
    ->concatenate(
      dialectLiteralProcessors_default()
    )
    ->concatenate(
      dialectSelectItemProcessors_default()
    )
    ->concatenate(
      dialectOtherNodeProcessors_default()
    )
    ->map(n | pair($n.nodeType, $n))
  )
}



function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresKeywords(): String[*]
{
  [
    'all', 
    'analyse', 
    'analyze', 
    'and', 
    'any', 
    'array', 
    'as', 
    'asc', 
    'asymmetric', 
    'authorization', 
    'binary', 
    'both', 
    'case', 
    'cast', 
    'check', 
    'collate', 
    'collation', 
    'column', 
    'concurrently', 
    'constraint', 
    'create', 
    'cross', 
    'current_catalog', 
    'current_date', 
    'current_role', 
    'current_schema', 
    'current_time', 
    'current_timestamp', 
    'current_user', 
    'default', 
    'deferrable', 
    'desc', 
    'distinct', 
    'do', 
    'else', 
    'end', 
    'except', 
    'false', 
    'fetch', 
    'for', 
    'foreign', 
    'freeze', 
    'from', 
    'full', 
    'grant', 
    'group', 
    'having', 
    'ilike', 
    'in', 
    'initially', 
    'inner', 
    'intersect', 
    'into', 
    'is', 
    'isnull', 
    'join', 
    'lateral', 
    'leading', 
    'left', 
    'like', 
    'limit', 
    'localtime', 
    'localtimestamp', 
    'natural', 
    'not', 
    'notnull', 
    'null', 
    'offset', 
    'on', 
    'only', 
    'or', 
    'order', 
    'outer', 
    'overlaps', 
    'placing', 
    'primary', 
    'references', 
    'returning', 
    'right', 
    'select', 
    'session_user', 
    'similar', 
    'some', 
    'symmetric', 
    'system_user', 
    'table', 
    'tablesample', 
    'then', 
    'to', 
    'trailing', 
    'true', 
    'union', 
    'unique', 
    'user', 
    'using', 
    'variadic', 
    'verbose', 
    'when', 
    'where', 
    'window', 
    'with'
  ];
}

// ---------------------------- Function processing -------------------------

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::functionProcessorMap(sqlDialect: SqlDialect[1], state: SqlDialectTranslationState[1], config: SqlDialectTranslationConfig[1]): Map<Class<SqlFunction>, FunctionProcessor>[1]
{
  newMap([
    // Numeric
    pair(Abs, simpleFunctionProcessor('abs')),
    pair(Cbrt, simpleFunctionProcessor('cbrt')),
    pair(Ceil, simpleFunctionProcessor('ceil')),
    pair(Ceiling, simpleFunctionProcessor('ceiling')),
    pair(Degrees, simpleFunctionProcessor('degrees')),
    pair(Exp, simpleFunctionProcessor('exp')),
    pair(Ln, simpleFunctionProcessor('ln')),
    pair(Log, simpleFunctionProcessor('log')),
    pair(Log10, argTransformFunctionProcessor('log10', 'log(10, %s)')),
    pair(Sqrt, simpleFunctionProcessor('sqrt')),
    pair(Acos, simpleFunctionProcessor('acos')),
    pair(Asin, simpleFunctionProcessor('asin')),
    pair(Atan, simpleFunctionProcessor('atan')),
    pair(Atan2, simpleFunctionProcessor('atan2')),
    pair(Cos, simpleFunctionProcessor('cos')),
    pair(Cot, simpleFunctionProcessor('cot')),
    pair(Sin, simpleFunctionProcessor('sin')),
    pair(Tan, simpleFunctionProcessor('tan')),
    pair(Power, simpleFunctionProcessor('power')),
    pair(Sign, argTransformFunctionProcessor('sign','cast(sign(%s) as int)')), //explicit casting was needed since postgres was returning decimal,which is non-standard
    pair(Mod, simpleFunctionProcessor('mod')),
    pair(Round, simpleFunctionProcessor('round')),
    pair(Greatest, simpleFunctionProcessor('greatest')),
    pair(Least, simpleFunctionProcessor('least')),


    // String
    pair(Lpad, simpleFunctionProcessor('lpad')),
    pair(Rpad, simpleFunctionProcessor('rpad')),
    pair(Ltrim, simpleFunctionProcessor('ltrim')),
    pair(Rtrim, simpleFunctionProcessor('rtrim')),
    pair(Ascii, simpleFunctionProcessor('ascii')),
    pair(Lower, simpleFunctionProcessor('lower')),
    pair(Upper, simpleFunctionProcessor('upper')),
    pair(Repeat, simpleFunctionProcessor('repeat')),
    pair(Replace, simpleFunctionProcessor('replace')),
    pair(Md5, simpleFunctionProcessor('md5')),
    pair(CharLength, simpleFunctionProcessor('char_length')),
    pair(Chr, simpleFunctionProcessor('chr')),
    pair(Left, simpleFunctionProcessor('left')),
    pair(Right, simpleFunctionProcessor('right')),
    pair(StrPos, simpleFunctionProcessor('strpos')),
    pair(Concat, simpleFunctionProcessor('concat')),
    pair(Coalesce, simpleFunctionProcessor('coalesce')),
    pair(Sha1, argTransformFunctionProcessor('sha1', 'encode(digest(%s, \'sha1\'), \'hex\')')),
    pair(Sha256, argTransformFunctionProcessor('sha256', 'encode(digest(%s, \'sha256\'), \'hex\')')),


    // Boolean
    pair(RegexpLike, argTransformFunctionProcessor('regexp_like', regexpPattern('~'), {p:String[*]|$p->transformRegexpParams()})),

    // Temporal
    pair(DateTrunc, simpleFunctionProcessor('date_trunc')),
    pair(DatePart, argTransformFunctionProcessor('date_part', 'cast(floor(date_part(%s, %s)) as integer)')), // Postgres returns double for some reason, also, date_part to second includes milliseconds, which is non-standard.
    pair(Now, simpleFunctionProcessor('now')),
    pair(ToDate, simpleFunctionProcessor('to_date')),
    pair(ToTimestamp, simpleFunctionProcessor('to_timestamp')),
    pair(ToChar, argTransformFunctionProcessor('to_char', 'trim(to_char(%s,%s))')), // trim was needed to handle the extra spaces  that are appended to result to match September's length.
    pair(DateDiff, argTransformFunctionProcessor('dateDiff', '%s', {p:String[*]|$p->dateDiffHandlerForPostgres()}))
  ])
}

function meta::external::store::relational::sqlDialectTranslation::postgres::dateDiffHandlerForPostgres(p:String[*]): String[1]
{
  
  let timeUnits=['year', 'month', 'day', 'week', 'hour', 'minute', 'second', 'millisecond'];
  let indexOfUnit=$timeUnits->indexOf($p->at(0)->replace('\'', ''));
  let unitFunctionsList=[

    { | format('(%s)', [
        'cast((extract(\'year\' from %s) - extract(\'year\' from %s)) as int)'
     ])},
    
    { | format('(%s * 12 + (%s))', [
        ['year', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'month\' from %s) - extract(\'month\' from %s)) as int)'
     ])},

    { | format('(%s)', [
        '(cast(%s as date) - cast(%s as date))'
     ])},

    { | format('(cast(%s/7 as int))', [
        ['day', '%s', '%s']->dateDiffHandlerForPostgres()
     ])},
    
    { | format('cast((%s * 24 + (%s)) as int)', [
        ['day', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'hour\' from %s) - extract(\'hour\' from %s)) as int)'
     ])},

    { | format('cast((%s * 60 + (%s)) as int)', [
        ['hour', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'minute\' from %s) - extract(\'minute\' from %s)) as int)'
     ])},

    { | format('cast((%s * 60 + (%s)) as int)', [
        ['minute', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'second\' from %s) - extract(\'second\' from %s)) as int)'
     ])},

    { | format('cast((%s * 1000 + (%s)) as int)', [
        ['second', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'millisecond\' from %s) - extract(\'millisecond\' from %s)) as int)'
     ])}

  ];

  format($unitFunctionsList->at($indexOfUnit)->eval(), [$p->at(2), $p->at(1)]);

}