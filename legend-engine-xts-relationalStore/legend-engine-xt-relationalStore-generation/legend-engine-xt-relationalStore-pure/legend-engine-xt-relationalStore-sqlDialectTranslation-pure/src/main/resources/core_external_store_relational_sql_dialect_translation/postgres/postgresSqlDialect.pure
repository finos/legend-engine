// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensiveFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::boolean::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::misc::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numeric::*;
import meta::external::query::sql::metamodel::*;
import meta::external::store::relational::sqlDialectTranslation::*;
import meta::external::store::relational::sqlDialectTranslation::defaults::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::*;
import meta::external::store::relational::sqlDialectTranslation::postgres::*;
import meta::external::store::relational::sqlDialectTranslation::sqlTyping::typeInference::*;
import meta::external::store::relational::sqlDialectTranslation::utils::*;
import meta::pure::extension::*;

function meta::external::store::relational::sqlDialectTranslation::postgres::postgresSqlDialect(): SqlDialect[1]
{
  ^SqlDialect
  (
    dbType = 'Postgres',
    quoteConfig = postgresQuoteConfiguration(),
    nodeProcessors = postgresDialectNodeProcessors(),
    identifierProcessor = postgresIdentifierProcessor(),
    expressionPrecedenceComparator = postgresExpressionPrecedenceComparator(),
    keywords = postgresKeywords(),
    functionProcessorMap = functionProcessorMap()
  )
}

function  meta::external::store::relational::sqlDialectTranslation::postgres::postgresSqlDialectExtension(): Extension[1]
{
  ^Extension
  (
    type = 'PostgresSqlDialectExtension',
    moduleExtensions = [
      ^SqlDialectTranslationModuleExtension
      (
        module = sqlDialectTranslationModuleExtensionName(),
        extraSqlDialects = postgresSqlDialect()
      )
    ]
  )
}

function meta::external::store::relational::sqlDialectTranslation::postgres::postgresFunctionTestsExpectedErrors(): Map<String, String>[1]
{
  [
    
  ]->newMap()->cast(@Map<String, String>)
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresQuoteConfiguration(): QuoteConfiguration[1]
{
  ^QuoteConfiguration
  (
    start = '"',
    end = '"',
    escape = '""'
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresDialectNodeProcessors(): Map<Class<Node>, NodeProcessor<Node>>[1]
{
  newMap(
    postgresDialectStatementProcessors()
    ->concatenate(
      postgresDialectRelationProcessors()
    )
    ->concatenate(
      postgresDialectExpressionProcessors()
    )
    ->concatenate(
      postgresDialectLiteralProcessors()
    )
    ->concatenate(
      postgresDialectSelectItemProcessors()
    )
    ->concatenate(
      postgresDialectOtherNodeProcessors()
    )
    ->map(n | pair($n.nodeType, $n))
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresDialectStatementProcessors(): NodeProcessor<Statement>[*]
{
  [
    queryProcessor_default(),
    windowProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresDialectRelationProcessors(): NodeProcessor<Relation>[*]
{
  [
    tableProcessor_default(),
    aliasedRelationProcessor_default(),
    joinProcessor_default(),
    querySpecificationProcessor_default(),
    unionProcessor_default(),
    tableSubqueryProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresDialectExpressionProcessors(): NodeProcessor<meta::external::query::sql::metamodel::Expression>[*]
{
  [
    comparisonExpressionNodeProcessor_default(),
    logicalBinaryExpressionNodeProcessor_default(),
    notExpressionNodeProcessor_default(),
    arithmeticExpressionNodeProcessor_default(),
    qualifiedNameReferenceNodeProcessor_default(),
    isNullPredicateNodeProcessor_default(),
    isNotNullPredicateNodeProcessor_default(),
    negativeNodeProcessor_default(),
    currentTimeNodeProcessor_default(),
    whenClauseNodeProcessor_default(),
    searchedCaseExpressionNodeProcessor_default(),
    columnTypeProcessor_default(),
    castProcessor_default(),
    inListExpressionProcessor_default(),
    inPredicateProcessor_default(),
    extractProcessor_default(),
    betweenPredicateProcessor_default(),
    functionCallProcessor_default(),
    subQueryExpressionProcessor_default(),
    trimProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresDialectLiteralProcessors(): NodeProcessor<Literal>[*]
{
  [
    integerLiteralNodeProcessor_default(),
    stringLiteralNodeProcessor_default(),
    booleanLiteralNodeProcessor_default(),
    longLiteralNodeProcessor_default(),
    doubleLiteralNodeProcessor_default(),
    nullLiteralNodeProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresDialectSelectItemProcessors(): NodeProcessor<SelectItem>[*]
{
  [
    allColumnsNodeProcessor_default(),
    singleColumnNodeProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresDialectOtherNodeProcessors(): NodeProcessor<Node>[*]
{
  [
    sortItemProcessor_default(),
    selectProcessor_default()
  ]
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresIdentifierProcessor(): IdentifierProcessor[1]
{
  identifierProcessor_default()
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresExpressionPrecedenceComparator(): ExpressionPrecedenceComparator[1]
{
  ^ExpressionPrecedenceComparator(
    findOperatorType = findOperatorType_default_Expression_1__String_1_,
    operatorPrecedence = operatorPrecedence_default()
  )
}


function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresKeywords(): String[*]
{
  [
    'all', 
    'analyse', 
    'analyze', 
    'and', 
    'any', 
    'array', 
    'as', 
    'asc', 
    'asymmetric', 
    'authorization', 
    'binary', 
    'both', 
    'case', 
    'cast', 
    'check', 
    'collate', 
    'collation', 
    'column', 
    'concurrently', 
    'constraint', 
    'create', 
    'cross', 
    'current_catalog', 
    'current_date', 
    'current_role', 
    'current_schema', 
    'current_time', 
    'current_timestamp', 
    'current_user', 
    'default', 
    'deferrable', 
    'desc', 
    'distinct', 
    'do', 
    'else', 
    'end', 
    'except', 
    'false', 
    'fetch', 
    'for', 
    'foreign', 
    'freeze', 
    'from', 
    'full', 
    'grant', 
    'group', 
    'having', 
    'ilike', 
    'in', 
    'initially', 
    'inner', 
    'intersect', 
    'into', 
    'is', 
    'isnull', 
    'join', 
    'lateral', 
    'leading', 
    'left', 
    'like', 
    'limit', 
    'localtime', 
    'localtimestamp', 
    'natural', 
    'not', 
    'notnull', 
    'null', 
    'offset', 
    'on', 
    'only', 
    'or', 
    'order', 
    'outer', 
    'overlaps', 
    'placing', 
    'primary', 
    'references', 
    'returning', 
    'right', 
    'select', 
    'session_user', 
    'similar', 
    'some', 
    'symmetric', 
    'system_user', 
    'table', 
    'tablesample', 
    'then', 
    'to', 
    'trailing', 
    'true', 
    'union', 
    'unique', 
    'user', 
    'using', 
    'variadic', 
    'verbose', 
    'when', 
    'where', 
    'window', 
    'with'
  ];
}

// ---------------------------- Function processing -------------------------

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::functionProcessorMap(): Map<Class<SqlFunction>, FunctionProcessor>[1]
{
  newMap([
    // Numeric
    pair(Abs, simpleFunctionProcessor('abs')),
    pair(Cbrt, simpleFunctionProcessor('cbrt')),
    pair(Ceil, simpleFunctionProcessor('ceil')),
    pair(Ceiling, simpleFunctionProcessor('ceiling')),
    pair(Degrees, simpleFunctionProcessor('degrees')),
    pair(Exp, simpleFunctionProcessor('exp')),
    pair(Ln, simpleFunctionProcessor('ln')),
    pair(Log, simpleFunctionProcessor('log')),
    pair(Log10, argTransformFunctionProcessor('log', {n:Node[*]| literal(10)->concatenate($n)})),
    pair(Sqrt, simpleFunctionProcessor('sqrt')),
    pair(Acos, simpleFunctionProcessor('acos')),
    pair(Asin, simpleFunctionProcessor('asin')),
    pair(Atan, simpleFunctionProcessor('atan')),
    pair(Atan2, simpleFunctionProcessor('atan2')),
    pair(Cos, simpleFunctionProcessor('cos')),
    pair(Cot, simpleFunctionProcessor('cot')),
    pair(Sin, simpleFunctionProcessor('sin')),
    pair(Tan, simpleFunctionProcessor('tan')),
    pair(Power, simpleFunctionProcessor('power')),
    pair(Sign, customFunctionProcessor(processorForSign_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)), 
    pair(Mod, simpleFunctionProcessor('mod')),
    pair(Round, simpleFunctionProcessor('round')),
    pair(Greatest, simpleFunctionProcessor('greatest')),
    pair(Least, simpleFunctionProcessor('least')),
    pair(Floor, simpleFunctionProcessor('floor')),


    // String
    pair(Lpad, simpleFunctionProcessor('lpad')),
    pair(Rpad, simpleFunctionProcessor('rpad')),
    pair(Ltrim, simpleFunctionProcessor('ltrim')),
    pair(Rtrim, simpleFunctionProcessor('rtrim')),
    pair(Ascii, simpleFunctionProcessor('ascii')),
    pair(Lower, simpleFunctionProcessor('lower')),
    pair(Upper, simpleFunctionProcessor('upper')),
    pair(Repeat, simpleFunctionProcessor('repeat')),
    pair(Replace, simpleFunctionProcessor('replace')),
    pair(Md5, simpleFunctionProcessor('md5')),
    pair(CharLength, simpleFunctionProcessor('char_length')),
    pair(Chr, simpleFunctionProcessor('chr')),
    pair(Reverse, simpleFunctionProcessor('reverse')),
    pair(SplitPart, simpleFunctionProcessor('split_part')),
    pair(Substring, simpleFunctionProcessor('substring')),


    pair(Left, simpleFunctionProcessor('left')),
    pair(Right, simpleFunctionProcessor('right')),
    pair(StrPos, simpleFunctionProcessor('strpos')),
    pair(Sha1, customFunctionProcessor({f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]| processorForSha('sha1',$f,$sqlDialect,$state,$config )})),
    pair(Sha256, customFunctionProcessor({f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]| processorForSha('sha256',$f,$sqlDialect,$state,$config )})),
    pair(Concat, simpleFunctionProcessor('concat')),

    // Boolean
    pair(RegexpLike, customFunctionProcessor(processorForRegexpLike_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Temporal
    pair(DateTrunc, simpleFunctionProcessor('date_trunc')),
    pair(DatePart, customFunctionProcessor(processorForDatePart_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Now, simpleFunctionProcessor('now')),
    pair(ToDate, simpleFunctionProcessor('to_date')),
    pair(ToTimestamp, simpleFunctionProcessor('to_timestamp')),
     pair(ToChar, customFunctionProcessor(processorForToChar_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
     pair(DateDiff, customFunctionProcessor(processorForDateDiff_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
     pair(DateAdd, customFunctionProcessor(processorForDateAdd_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Miscellaneous
    pair(Coalesce, simpleFunctionProcessor('coalesce'))
  ])
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForSha(hashing:String[1], f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let hashType = '\''+$hashing+'\'';
  let digestCall = generateFunctionCallWithArgs($sqlDialect, 'digest', [$processedArgs->at(0), $hashType], [], $state, $config);
  generateFunctionCallWithArgs($sqlDialect, 'encode', [$digestCall,'\'hex\''], [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForDatePart(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  // Postgres returns double for some reason, also, date_part to second includes milliseconds, which is non-standard.
  let datePart = simpleFunctionProcessor('date_part').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  let roundedDatePart = $sqlDialect->generateFunctionCallWithArgs('floor', $datePart, [], $state, $config);
  $sqlDialect->generateCast($roundedDatePart, 'integer', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForSign(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  // Postgres returns sign in decimal, which is non standard.
  let floatedSign = simpleFunctionProcessor('sign').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($floatedSign, 'integer', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForToChar(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  // trim was needed to handle the extra spaces  that are appended to result to match September's length.
  let unTrimmed = simpleFunctionProcessor('to_char').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('trim', $unTrimmed, [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForDateDiff(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $processedArgs->dateDiffHandlerForPostgres();
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForDateAdd(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let dateAddCall = $processedArgs->at(0) + ' + INTERVAL \''+$processedArgs->at(1) +' '+$processedArgs->at(2)->removeQuotes()+'\'';
  let dateUnit = $processedArgs->at(2)->removeQuotes();
  if($dateUnit->in(['DAY', 'MONTH', 'YEAR', 'WEEK']) ,
    |$sqlDialect->generateCast($dateAddCall, 'date', $state, $config), 
    |$dateAddCall
   );
}

function meta::external::store::relational::sqlDialectTranslation::postgres::dateDiffHandlerForPostgres(p: String[*]): String[1]
{ 
  let timeUnits = ['year', 'month', 'day', 'week', 'hour', 'minute', 'second', 'millisecond'];
  let indexOfUnit = $timeUnits->indexOf($p->at(0)->removeQuotes());
  let unitFunctionsList = [

    { | format('(%s)', [
        'cast((extract(\'year\' from %s) - extract(\'year\' from %s)) as int)'
     ])},
    
    { | format('(%s * 12 + (%s))', [
        ['year', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'month\' from %s) - extract(\'month\' from %s)) as int)'
     ])},

    { | format('(%s)', [
        '(cast(%s as date) - cast(%s as date))'
     ])},

    { | format('(cast(%s/7 as int))', [
        ['day', '%s', '%s']->dateDiffHandlerForPostgres()
     ])},
    
    { | format('cast((%s * 24 + (%s)) as int)', [
        ['day', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'hour\' from %s) - extract(\'hour\' from %s)) as int)'
     ])},

    { | format('cast((%s * 60 + (%s)) as int)', [
        ['hour', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'minute\' from %s) - extract(\'minute\' from %s)) as int)'
     ])},

    { | format('cast((%s * 60 + (%s)) as int)', [
        ['minute', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'second\' from %s) - extract(\'second\' from %s)) as int)'
     ])},

    { | format('cast((%s * 1000 + (%s)) as int)', [
        ['second', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'millisecond\' from %s) - extract(\'millisecond\' from %s)) as int)'
     ])}

  ];

  format($unitFunctionsList->at($indexOfUnit)->eval(), [$p->at(2), $p->at(1)]);
}
