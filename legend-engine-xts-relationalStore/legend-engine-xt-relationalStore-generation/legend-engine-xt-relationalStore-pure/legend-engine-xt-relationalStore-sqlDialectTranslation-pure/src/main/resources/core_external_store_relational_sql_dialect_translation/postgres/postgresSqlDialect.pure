// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::boolean::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::string::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::misc::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::numeric::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::extensionFunctions::temporal::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::postgresNativeFunctions::numeric::*;
import meta::external::query::sql::metamodel::*;
import meta::external::store::relational::sqlDialectTranslation::*;
import meta::external::store::relational::sqlDialectTranslation::defaults::*;
import meta::external::store::relational::sqlDialectTranslation::functionRegistry::*;
import meta::external::store::relational::sqlDialectTranslation::postgres::*;
import meta::external::store::relational::sqlDialectTranslation::sqlTyping::typeInference::*;
import meta::external::store::relational::sqlDialectTranslation::utils::*;
import meta::pure::extension::*;

function meta::external::store::relational::sqlDialectTranslation::postgres::postgresSqlDialect(): SqlDialect[1]
{
  ^SqlDialect
  (
    dbType = 'Postgres',
    quoteConfig = doubleQuotesConfiguration_default(),
    nodeProcessors = postgresDialectNodeProcessors(),
    identifierProcessor = identifierProcessor_default(),
    expressionPrecedenceComparator = expressionPrecedenceComparator_default(),
    keywords = postgresKeywords(),
    functionProcessorMap = functionProcessorMap()
  )
}

function <<db.ExtensionLoader>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresSqlDialectExtension(): Extension[1]
{
  ^Extension
  (
    type = 'PostgresSqlDialectExtension',
    moduleExtensions = [
      ^SqlDialectTranslationModuleExtension
      (
        module = sqlDialectTranslationModuleExtensionName(),
        extraSqlDialects = postgresSqlDialect()
      )
    ]
  )
}

function meta::external::store::relational::sqlDialectTranslation::postgres::postgresFunctionTestsExpectedErrors(): Map<String, String>[1]
{
  [
    pair(
      'FuncTests - string_agg(0/0)',
      'Tests for aggregate functions not supported yet!'
    ),
    pair(
      'FuncTests - denseRank(0/0)',
      'Tests for aggregate functions not supported yet!'
    ),
    pair(
      'FuncTests - now(0/1)',
      'TimeZone Issue : Result is five hours ahead'
    ),
    pair(
      'FuncTests - now(1/1)',
      'TimeZone Issue : Result is five hours ahead'
    ),
    pair(
      'FuncTests - to_timestamp(0/3)',
      'TimeZone Issue : Result is five hours ahead'
    ),
    pair(
      'FuncTests - to_timestamp(1/3)',
      'TimeZone Issue : Result is five hours ahead'
    )
  ]->newMap()->cast(@Map<String, String>)
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresDialectNodeProcessors(): Map<Class<Node>, NodeProcessor<Node>>[1]
{
  newMap(
    dialectStatementProcessors_default()
    ->concatenate(
      dialectRelationProcessors_default()
    )
    ->concatenate(
      dialectExpressionProcessors_default()
    )
    ->concatenate(
      dialectLiteralProcessors_default()
    )
    ->concatenate(
      dialectSelectItemProcessors_default()
    )
    ->concatenate(
      dialectOtherNodeProcessors_default()
    )
    ->map(n | pair($n.nodeType, $n))
  )
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::postgresKeywords(): String[*]
{
  [
    'all', 
    'analyse', 
    'analyze', 
    'and', 
    'any', 
    'array', 
    'as', 
    'asc', 
    'asymmetric', 
    'authorization', 
    'binary', 
    'both', 
    'case', 
    'cast', 
    'check', 
    'collate', 
    'collation', 
    'column', 
    'concurrently', 
    'constraint', 
    'create', 
    'cross', 
    'current_catalog', 
    'current_date', 
    'current_role', 
    'current_schema', 
    'current_time', 
    'current_timestamp', 
    'current_user', 
    'default', 
    'deferrable', 
    'desc', 
    'distinct', 
    'do', 
    'else', 
    'end', 
    'except', 
    'false', 
    'fetch', 
    'for', 
    'foreign', 
    'freeze', 
    'from', 
    'full', 
    'grant', 
    'group', 
    'having', 
    'ilike', 
    'in', 
    'initially', 
    'inner', 
    'intersect', 
    'into', 
    'is', 
    'isnull', 
    'join', 
    'lateral', 
    'leading', 
    'left', 
    'like', 
    'limit', 
    'localtime', 
    'localtimestamp', 
    'natural', 
    'not', 
    'notnull', 
    'null', 
    'offset', 
    'on', 
    'only', 
    'or', 
    'order', 
    'outer', 
    'overlaps', 
    'placing', 
    'primary', 
    'references', 
    'returning', 
    'right', 
    'select', 
    'session_user', 
    'similar', 
    'some', 
    'symmetric', 
    'system_user', 
    'table', 
    'tablesample', 
    'then', 
    'to', 
    'trailing', 
    'true', 
    'union', 
    'unique', 
    'user', 
    'using', 
    'variadic', 
    'verbose', 
    'when', 
    'where', 
    'window', 
    'with'
  ];
}

// ---------------------------- Function processing -------------------------

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::functionProcessorMap(): Map<Class<SqlFunction>, FunctionProcessor>[1]
{
  newMap([
    // Numeric
    pair(Abs, simpleFunctionProcessor('abs')),
    pair(Cbrt, simpleFunctionProcessor('cbrt')),
    pair(Ceil, simpleFunctionProcessor('ceil')),
    pair(Ceiling, simpleFunctionProcessor('ceiling')),
    pair(Degrees, simpleFunctionProcessor('degrees')),
    pair(Exp, simpleFunctionProcessor('exp')),
    pair(Ln, simpleFunctionProcessor('ln')),
    pair(Log, simpleFunctionProcessor('log')),
    pair(Log10, argTransformFunctionProcessor('log', {n:Node[*]| literal(10)->concatenate($n)})),
    pair(Sqrt, simpleFunctionProcessor('sqrt')),
    pair(Acos, simpleFunctionProcessor('acos')),
    pair(Asin, simpleFunctionProcessor('asin')),
    pair(Atan, simpleFunctionProcessor('atan')),
    pair(Atan2, simpleFunctionProcessor('atan2')),
    pair(Cos, simpleFunctionProcessor('cos')),
    pair(Cot, simpleFunctionProcessor('cot')),
    pair(Sin, simpleFunctionProcessor('sin')),
    pair(Tan, simpleFunctionProcessor('tan')),
    pair(Power, simpleFunctionProcessor('power')),
    pair(Sign, customFunctionProcessor(processorForSign_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)), 
    pair(Mod, simpleFunctionProcessor('mod')),
    pair(Round, simpleFunctionProcessor('round')),
    pair(Greatest, simpleFunctionProcessor('greatest')),
    pair(Least, simpleFunctionProcessor('least')),
    pair(DenseRank, simpleFunctionProcessor('denseRank')),

    // String
    pair(Lpad, simpleFunctionProcessor('lpad')),
    pair(Rpad, simpleFunctionProcessor('rpad')),
    pair(Ltrim, simpleFunctionProcessor('ltrim')),
    pair(Rtrim, simpleFunctionProcessor('rtrim')),
    pair(Ascii, simpleFunctionProcessor('ascii')),
    pair(Lower, simpleFunctionProcessor('lower')),
    pair(Upper, simpleFunctionProcessor('upper')),
    pair(Repeat, simpleFunctionProcessor('repeat')),
    pair(Replace, simpleFunctionProcessor('replace')),
    pair(Md5, simpleFunctionProcessor('md5')),
    pair(CharLength, simpleFunctionProcessor('char_length')),
    pair(Chr, simpleFunctionProcessor('chr')),
    pair(Reverse, simpleFunctionProcessor('reverse')),
    pair(SplitPart, simpleFunctionProcessor('split_part')),
    pair(Substring, simpleFunctionProcessor('substring')),


    pair(Left, simpleFunctionProcessor('left')),
    pair(Right, simpleFunctionProcessor('right')),
    pair(StrPos, simpleFunctionProcessor('strpos')),
    pair(Sha1, argTransformFunctionProcessor('digest', {n:Node[*]| literal('sha1')->concatenate($n)->reverse()})),
    pair(Sha256, argTransformFunctionProcessor('digest', {n:Node[*]| literal('sha256')->concatenate($n)->reverse()})),
    pair(StringAgg, simpleFunctionProcessor('string_agg')),
    pair(Concat, simpleFunctionProcessor('concat')),

    // Boolean
    pair(RegexpLike, customFunctionProcessor(processorForRegexpLike_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Temporal
    pair(DateTrunc, simpleFunctionProcessor('date_trunc')),
    pair(DatePart, customFunctionProcessor(processorForDatePart_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
    pair(Now, simpleFunctionProcessor('now')),
    pair(ToDate, simpleFunctionProcessor('to_date')),
    pair(ToTimestamp, simpleFunctionProcessor('to_timestamp')),
     pair(ToChar, customFunctionProcessor(processorForToChar_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
     pair(DateDiff, customFunctionProcessor(processorForDateDiff_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),
     pair(DateAdd, customFunctionProcessor(processorForDateAdd_FunctionCall_1__SqlDialect_1__SqlDialectTranslationState_1__SqlDialectTranslationConfig_1__String_1_)),

    // Miscellaneous
    pair(Coalesce, simpleFunctionProcessor('coalesce'))
  ])
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForDatePart(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  // Postgres returns double for some reason, also, date_part to second includes milliseconds, which is non-standard.
  let datePart = simpleFunctionProcessor('date_part').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  let roundedDatePart = $sqlDialect->generateFunctionCallWithArgs('floor', $datePart, [], $state, $config);
  $sqlDialect->generateCast($roundedDatePart, 'integer', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForSign(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  // Postgres returns sign in decimal, which is non standard.
  let floatedSign = simpleFunctionProcessor('sign').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateCast($floatedSign, 'integer', $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForToChar(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  // trim was needed to handle the extra spaces  that are appended to result to match September's length.
  let unTrimmed = simpleFunctionProcessor('to_char').processFunction->toOne()->eval($sqlDialect, $f, $state, $config);
  $sqlDialect->generateFunctionCallWithArgs('trim', $unTrimmed, [], $state, $config);
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForDateDiff(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  $processedArgs->dateDiffHandlerForPostgres();
}

function <<access.private>> meta::external::store::relational::sqlDialectTranslation::postgres::processorForDateAdd(f:FunctionCall[1], sqlDialect:SqlDialect[1], state:SqlDialectTranslationState[1], config:SqlDialectTranslationConfig[1]): String[1]
{
  let processedArgs = $sqlDialect->processFunctionArgs($f.arguments, $state, $config);
  let dateAddCall = $processedArgs->at(0) + ' + INTERVAL \''+$processedArgs->at(1) +' '+$processedArgs->at(2)->replace('\'', '')+'\'';
  let dateUnit = $processedArgs->at(2)->replace('\'', '');
  if($dateUnit == 'DAY' || $dateUnit == 'MONTH' || $dateUnit == 'YEAR' || $dateUnit == 'WEEK' ,
    |$sqlDialect->generateCast($dateAddCall, 'date', $state, $config), 
    |$dateAddCall
   );
}

function meta::external::store::relational::sqlDialectTranslation::postgres::dateDiffHandlerForPostgres(p: String[*]): String[1]
{ 
  $p->map(x|println($x));
  let timeUnits=['year', 'month', 'day', 'week', 'hour', 'minute', 'second', 'millisecond'];
  let indexOfUnit=$timeUnits->indexOf($p->at(0)->replace('\'', ''));
  let unitFunctionsList=[

    { | format('(%s)', [
        'cast((extract(\'year\' from %s) - extract(\'year\' from %s)) as int)'
     ])},
    
    { | format('(%s * 12 + (%s))', [
        ['year', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'month\' from %s) - extract(\'month\' from %s)) as int)'
     ])},

    { | format('(%s)', [
        '(cast(%s as date) - cast(%s as date))'
     ])},

    { | format('(cast(%s/7 as int))', [
        ['day', '%s', '%s']->dateDiffHandlerForPostgres()
     ])},
    
    { | format('cast((%s * 24 + (%s)) as int)', [
        ['day', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'hour\' from %s) - extract(\'hour\' from %s)) as int)'
     ])},

    { | format('cast((%s * 60 + (%s)) as int)', [
        ['hour', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'minute\' from %s) - extract(\'minute\' from %s)) as int)'
     ])},

    { | format('cast((%s * 60 + (%s)) as int)', [
        ['minute', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'second\' from %s) - extract(\'second\' from %s)) as int)'
     ])},

    { | format('cast((%s * 1000 + (%s)) as int)', [
        ['second', $p->at(1), $p->at(2)]->dateDiffHandlerForPostgres(),
        'cast((extract(\'millisecond\' from %s) - extract(\'millisecond\' from %s)) as int)'
     ])}

  ];

  format($unitFunctionsList->at($indexOfUnit)->eval(), [$p->at(2), $p->at(1)]);
}
