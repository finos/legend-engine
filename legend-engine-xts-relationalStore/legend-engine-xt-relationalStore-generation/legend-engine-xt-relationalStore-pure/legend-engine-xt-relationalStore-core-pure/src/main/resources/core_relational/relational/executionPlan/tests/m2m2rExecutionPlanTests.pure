// Copyright 2026 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::executionPlan::m2m2r::tests::*;

function <<meta::pure::profiles::test.Test>> meta::pure::executionPlan::m2m2r::tests::planProjectWithDerivedProperty() : Boolean[1]
{
  let query = {|Person.all()->project([x|$x.fullName], ['fullName'])};
  let runtime = getM2M2RRuntime();
  let mapping = ModelToModelMapping;
  let plan = planToString($query, $mapping, $runtime);
  let expected = 'Relational\n(\n  type = TDS[(fullName, String, VARCHAR(8192), "")]\n  resultColumns = [("fullName", "")]\n  sql = select concat("root".firstName, \' \', "root".lastName) as "fullName" from S.Person as "root"\n  connection = DatabaseConnection(type = "H2")\n)\n';
  assertEquals($expected, $plan);
}

function <<meta::pure::profiles::test.Test>> meta::pure::executionPlan::m2m2r::tests::planProjectWithDerivedProperty1() : Boolean[1]
{
  let query = {|Person.all()->project([x|$x.isName('Peter Smith')], ['isPeterSmith'])};
  let runtime = getM2M2RRuntime();
  let mapping = ModelToModelMapping;
  let plan = planToString($query, $mapping, $runtime);
  let expected = 'Relational\n(\n  type = TDS[(isPeterSmith, Boolean, BIT, "")]\n  resultColumns = [("isPeterSmith", "")]\n  sql = select concat("root".firstName, \' \', "root".lastName) = \'name\' as "isPeterSmith" from S.Person as "root"\n  connection = DatabaseConnection(type = "H2")\n)\n';
  assertEquals($expected, $plan);
}

function <<meta::pure::profiles::test.Test>> meta::pure::executionPlan::m2m2r::tests::planGraphFetchWithDerivedProperty() : Boolean[1]
{
  let query = {|PersonPeterSmith.all()->meta::pure::graphFetch::execution::graphFetch(#{PersonPeterSmith{isPeterSmith}}#)};
  let runtime = getM2M2RRuntime();
  let mapping = ModelToModelMapping;
  let plan = planToString($query, $mapping, $runtime);
  let expected = 
    'StoreMappingGlobalGraphFetch\n' +
    '(\n' +
    '  type = PartialClass[impls=[(meta::pure::executionPlan::m2m2r::tests::PersonPeterSmith | ModelToModelMapping.meta_pure_executionPlan_m2m2r_tests_PersonPeterSmith)], propertiesWithParameters = [isPeterSmith()]]\n' +
    '  resultSizeRange = *\n' +
    '  store = MODEL\n' +
    '  localGraphFetchExecutionNode = \n' +
    '     InMemoryRootGraphFetch\n' +
    '     (\n' +
    '       type = PartialClass[impls=[(meta::pure::executionPlan::m2m2r::tests::PersonPeterSmith | ModelToModelMapping.meta_pure_executionPlan_m2m2r_tests_PersonPeterSmith)], propertiesWithParameters = [isPeterSmith()]]\n' +
    '       graphFetchTree = [meta_pure_executionPlan_m2m2r_tests_PersonPeterSmith/meta::pure::executionPlan::m2m2r::tests::PersonPeterSmith]{[/isPeterSmith()]}\n' +
    '       nodeIndex = 0\n' +
    '       batchSize = 1\n' +
    '       checked = false\n' +
    '       (\n' +
    '         StoreMappingGlobalGraphFetch\n' +
    '         (\n' +
    '           type = PartialClass[impls=[(meta::pure::executionPlan::m2m2r::tests::_Person | RelationalMapping.meta_pure_executionPlan_m2m2r_tests__Person)], propertiesWithParameters = [firstName, lastName]]\n' +
    '           resultSizeRange = *\n' +
    '           store = meta::pure::executionPlan::m2m2r::tests::DB\n' +
    '           localGraphFetchExecutionNode = \n' +
    '              RelationalGraphFetch\n' +
    '              (\n' +
    '                type = PartialClass[impls=[(meta::pure::executionPlan::m2m2r::tests::_Person | RelationalMapping.meta_pure_executionPlan_m2m2r_tests__Person)], propertiesWithParameters = [firstName, lastName]]\n' +
    '                nodeIndex = 0\n' +
    '                relationalNode = \n' +
    '                   SQL\n' +
    '                   (\n' +
    '                     type = meta::pure::metamodel::type::Any\n' +
    '                     resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("lastName", VARCHAR(200))]\n' +
    '                     sql = select "root".id as "pk_0", "root".firstName as "firstName", "root".lastName as "lastName" from S.Person as "root"\n' +
    '                     connection = DatabaseConnection(type = "H2")\n' +
    '                   )\n' +
    '                children = [\n' +
    '                   \n' +
    '                ]\n' +
    '              )\n' +
    '           children = [\n' +
    '              \n' +
    '           ]\n' +
    '           localTreeIndices = [0, 1, 2]\n' +
    '           dependencyIndices = []\n' +
    '         )\n' +
    '       )\n' +
    '       children = [\n' +
    '          \n' +
    '       ]\n' +
    '     )\n' +
    '  children = [\n' +
    '     \n' +
    '  ]\n' +
    '  localTreeIndices = [0, 1]\n' +
    '  dependencyIndices = []\n' +
    ')\n';
  assertEquals($expected, $plan);
}

function <<meta::pure::profiles::test.Test>> meta::pure::executionPlan::m2m2r::tests::planProjectWithNestedProperty() : Boolean[1]
{
  let query = {|PersonPeterSmith.all()->project([x|$x.details.firstName], ['firstName'])};
  let runtime = getM2M2RRuntime();
  let mapping = ModelToModelMapping;
  let plan = planToString($query, $mapping, $runtime);
  let expected = 'Relational\n(\n  type = TDS[(firstName, String, VARCHAR(8192), "")]\n  resultColumns = [("firstName", VARCHAR(200))]\n  sql = select "root".firstName as "firstName" from S.Person as "root"\n  connection = DatabaseConnection(type = "H2")\n)\n';
  assertEquals($expected, $plan);
}

function <<meta::pure::profiles::test.Test>> meta::pure::executionPlan::m2m2r::tests::planProjectWithNestedDerivedProperty() : Boolean[1]
{
  let query = {|PersonPeterSmith.all()->project([x|$x.isPeterSmith], ['isPeterSmith'])};
  let runtime = getM2M2RRuntime();
  let mapping = ModelToModelMapping;
  let plan = planToString($query, $mapping, $runtime);
  let expected = 'Relational\n(\n  type = TDS[(isPeterSmith, Boolean, BIT, "")]\n  resultColumns = [("isPeterSmith", "")]\n  sql = select concat("root".firstName, \' \', "root".lastName) = \'name\' as "isPeterSmith" from S.Person as "root"\n  connection = DatabaseConnection(type = "H2")\n)\n';
  assertEquals($expected, $plan);
}

function <<meta::pure::profiles::test.Test>> meta::pure::executionPlan::m2m2r::tests::planGraphFetchWithNestedDerivedProperty() : Boolean[1]
{
  let query = {|PersonPeterSmith.all()->meta::pure::graphFetch::execution::graphFetch(#{PersonPeterSmith{isPeterSmith}}#)};
  let runtime = getM2M2RRuntime();
  let mapping = ModelToModelMapping;
  let plan = planToString($query, $mapping, $runtime);
  let expected = 
    'StoreMappingGlobalGraphFetch\n' +
    '(\n' +
    '  type = PartialClass[impls=[(meta::pure::executionPlan::m2m2r::tests::PersonPeterSmith | ModelToModelMapping.meta_pure_executionPlan_m2m2r_tests_PersonPeterSmith)], propertiesWithParameters = [isPeterSmith()]]\n' +
    '  resultSizeRange = *\n' +
    '  store = MODEL\n' +
    '  localGraphFetchExecutionNode = \n' +
    '     InMemoryRootGraphFetch\n' +
    '     (\n' +
    '       type = PartialClass[impls=[(meta::pure::executionPlan::m2m2r::tests::PersonPeterSmith | ModelToModelMapping.meta_pure_executionPlan_m2m2r_tests_PersonPeterSmith)], propertiesWithParameters = [isPeterSmith()]]\n' +
    '       graphFetchTree = [meta_pure_executionPlan_m2m2r_tests_PersonPeterSmith/meta::pure::executionPlan::m2m2r::tests::PersonPeterSmith]{[/isPeterSmith()]}\n' +
    '       nodeIndex = 0\n' +
    '       batchSize = 1\n' +
    '       checked = false\n' +
    '       (\n' +
    '         StoreMappingGlobalGraphFetch\n' +
    '         (\n' +
    '           type = PartialClass[impls=[(meta::pure::executionPlan::m2m2r::tests::_Person | RelationalMapping.meta_pure_executionPlan_m2m2r_tests__Person)], propertiesWithParameters = [firstName, lastName]]\n' +
    '           resultSizeRange = *\n' +
    '           store = meta::pure::executionPlan::m2m2r::tests::DB\n' +
    '           localGraphFetchExecutionNode = \n' +
    '              RelationalGraphFetch\n' +
    '              (\n' +
    '                type = PartialClass[impls=[(meta::pure::executionPlan::m2m2r::tests::_Person | RelationalMapping.meta_pure_executionPlan_m2m2r_tests__Person)], propertiesWithParameters = [firstName, lastName]]\n' +
    '                nodeIndex = 0\n' +
    '                relationalNode = \n' +
    '                   SQL\n' +
    '                   (\n' +
    '                     type = meta::pure::metamodel::type::Any\n' +
    '                     resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("lastName", VARCHAR(200))]\n' +
    '                     sql = select "root".id as "pk_0", "root".firstName as "firstName", "root".lastName as "lastName" from S.Person as "root"\n' +
    '                     connection = DatabaseConnection(type = "H2")\n' +
    '                   )\n' +
    '                children = [\n' +
    '                   \n' +
    '                ]\n' +
    '              )\n' +
    '           children = [\n' +
    '              \n' +
    '           ]\n' +
    '           localTreeIndices = [0, 1, 2]\n' +
    '           dependencyIndices = []\n' +
    '         )\n' +
    '       )\n' +
    '       children = [\n' +
    '          \n' +
    '       ]\n' +
    '     )\n' +
    '  children = [\n' +
    '     \n' +
    '  ]\n' +
    '  localTreeIndices = [0, 1]\n' +
    '  dependencyIndices = []\n' +
    ')\n';
  assertEquals($expected, $plan);
}

function  meta::pure::executionPlan::m2m2r::tests::planToString(query: FunctionDefinition<Any>[1], mapping: meta::pure::mapping::Mapping[1], runtime: meta::core::runtime::Runtime[1]) : String[1]
{
  meta::pure::executionPlan::executionPlan($query, $mapping, $runtime, meta::relational::extension::relationalExtensions())
  ->meta::pure::executionPlan::toString::planToString(meta::relational::extension::relationalExtensions())
}

Class meta::pure::executionPlan::m2m2r::tests::PersonPeterSmith
{
  details : Person[1];
  isPeterSmith()
  {
    $this.details.isName('Peter Smith')
  } : Boolean[1];
}

Class meta::pure::executionPlan::m2m2r::tests::Person
{
  firstName : String[1];
  lastName  : String[1];
  fullName()
  {
    $this.firstName + ' ' + $this.lastName
  } : String[1];
  isName(name : String[1])
  {
    $this.fullName == 'name'
  } : Boolean[1];
}

Class meta::pure::executionPlan::m2m2r::tests::_Person
{
  firstName : String[1];
  lastName  : String[1];
}

###Relational
Database meta::pure::executionPlan::m2m2r::tests::DB
(
  Schema S
  (
    Table Person
    (
      id INTEGER PRIMARY KEY,
      firstName VARCHAR(200),
      lastName VARCHAR(200)
    )
  )
)

###Mapping 
import meta::pure::executionPlan::m2m2r::tests::*;

Mapping meta::pure::executionPlan::m2m2r::tests::ModelToModelMapping
(
  Person : Pure
  {
    ~src _Person
    firstName : $src.firstName,
    lastName : $src.lastName
  }

  PersonPeterSmith : Pure
  {
    ~src _Person
    details : $src
  }
)

Mapping meta::pure::executionPlan::m2m2r::tests::RelationalMapping
(
  _Person : Relational
  {
    firstName : [DB] S.Person.firstName,
    lastName : [DB] S.Person.lastName
  }
)

###Pure
//-------------
// Connections
//-------------
function meta::pure::executionPlan::m2m2r::tests::getH2Connection(): meta::external::store::relational::runtime::DatabaseConnection[1]
{
  ^meta::external::store::relational::runtime::DatabaseConnection(type=meta::relational::runtime::DatabaseType.H2)
}

function meta::pure::executionPlan::m2m2r::tests::getModelChainConnection(): meta::external::store::model::ModelChainConnection[1]
{
  ^meta::external::store::model::ModelChainConnection(
    mappings = [meta::pure::executionPlan::m2m2r::tests::RelationalMapping]
  )
}

//-------------
// ConnectionStores
//-------------
function meta::pure::executionPlan::m2m2r::tests::getRelationalConnectionStore(): meta::core::runtime::ConnectionStore[1]
{
  ^meta::core::runtime::ConnectionStore(
    element = meta::pure::executionPlan::m2m2r::tests::DB,
    connection= meta::pure::executionPlan::m2m2r::tests::getH2Connection()
  )
}

function meta::pure::executionPlan::m2m2r::tests::getM2M2RConnectionStore(): meta::core::runtime::ConnectionStore[1]
{
  ^meta::core::runtime::ConnectionStore(
    element = ^meta::external::store::model::ModelStore(),
    connection= meta::pure::executionPlan::m2m2r::tests::getModelChainConnection()
  )
}

//-------------
// Runtimes
//-------------
function meta::pure::executionPlan::m2m2r::tests::getRelationalRuntime(): meta::core::runtime::Runtime[1]
{
  ^meta::core::runtime::Runtime(
      connectionStores = [meta::pure::executionPlan::m2m2r::tests::getRelationalConnectionStore()]
  )
}

function meta::pure::executionPlan::m2m2r::tests::getM2M2RRuntime(): meta::core::runtime::Runtime[1]
{
  ^meta::core::runtime::Runtime(
      connectionStores = [
        meta::pure::executionPlan::m2m2r::tests::getM2M2RConnectionStore(),
        meta::pure::executionPlan::m2m2r::tests::getRelationalConnectionStore()
      ]
  )
}