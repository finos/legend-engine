// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::functions::math::olap::*;
import meta::relational::functions::asserts::*;
import meta::relational::mapping::*;
import meta::relational::tests::model::simple::*;
import meta::relational::tests::*;
import meta::external::store::relational::tests::*;
import meta::external::store::relational::runtime::*;
import meta::relational::runtime::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::*;
import meta::relational::tests::postProcessor::*;
import meta::relational::metamodel::join::*;
import meta::relational::postProcessor::*;
import meta::relational::tests::postProcessor::nonExecutable::*;


function <<test.BeforePackage>> meta::relational::tests::postProcessor::setUp():Boolean[1]
{
    createTablesAndFillDb();
}

function <<test.Test>> meta::relational::tests::postProcessor::testReplaceTablePostProcessor():Boolean[1]
{
   let oldTable = db->schema('default')->toOne()->table('personTable')->toOne();
   let newTable = db->schema('default')->toOne()->table('differentPersonTable')->toOne();
   let result = execute(|Person.all(), simpleRelationalMapping, runtimeWithTableReplace(pair($oldTable, $newTable)), meta::relational::extension::relationalExtensions());

   assertSameSQL('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from differentPersonTable as "root"', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::testReplaceTableMultiplePostProcessor():Boolean[1]
{

   let oldTable = db->schema('default')->toOne()->table('personTable')->toOne();
   let newTable = db->schema('default')->toOne()->table('differentPersonTable')->toOne();

   let runtime = ^meta::core::runtime::Runtime
   (
      connectionStores =
      ^meta::core::runtime::ConnectionStore(
        element = db,
        connection=^meta::external::store::relational::runtime::TestDatabaseConnection(
                        type=DatabaseType.H2,
                        sqlQueryPostProcessors = [{query:SelectSQLQuery[1] | replaceTables($query, pair($oldTable, $newTable)) }, {query:SelectSQLQuery[1] | replaceTables($query, pair($newTable, $oldTable))}]
                    )
      )
   );

   let result = execute(|Person.all(), simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());

   assertSameSQL('select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root"', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::testReplaceTablesPostProcessor():Boolean[1]
{
   let pair1 = pair(db->schema('default')->toOne()->table('personTable')->toOne(),db->schema('default')->toOne()->table('differentPersonTable')->toOne());
   let pair2 = pair(db->schema('default')->toOne()->table('firmTable')->toOne(),db->schema('default')->toOne()->table('otherFirmTable')->toOne());
   let result = execute(|Firm.all()->project([f|$f.legalName, f|$f.employees.firstName],['firm', 'employee']), simpleRelationalMapping, runtimeWithTableReplace([$pair1, $pair2]), meta::relational::extension::relationalExtensions());

   assertSameSQL('select "root".LEGALNAME as "firm", "persontable_0".FIRSTNAME as "employee" from otherFirmTable as "root" left outer join differentPersonTable as "persontable_0" on ("root".ID = "persontable_0".FIRMID)', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::testToSqlStringReplaceTablesPostProcessor():Boolean[1]
{
   let pair1 = pair(db->schema('default')->toOne()->table('personTable')->toOne(),db->schema('default')->toOne()->table('differentPersonTable')->toOne());
   let pair2 = pair(db->schema('default')->toOne()->table('firmTable')->toOne(),db->schema('default')->toOne()->table('otherFirmTable')->toOne());
   let sql = meta::relational::functions::sqlstring::toSQLStringPretty(|Firm.all()->project([f|$f.legalName, f|$f.employees.firstName],['firm', 'employee']), simpleRelationalMapping, runtimeWithTableReplace([$pair1, $pair2]), meta::relational::extension::relationalExtensions());

   assertSameSQL('select "root".LEGALNAME as "firm", "persontable_0".FIRSTNAME as "employee" from otherFirmTable as "root" left outer join differentPersonTable as "persontable_0" on ("root".ID = "persontable_0".FIRMID)', $sql->replace('\n', '')->replace('\t', ''));
}

function <<test.Test>> meta::relational::tests::postProcessor::testReplaceTablePostProcessorWithExists():Boolean[1]
{
   let oldTable = db->schema('default')->toOne()->table('personTable')->toOne();
   let newTable = db->schema('default')->toOne()->table('differentPersonTable')->toOne();
   let result = execute(|Firm.all()->filter(f | $f.employees->exists(p | $p.firstName == 'John')), simpleRelationalMapping, runtimeWithTableReplace(pair($oldTable, $newTable)), meta::relational::extension::relationalExtensions());

   assertSameSQL( 'select "root".ID as "pk_0", "root".LEGALNAME as "legalName" from firmTable as "root" left outer join (select distinct "persontable_1".FIRMID from differentPersonTable as "persontable_1" where "persontable_1".FIRSTNAME = \'John\') as "persontable_0" on ("root".ID = "persontable_0".FIRMID) where "persontable_0".FIRMID is not null', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::testReplaceTablePostProcessorWithView():Boolean[1]
{
   let oldTable = db->schema('default')->toOne()->table('personTable')->toOne();
   let newTable = db->schema('default')->toOne()->table('differentPersonTable')->toOne();
   let result = execute(|Order.all()->filter(o|$o.pnlContact->exists( p| $p.firm.legalName == 'Johnson')), meta::relational::tests::query::view::relationalMappingWithViewAndInnerJoin, runtimeWithTableReplace(pair($oldTable, $newTable)), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime" from orderTable as "root" left outer join (select distinct "salespersontable_1".ACCOUNT_ID from (select "salespersontable_1".ACCOUNT_ID as ACCOUNT_ID, "personfirmview_0".firm_name as firm_name from salesPersonTable as "salespersontable_1" inner join (select "root".ID as PERSON_ID, "root".LASTNAME as lastName, "firmtable_0".LEGALNAME as firm_name from differentPersonTable as "root" left outer join firmTable as "firmtable_0" on ("firmtable_0".ID = "root".FIRMID)) as "personfirmview_0" on ("salespersontable_1".PERSON_ID = "personfirmview_0".PERSON_ID) where "personfirmview_0".firm_name = \'Johnson\') as "salespersontable_1" where "salespersontable_1".firm_name = \'Johnson\') as "salespersontable_0" on ("root".accountID = "salespersontable_0".ACCOUNT_ID) where "salespersontable_0".ACCOUNT_ID is not null', $result);
}

function meta::relational::tests::postProcessor::runtimeWithTableReplace(oldToNewPairs:Pair<Table,Table>[*] ):meta::core::runtime::Runtime[1]
{

   let runtime = ^meta::core::runtime::Runtime
   (
      connectionStores =
      ^meta::core::runtime::ConnectionStore(
        element = db,
        connection=^meta::external::store::relational::runtime::TestDatabaseConnection(
                        type=DatabaseType.H2,
                        sqlQueryPostProcessorsConnectionAware = [{query:SelectSQLQuery[1],conn:meta::external::store::relational::runtime::DatabaseConnection[1] | replaceTables($query, $oldToNewPairs) }]
                    ))
   );
}


function <<test.Test>> meta::relational::tests::postProcessor::nonExecutable::testReplaceTablePostProcessorWithSubQueries():Boolean[1]
{

   let result = execute(|Trade.all()->filter(t | $t.product.cusipSynonym.name == 'CUSIP1')
                          ->groupBy([t|$t.product.cusipSynonym.name],
                                  agg(x|$x.quantity, y|$y->sum()),
                                    ['Cusip', 'Total Quantity']), simpleRelationalMapping, runtimeWithNonExecutable(), meta::relational::extension::relationalExtensions());

   assertSameSQL('select "synonymtable_0".NAME as "Cusip", sum("root".quantity) as "Total Quantity" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) left outer join (select "synonymtable_0".PRODID as PRODID, "synonymtable_0".NAME as NAME from productSchema.synonymTable as "synonymtable_0" where "synonymtable_0".TYPE = \'CUSIP\' and 1 = 2) as "synonymtable_0" on ("synonymtable_0".PRODID = "producttable_0".ID) left outer join productSchema.synonymTable as "synonymtable_1" on ("synonymtable_1".PRODID = "producttable_0".ID and "synonymtable_1".TYPE = \'CUSIP\') where "synonymtable_1".NAME = \'CUSIP1\' and 1 = 2 group by "Cusip"', $result);
}


function meta::relational::tests::postProcessor::nonExecutable::runtimeWithNonExecutable():meta::core::runtime::Runtime[1]
{

   let runtime = ^meta::core::runtime::Runtime
   (
    connectionStores =
      ^meta::core::runtime::ConnectionStore(
        element = db,
        connection=^meta::external::store::relational::runtime::TestDatabaseConnection(
                        type=DatabaseType.H2,
                        sqlQueryPostProcessors = [{query:SelectSQLQuery[1] | nonExecutable($query, meta::relational::extension::relationalExtensions()) }]
                    ))
   );
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorSimpleObjectFilterEqual():Boolean[1]
{
   let result = execute(|Trade.all()->filter(x | $x.id == 100)->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate']), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id = 100 group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id = 100) where "root".ID = 100', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorSimpleTDSFilterEqual():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate'])->filter(x | $x.getInteger('TradeID') == 100), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id = 100 group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id = 100) where "root".ID = 100', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorTDSFilterGreaterThan():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate'])->filter(x | $x.getInteger('TradeID') > 100), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id > 100 group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id > 100) where "root".ID > 100', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorTDSFilterGreaterThanWithDyna():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate'])->filter(x | $x.getInteger('TradeID') > (100 + 2)), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id > 100 + 2 group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id > 100 + 2) where "root".ID > 100 + 2', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorTDSFilterUnaryOp():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate'])->filter(x | $x.getInteger('TradeID')->isNotEmpty()), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id is not null group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id is not null) where "root".ID is not null', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorTDSFilterInOp():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate'])->filter(x | $x.getInteger('TradeID')->in([1,2,3,4,5])), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id in (1, 2, 3, 4, 5) group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id in (1, 2, 3, 4, 5)) where "root".ID in (1, 2, 3, 4, 5)', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorTDSFilterAndOp():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate'])->filter(x | ($x.getInteger('TradeID') > 0) && ($x.getInteger('TradeID') <= 5)), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id > 0 and "root".trade_id <= 5 group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id > 0 and "tradeeventviewmaxtradeeventdate_0".trade_id <= 5) where "root".ID > 0 and "root".ID <= 5', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorTDSFilterOrOp():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate'])->filter(x | !(($x.getInteger('TradeID') <= 0) || ($x.getInteger('TradeID') > 5))), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id) where not ("root".ID <= 0 or "root".ID > 5)', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorTDSFilterCombinedOp():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate'])->filter(x | $x.getInteger('TradeID')->isNotEmpty() && $x.getInteger('TradeID')->in([1,2])), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id is not null and "root".trade_id in (1, 2) group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id is not null and "tradeeventviewmaxtradeeventdate_0".trade_id in (1, 2)) where "root".ID is not null and "root".ID in (1, 2)', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorTDSFilterCombinedWithOrOp():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate], ['TradeID', 'Quantity', 'LastEventDate'])->filter(x | $x.getInteger('TradeID')->isNotEmpty() && !(($x.getInteger('TradeID') <= 0) || ($x.getInteger('TradeID') > 5))), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id is not null group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id is not null) where "root".ID is not null and not ("root".ID <= 0 or "root".ID > 5)', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorMultipleChildren():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate, x|$x.initiator.firstName], ['TradeID', 'Quantity', 'LastEventDate', 'Initiator'])->filter(x | $x.getInteger('TradeID')->in([1,2,3,4,5])), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate", "persontable_0".FIRSTNAME as "Initiator" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id in (1, 2, 3, 4, 5) group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id in (1, 2, 3, 4, 5)) left outer join tradeEventTable as "tradeeventtable_1" on ("root".ID = "tradeeventtable_1".trade_id and "tradeeventtable_1".trade_id in (1, 2, 3, 4, 5) and "tradeeventtable_1".eventDate = "root".tradeDate) left outer join personTable as "persontable_0" on ("tradeeventtable_1".person_id = "persontable_0".ID) where "root".ID in (1, 2, 3, 4, 5)', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownIntoSubQuery():Boolean[1]
{
  let result = execute(
    {|Trade.all()
        ->project(
          [
            x|$x.id,
            x|$x.date,
            x|$x.quantity,
            x|$x.product.name,
            x|$x.latestEventDate
          ],
          [
            'TradeID',
            'TradeDate',
            'Quantity',
            'Product',
            'LastEventDate'
          ]
        )
        ->distinct()
        ->restrict(
          [
            'TradeID',
            'TradeDate',
            'Quantity',
            'Product'
          ]
        )
        ->filter(x | $x.getInteger('TradeID') == 1)
    },
    simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions()
  );
  
  assertSameSQL('select "tradetable_0"."TradeID" as "TradeID", "tradetable_0"."TradeDate" as "TradeDate", "tradetable_0"."Quantity" as "Quantity", "tradetable_0"."Product" as "Product" from (select distinct "root".ID as "TradeID", "root".tradeDate as "TradeDate", "root".quantity as "Quantity", "producttable_0".NAME as "Product", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id = 1 group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id = 1) where "root".ID = 1) as "tradetable_0" where "tradetable_0"."TradeID" = 1', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownIntoSubQueryWithTDSJoin():Boolean[1]
{
  let result = execute(
    {|Trade.all()
        ->project(
          [
            x|$x.id,
            x|$x.date
          ],
          [
            'TradeID',
            'TradeDate'
          ]
        )
        ->join(
          Trade.all()
            ->project(
              [
                x|$x.id,
                x|$x.product.name
              ],
              [
                'TradeID',
                'ProductName'
              ]
            ),
            JoinType.INNER,
            ['TradeID']
        )
        ->filter(x | $x.getInteger('TradeID') == 1)
    },
    simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions()
  );
  
  assertSameSQL('select "tradetable_0"."TradeID" as "TradeID", "tradetable_0"."TradeDate" as "TradeDate", "tradetable_0"."ProductName" as "ProductName" from (select "tradetable_1"."TradeID" as "TradeID", "tradetable_1"."TradeDate" as "TradeDate", "tradetable_3"."ProductName" as "ProductName" from (select "root".ID as "TradeID", "root".tradeDate as "TradeDate" from tradeTable as "root" where "root".ID = 1) as "tradetable_1" inner join (select "root".ID as "TradeID", "producttable_0".NAME as "ProductName" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) where "root".ID = 1) as "tradetable_3" on ("tradetable_1"."TradeID" = "tradetable_3"."TradeID" and "tradetable_3"."TradeID" = 1) where "tradetable_1"."TradeID" = 1) as "tradetable_0" where "tradetable_0"."TradeID" = 1', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownIntoSubQueryWithTDSJoinPartial():Boolean[1]
{
  let result = execute(
    {|Trade.all()
        ->project(
          [
            x|$x.id,
            x|$x.product.name
          ],
          [
            'TradeID',
            'ProductName'
          ]
        )
        ->join(
          Product.all()
            ->project(
              [
                x|$x.name,
                x|$x.cusip
              ],
              [
                'ProductName',
                'CUSIP'
              ]
            ),
            JoinType.INNER,
            ['ProductName']
        )
        ->filter(x | $x.getInteger('TradeID') == 1)
    },
    simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions()
  );
  
  assertSameSQL('select "tradetable_0"."TradeID" as "TradeID", "tradetable_0"."ProductName" as "ProductName", "tradetable_0"."CUSIP" as "CUSIP" from (select "tradetable_1"."TradeID" as "TradeID", "tradetable_1"."ProductName" as "ProductName", "producttable_1"."CUSIP" as "CUSIP" from (select "root".ID as "TradeID", "producttable_0".NAME as "ProductName" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) where "root".ID = 1) as "tradetable_1" inner join (select "root".NAME as "ProductName", "synonymtable_0".NAME as "CUSIP" from productSchema.productTable as "root" left outer join productSchema.synonymTable as "synonymtable_0" on ("synonymtable_0".PRODID = "root".ID and "synonymtable_0".TYPE = \'CUSIP\')) as "producttable_1" on ("tradetable_1"."ProductName" = "producttable_1"."ProductName") where "tradetable_1"."TradeID" = 1) as "tradetable_0" where "tradetable_0"."TradeID" = 1', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownIntoSubQueryWithGroupByGroupingColumnsFilter():Boolean[1]
{
  let result = execute(
    {|Trade.all()
        ->groupBy(
          [
            x|$x.date,
            x|$x.product.name
          ],
          [
            agg(x|$x.id, y|$y->count()),
            agg(x|$x.quantity, y|$y->sum())
          ],
          [
            'TradeDate',
            'Product',
            'TradeCount',
            'QtySum'
          ]
        )
        ->distinct()
        ->restrict(
          [
            'TradeDate',
            'Product',
            'TradeCount',
            'QtySum'
          ]
        )
        ->filter(x | ($x.isNotNull('TradeDate')) && ($x.getString('Product') == 'Product A'))
    },
    simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions()
  );

  assertSameSQL('select "tradetable_0"."TradeDate" as "TradeDate", "tradetable_0"."Product" as "Product", "tradetable_0"."TradeCount" as "TradeCount", "tradetable_0"."QtySum" as "QtySum" from (select distinct "root".tradeDate as "TradeDate", "producttable_0".NAME as "Product", count("root".ID) as "TradeCount", sum("root".quantity) as "QtySum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) where "root".tradeDate is not null and "producttable_0".NAME = \'Product A\' group by "TradeDate", "Product") as "tradetable_0" where "tradetable_0"."TradeDate" is not null and "tradetable_0"."Product" = \'Product A\'', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownIntoSubQueryWithGroupByGroupingAndAggregateColumnsFilter():Boolean[1]
{
  let result = execute(
    {|Trade.all()
        ->groupBy(
          [
            x|$x.date,
            x|$x.product.name
          ],
          [
            agg(x|$x.id, y|$y->count()),
            agg(x|$x.quantity, y|$y->sum())
          ],
          [
            'TradeDate',
            'Product',
            'TradeCount',
            'QtySum'
          ]
        )
        ->distinct()
        ->restrict(
          [
            'TradeDate',
            'Product',
            'TradeCount',
            'QtySum'
          ]
        )
        ->filter(x | ($x.isNotNull('TradeDate')) && ($x.getString('Product') == 'Product A') && ($x.getInteger('TradeCount') > 2) && ($x.getFloat('QtySum') > 20))
    },
    simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions()
  );
  
  // Filters on aggregate columns are not pushed into having clause of the subquery, as currently targeting columns with relOp being a TableAliasColumn
  assertSameSQL('select "tradetable_0"."TradeDate" as "TradeDate", "tradetable_0"."Product" as "Product", "tradetable_0"."TradeCount" as "TradeCount", "tradetable_0"."QtySum" as "QtySum" from (select distinct "root".tradeDate as "TradeDate", "producttable_0".NAME as "Product", count("root".ID) as "TradeCount", sum("root".quantity) as "QtySum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) where "root".tradeDate is not null and "producttable_0".NAME = \'Product A\' group by "TradeDate", "Product") as "tradetable_0" where "tradetable_0"."TradeDate" is not null and "tradetable_0"."Product" = \'Product A\' and "tradetable_0"."TradeCount" > 2 and "tradetable_0"."QtySum" > 20', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::filterPushDown::testPushFiltersDownToJoinsPostProcessorToSQL():Boolean[1]
{
   let result = meta::relational::functions::sqlstring::toSQL(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate, x|$x.initiator.firstName], ['TradeID', 'Quantity', 'LastEventDate', 'Initiator'])->filter(x | $x.getInteger('TradeID')->in([1,2,3,4,5])), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions()).sqlQueries->at(0)->meta::relational::functions::sqlQueryToString::sqlQueryToString(DatabaseType.H2, '', [], meta::relational::extension::relationalExtensions());
   assertEquals('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate", "persontable_0".FIRSTNAME as "Initiator" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id in (1, 2, 3, 4, 5) group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id in (1, 2, 3, 4, 5)) left outer join tradeEventTable as "tradeeventtable_1" on ("root".ID = "tradeeventtable_1".trade_id and "tradeeventtable_1".trade_id in (1, 2, 3, 4, 5) and "tradeeventtable_1".eventDate = "root".tradeDate) left outer join personTable as "persontable_0" on ("tradeeventtable_1".person_id = "persontable_0".ID) where "root".ID in (1, 2, 3, 4, 5)', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::testSqlRealiasJoin():Boolean[1]
{
   let result = execute(|Trade.all()->project([x|$x.id, x|$x.quantity, x|$x.latestEventDate, x|$x.initiator.firstName], ['TradeID', 'Quantity', 'LastEventDate', 'Initiator'])->filter(x | $x.getInteger('TradeID')->in([1,2,3,4,5])), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions(), noDebug());
   assertSameSQL('select "root".ID as "TradeID", "root".quantity as "Quantity", "tradeeventviewmaxtradeeventdate_0".maxTradeEventDate as "LastEventDate", "persontable_0".FIRSTNAME as "Initiator" from tradeTable as "root" left outer join (select "root".trade_id as trade_id, max("root".eventDate) as maxTradeEventDate from tradeEventTable as "root" where "root".trade_id in (1, 2, 3, 4, 5) group by "root".trade_id) as "tradeeventviewmaxtradeeventdate_0" on ("root".ID = "tradeeventviewmaxtradeeventdate_0".trade_id and "tradeeventviewmaxtradeeventdate_0".trade_id in (1, 2, 3, 4, 5)) left outer join tradeEventTable as "tradeeventtable_1" on ("root".ID = "tradeeventtable_1".trade_id and "tradeeventtable_1".trade_id in (1, 2, 3, 4, 5) and "tradeeventtable_1".eventDate = "root".tradeDate) left outer join personTable as "persontable_0" on ("tradeeventtable_1".person_id = "persontable_0".ID) where "root".ID in (1, 2, 3, 4, 5)', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::testSqlRealiasViews():Boolean[1]
{
   let result = execute(|AccountPnl.all(), simpleRelationalMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameElements(['Account 1,100.0', 'Account 2,350.0'], $result.values->map(p|[$p.account->toOne().name, $p.pnl]->makeString(',')));
   assertEquals('select "root".accountId as "pk_0", "root".orderPnl as "pnl" from (select "root".accountID as accountId, sum("orderpnltable_0".pnl) as orderPnl from orderTable as "root" left outer join orderPnlTable as "orderpnltable_0" on ("orderpnltable_0".ORDER_ID = "root".ID) group by "root".accountID) as "root"', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::postProcessor::testSqlRealiasFreeMarker():Boolean[1]
{
   let result = execute({| let type = meta::relational::tests::model::simple::ProductSynonymType.CUSIP;
                           meta::relational::tests::model::simple::Trade.all()->filter(x|$x.product->toOne().synonymByType(meta::relational::tests::model::simple::ProductSynonymType.CUSIP).type == $type)->project([t|$t.product.name],['id'])->distinct();},
                           simpleRelationalMapping,  meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameElements(['Firm A,Firm C,Firm X'], $result.values.rows->map(r|$r.values)->makeString(','));
   assertSameSQL('select distinct "producttable_0".NAME as "id" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) left outer join productSchema.synonymTable as "synonymtable_0" on ("synonymtable_0".PRODID = "producttable_0".ID and "synonymtable_0".TYPE = \'CUSIP\') where "synonymtable_0".TYPE = \'CUSIP\'', $result);
}

function <<test.Test>> meta::relational::tests::postProcessor::testSQLRealiasCaseSensitiveTableNames():Boolean[1]
{
  let result = execute(|Firm.all()->project([f|$f.employees.firstName, f|$f.employees.age],['firstName', 'age']), caseSentitiveMapping, meta::external::store::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
  assertEquals('select "personset_0".firstName as "firstName", "personset_1".age as "age" from schemaA.firmSet as "root" left outer join schemaA.personset as "personset_0" on ("root".ID = "personset_0".FirmID) left outer join schemaB.PERSONSET as "personset_1" on ("personset_0".ID = "personset_1".ID)',$result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::postProcessor::testDb2ColumnRename():Boolean[1]
{
   let runtime = ^meta::core::runtime::Runtime(connectionStores = ^meta::core::runtime::ConnectionStore(element = meta::relational::tests::mapping::union::myDB, connection=^meta::external::store::relational::runtime::TestDatabaseConnection(type = DatabaseType.DB2)));
   let result = meta::relational::functions::sqlstring::toSQL(|Person.all()->project([p|$p.lastName], ['name']), meta::relational::tests::mapping::union::unionMappingWithLongPropertyMapping, $runtime, meta::relational::extension::relationalExtensions()).sqlQueries->at(0)->cast(@SelectSQLQuery)->meta::relational::postProcessor::reAliasColumnName::trimColumnName($runtime).values->meta::relational::functions::sqlQueryToString::sqlQueryToString(DatabaseType.DB2, '', [], meta::relational::extension::relationalExtensions());
   assertEquals('select "unionBase"."concat_thisStringIsThisLongMakeTheGeneratedAliasExplodePastTheDb2limitOf128Characters_concat_ForTestPurposesOnly_Perso_0" as "name" from (select "root".ID as "pk_0_0", null as "pk_0_1", (\'thisStringIsThisLongMakeTheGeneratedAliasExplodePastTheDb2limitOf128Characters\' concat (\'ForTestPurposesOnly\' concat "root".lastName_s1)) as "concat_thisStringIsThisLongMakeTheGeneratedAliasExplodePastTheDb2limitOf128Characters_concat_ForTestPurposesOnly_Perso_0" from PersonSet1 as "root" UNION ALL select null as "pk_0_0", "root".ID as "pk_0_1", (\'thisStringIsThisLongMakeTheGeneratedAliasExplodePastTheDb2limitOf128Characters\' concat (\'ForTestPurposesOnly\' concat "root".lastName_s2)) as "concat_thisStringIsThisLongMakeTheGeneratedAliasExplodePastTheDb2limitOf128Characters_concat_ForTestPurposesOnly_Perso_0" from PersonSet2 as "root") as "unionBase"',$result);
}

function <<test.Test>> meta::relational::tests::postProcessor::testPostProcessTransformJoinOp():Boolean[1]
{
   let runtime = meta::external::store::relational::tests::testRuntime();
   let connectionStore = $runtime.connectionStores->at(0);
   let conn = $connectionStore.connection->cast(@meta::external::store::relational::runtime::TestDatabaseConnection);
   let runtimeWithPostProcessor = ^$runtime(connectionStores = ^$connectionStore(connection=^$conn(sqlQueryPostProcessors= [{query:meta::relational::metamodel::relation::SelectSQLQuery[1] | $query->meta::relational::postProcessor::postprocess({rel | $rel->match([t:TableAliasColumn[1] | if($t.column.type->instanceOf(meta::relational::metamodel::datatype::Integer), | ^Literal(value=2), |$t ) , r:RelationalOperationElement[1] |$r])}) }])));

   let result = meta::relational::functions::sqlstring::toSQL(|Trade.all()->project([x|$x.id, x|$x.initiator.name], ['TradeID', 'Initiator']), simpleRelationalMapping, $runtimeWithPostProcessor, meta::relational::extension::relationalExtensions()).sqlQueries->at(0)->cast(@SelectSQLQuery)->meta::relational::functions::sqlQueryToString::sqlQueryToString(DatabaseType.H2, '', [], meta::relational::extension::relationalExtensions());
   assertEquals('select 2 as "TradeID", concat("persontable_0".FIRSTNAME, \' \', "persontable_0".LASTNAME) as "Initiator" from tradeTable as "root" left outer join tradeEventTable as "tradeeventtable_0" on (2 = 2 and "tradeeventtable_0".eventDate = "root".tradeDate) left outer join personTable as "persontable_0" on (2 = 2)', $result);
}
