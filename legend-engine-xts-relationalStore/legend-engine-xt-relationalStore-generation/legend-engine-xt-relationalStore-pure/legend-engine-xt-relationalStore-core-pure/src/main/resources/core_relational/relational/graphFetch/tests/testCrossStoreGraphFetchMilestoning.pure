// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::graphFetch::tests::XStore::milestoning::*;

Class meta::pure::graphFetch::tests::XStore::milestoning::Trade
{
  customerEntityId: Integer[0..1];
  tradeID: String[0..1];
}

Class meta::pure::graphFetch::tests::XStore::milestoning::SourceTrade
{
  s_customerEntityId: Integer[0..1];
  s_tradeID: String[0..1];

}

Class <<meta::pure::profiles::temporal.bitemporal>> meta::pure::graphFetch::tests::XStore::milestoning::LegalEntity
{
  id: Integer[1];
  address: Address[1];
}

Class <<meta::pure::profiles::temporal.businesstemporal>> meta::pure::graphFetch::tests::XStore::milestoning::Address
{
  country: String[1];
}

Association meta::pure::graphFetch::tests::XStore::milestoning::Trade_CustomerLegalEntity
{
  trade: Trade[*];
  customer: LegalEntity[0..1];
}


###Relational
Database meta::pure::graphFetch::tests::XStore::milestoning::EntityStore
(
  Schema Entity
  (
    Table Entity
    (
      milestoning
      (
        processing(PROCESSING_IN=in_z, PROCESSING_OUT=out_z, INFINITY_DATE=%9999-12-31T00:00:00.0000),
        business(BUS_FROM=from_z, BUS_THRU=thru_z, INFINITY_DATE=%9999-12-31T00:00:00.0000)
      )

      entityId INTEGER PRIMARY KEY,
      country VARCHAR(50),
      in_z DATE,
      out_z DATE,
      from_z DATE,
      thru_z DATE
    )
  )

  Join Entity_Self(Entity.Entity.entityId = {target}.entityId)
)

###Relational
Database meta::pure::graphFetch::tests::XStore::milestoning::TradeStore
(
  Schema Trade
  (
    Table Trade
    (
      tradeID  VARCHAR(50) PRIMARY KEY,
      customerEntityId INTEGER
    )
  )

)


###Mapping
import meta::pure::graphFetch::tests::XStore::milestoning::*;

Mapping meta::pure::graphFetch::tests::XStore::milestoning::LegalEntityMapping
(
  *LegalEntity[legal_entity]: Relational
  {
    ~primaryKey
    (
      [EntityStore]Entity.Entity.entityId
    )
    ~mainTable [EntityStore]Entity.Entity
    id: [EntityStore]Entity.Entity.entityId,
    address
    (
      country: [EntityStore]Entity.Entity.country
    )
  }
)

Mapping meta::pure::graphFetch::tests::XStore::milestoning::TradeLinkageMapping
(
  include LegalEntityMapping

  *Trade[trade_self]: Pure
  {
    ~src Trade
    customerEntityId: $src.customerEntityId
  }

  Trade_CustomerLegalEntity: XStore
  {
    customer[trade_self, legal_entity]: $this.customerEntityId == $that.id
  }
)


Mapping meta::pure::graphFetch::tests::XStore::milestoning::TradeLinkageMappingForModelChain
(
  include LegalEntityMapping

  *Trade[trade_self]: Pure
  {
    ~src SourceTrade
    customerEntityId: $src.s_customerEntityId,
    tradeID: $src.s_tradeID
  }

    *SourceTrade: Relational
  {
    ~primaryKey
    (
      [TradeStore]Trade.Trade.tradeID
    )
    ~mainTable [TradeStore]Trade.Trade
    s_customerEntityId: [TradeStore]Trade.Trade.customerEntityId,
    s_tradeID: [TradeStore]Trade.Trade.tradeID

  }
  Trade_CustomerLegalEntity: XStore
  {
    customer[trade_self, legal_entity]: $this.customerEntityId == $that.id
  }
)

###Pure
import meta::pure::executionPlan::toString::*;
import meta::pure::executionPlan::*;
import meta::pure::graphFetch::tests::XStore::milestoning::*;
import meta::pure::graphFetch::execution::*;
import meta::core::runtime::*;
function meta::pure::graphFetch::tests::XStore::milestoning::runtime():Runtime[1]
{
  let csvData = 'Create Schema if not exists Entity;\n' +
                'Drop Table if exists Entity.Entity;\n' +
                'Create Table Entity.Entity(entityId INTEGER, country VARCHAR(50), in_z TIMESTAMP, out_z TIMESTAMP, from_z TIMESTAMP, thru_z TIMESTAMP);\n' +
                'INSERT INTO Entity.Entity(entityId,country,in_z, out_z,from_z,thru_z) VALUES (12,\'US\',\'2023-10-12 00:00:00\', \'9999-12-31 00:00:00\', \'2023-10-12 00:00:00\',\'9999-12-31 00:00:00\');\n' +
                'INSERT INTO Entity.Entity(entityId,country,in_z, out_z,from_z,thru_z) VALUES (34,\'US\',\'2023-10-12 00:00:00\', \'9999-12-31 00:00:00\', \'2023-10-18 00:00:00\',\'9999-12-31 00:00:00\');\n' +
                'INSERT INTO Entity.Entity(entityId,country,in_z, out_z,from_z,thru_z) VALUES (34,\'US\',\'2023-10-18 00:00:00\', \'9999-12-31 00:00:00\', \'2023-10-12 00:00:00\',\'9999-12-31 00:00:00\');\n' +
                'INSERT INTO Entity.Entity(entityId,country,in_z, out_z,from_z,thru_z) VALUES (56,\'IE\',\'2023-10-12 00:00:00\', \'9999-12-31 00:00:00\', \'2023-10-12 00:00:00\',\'9999-12-31 00:00:00\');';
  let runtime = ^Runtime( connectionStores = [
                                        ^ConnectionStore(
                                          element = ^meta::external::store::model::ModelStore(),
                                          connection =
                                          ^meta::external::store::model::JsonModelConnection
                                            (
                                              class = Trade,
                                              url = 'data:application/json,\n{"customerEntityId": 12}\n{"customerEntityId": 34}\n{"customerEntityId": 56}\n'
                                            )),
                                        ^ConnectionStore(
                                          element = EntityStore,
                                          connection =
                                          ^meta::external::store::relational::runtime::RelationalDatabaseConnection
                                            (
                                              type = meta::relational::runtime::DatabaseType.H2,
                                              datasourceSpecification = ^meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification(testDataSetupSqls=[$csvData]),
                                              authenticationStrategy = ^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy()
                                            ))]);
}


function meta::pure::graphFetch::tests::XStore::milestoning::runtimeM2M2R():Runtime[1]
{
  let csvData = 'Create Schema if not exists Entity;\n' +
                'Drop Table if exists Entity.Entity;\n' +
                'Create Table Entity.Entity(entityId INTEGER, country VARCHAR(50), in_z TIMESTAMP, out_z TIMESTAMP, from_z TIMESTAMP, thru_z TIMESTAMP);\n' +
                'INSERT INTO Entity.Entity(entityId,country,in_z, out_z,from_z,thru_z) VALUES (12,\'US\',\'2023-10-12 00:00:00\', \'9999-12-31 00:00:00\', \'2023-10-12 00:00:00\',\'9999-12-31 00:00:00\');\n' +
                'INSERT INTO Entity.Entity(entityId,country,in_z, out_z,from_z,thru_z) VALUES (34,\'US\',\'2023-10-12 00:00:00\', \'9999-12-31 00:00:00\', \'2023-10-18 00:00:00\',\'9999-12-31 00:00:00\');\n' +
                'INSERT INTO Entity.Entity(entityId,country,in_z, out_z,from_z,thru_z) VALUES (34,\'US\',\'2023-10-18 00:00:00\', \'9999-12-31 00:00:00\', \'2023-10-12 00:00:00\',\'9999-12-31 00:00:00\');\n' +
                'INSERT INTO Entity.Entity(entityId,country,in_z, out_z,from_z,thru_z) VALUES (56,\'IE\',\'2023-10-12 00:00:00\', \'9999-12-31 00:00:00\', \'2023-10-12 00:00:00\',\'9999-12-31 00:00:00\');\n' +
                'Create Schema if not exists Trade;\n' +
                'Drop Table if exists Trade.Trade;\n' +
                'Create Table Trade.Trade(tradeID VARCHAR(50), customerEntityId INTEGER);\n' +
                'INSERT INTO Trade.Trade(tradeID,customerEntityId) VALUES (\'ABC\',12);\n'

                ;
  let runtime = ^Runtime( connectionStores = [
                                     ^ConnectionStore(
                                           element=^meta::external::store::model::ModelStore(),
                                           connection=
                                           ^meta::external::store::model::ModelChainConnection(mappings = TradeLinkageMappingForModelChain)),
                                     ^ConnectionStore(
                                          element = EntityStore,
                                          connection =
                                          ^meta::external::store::relational::runtime::RelationalDatabaseConnection
                                            (
                                              type = meta::relational::runtime::DatabaseType.H2,
                                              datasourceSpecification = ^meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification(testDataSetupSqls=[$csvData]),
                                              authenticationStrategy = ^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy()
                                            )),
                                    ^ConnectionStore(
                                            element = TradeStore,
                                            connection =
                                           ^meta::external::store::relational::runtime::RelationalDatabaseConnection
                                            (
                                              type = meta::relational::runtime::DatabaseType.H2,
                                              datasourceSpecification = ^meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification(testDataSetupSqls=[$csvData]),
                                              authenticationStrategy = ^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy()
                                            ))
                                            ]
                                            );
}

function <<meta::pure::profiles::test.Test, test.AlloyOnly>> meta::pure::graphFetch::tests::XStore::milestoning::CrossStoreGraphFetchWithRelationalMilestoned():Boolean[1]
{
   let query   = {processingDate: StrictDate[1], businessDate: StrictDate[1]|Trade.all()->graphFetch(#{Trade{customer($processingDate, $businessDate){id}}}#)->serialize(#{Trade{customer($processingDate, $businessDate){id}}}#)->meta::pure::mapping::from(TradeLinkageMapping, runtime())};
   let result = meta::legend::executeLegendQuery($query,  [pair('processingDate', '2023-10-15'), pair('businessDate', '2023-10-15')], ^meta::pure::runtime::ExecutionContext(), meta::relational::extension::relationalExtensions());
   assertJsonStringsEqual('{"builder":{"_type":"json"},"values":[{"customer($processingDate, $businessDate)":{"id":12}},{"customer($processingDate, $businessDate)":null},{"customer($processingDate, $businessDate)":{"id":56}}]}', $result);
}

function <<test.Test, test.AlloyOnly>> meta::pure::graphFetch::tests::XStore::milestoning::CrossStoreGraphFetchWithRelationalMilestonedFlowDown():Boolean[1]
{
   let query   = {processingDate: StrictDate[1], businessDate: StrictDate[1]|Trade.all()->graphFetch(#{Trade{customer($processingDate, $businessDate){id, address($businessDate){country}}}}#)->serialize(#{Trade{customer($processingDate, $businessDate){id, address($businessDate){country}}}}#)->meta::pure::mapping::from(TradeLinkageMapping, runtime())};
   let result = meta::legend::executeLegendQuery($query,  [pair('processingDate', '2023-10-15'), pair('businessDate', '2023-10-15')], ^meta::pure::runtime::ExecutionContext(), meta::relational::extension::relationalExtensions());
   assertJsonStringsEqual('{"builder":{"_type":"json"},"values":[{"customer($processingDate, $businessDate)":{"id":12,"address($businessDate)":{"country":"US"}}},{"customer($processingDate, $businessDate)":null},{"customer($processingDate, $businessDate)":{"id":56,"address($businessDate)":{"country":"IE"}}}]}', $result);
}



function <<test.Test, test.AlloyOnly>> meta::pure::graphFetch::tests::XStore::milestoning::CrossStoreGraphFetchWithRelationalMilestonedAllversions():Boolean[1]
{
  let query   = {processingDate: StrictDate[1], businessDate: StrictDate[1]|Trade.all()->graphFetch(#{Trade{ customerAllVersions{id},tradeID}}#)->serialize(#{Trade{customerAllVersions{id},tradeID}}#)->meta::pure::mapping::from(TradeLinkageMappingForModelChain, runtimeM2M2R())};
  let result = meta::legend::executeLegendQuery($query,  [pair('processingDate', '2023-10-15'), pair('businessDate', '2023-10-15')], ^meta::pure::runtime::ExecutionContext(), meta::relational::extension::relationalExtensions());
  assertJsonStringsEqual('{"builder":{"_type":"json"},"values":{"customerAllVersions":[{"id":12}],"tradeID":"ABC"}}', $result);

}


function <<test.Test, test.AlloyOnly>> meta::pure::graphFetch::tests::XStore::milestoning::CrossStoreGraphFetchWithRelationalMilestonedFlowDownM2M():Boolean[1]
{
   let query   = {processingDate: StrictDate[1], businessDate: StrictDate[1]|Trade.all()->graphFetch(#{Trade{customer($processingDate, $businessDate){id, address($businessDate){country}}}}#)->serialize(#{Trade{customer($processingDate, $businessDate){id, address($businessDate){country}}}}#)->meta::pure::mapping::from(TradeLinkageMappingForModelChain, runtimeM2M2R())};
   let result = meta::legend::executeLegendQuery($query,  [pair('processingDate', '2023-10-15'), pair('businessDate', '2023-10-15')], ^meta::pure::runtime::ExecutionContext(), meta::relational::extension::relationalExtensions());
   assertJsonStringsEqual('{"builder":{"_type":"json"},"values":{"customer($processingDate, $businessDate)":{"id":12,"address($businessDate)":{"country":"US"}}}}', $result);
}

function <<test.Test, test.AlloyOnly>> meta::pure::graphFetch::tests::XStore::milestoning::testCrossStoreGraphFetchWithRelationalDatePropagationForMilestonedPropertyConstraint(): Boolean[1]
{
  let grammar = '###Relational\n' +
                    'Database test::stores::testDB\n' +
                    '(\n' +
                    '  Schema TEST_SCHEMA\n' +
                    '  (\n' +
                    '    Table FIRM_TABLE\n' +
                    '    (\n' +
                    '      milestoning\n' +
                    '      (\n' +
                    '        business(BUS_FROM = from_z, BUS_THRU = thru_z, INFINITY_DATE = %9999-12-31T00:00:00.0000)\n' +
                    '      )\n' +
                    '\n' +
                    '      ID VARCHAR(10) PRIMARY KEY,\n' +
                    '      LEGALNAME VARCHAR(100),\n' +
                    '      ADDRESS VARCHAR(100),\n' +
                    '      from_z TIMESTAMP,\n' +
                    '      thru_z TIMESTAMP PRIMARY KEY\n' +
                    '    )\n' +
                    '  )\n' +
                    ')\n' +
                    '\n' +
                    '###ExternalFormat\n' +
                    'Binding test::binding::FirmIdInputBinding\n' +
                    '{\n' +
                    '  contentType: \'application/json\';\n' +
                    '  modelIncludes: [\n' +
                    '    test::model::FirmIdInput\n' +
                    '  ];\n' +
                    '}\n' +
                    '\n' +
                    '\n' +
                    '###Pure\n' +
                    'Class test::model::FirmOutput\n' +
                    '{\n' +
                    '  firmId: String[1];\n' +
                    '  firmTarget: test::model::FirmTarget[0..1];\n' +
                    '}\n' +
                    '\n' +
                    'Class <<temporal.businesstemporal>> test::model::Firm\n' +
                    '[\n' +
                    '  firmMustHaveAddress\n' +
                    '  (\n' +
                    '    ~function: $this.address(%2023-10-12).name->isNotEmpty()\n' +
                    '    ~enforcementLevel: Error\n' +
                    '    ~message: \'Firm should have legal name\'\n' +
                    '  )\n' +
                    ']\n' +
                    '{\n' +
                    '  id: String[1];\n' +
                    '  legalName: String[1];\n' +
                    '  address: test::model::Address[1];\n' +
                    '  from_z: Date[1];\n' +
                    '  thru_z: Date[1];\n' +
                    '}\n' +
                    '\n' +
                    'Class test::model::FirmIdInput\n' +
                    '{\n' +
                    '  firmId: String[1];\n' +
                    '}\n' +
                    '\n' +
                    'Class test::model::FirmIdInputEnriched extends test::model::FirmIdInput\n' +
                    '{\n' +
                    '}\n' +
                    '\n' +
                    'Class <<temporal.businesstemporal>> test::model::Address\n' +
                    '{\n' +
                    '  name: String[1];\n' +
                    '}\n' +
                    '\n' +
                    'Class test::model::FirmTarget\n' +
                    '{\n' +
                    '  legalName: String[0..1];\n' +
                    '}\n' +
                    '\n' +
                    'Association test::model::FirmIdInputEnriched_Firm\n' +
                    '{\n' +
                    '  firm: test::model::Firm[1];\n' +
                    '  firmIdInputEnriched: test::model::FirmIdInputEnriched[*];\n' +
                    '}\n' +
                    '\n' +
                    'function test::function::getFirmXstoreFunc(collection: test::model::FirmOutput[*]): test::model::FirmOutput[*]\n' +
                    '{\n' +
                    '  $collection->graphFetch(\n' +
                    '    #{\n' +
                    '      test::model::FirmOutput{\n' +
                    '        firmId,\n' +
                    '        firmTarget{\n' +
                    '          legalName\n' +
                    '        }\n' +
                    '      }\n' +
                    '    }#\n' +
                    '  )\n' +
                    '}\n' +
                    '\n' +
                    'function test::function::finalQuery(var_1: String[1]): String[1]\n' +
                    '{\n' +
                    '  test::model::FirmOutput.all()->test::function::getFirmXstoreFunc()->from(\n' +
                    '    test::mapping::FirmOutputMapping,\n' +
                    '    [\n' +
                    '      test::model::FirmIdInput->getRuntimeWithModelQueryConnection(\n' +
                    '      test::binding::FirmIdInputBinding,\n' +
                    '      $var_1\n' +
                    '    ),\n' +
                    '      test::runtimes::xstoreRuntime\n' +
                    '    ]->mergeRuntimes()\n' +
                    '  )->test::function::getFirmXstoreFunc_serialized()\n' +
                    '}\n' +
                    '\n' +
                    'function test::function::getFirmXstoreFunc_serialized(collection: test::model::FirmOutput[*]): String[1]\n' +
                    '{\n' +
                    '  $collection->serialize(\n' +
                    '    #{\n' +
                    '      test::model::FirmOutput{\n' +
                    '        firmId,\n' +
                    '        firmTarget{\n' +
                    '          legalName\n' +
                    '        }\n' +
                    '      }\n' +
                    '    }#,\n' +
                    '    ^meta::pure::graphFetch::execution::AlloySerializationConfig(typeKeyName=\'@type\' , includeType=true , includeEnumType=false , removePropertiesWithNullValues=true , removePropertiesWithEmptySets=true , fullyQualifiedTypePath=false)\n' +
                    '  )\n' +
                    '}\n' +
                    '\n' +
                    '\n' +
                    '###Mapping\n' +
                    'Mapping test::mapping::firmMappingRelational\n' +
                    '(\n' +
                    '  *test::model::Firm[firm]: Relational\n' +
                    '  {\n' +
                    '    ~primaryKey\n' +
                    '    (\n' +
                    '      [test::stores::testDB]TEST_SCHEMA.FIRM_TABLE.ID,\n' +
                    '      [test::stores::testDB]TEST_SCHEMA.FIRM_TABLE.thru_z\n' +
                    '    )\n' +
                    '    ~mainTable [test::stores::testDB]TEST_SCHEMA.FIRM_TABLE\n' +
                    '    id: [test::stores::testDB]TEST_SCHEMA.FIRM_TABLE.ID,\n' +
                    '    legalName: [test::stores::testDB]TEST_SCHEMA.FIRM_TABLE.LEGALNAME,\n' +
                    '    address\n' +
                    '    (\n' +
                    '      name: [test::stores::testDB]TEST_SCHEMA.FIRM_TABLE.ADDRESS\n' +
                    '    ),\n' +
                    '    from_z: [test::stores::testDB]TEST_SCHEMA.FIRM_TABLE.from_z,\n' +
                    '    thru_z: [test::stores::testDB]TEST_SCHEMA.FIRM_TABLE.thru_z\n' +
                    '  }\n' +
                    ')\n' +
                    '\n' +
                    'Mapping test::mapping::FirmIdInputMapping\n' +
                    '(\n' +
                    '  include mapping test::mapping::firmMappingRelational\n' +
                    '\n' +
                    '  test::model::Firm[newFirm] extends [firm]: Relational\n' +
                    '  {\n' +
                    '  }\n' +
                    '  test::model::FirmIdInputEnriched[ip]: Pure\n' +
                    '  {\n' +
                    '    ~src test::model::FirmIdInput\n' +
                    '    firmId: $src.firmId\n' +
                    '  }\n' +
                    '\n' +
                    '  test::model::FirmIdInputEnriched_Firm: XStore\n' +
                    '  {\n' +
                    '    firm[ip, newFirm]: $this.firmId ==\n' +
                    '  $that.id\n' +
                    '  }\n' +
                    ')\n' +
                    '\n' +
                    'Mapping test::mapping::FirmOutputMapping\n' +
                    '(\n' +
                    '  *test::model::FirmOutput: Pure\n' +
                    '  {\n' +
                    '    ~src test::model::FirmIdInputEnriched\n' +
                    '    firmId: $src.firmId,\n' +
                    '    firmTarget[firmTarget]: $src.firm(%2023-10-12)\n' +
                    '  }\n' +
                    '  *test::model::FirmTarget[firmTarget]: Pure\n' +
                    '  {\n' +
                    '    ~src test::model::Firm\n' +
                    '    legalName: $src.legalName\n' +
                    '  }\n' +
                    ')\n' +
                    '\n' +
                    '\n' +
                    '###Connection\n' +
                    'RelationalDatabaseConnection test::connections::testH2Connection\n' +
                    '{\n' +
                    '  store: test::stores::testDB;\n' +
                    '  type: H2;\n' +
                    '  specification: LocalH2\n' +
                    '  {\n' +
                    '    testDataSetupSqls: [\n' +
                    '      \'CREATE SCHEMA IF NOT EXISTS TEST_SCHEMA;DROP TABLE IF EXISTS TEST_SCHEMA.FIRM_TABLE;CREATE TABLE TEST_SCHEMA.FIRM_TABLE (ID VARCHAR(10), LEGALNAME VARCHAR(100), ADDRESS VARCHAR(100), from_z TIMESTAMP, thru_z TIMESTAMP);INSERT INTO TEST_SCHEMA.FIRM_TABLE (ID, LEGALNAME, ADDRESS, from_z, thru_z) VALUES (\\\'1\\\',\\\'FIRM_A\\\', \\\'Mumbai\\\', \\\'2023-10-12 00:00:00\\\',\\\'9999-12-31 00:00:00\\\');\'\n' +
                    '      ];\n' +
                    '  };\n' +
                    '  auth: DefaultH2;\n' +
                    '}\n' +
                    '\n' +
                    '\n' +
                    '###Runtime\n' +
                    'Runtime test::runtimes::xstoreRuntime\n' +
                    '{\n' +
                    '  mappings:\n' +
                    '  [\n' +
                    '    test::mapping::FirmOutputMapping\n' +
                    '  ];\n' +
                    '  connections:\n' +
                    '  [\n' +
                    '    ModelStore:\n' +
                    '    [\n' +
                    '      connection_1:\n' +
                    '      #{\n' +
                    '        ModelChainConnection\n' +
                    '        {\n' +
                    '          mappings: [\n' +
                    '            test::mapping::FirmIdInputMapping\n' +
                    '          ];\n' +
                    '        }\n' +
                    '      }#\n' +
                    '    ],\n' +
                    '    test::stores::testDB:\n' +
                    '    [\n' +
                    '      connection_2: test::connections::testH2Connection\n' +
                    '    ]\n' +
                    '  ];\n' +
                    '}\n';
  let elements = meta::legend::compileLegendGrammar($grammar);
  let function = $elements->filter(e|$e->instanceOf(FunctionDefinition))->at(1)->cast(@ConcreteFunctionDefinition<{String[1]->String[1]}>);
  let expected = '{"builder":{"_type":"json"},"values":{"@type":"FirmOutput","firmId":"1","firmTarget":{"@type":"FirmTarget","legalName":"FIRM_A"}}}';
  assertEquals($expected,meta::legend::executeLegendQuery($function,^Pair<String, String>(first='var_1',second='{"firmId": "1"}'),meta::pure::executionPlan::platformBinding::localBinding::extractClasspathExtensions()));
}