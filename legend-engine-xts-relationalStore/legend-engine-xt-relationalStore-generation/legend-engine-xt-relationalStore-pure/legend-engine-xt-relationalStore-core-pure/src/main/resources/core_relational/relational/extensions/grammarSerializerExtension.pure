import meta::relational::metamodel::join::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::store::*;
import meta::external::store::relational::runtime::*;
import meta::relational::metamodel::relation::*;
import meta::relational::mapping::*;
import meta::relational::metamodel::datatype::*;
import meta::pure::mapping::*;
import meta::relational::metamodel::*;
import meta::relational::grammar::serialization::*;
// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function meta::relational::grammar::serialization::printDatabase(d:Database[1]):String[1]
{
  'Database ' + $d->elementToPath() + '\n' +
  '('+
   $d.includes->map(x|'\n  include ' + $x->elementToPath())->joinStrings('\n') + if($d.includes->isEmpty(), |'', |'\n') +
   $d.schemas->map(
      s | let defaultSchema = if($s.name->toOne()->equalIgnoreCase('DEFAULT'), |true, |false);
          let indent = if($defaultSchema, |'  ', |'    ');
          if($defaultSchema, |'', |'\n  Schema '+$s.name + '\n  (')+
            + $s.tables->map(x|
              '\n'+$indent+'Table '+escapeIdentifier($x.name)+'\n'+$indent+'(\n'+
                  $x.columns->map(z| printDatabaseColumn($z->cast(@meta::relational::metamodel::Column), $x.primaryKey, $indent))->joinStrings(',\n')+
              '\n'+$indent+')'
            )->joinStrings('') +
            if ($s.tabularFunctions->isEmpty(), | '', | '\n') +
            $s.tabularFunctions->map(t | 
              $indent + 'TabularFunction ' + escapeIdentifier($t.name) + '\n' + 
              $indent + '(\n' + 
                $t.columns->map(c | printDatabaseColumn($c->cast(@meta::relational::metamodel::Column), [], $indent))->joinStrings(',\n') + '\n' +
              $indent + ')'
            )->joinStrings('') +
            if ($s.views->isEmpty(), | '', | '\n')+
            $s.views->map(v | 
              let v_indent = $indent + '  ';
              '\n' + $indent + 'View ' + escapeIdentifier($v.name) + '\n' + $indent + '(\n' + 
                  if ($v.filter->isEmpty(), | '', | $v_indent + printFilterMapping($v.filter->toOne()) + '\n') +
                  if ($v.groupBy->isEmpty(), | '', | $v_indent + '~groupBy\n' + $indent + '  (\n' + $v.groupBy.columns->map(g | $v_indent + '  ' + printRelationalOperationElement($g, false))->joinStrings(',\n') + '\n' + $v_indent + ')\n') +
                  if ($v.distinct->isTrue(), | $v_indent + '~distinct\n', | '') +
                  if ($v.columnMappings->isEmpty(), | '', | $v.columnMappings->map(c | printViewColumnMapping($c, $v.primaryKey, $v_indent))->joinStrings(',\n') + '\n') +
              $indent + ')';
            )->joinStrings('')
        +if($defaultSchema, |'', |'\n  )');
    )->joinStrings('')+
    if($d.joins->isEmpty(), |'', |'\n')+
    $d.joins->map(
      j | '\n  Join '+ escapeIdentifier($j.name) +'('+$j.operation->printRelationalOperationElement(false)+')'
    )->joinStrings('')+
    if($d.filters->isEmpty(), |'', |'\n')+
    $d.filters->map(
      f | '\n  '+if($f->instanceOf(MultiGrainFilter), | 'MultiGrainFilter', | 'Filter') + ' ' + escapeIdentifier($f.name) + '(' + $f.operation->printRelationalOperationElement(false) + ')'
    )->joinStrings('')+
  '\n)';
}

function meta::relational::grammar::serialization::printDatabaseColumn(c:Column[1], primaryKey:Column[*], indent:String[1]):String[1]
{
  $indent+ '  ' + escapeIdentifier($c.name) + ' ' + meta::relational::metamodel::datatype::dataTypeToSqlText($c.type)
                + if ($primaryKey->contains($c),
                    |' PRIMARY KEY',
                    |if ($c.nullable->isNotEmpty() && $c.nullable->toOne(), |'', |' NOT NULL')
                  )  
}

function meta::relational::grammar::serialization::escapeIdentifier(name:String[1]):String[1]
{
  if ($name->contains(' ') && !$name->startsWith('"'), | '"' + $name + '"', | $name);
}

function meta::relational::grammar::serialization::printViewColumnMapping(c:ColumnMapping[1], primaryKey:Column[*], indent:String[1]):String[1]
{
  $indent + $c.columnName + ': ' + printRelationalOperationElement($c.relationalOperationElement, false) + if ($primaryKey.name->contains($c.columnName), | ' PRIMARY KEY', | '')
}

function meta::relational::grammar::serialization::printFilterMapping(filterMapping:FilterMapping[1]):String[1]
{
  let joins = flattenJoinTreeNode($filterMapping.joinTreeNode);

   let joinSize = $joins->size();
   let firstJoin = if($joinSize > 0,
                      | printJoinTreeNode($filterMapping.joinTreeNode->at(0), true),
                      | '');

   let otherJoins = if($joinSize > 1,
                       | $joins->tail(),
                       | []);

   let body = $firstJoin +
              if($otherJoins->isNotEmpty(),
                 | ' > ' + $otherJoins->map(j | printJoinTreeNode($j, false))->joinStrings(' > '),
                 | '') +
              if($joins->isNotEmpty(), | ' | ', | '') +
              printDatabasePointer($filterMapping.filter.database->toOne());

   '~filter ' + if($filterMapping.filter.database->isNotEmpty(), | $body, | '') +  $filterMapping.filterName;
}

function meta::relational::grammar::serialization::printMapping(d:Mapping[1]):String[1]
{
  'Mapping '+$d->elementToPath()+
  '\n('+
    $d.includes->map(x|'\n  include mapping ' + $x.included->elementToPath())->joinStrings('\n') +
    if($d.classMappings->isEmpty(), |'', |'\n')+
    $d.classMappings->map(si|$si->match(
      [
          rs:meta::relational::mapping::RootRelationalInstanceSetImplementation[1] | '  '+if($si.root, |'*', |'')+$si.class->elementToPath()++if($si.id->isEmpty(), |'', |'['+$si.id+']')+': Relational\n'+'  {\n'+
              if($rs.primaryKey->isNotEmpty(),
                | let pk = $rs.primaryKey->cast(@TableAliasColumn);
                  '    ~primaryKey\n'+
                  '    (\n'+
                  '      '+$pk->map(pk|$pk->printRelationalOperationElement(true))->joinStrings(',\n')+
                  '\n    )\n';,
                | ''
              ) +
              if($rs.mainTableAlias->isNotEmpty(),
                | '    ~mainTable ['+$rs.mainTableAlias.database->toOne()->elementToPath()+']'+$rs.mainTableAlias.relationalElement->printRelationalOperationElementTarget()+'\n',
                | ''
              ) +
              $rs.propertyMappings->cast(@meta::relational::mapping::RelationalPropertyMapping)->map(pm|
                '    '+$pm.property.name->toOne()+$pm.transformer->match(
                  [
                    em:meta::pure::mapping::EnumerationMapping<Any>[1] | ': EnumerationMapping '+$em.name,
                    a:Any[0..1] | ''
                  ])+
                if($pm.targetSetImplementationId == '',|'',|'['+$pm.targetSetImplementationId+']')+': '+$pm.relationalOperationElement->printRelationalOperationElement(true))->joinStrings(',\n')
          +'\n  }'
      ]
    ))->joinStrings('\n')+
    if($d.enumerationMappings->isEmpty(), |'', |'\n')+
    $d.enumerationMappings->map(em|'  '+$em.enumeration->elementToPath()+': EnumerationMapping '+$em.name+'\n  {\n'+
        $em.enumValueMappings->map(v|$v->match(
          [
            evm:meta::pure::mapping::EnumValueMapping[1] | '    '+$evm.enum.name+': ['+$evm.sourceValues->map(sv|$sv->match(
              [
                r:RelationalOperationElement[1] | $r->printRelationalOperationElement(true),
                a:Any[1] | $a->meta::pure::functions::string::toRepresentation()
              ]
            ))->joinStrings(',')+']'
          ]
        ))->joinStrings(',\n')
        +'\n  }'
    )->joinStrings('\n')+
    if($d.associationMappings->isEmpty(), |'', |'\n')+
    $d.associationMappings->map(am|$am->match(
      [
          ra:meta::relational::mapping::RelationalAssociationImplementation[1] | '  '+$am.association->elementToPath()+if($am.id->isEmpty(), |'', |'['+$am.id+']')+': Relational\n'+
              '  {\n'+
              '    AssociationMapping\n'+
              '    (\n'+
              $ra.propertyMappings->cast(@meta::relational::mapping::RelationalPropertyMapping)->map(pm|
              '      '+$pm.property.name->toOne()+'['+$pm.sourceSetImplementationId+','+$pm.targetSetImplementationId+']: '+$pm.relationalOperationElement->printRelationalOperationElement(true))->joinStrings(',\n')+'\n'+
              '    )\n'+
              '  }'
      ]
    ))->joinStrings('\n')+
  '\n)';
}

function meta::relational::grammar::serialization::printRelationalOperationElementTarget(r:RelationalOperationElement[1]):String[1]
{
  $r->match([
    t:Table[1] | printName($t.schema, $t.name),
    v:View[1] | printName($v.schema, $v.name)
  ])
}

function meta::relational::grammar::serialization::printName(schema:Schema[1], name:String[1]):String[1]
{
  if ($schema.name->toOne()->equalIgnoreCase('DEFAULT'), |'', |$schema.name->toOne() + '.') + $name
}

function meta::relational::grammar::serialization::flattenJoinTreeNode(tree:JoinTreeNode[0..1]):JoinTreeNode[*]
{
  $tree->concatenate($tree.childrenData->cast(@JoinTreeNode)->map(t | flattenJoinTreeNode($t)));
}

function meta::relational::grammar::serialization::printJoinTreeNode(tree:JoinTreeNode[1], first:Boolean[1]):String[1]
{
  let type = if ($tree.joinType->isEmpty(), | '', | '(' + $tree.joinType->toOne().name->replace('LEFT_OUTER', 'OUTER') + ')');
  let db = if ($tree.database->isEmpty(), | '', | printDatabasePointer($tree.database));

  if ($first, 
    | $db + $type + '@' + $tree.joinName, 
    | $type + $db + '@' + $tree.joinName);
}

function meta::relational::grammar::serialization::printDatabasePointer(db:Database[1]):String[1]
{
  '[' + $db->elementToPath() + ']'
}

function meta::relational::grammar::serialization::printRelationalOperationElement(d:RelationalOperationElement[1], forMapping:Boolean[1]):String[1]
{
  $d->match(
    [
      t:TableAliasColumn[1]|
        let relation = $t.alias.relation->cast(@NamedRelation);
        let name = if($t.alias.name->equal('t_' + $relation.name),|'{target}',|$relation->printRelationalOperationElementTarget());

        if($forMapping,|'['+$t.alias.database->toOne()->elementToPath()+']',|'')+ $name +'.'+$t.column.name;,
      x:RelationalOperationElementWithJoin[1]|
        let joins = flattenJoinTreeNode($x.joinTreeNode);

        let joinStr = if ($joins->isEmpty(), 
          | '', 
          | printJoinTreeNode($joins->at(0), true) + if ($joins->size() == 1, | '', | ' > ' + $joins->tail()->map(j | printJoinTreeNode($j, false))->joinStrings(' > '));
        );

        let element = if ($x.relationalOperationElement->isEmpty(), 
          | '', 
          | if ($joins->isNotEmpty(), | ' | ', | '') + printRelationalOperationElement($x.relationalOperationElement->toOne(), $forMapping)
        );
        
        $joinStr + $element;,
      v:DynaFunction[1]|
        if ([
          dynaFunc2($v, 'equal', '=', $forMapping),
          dynaFunc2($v, 'notEqual', '!=', $forMapping),
          dynaFunc2($v, 'greaterThan', '>', $forMapping),
          dynaFunc2($v, 'greaterThanEqual', '>=', $forMapping),
          dynaFunc2($v, 'lessThan', '<', $forMapping),
          dynaFunc2($v, 'lessThanEqual', '<=', $forMapping),
          dynaFunc2($v, 'notEqualAnsi', '<>', $forMapping),
          dynaFunc1($v, 'isNull', 'is null', $forMapping),
          dynaFunc1($v, 'isNotNull', 'is not null', $forMapping),
          pair(|$v.name == 'group', | '(' + $v.parameters->at(0)->printRelationalOperationElement($forMapping) + ')'),
          pair(|$v.name->in(['and', 'or']), | $v.parameters->map(p | $p->printRelationalOperationElement($forMapping))->joinStrings(' ' + $v.name + ' '))
        ], | 
          $v.name + '('+$v.parameters->map(p|$p->printRelationalOperationElement($forMapping))->joinStrings(',')+')'
        ),
      l:Literal[1] | $l.value->match([
        r:RelationalOperationElement[1] | printRelationalOperationElement($r, $forMapping),
        a:Any[1] | meta::pure::functions::string::toRepresentation($a)
      ])
    ]
  );
}

function meta::relational::grammar::serialization::dynaFunc2(v:DynaFunction[1], name:String[1], func:String[1], forMapping:Boolean[1]): Pair<Function<{->Boolean[1]}>, Function<{->String[1]}>>[1]
{
  pair(|$v.name == $name, 
       {| assert($v.parameters->size() == 2, | 'Unable to transform operation: exactly 2 parameters are expected for ' + $func + ' operation');
         $v.parameters->at(0)->printRelationalOperationElement($forMapping) + ' ' + $func + ' ' + $v.parameters->at(1)->printRelationalOperationElement($forMapping);}
  );
}

function meta::relational::grammar::serialization::dynaFunc1(v:DynaFunction[1], name:String[1], func:String[1], forMapping:Boolean[1]): Pair<Function<{->Boolean[1]}>, Function<{->String[1]}>>[1]
{
  pair(|$v.name == $name, 
       {| assert($v.parameters->size() == 1, | 'Unable to transform operation: exactly 2 parameters are expected for ' + $func + ' operation');
         $v.parameters->at(0)->printRelationalOperationElement($forMapping) + ' ' + $func;}
  );
}


function meta::relational::grammar::serialization::printRelationalDatabaseConnection(connection:meta::external::store::relational::runtime::RelationalDatabaseConnection[1]):String[1]
{
  '^meta::external::store::relational::runtime::RelationalDatabaseConnection('+
  'type='+$connection.type->meta::pure::metamodel::serialization::grammar::printValueSpecification([], ^meta::pure::metamodel::serialization::grammar::GContext(space=''))+','+
  'authenticationStrategy = '+$connection.authenticationStrategy->printNew()+','+ //^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy(),'+
  'datasourceSpecification = '+$connection.datasourceSpecification->printNew()+ //^meta::pure::alloy::connections::alloy::specification::DuckDBDatasourceSpecification(path = \'\')'+
  ')'
}

function meta::relational::grammar::serialization::relationGrammarConfiguration():meta::pure::metamodel::serialization::grammar::Configuration[1]
{
  ^meta::pure::metamodel::serialization::grammar::Configuration
  (
    fullPath = true,
    extensions = meta::relational::grammar::serialization::relationGrammarExtension()  
  );
}

function meta::relational::grammar::serialization::relationGrammarExtension():meta::pure::metamodel::serialization::grammar::GrammarExtension[1]
{
    ^meta::pure::metamodel::serialization::grammar::GrammarExtension(
        extraConnectionHandlers =
          [
            x:RelationalDatabaseConnection[0..1] |
                $x->toOne()->printRelationalDatabaseConnection(); 
          ],
        extraInstanceValueHandlers = 
          [
            x:RelationStoreAccessor<Any>[1]|
              let table = $x.sourceElement->cast(@Table);  
              let schema = $table.schema;
              let schemaName = if ($schema.name == 'default', |'', |$schema.name + '.');
              '#>{' + $x.store->elementToPath() + '.' + $schemaName + $table.name->toOne() + '}#';
              ,
            t:meta::pure::metamodel::relation::TDS<Any>[1]|
                      $t->toString(true)
                      ->replace('#TDS\n','#TDS{\n')
                      ->replace('\n#','\n}#')
                      ->regexpReplace('\n\\s+', '\n', true)
                      ->regexpReplace(',\\s*+', ',', true);                      
          ],
        extraPackageableElementHandlers =
          [
            x:Database[1] |'###Relational\n'+$x->printDatabase(),
            m:Mapping[1]  |'###Mapping\n'+$m->printMapping()
          ]
    );
}