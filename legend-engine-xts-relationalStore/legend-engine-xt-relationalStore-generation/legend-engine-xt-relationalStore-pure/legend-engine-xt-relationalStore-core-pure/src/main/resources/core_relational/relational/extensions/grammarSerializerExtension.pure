import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::store::*;
import meta::external::store::relational::runtime::*;
import meta::relational::metamodel::relation::*;
import meta::relational::mapping::*;
import meta::relational::metamodel::datatype::*;
import meta::pure::mapping::*;
import meta::relational::metamodel::*;
import meta::relational::grammar::serialization::*;
// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function meta::relational::grammar::serialization::printDatabase(d:Database[1]):String[1]
{
  'Database ' + $d->elementToPath() +
  '\n('+
   $d.includes->map(x|'\n  include ' + $x->elementToPath())->joinStrings('\n') +
   $d.schemas->map(
      s | let defaultSchema = if($s.name->toOne()->equalIgnoreCase('DEFAULT'), |true, |false);
          let indent = if($defaultSchema, |'  ', |'    ');
          if($defaultSchema, |'', |'\n  Schema '+$s.name + '\n  (')+
            + $s.tables->map(x|
              '\n'+$indent+'Table '+$x.name+'\n'+$indent+'(\n'+
                  $x.columns->map(z|let c = $z->cast(@meta::relational::metamodel::Column);
                                    $indent+'  ' + if($c.name->contains(' '),|'"'+$c.name+'"',|$c.name) + ' ' + $c.type->match([
                                                          x : meta::relational::metamodel::datatype::Varchar[1] | 'VARCHAR(' + $x.size->toString() + ')',
                                                          d : meta::relational::metamodel::datatype::Decimal[1] | 'DECIMAL(' + $d.precision->toString() + ',' + $d.scale->toString() + ')',
                                                          z : Any[1] | $z->type().name->toOne()->toUpper()
                                                        ]
                                                      ) + if ($x.primaryKey->contains($c),
                                                                |' PRIMARY KEY',
                                                                |if ($c.nullable->isNotEmpty() && $c.nullable->toOne(), |'', |' NOT NULL')
                                                          );
                                 )->joinStrings(',\n')+
              '\n'+$indent+')'
            )->joinStrings('')+if($defaultSchema, |'', |'\n  )');
          )->joinStrings('')+
    $d.joins->map(
      j | '\n  Join '+$j.name+'('+$j.operation->printRelationalOperationElement(false)+')'
    )->joinStrings('')+
  '\n)';
}

function meta::relational::grammar::serialization::printMapping(d:Mapping[1]):String[1]
{
  'Mapping '+$d->elementToPath()+
  '\n(\n'+
    $d.includes->map(x|'  include mapping ' + $x.included->elementToPath())->joinStrings('\n') +
    $d.classMappings->map(si|$si->match(
      [
          rs:meta::relational::mapping::RootRelationalInstanceSetImplementation[1] | '  *'+$si.class->elementToPath()+'['+$si.id+']: Relational\n'+'  {\n'+
              if($rs.primaryKey->isNotEmpty(),
                | let pk = $rs.primaryKey->cast(@TableAliasColumn);
                  '    ~primaryKey\n'+
                  '    (\n'+
                  '      '+$pk->map(pk|$pk->printRelationalOperationElement(true))->joinStrings(',\n')+
                  '\n    )\n';,
                | ''
              ) +
              if($rs.mainTableAlias->isNotEmpty(),
                | '    ~mainTable ['+$rs.mainTableAlias.database->toOne()->elementToPath()+']'+$rs.mainTableAlias.relationalElement->cast(@meta::relational::metamodel::relation::Table)->printTable()+'\n',
                | ''
              ) +
              $rs.propertyMappings->cast(@meta::relational::mapping::RelationalPropertyMapping)->map(pm|
                '    '+$pm.property.name->toOne()+if($pm.targetSetImplementationId == '',|'',|'['+$pm.targetSetImplementationId+']')+': '+$pm.relationalOperationElement->printRelationalOperationElement(true))->joinStrings(',\n')
          +'\n  }'
      ]
    ))->joinStrings('\n')+
  '\n)';
}

function meta::relational::grammar::serialization::printTable(t:Table[1]):String[1]
{
  if ($t.schema.name->toOne()->equalIgnoreCase('DEFAULT'), |'', |$t.schema.name->toOne() + '.') + $t.name
}

function meta::relational::grammar::serialization::printRelationalOperationElement(d:RelationalOperationElement[1], forMapping:Boolean[1]):String[1]
{
  $d->match(
    [
      t:TableAliasColumn[1]|
        let table = $t.alias.relationalElement->cast(@Table);
        let name = if($t.alias.name->equal('t_' + $table.name),|'{target}',|$table->printTable());

        if($forMapping,|'['+$t.alias.database->toOne()->elementToPath()+']',|'')+ $name +'.'+$t.column.name;,
      x:RelationalOperationElementWithJoin[1]|'['+$x.joinTreeNode.database->toOne()->elementToPath()+']@'+$x.joinTreeNode.joinName->toOne(),
      v:DynaFunction[1]|
        if ([
          dynaFunc2($v, 'equal', '=', $forMapping),
          dynaFunc2($v, 'notEqual', '!=', $forMapping),
          dynaFunc2($v, 'greaterThan', '>', $forMapping),
          dynaFunc2($v, 'greaterThanEqual', '>=', $forMapping),
          dynaFunc2($v, 'lessThan', '<', $forMapping),
          dynaFunc2($v, 'lessThanEqual', '<=', $forMapping),
          dynaFunc2($v, 'notEqualAnsi', '<>', $forMapping),
          dynaFunc1($v, 'isNull', 'is null', $forMapping),
          dynaFunc1($v, 'isNotNull', 'is not null', $forMapping),
          pair(|$v.name == 'group', | '(' + $v.parameters->at(0)->printRelationalOperationElement($forMapping) + ')'),
          pair(|$v.name->in(['and', 'or']), | $v.parameters->map(p | $p->printRelationalOperationElement($forMapping))->joinStrings(' ' + $v.name + ' '))
        ], | 
          $v.name + '('+$v.parameters->map(p|$p->printRelationalOperationElement($forMapping))->joinStrings(',')+')'
        ),
      l:Literal[1]|'\''+$l.value->toString()+'\''
    ]
  );
}

function meta::relational::grammar::serialization::dynaFunc2(v:DynaFunction[1], name:String[1], func:String[1], forMapping:Boolean[1]): Pair<Function<{->Boolean[1]}>, Function<{->String[1]}>>[1]
{
  pair(|$v.name == $name, 
       {| assert($v.parameters->size() == 2, | 'Unable to transform operation: exactly 2 parameters are expected for ' + $func + ' operation');
         $v.parameters->at(0)->printRelationalOperationElement($forMapping) + ' ' + $func + ' ' + $v.parameters->at(1)->printRelationalOperationElement($forMapping);}
  );
}

function meta::relational::grammar::serialization::dynaFunc1(v:DynaFunction[1], name:String[1], func:String[1], forMapping:Boolean[1]): Pair<Function<{->Boolean[1]}>, Function<{->String[1]}>>[1]
{
  pair(|$v.name == $name, 
       {| assert($v.parameters->size() == 1, | 'Unable to transform operation: exactly 2 parameters are expected for ' + $func + ' operation');
         $v.parameters->at(0)->printRelationalOperationElement($forMapping) + ' ' + $func;}
  );
}


function meta::relational::grammar::serialization::printRelationalDatabaseConnection(connection:meta::external::store::relational::runtime::RelationalDatabaseConnection[1]):String[1]
{
  '^meta::external::store::relational::runtime::RelationalDatabaseConnection('+
  'type='+$connection.type->meta::pure::metamodel::serialization::grammar::printValueSpecification([], ^meta::pure::metamodel::serialization::grammar::GContext(space=''))+','+
  'authenticationStrategy = '+$connection.authenticationStrategy->printNew()+','+ //^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy(),'+
  'datasourceSpecification = '+$connection.datasourceSpecification->printNew()+ //^meta::pure::alloy::connections::alloy::specification::DuckDBDatasourceSpecification(path = \'\')'+
  ')'
}

function meta::relational::grammar::serialization::relationGrammarConfiguration():meta::pure::metamodel::serialization::grammar::Configuration[1]
{
  ^meta::pure::metamodel::serialization::grammar::Configuration
  (
    fullPath = true,
    extensions = meta::relational::grammar::serialization::relationGrammarExtension()  
  );
}

function meta::relational::grammar::serialization::relationGrammarExtension():meta::pure::metamodel::serialization::grammar::GrammarExtension[1]
{
    ^meta::pure::metamodel::serialization::grammar::GrammarExtension(
        extraConnectionHandlers =
          [
            x:RelationalDatabaseConnection[0..1] |
                $x->toOne()->printRelationalDatabaseConnection(); 
          ],
        extraInstanceValueHandlers = 
          [
            x:RelationStoreAccessor<Any>[1]|
              let table = $x.sourceElement->cast(@Table);  
              let schema = $table.schema;
              let schemaName = if ($schema.name == 'default', |'', |$schema.name + '.');
              '#>{' + $x.store->elementToPath() + '.' + $schemaName + $table.name->toOne() + '}#';
              ,
            t:meta::pure::metamodel::relation::TDS<Any>[1]|'#TDS{\n'+$t.csv->replace(' ','')+'}#';
          ],
        extraPackageableElementHandlers =
          [
            x:Database[1] |'###Relational\n'+$x->printDatabase(),
            m:Mapping[1]  |'###Mapping\n'+$m->printMapping()
          ]
    );
}