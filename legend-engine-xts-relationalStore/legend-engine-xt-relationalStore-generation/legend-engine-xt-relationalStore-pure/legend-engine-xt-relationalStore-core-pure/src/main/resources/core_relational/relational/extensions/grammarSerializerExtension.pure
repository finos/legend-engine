import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::store::*;
import meta::external::store::relational::runtime::*;
import meta::relational::metamodel::relation::*;
import meta::relational::mapping::*;
import meta::relational::metamodel::datatype::*;
import meta::pure::mapping::*;
import meta::relational::metamodel::*;
import meta::relational::grammar::serialization::*;
// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function meta::relational::grammar::serialization::printDatabase(d:Database[1]):String[1]
{
  'Database ' + $d->elementToPath() + '\n' +
  '('+
   if ($d.includes->isEmpty(), |'', |'\n') +
   $d.includes->map(x|'  include ' + $x->elementToPath())->joinStrings('\n') +
   if ($d.includes->isEmpty(), |'', |'\n') +
   $d.schemas->map(
      s | '\n  Schema '+$s.name + '\n  ('+ $s.tables->map(x|
              '\n    Table '+$x.name+' ('+
                  $x.columns->map(z|let c = $z->cast(@meta::relational::metamodel::Column);
                                    if($c.name->contains(' '),|'"'+$c.name+'"',|$c.name) + ' ' + $c.type->match([
                                                          x : Varchar[1] | 'VARCHAR(' + $x.size->toString() + ')',
                                                          c : Char[1] | 'CHAR(' + $c.size->toString() + ')',
                                                          b : Binary[1] | 'BINARY(' + $b.size->toString() + ')',
                                                          v : Varbinary[1] | 'VARBINARY(' + $v.size->toString() + ')',
                                                          d : meta::relational::metamodel::datatype::Decimal[1] | 'DECIMAL(' + $d.precision->toString() + ',' + $d.scale->toString() + ')',
                                                          n : meta::relational::metamodel::datatype::Numeric[1] | 'NUMERIC(' + $n.precision->toString() + ',' + $n.scale->toString() + ')',
                                                          z : Any[1] | $z->type().name->toOne()
                                                        ]
                                                      ) + if ($x.primaryKey->contains($c),
                                                                |' PRIMARY KEY',
                                                                |if ($c.nullable->isNotEmpty() && $c.nullable->toOne(), |'', |' NOT NULL')
                                                          );
                                 )->joinStrings(', ')+
              ')'
                  )->joinStrings('') + '\n  )'
          )->joinStrings('\n  ') + 
    $d.joins->map(
      j | 'Join '+$j.name+'('+$j.operation->printRelationalOperationElement(false)+')'
    )->joinStrings('\n  ', '\n  ', '')+
  '\n)';
}

function meta::relational::grammar::serialization::printMapping(d:Mapping[1]):String[1]
{
  'Mapping '+$d->elementToPath()+
  '('+
    $d.classMappings->map(si|
      $si.class->elementToPath() + '['+$si.id+']:' + $si->match(
        [
          rs:RootRelationalInstanceSetImplementation[1] | 'Relational {'+
              $rs.propertyMappings->cast(@RelationalPropertyMapping)->map(pm|
                $pm.property.name->toOne() + if($pm.targetSetImplementationId == '',|'',|'['+$pm.targetSetImplementationId+']') + ':'+$pm.relationalOperationElement->printRelationalOperationElement(true))->joinStrings(', ')
          +'}'
        ]
      )
    )->joinStrings(' ')+
  ')';
}

function meta::relational::grammar::serialization::printRelationalOperationElement(d:RelationalOperationElement[1], forMapping:Boolean[1]):String[1]
{
  $d->match(
    [
      t:TableAliasColumn[1]|
        let table = $t.alias.relationalElement->cast(@Table);
        let name = if($t.alias.name->equal('t_' + $table.name),|'{target}',|$table.schema.name->toOne()+'.'+$table.name);

        if($forMapping,|'['+$t.alias.database->toOne()->elementToPath()+']',|'')+ $name +'.'+$t.column.name;,
      x:RelationalOperationElementWithJoin[1]|'['+$x.joinTreeNode.database->toOne()->elementToPath()+']@'+$x.joinTreeNode.joinName->toOne(),
      v:DynaFunction[1]|
        if ([
          dynaFunc2($v, 'equal', '=', $forMapping),
          dynaFunc2($v, 'notEqual', '!=', $forMapping),
          dynaFunc2($v, 'greaterThan', '>', $forMapping),
          dynaFunc2($v, 'greaterThanEqual', '>=', $forMapping),
          dynaFunc2($v, 'lessThan', '<', $forMapping),
          dynaFunc2($v, 'lessThanEqual', '<=', $forMapping),
          dynaFunc2($v, 'notEqualAnsi', '<>', $forMapping),
          dynaFunc1($v, 'isNull', 'is null', $forMapping),
          dynaFunc1($v, 'isNotNull', 'is not null', $forMapping),
          pair(|$v.name == 'group', | '(' + $v.parameters->at(0)->printRelationalOperationElement($forMapping) + ')'),
          pair(|$v.name->in(['and', 'or']), | $v.parameters->map(p | $p->printRelationalOperationElement($forMapping))->joinStrings(' ' + $v.name + ' '))
        ], | 
          $v.name + '('+$v.parameters->map(p|$p->printRelationalOperationElement($forMapping))->joinStrings(',')+')'
        )
    ]
  );
}

function meta::relational::grammar::serialization::dynaFunc2(v:DynaFunction[1], name:String[1], func:String[1], forMapping:Boolean[1]): Pair<Function<{->Boolean[1]}>, Function<{->String[1]}>>[1]
{
  pair(|$v.name == $name, 
       {| assert($v.parameters->size() == 2, | 'Unable to transform operation: exactly 2 parameters are expected for ' + $func + ' operation');
         $v.parameters->at(0)->printRelationalOperationElement($forMapping) + ' ' + $func + ' ' + $v.parameters->at(1)->printRelationalOperationElement($forMapping);}
  );
}

function meta::relational::grammar::serialization::dynaFunc1(v:DynaFunction[1], name:String[1], func:String[1], forMapping:Boolean[1]): Pair<Function<{->Boolean[1]}>, Function<{->String[1]}>>[1]
{
  pair(|$v.name == $name, 
       {| assert($v.parameters->size() == 1, | 'Unable to transform operation: exactly 2 parameters are expected for ' + $func + ' operation');
         $v.parameters->at(0)->printRelationalOperationElement($forMapping) + ' ' + $func;}
  );
}


function meta::relational::grammar::serialization::printRelationalDatabaseConnection(connection:meta::external::store::relational::runtime::RelationalDatabaseConnection[1]):String[1]
{
  '^meta::external::store::relational::runtime::RelationalDatabaseConnection('+
  'type='+$connection.type->meta::pure::metamodel::serialization::grammar::printValueSpecification([], ^meta::pure::metamodel::serialization::grammar::GContext(space=''))+','+
  'authenticationStrategy = '+$connection.authenticationStrategy->printNew()+','+ //^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy(),'+
  'datasourceSpecification = '+$connection.datasourceSpecification->printNew()+ //^meta::pure::alloy::connections::alloy::specification::DuckDBDatasourceSpecification(path = \'\')'+
  ')'
}

function meta::relational::grammar::serialization::relationGrammarConfiguration():meta::pure::metamodel::serialization::grammar::Configuration[1]
{
  ^meta::pure::metamodel::serialization::grammar::Configuration
  (
    fullPath = true,
    extensions = meta::relational::grammar::serialization::relationGrammarExtension()  
  );
}

function meta::relational::grammar::serialization::relationGrammarExtension():meta::pure::metamodel::serialization::grammar::GrammarExtension[1]
{
    ^meta::pure::metamodel::serialization::grammar::GrammarExtension(
        extraConnectionHandlers =
          [
            x:RelationalDatabaseConnection[0..1] |
                $x->toOne()->printRelationalDatabaseConnection(); 
          ],
        extraInstanceValueHandlers = 
          [
            x:RelationStoreAccessor<Any>[1]|
              let table = $x.sourceElement->cast(@Table);  
              let schema = $table.schema;
              let schemaName = if ($schema.name == 'default', |'', |$schema.name + '.');
              '#>{' + $x.store->elementToPath() + '.' + $schemaName + $table.name->toOne() + '}#';
              ,
            t:meta::pure::metamodel::relation::TDS<Any>[1]|'#TDS{\n'+$t.csv->replace(' ','')+'}#';
          ],
        extraPackageableElementHandlers =
          [
            x:Database[1]|'###Relational\n'+$x->printDatabase()
          ]
    );
}