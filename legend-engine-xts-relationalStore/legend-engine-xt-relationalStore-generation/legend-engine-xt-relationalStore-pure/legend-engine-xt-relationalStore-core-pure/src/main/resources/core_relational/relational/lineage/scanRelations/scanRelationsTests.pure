// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::tests::tds::tdsJoin::*;
import meta::pure::lineage::scanRelations::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::relational::extension::*;
import meta::relational::metamodel::join::*;
import meta::relational::functions::database::*;
import meta::pure::graphFetch::execution::*;
import meta::relational::tests::model::simple::*;

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTree_Inheritance_1():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> project([f|$f.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).owner.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Bicycle).owner.name],
                                                                          ['Person','Car Owner','Bicycle Owner'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [b_PersonID]\n' +
                  '    ------> (t) Car(PersonCar) [ID, c_PersonID]\n' +
                  '      ------> (t) Owner(CarOwner) [VEHICLE_ID, name]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions())-> toOne();

   let expected1 = 'root\n' +
                   '  ------> (t) Person [ID, name]\n' +
                   '    ------> (t) Bicycle(equal_rootID_Bicycle_d#7_d_m3b_PersonID) [b_PersonID]\n' +
                   '    ------> (t) Car(equal_rootID_Car_d#7_d_m2c_PersonID) [ID, c_PersonID]\n' +
                   '      ------> (t) Owner(equal_Car_d#7_d_m2ID_Owner_d#4_f_d_d_m2_rVEHICLE_ID) [VEHICLE_ID, name]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTree_Inheritance_2():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> project([f|$f.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).engineType,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Bicycle).person.name],
                                                                          ['Person','Engine Type','Bicycle Person'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();

   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [b_PersonID]\n' +
                  '      ------> (t) Person(PersonBicycle) [ID, name]\n' +
                  '    ------> (t) Car(PersonCar) [c_PersonID, engineType]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) Person [ID, name]\n' +
                   '    ------> (t) Bicycle(equal_rootID_Bicycle_d#7_d_m3b_PersonID) [b_PersonID]\n' +
                   '      ------> (t) Person(equal_Person_d#4_f_d_d_m3_rID_Bicycle_d#7_d_m3b_PersonID) [ID, name]\n' +
                   '    ------> (t) Car(equal_rootID_Car_d#5_d_m2c_PersonID) [c_PersonID, engineType]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeMultiJoin():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> project([f|$f.name, f|$f.vehicles.description], ['Person','Description'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [b_Description, b_PersonID]\n' +
                  '    ------> (t) Car(PersonCar) [c_Description, c_PersonID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions())-> toOne();
   let expected1 =  'root\n' +
                    '  ------> (t) Person [ID, name]\n' +
                    '    ------> (t) Bicycle(or_equal_rootID_unionAlias_d#4_d_m2b_PersonID_0_equal_rootID_SQLNull) [b_Description, b_PersonID]\n' +
                    '    ------> (t) Car(or_equal_rootID_SQLNull_equal_rootID_unionAlias_d#4_d_m2c_PersonID_1) [c_Description, c_PersonID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testConstant():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> project([f|'constant'], ['col'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions())-> toOne();

   let expected = 'root\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let expectedWithJustTable =  'root\n' +
                                '  ------> (t) Person []\n';
   assertEquals($expectedWithJustTable, $relationTreeFromPureToSQL-> relationTreeAsString());
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSelectOnLeftSide():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> filter(p|$p.name == 'ok' && $p.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).owner.name == 'test').name};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());

   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [b_PersonID]\n' +
                  '    ------> (t) Car(PersonCar) [ID, c_PersonID]\n' +
                  '      ------> (t) Owner(CarOwner) [VEHICLE_ID, name]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let expected2 = 'root\n' +
                   '  ------> (t) Person [ID, name]\n' +
                   '    ------> (t) Car(equal_rootID_Car_d#4_dy1_d#7_d#4_m1_d#3_m1c_PersonID) [ID, c_PersonID]\n' +
                   '      ------> (t) Owner(equal_Car_d#4_dy1_d#7_d#4_m1_d#3_m1ID_Owner_d#4_dy1_d#4_f_d_d#4_m1_r_d#3_m1_rVEHICLE_ID) [VEHICLE_ID, name]\n';
   assertEquals($expected2, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeTwoFilters():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> filter(x|$x.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).owner.name != 'x')
                                                                -> filter(x|$x.bicycles.id != 'okok')
                                                                -> project([f|$f.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).owner.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Bicycle).owner.name],
                                                                          ['Person','Car Owner','Bicycle Owner'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [ID, b_PersonID]\n' +
                  '    ------> (t) Car(PersonCar) [ID, c_PersonID]\n' +
                  '      ------> (t) Owner(CarOwner) [VEHICLE_ID, name]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) Person [ID, name]\n' +
                   '    ------> (t) Bicycle(equal_rootID_Bicycle_d#7_d#2_m1b_PersonID) [ID, b_PersonID]\n' +
                   '    ------> (t) Car(equal_rootID_Car_d#11_d#3_m1c_PersonID) [ID, c_PersonID]\n' +
                   '      ------> (t) Owner(equal_Car_d#11_d#3_m1ID_Owner_d#8_f_d_d#3_m1_rVEHICLE_ID) [VEHICLE_ID, name]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeQualifier():Boolean[1]
{
   let query = {|Trade.all()-> project([t|$t.product.name, t|$t.product->toOne().synonymByType(ProductSynonymType.CUSIP).name],['prodName', 'synName'])};
   let mapping = meta::relational::tests::simpleRelationalMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) tradeTable [prodId]\n' +
                  '    ------> (t) productTable(Trade_Product) [ID, NAME]\n' +
                  '      ------> (t) synonymTable(Product_Synonym) [NAME, PRODID, TYPE]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) tradeTable [prodId]\n' +
                   '    ------> (t) productTable(equal_rootprodId_productTable_d#4_d_m1ID) [ID, NAME]\n' +
                   '      ------> (t) synonymTable(equal_synonymTable_d#6_d_m2_mdPRODID_productTable_d#4_d_m1ID) [NAME, PRODID, TYPE]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeWithMappingFilter():Boolean[1]
{
   let query = {|Person.all()-> project([p|$p.firstName], ['c1'])};
   let mapping = meta::relational::tests::mapping::filter::filterMappingWithJoinInFilterAndProperty;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) personTable [FIRMID, FIRSTNAME]\n' +
                  '    ------> (t) firmTable(Firm_Person) [ID, LEGALNAME]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions())-> toOne();
   let expected1 = 'root\n' +
                   '  ------> (t) personTable [FIRMID, FIRSTNAME]\n' +
                   '    ------> (t) firmTable(equal_firmTable_d#2_d#2_m1ID_rootFIRMID) [ID, LEGALNAME]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeMilestoning():Boolean[1]
{
   let query = {|meta::relational::tests::milestoning::Order.all()-> project(o|$o.biTemporalProduct(%2017-6-10, %2017-6-9).biTemporalClassification(%2017-6-11, %2017-6-10).type, 'type')};
   let mapping = meta::relational::tests::milestoning::latestbitemporalmap;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) OrderTable [prodFk]\n' +
                  '    ------> (t) BiTemporalProductTableWithLatest(Order_BiTemporalProductWithLatest) [id, type]\n' +
                  '      ------> (t) BiTemporalProductClassificationTableWithLatest(BiTemporalProductWithLatest_BiTemporalClassificationWithLatest) [type]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) OrderTable [prodFk]\n' +
                   '    ------> (t) BiTemporalProductTableWithLatest(equal_rootprodFk_BiTemporalProductTableWithLatest_d#8_d_m1id) [from_z, id, in_z, out_z, thru_z, type]\n' +
                   '      ------> (t) BiTemporalProductClassificationTableWithLatest(equal_BiTemporalProductTableWithLatest_d#8_d_m1type_BiTemporalProductClassificationTableWithLatest_d#4_f_d#4_d_m1_rtype) [from_z, in_z, out_z, thru_z, type]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeMilestoning_ChainJoins():Boolean[1]
{
   let query = {|meta::relational::tests::milestoning::Order.all()-> project([o|$o.biTemporalProduct(%2017-6-10, %2017-6-9).biTemporalClassification(%2017-6-11, %2017-6-10).type, o|$o.systemADescription(%2017-6-10).description], ['type', 'description'])};
   let mapping = meta::relational::tests::milestoning::milestoningmap;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
      '  ------> (t) OrderTable [id, prodFk]\n' +
      '    ------> (t) BiTemporalProductTable(Order_BiTemporalProduct) [id, type]\n' +
      '      ------> (t) BiTemporalProductClassificationTable(BiTemporalProduct_BiTemporalClassification) [type]\n' +
      '    ------> (t) OrderToSystemADescriptions(Order_OrderToSystemADescriptions) [orderId, systemADescriptionId]\n' +
      '      ------> (t) SystemAOrderDescriptionTable(OrderToSystemADescriptions_SystemAOrderDescriptionTable) [description, descriptionId]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) OrderTable [id, prodFk]\n' +
                   '    ------> (t) BiTemporalProductTable(equal_rootprodFk_BiTemporalProductTable_d#8_d_m1id) [from_z, id, in_z, out_z, thru_z, type]\n' +
                   '      ------> (t) BiTemporalProductClassificationTable(equal_BiTemporalProductTable_d#8_d_m1type_BiTemporalProductClassificationTable_d#4_f_d#4_d_m1_rtype) [from_z, in_z, out_z, thru_z, type]\n' +
                   '    ------> (t) OrderToSystemADescriptions(equal_rootid_OrderToSystemADescriptions_d#6_d_m2orderId) [from_z, orderId, systemADescriptionId, thru_z]\n' +
                   '      ------> (t) SystemAOrderDescriptionTable(equal_OrderToSystemADescriptions_d#6_d_m2systemADescriptionId_SystemAOrderDescriptionTable_d#6_l_d_m2_rdescriptionId) [description, descriptionId]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeMilestoningWithLet():Boolean[1]
{
   let query = {|let date1 = %2017-6-10;
                 let date2 = %2017-6-9;
                 meta::relational::tests::milestoning::Order.all()-> project(o|$o.biTemporalProduct($date1, $date2).biTemporalClassification(%2017-6-11, $date1).type, 'type');};
   let mapping = meta::relational::tests::milestoning::latestbitemporalmap;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) OrderTable [prodFk]\n' +
                  '    ------> (t) BiTemporalProductTableWithLatest(Order_BiTemporalProductWithLatest) [id, type]\n' +
                  '      ------> (t) BiTemporalProductClassificationTableWithLatest(BiTemporalProductWithLatest_BiTemporalClassificationWithLatest) [type]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) OrderTable [prodFk]\n' +
                   '    ------> (t) BiTemporalProductTableWithLatest(equal_rootprodFk_BiTemporalProductTableWithLatest_d#8_d_m1id) [from_z, id, in_z, out_z, thru_z, type]\n' +
                   '      ------> (t) BiTemporalProductClassificationTableWithLatest(equal_BiTemporalProductTableWithLatest_d#8_d_m1type_BiTemporalProductClassificationTableWithLatest_d#4_f_d#4_d_m1_rtype) [from_z, in_z, out_z, thru_z, type]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnion():Boolean[1]
{
   let query = {|Firm.all()-> project([p|$p.legalName, p|$p.employees.name], ['Firm','Employee'])};
   let mapping = meta::relational::tests::mapping::union::unionMappingWithSameJoinInPropertyInBothUnions;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonMaster(PersonMasterFirmSet1) [FirmID, firstName, lastName]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n' +
                  '    ------> (t) PersonMaster(PersonMasterFirmSet2) [FirmID, firstName, lastName]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonMaster [FirmID, ID, firstName, lastName]\n' +
                  '    ------> (t) PersonMaster [FirmID, ID, firstName, lastName]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n' +
                  '    ------> (t) PersonMaster [FirmID, ID, firstName, lastName]\n' +
                  '    ------> (t) PersonMaster [FirmID, ID, firstName, lastName]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionWithJoinToOneTable():Boolean[1]
{
   let query = {|Firm.all()-> project([p|$p.legalName, p|$p.employees.name], ['Firm','EmployeeName'])};
   let mapping = meta::relational::tests::mapping::union::unionToUnionMapping3;

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonSet1 [FirmID, firstName_s1, lastName_s1]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionToUnion():Boolean[1]
{
   let query = {|Firm.all()-> project([p|$p.legalName, p|$p.bridge.employees.name], ['Firm','Employee'])};
   let mapping = meta::relational::tests::mapping::union::unionMappingWithEmbeddedProperty2;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonSet1(PersonSet1FirmSet1) [FirmID, firstName_s1, lastName_s1]\n' +
                  '    ------> (t) PersonSet2(PersonSet2FirmSet1) [FirmID, firstName_s2, lastName_s2]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n' +
                  '    ------> (t) PersonSet1(PersonSet1FirmSet2) [FirmID, firstName_s1, lastName_s1]\n' +
                  '    ------> (t) PersonSet2(PersonSet2FirmSet2) [FirmID, firstName_s2, lastName_s2]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonSet1 [FirmID, ID, firstName_s1, lastName_s1]\n' +
                  '    ------> (t) PersonSet2 [FirmID, ID, firstName_s2, lastName_s2]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n' +
                  '    ------> (t) PersonSet1 [FirmID, ID, firstName_s1, lastName_s1]\n' +
                  '    ------> (t) PersonSet2 [FirmID, ID, firstName_s2, lastName_s2]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionToUnionMultiple():Boolean[1]
{
   let query = {|Person.all()-> project([p|$p.lastName, p|$p.firm.legalName, p|$p.address.name], ['Person','Firm', 'Employee'])};
   let mapping = meta::relational::tests::mapping::union::unionToUnionMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '    ------> (t) AddressSet1(PersonSet1AddressSet1) [ID, name]\n' +
                  '    ------> (t) AddressSet2(PersonSet1AddressSet2) [ID, name]\n' +
                  '    ------> (t) FirmSet1(PersonSet1FirmSet1) [ID, name]\n' +
                  '    ------> (t) FirmSet2(PersonSet1FirmSet2) [ID, name]\n' +
                  '  ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '    ------> (t) AddressSet1(PersonSet2AddressSet1) [ID, name]\n' +
                  '    ------> (t) AddressSet2(PersonSet2AddressSet2) [ID, name]\n' +
                  '    ------> (t) FirmSet1(PersonSet2FirmSet1) [ID, name]\n' +
                  '    ------> (t) FirmSet2(PersonSet2FirmSet2) [ID, name]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) PersonSet1 [FirmID, ID, lastName_s1]\n' +
                  '    ------> (t) AddressSet1 [ID, name]\n' +
                  '    ------> (t) AddressSet2 [ID, name]\n' +
                  '    ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) FirmSet2 [ID, name]\n' +
                  '  ------> (t) PersonSet2 [FirmID, ID, lastName_s2]\n' +
                  '    ------> (t) AddressSet1 [ID, name]\n' +
                  '    ------> (t) AddressSet2 [ID, name]\n' +
                  '    ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) FirmSet2 [ID, name]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionToUnionMultipleLevels():Boolean[1]
{
   let query = {|Person.all()-> project([p|$p.lastName, p|$p.firm.legalName, p|$p.firm.employees.lastName, p|$p.address.name], ['Person','Firm','Colleague','Employee'])};
   let mapping = meta::relational::tests::mapping::union::unionToUnionMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '    ------> (t) AddressSet1(PersonSet1AddressSet1) [ID, name]\n' +
                  '    ------> (t) AddressSet2(PersonSet1AddressSet2) [ID, name]\n' +
                  '    ------> (t) FirmSet1(PersonSet1FirmSet1) [ID, name]\n' +
                  '      ------> (t) PersonSet1(PersonSet1FirmSet1) [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2(PersonSet2FirmSet1) [FirmID, lastName_s2]\n' +
                  '    ------> (t) FirmSet2(PersonSet1FirmSet2) [ID, name]\n' +
                  '      ------> (t) PersonSet1(PersonSet1FirmSet2) [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2(PersonSet2FirmSet2) [FirmID, lastName_s2]\n' +
                  '  ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '    ------> (t) AddressSet1(PersonSet2AddressSet1) [ID, name]\n' +
                  '    ------> (t) AddressSet2(PersonSet2AddressSet2) [ID, name]\n' +
                  '    ------> (t) FirmSet1(PersonSet2FirmSet1) [ID, name]\n' +
                  '      ------> (t) PersonSet1(PersonSet1FirmSet1) [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2(PersonSet2FirmSet1) [FirmID, lastName_s2]\n' +
                  '    ------> (t) FirmSet2(PersonSet2FirmSet2) [ID, name]\n' +
                  '      ------> (t) PersonSet1(PersonSet1FirmSet2) [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2(PersonSet2FirmSet2) [FirmID, lastName_s2]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) PersonSet1 [FirmID, ID, lastName_s1]\n' +
                  '    ------> (t) AddressSet1 [ID, name]\n' +
                  '    ------> (t) AddressSet2 [ID, name]\n' +
                  '    ------> (t) FirmSet1 [ID, name]\n' +
                  '      ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '    ------> (t) FirmSet2 [ID, name]\n' +
                  '      ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '  ------> (t) PersonSet2 [FirmID, ID, lastName_s2]\n' +
                  '    ------> (t) AddressSet1 [ID, name]\n' +
                  '    ------> (t) AddressSet2 [ID, name]\n' +
                  '    ------> (t) FirmSet1 [ID, name]\n' +
                  '      ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '    ------> (t) FirmSet2 [ID, name]\n' +
                  '      ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2 [FirmID, lastName_s2]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionToSameTableWithDiffKeys():Boolean[1]
{
   let query = {|Firm.all()-> project([f|$f.legalName, f|$f.employees.firstName], ['legalName','employee_firstname'])};
   let mapping = meta::relational::tests::mapping::union::unionToUnionMappingWithJoinToSameTableWithDiffKeys;

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) Firm [ID, name]\n' +
                  '    ------> (t) PersonSet4(equal_unionAlias_d#4_d_m2firmId_rootID) [FirmID_1, firstName_s1]\n' +
                  '    ------> (t) PersonSet4(equal_unionAlias_d#4_d_m2firmId_rootID) [FirmID_2, firstName_s1]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(true));
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSimpleViewRoot():Boolean[1]
{

   let query = {|OrderPnl.all()->project(#/OrderPnl/pnl#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (v) orderPnlView [pnl]\n' +
                  '    root\n' +
                  '      ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '        ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '          ------> (t) accountTable(Order_Account) [ID]\n' +
                  '          ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (v) orderPnlView [pnl]\n' +
                   '    root\n' +
                   '      ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                   '        ------> (t) orderTable(equal_rootORDER_ID_orderTable_d#2_d#2_m3ID) [ID, accountID]\n' +
                   '          ------> (t) accountTable(equal_orderTable_d#2_d#2_m3accountID_accountTable_d#2_l_d#2_m3_rID) [ID]\n' +
                   '          ------> (t) salesPersonTable(equal_orderTable_d#2_d#2_m3accountID_salesPersonTable_d#2_l_d#2_m4_mdACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSimpleViewRootToJoin():Boolean[1]
{

   let query = {|OrderPnl.all()->project([#/OrderPnl/pnl#, #/OrderPnl/order/settlementDateTime#])};
   let mapping = meta::relational::tests::simpleRelationalMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (v) orderPnlView [ORDER_ID, pnl]\n' +
                  '    ------> (t) orderTable(OrderPnlView_Order) [ID, settlementDateTime]\n' +
                  '    root\n' +
                  '      ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '        ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '          ------> (t) accountTable(Order_Account) [ID]\n' +
                  '          ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (v) orderPnlView [ORDER_ID, pnl]\n' +
                   '    ------> (t) orderTable(equal_rootORDER_ID_orderTable_d_1_d_m2ID) [ID, settlementDateTime]\n' +
                   '    root\n' +
                   '      ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                   '        ------> (t) orderTable(equal_rootORDER_ID_orderTable_d#2_d#2_m3ID) [ID, accountID]\n' +
                   '          ------> (t) accountTable(equal_orderTable_d#2_d#2_m3accountID_accountTable_d#2_l_d#2_m3_rID) [ID]\n' +
                   '          ------> (t) salesPersonTable(equal_orderTable_d#2_d#2_m3accountID_salesPersonTable_d#2_l_d#2_m4_mdACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSimpleTableToViewJoin():Boolean[1]
{

   let query = {|Order.all()->project([o|$o.id, o|$o.pnl], ['ID', 'PNL'])};
   let mapping = meta::relational::tests::simpleRelationalMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) orderTable [ID]\n' +
                  '    ------> (v) orderPnlView(OrderPnlView_Order) [ORDER_ID, pnl]\n' +
                  '      root\n' +
                  '        ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '          ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '            ------> (t) accountTable(Order_Account) [ID]\n' +
                  '            ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) orderTable [ID]\n' +
                  '    ------> (v) orderPnlView(equal_orderPnlView_d#2_d_m2ORDER_ID_rootID) [ORDER_ID, pnl]\n' +
                  '      root\n' +
                  '        ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '          ------> (t) orderTable(equal_rootORDER_ID_orderTable_d#2_d#2_m3ID) [ID, accountID]\n' +
                  '            ------> (t) accountTable(equal_orderTable_d#2_d#2_m3accountID_accountTable_d#2_l_d#2_m3_rID) [ID]\n' +
                  '            ------> (t) salesPersonTable(equal_orderTable_d#2_d#2_m3accountID_salesPersonTable_d#2_l_d#2_m4_mdACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionViewOnView():Boolean[1]
{

   let query = {|OrderPnl.all()->project([#/OrderPnl/pnl#, #/OrderPnl/order/settlementDateTime#])};
   let mapping = meta::relational::tests::projection::view::unionOnViewOnViewMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (v) orderNegativePnlViewOnView [ORDER_ID, pnl]\n' +
                  '    ------> (t) orderTable(OrderNegativePnlViewOnView_Order) [ID, settlementDateTime]\n' +
                  '    root\n' +
                  '      ------> (v) orderNegativePnlView [ORDER_ID, pnl]\n' +
                  '        root\n' +
                  '          ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '            ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '              ------> (t) accountTable(Order_Account) [ID]\n' +
                  '              ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n' +
                  '  ------> (v) orderPnlViewOnView [ORDER_ID, pnl]\n' +
                  '    ------> (t) orderTable(OrderPnlViewOnView_Order) [ID, settlementDateTime]\n' +
                  '    root\n' +
                  '      ------> (v) orderPnlView [ORDER_ID, pnl]\n' +
                  '        root\n' +
                  '          ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '            ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '              ------> (t) accountTable(Order_Account) [ID]\n' +
                  '              ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 ='root\n'+
                  '  ------> (v) orderNegativePnlViewOnView [ORDER_ID, pnl]\n'+
                  '    ------> (t) orderTable(or_equal_SQLNull_orderTable_d_1_d_m2ID_equal_unionBaseORDER_ID_1_orderTable_d_1_d_m2ID) [ID, settlementDateTime]\n'+
                  '    root\n'+
                  '      ------> (v) orderNegativePnlView [ORDER_ID, pnl]\n'+
                  '        root\n'+
                  '          ------> (t) orderPnlTable [ORDER_ID, pnl]\n'+
                  '            ------> (t) orderTable(equal_rootORDER_ID_orderTable_d#2_d#2_m3ID) [ID, accountID]\n'+
                  '              ------> (t) accountTable(equal_orderTable_d#2_d#2_m3accountID_accountTable_d#2_l_d#2_m3_rID) [ID]\n'+
                  '              ------> (t) salesPersonTable(equal_orderTable_d#2_d#2_m3accountID_salesPersonTable_d#2_l_d#2_m4_mdACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n'+
                  '  ------> (v) orderPnlViewOnView [ORDER_ID, pnl]\n'+
                  '    ------> (t) orderTable(or_equal_unionBaseORDER_ID_0_orderTable_d_1_d_m2ID_equal_SQLNull_orderTable_d_1_d_m2ID) [ID, settlementDateTime]\n'+
                  '    root\n'+
                  '      ------> (v) orderPnlView [ORDER_ID, pnl]\n'+
                  '        root\n'+
                  '          ------> (t) orderPnlTable [ORDER_ID, pnl]\n'+
                  '            ------> (t) orderTable(equal_rootORDER_ID_orderTable_d#2_d#2_m3ID) [ID, accountID]\n'+
                  '              ------> (t) accountTable(equal_orderTable_d#2_d#2_m3accountID_accountTable_d#2_l_d#2_m3_rID) [ID]\n'+
                  '              ------> (t) salesPersonTable(equal_orderTable_d#2_d#2_m3accountID_salesPersonTable_d#2_l_d#2_m4_mdACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testViewEmbeddedInChainedJoin():Boolean[1]
{

   let query = {|Order.all()->project([o|$o.id, o|$o.pnlContact.firm.legalName], ['ID', 'PNL'])};
   let mapping = meta::relational::tests::MappingWithInnerJoinAndEmbeddedMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) orderTable [ID, accountID]\n' +
                  '    ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, PERSON_ID]\n' +
                  '      ------> (v) PersonFirmView(SalesPerson_PersonView) [PERSON_ID, firm_name]\n' +
                  '        root\n' +
                  '          ------> (t) personTable [FIRMID, ID, LASTNAME]\n' +
                  '            ------> (t) firmTable(Firm_Person) [ID, LEGALNAME]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) orderTable [ID, accountID]\n' +
                  '    ------> (t) salesPersonTable(equal_rootaccountID_salesPersonTable_d#6_d_m2ACCOUNT_ID) [ACCOUNT_ID, PERSON_ID]\n' +
                  '      ------> (v) PersonFirmView(equal_salesPersonTable_d#6PERSON_ID_PersonFirmView_d#6_lPERSON_ID) [PERSON_ID, firm_name]\n' +
                  '        root\n' +
                  '          ------> (t) personTable [FIRMID, ID, LASTNAME]\n' +
                  '            ------> (t) firmTable(equal_firmTable_d#6_l_d#6_l_m3ID_rootFIRMID) [ID, LEGALNAME]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSameRelationsAtSameLevel():Boolean[1]
{
   let query = {|meta::relational::tests::mapping::union::sqlQueryMerging::model::A.all()->filter(a|$a.p3 == 'A')->project([a|$a.pk, a|$a.p1, a|$a.p2], ['a_pk', 'a_p1', 'a_p3'])};
   let mapping = meta::relational::tests::mapping::union::sqlQueryMerging::mapping::unionMapping;

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::external::store::relational::tests::testRuntime(), relationalExtensions());
   let expected = 'root\n'+
                  '  ------> (t) aTable1 [fk, pk]\n'+
                  '    ------> (t) bTable1(equal_rootfk_bTable1_d#2_d_m2_m1fk) [fk]\n'+
                  '      ------> (t) cTable1(and_equal_bTable1_d#2fk_cTable1_d#2_lfk_equal_cTable1_d#2_lfk_8) [c1, fk]\n'+
                  '    ------> (t) bTable1(equal_rootfk_bTable1_d#2_d_m3_m1fk) [fk]\n'+
                  '      ------> (t) cTable1(and_equal_bTable1_d#2fk_cTable1_d#2_lfk_equal_cTable1_d#2_lfk_9) [c2, fk]\n'+
                  '    ------> (t) bTable1(equal_rootfk_bTable1_d#4_d#2_m1#2fk) [fk]\n'+
                  '      ------> (t) cTable1(and_equal_bTable1_d#4fk_cTable1_d#4_lfk_equal_cTable1_d#4_lfk_9) [fk]\n'+
                  '        ------> (t) dTable1(equal_cTable1_d#4_lfk_dTable1_d#4_l#2fk) [fk, pk]\n'+
                  '  ------> (t) aTable2 [fk, pk]\n'+
                  '    ------> (t) bTable2(equal_rootfk_bTable2_d#2_d_m2_m1fk) [fk]\n'+
                  '      ------> (t) cTable2(and_equal_bTable2_d#2fk_cTable2_d#2_lfk_equal_cTable2_d#2_lfk_8) [c1, fk]\n'+
                  '    ------> (t) bTable2(equal_rootfk_bTable2_d#2_d_m3_m1fk) [fk]\n'+
                  '      ------> (t) cTable2(and_equal_bTable2_d#2fk_cTable2_d#2_lfk_equal_cTable2_d#2_lfk_9) [c2, fk]\n'+
                  '    ------> (t) bTable2(equal_rootfk_bTable2_d#4_d#2_m1#2fk) [fk]\n'+
                  '      ------> (t) cTable2(and_equal_bTable2_d#4fk_cTable2_d#4_lfk_equal_cTable2_d#4_lfk_9) [fk]\n'+
                  '        ------> (t) dTable2(equal_cTable2_d#4_lfk_dTable2_d#4_l#2fk) [fk, pk]\n';

   assertEquals($expected, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testFunctionWithGraphFetch():Boolean[1]
{

   let query = {|Trade.all()->graphFetch(#{
      Trade {
         id,
         product {
            name,
            synonymByType(ProductSynonymType.CUSIP) {
               typeAsString,
               name
            }
         }
      }
   }#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   assertEquals(
      'root\n'+
      '  ------> (t) tradeTable [ID, prodId]\n'+
      '    ------> (t) productTable(Trade_Product) [ID, NAME]\n'+
      '      ------> (t) synonymTable(Product_Synonym) [NAME, PRODID, TYPE]\n', $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testFunctionWithGraphFetchNoDefaults():Boolean[1]
{

   let query = {|Trade.all()->graphFetch(#{
      Trade {
         id,
         product {
            name,
            synonymByType(ProductSynonymType.CUSIP) {
               type
            }
         }
      }
   }#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   assertEquals(
      'root\n'+
      '  ------> (t) tradeTable [ID, prodId]\n'+
      '    ------> (t) productTable(Trade_Product) [ID, NAME]\n'+
      '      ------> (t) synonymTable(Product_Synonym) [PRODID, TYPE]\n', $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableInQualifiedPropertiesInGraphFetchTree():Boolean[1]
{

   let query = {|Firm.all()->graphFetch(#{
      Firm {
         legalName,
         averageEmployeesAge
      }
   }#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   assertEquals(
      'root\n'+
      '  ------> (t) firmTable [ID, LEGALNAME]\n'+
      '    ------> (t) personTable(Firm_Person) [AGE, FIRMID]\n', $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testMultipleTablesInQualifiedPropertiesInGraphFetchTree():Boolean[1]
{

   let query = {|Firm.all()->graphFetch(#{
      Firm {
         legalName,
         averageEmployeesAge,
         employeesByCityOrManagerAndLastName('', '', '') {
            lastName
         }
      }
   }#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, relationalExtensions())-> toOne();
   assertEquals(
      'root\n'+
      '  ------> (t) firmTable [ID, LEGALNAME]\n'+
      '    ------> (t) personTable(Firm_Person) [ADDRESSID, AGE, FIRMID, ID, LASTNAME, MANAGERID]\n'+
      '      ------> (t) addressTable(Address_Person) [ID, NAME]\n'+
      '      ------> (t) personTable(Person_Manager) [FIRSTNAME, ID, LASTNAME, MANAGERID]\n', $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsSimple():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n';
   assertEquals($expectedTree, $relationTree->relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithProject():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                          ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'first_name'), col(r:TDSRow[1]|$r.getString('LASTNAME'), 'last_name')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME, LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithDuplicateProjectColumns():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                          ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'first_name'), col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name_again')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithRestrict():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->restrict(['FIRSTNAME', 'AGE'])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [AGE, FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithFilter():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->meta::pure::tds::filter({r:TDSRow[1] | $r.getString('FIRSTNAME') == 'John'})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithFilterAndProject():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->meta::pure::tds::filter({r:TDSRow[1] | $r.getString('FIRSTNAME') == 'John'})
                        ->project([col(r:TDSRow[1]|$r.getString('LASTNAME'), 'name')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME, LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithFilterAndProjectOperatingOnSameColumns():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->meta::pure::tds::filter({r:TDSRow[1] | $r.getString('FIRSTNAME') == 'John'})
                        ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithExtend():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'firstName')])
                        ->extend([col({r:TDSRow[1]|'Hello'}, 'hello')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithDistinctAndTake():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name')])->distinct()->take(2)};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithSort():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->sort('LASTNAME')->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME, LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithGroupBy():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                         ->groupBy(['FIRSTNAME'], agg('cnt', x|$x.getString('LASTNAME'), y| $y->count()))};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME, LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithConcatenate():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::dbInc,'default','personTable'))
                        ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'firstName')])
                        ->concatenate(Person.all()->project([col(p|$p.lastName, 'lastName')]))};

   let mapping = meta::relational::tests::simpleRelationalMappingInc;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n'+
                      '  ------> (t) personTable [LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithConcatenateUsingDifferentTables():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::dbInc,'default','personTable'))
                        ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name')])
                        ->concatenate(tableToTDS(tableReference(meta::relational::tests::dbInc,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('LEGALNAME'), 'name')]))};

   let mapping = meta::relational::tests::simpleRelationalMappingInc;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) firmTable [LEGALNAME]\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithJoin():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))->project([col(r:TDSRow[1]|$r.getInteger('ID'), 'eID')])
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable')), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('ID');})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ID]\n'+
                      '    ------> (t) firmTable(equal_"joinleft_"_deID_"joinright_"_dID) [ADDRESSID, CEOID, ID, LEGALNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithJoinAndUnion():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->project([col(r:TDSRow[1]|$r.getString('ID'), 'eID')])
                        ->concatenate(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'eID')]))
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','addressTable')), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('ID');})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) firmTable [ID]\n'+
                      '    ------> (t) addressTable [COMMENTS, ID, NAME, STREET, TYPE]\n'+
                      '  ------> (t) personTable [ID]\n'+
                      '    ------> (t) addressTable [COMMENTS, ID, NAME, STREET, TYPE]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithMultipleJoin():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'personID')])
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'firmID'), col(r:TDSRow[1]|$r.getString('CEOID'), 'ceoID')]), JoinType.INNER, {a,b|$a.getInteger('personID') == $b.getInteger('firmID');})
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','addressTable')), JoinType.LEFT_OUTER, {a,b|$a.getInteger('ceoID') == $b.getInteger('ID');})
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','locationTable'))->project([col(r:TDSRow[1]|$r.getInteger('PERSONID'), 'locationPersonID')]), JoinType.LEFT_OUTER, {a,b|$a.getInteger('personID') == $b.getInteger('locationPersonID');})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ID]\n'+
                      '    ------> (t) firmTable [CEOID, ID]\n'+
                      '      ------> (t) addressTable [COMMENTS, ID, NAME, STREET, TYPE]\n'+
                      '    ------> (t) locationTable [PERSONID]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithJoinToSameTable():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'personID')])
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','personTable')), JoinType.INNER, {a,b|$a.getInteger('personID') == $b.getInteger('ID');})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ID]\n'+
                      '    ------> (t) personTable(equal_"joinleft_"_dpersonID_"joinright_"_dID) [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithOLAPGroupBy():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                     ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'firmID'), col(r:TDSRow[1]|$r.getString('CEOID'), 'ceoID')]), JoinType.INNER, {a,b|$a.getInteger('ID') == $b.getInteger('firmID');})
                     ->groupBy(['FIRSTNAME','LASTNAME'], agg('cnt', x|$x.getInteger('AGE'), y| $y->sum()))
                     ->olapGroupBy('FIRSTNAME',asc('LASTNAME'),func('cnt',y|$y->sum()),'testCol1')};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n' +
                      '    ------> (t) firmTable(equal_"joinleft_"_d#3ID_"joinright_"_d#3firmID) [CEOID, ID]\n';

   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithCrossJoin():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                     ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'firmID'), col(r:TDSRow[1]|$r.getString('CEOID'), 'ceoID')]), JoinType.INNER, {a,b| true})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::external::store::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n' +
                      '    ------> (t) firmTable(tdsJoin) [CEOID, ID]\n';

   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTdsJoinConcatenateAndJoin():Boolean[1]
{
  let query = {|testJoinTDS_Person.all()
                ->project([col({p:testJoinTDS_Person[1]|$p.firstName}, 'First_1'),
                          col({p:testJoinTDS_Person[1]|$p.age}, 'Age_1')])
                ->join(
                      testJoinTDS_Person.all()
                      ->project([col({p:testJoinTDS_Person[1]|$p.firstName}, 'First_2'),
                                col({p:testJoinTDS_Person[1]|$p.age}, 'Age_2')]), JoinType.LEFT_OUTER,  'First_1', 'First_2'
                )
                ->join(
                      testJoinTDS_Person.all()
                      ->project([col({p:testJoinTDS_Person[1]|$p.firstName}, 'First_3'),
                                col({p:testJoinTDS_Person[1]|$p.age}, 'Age_3')]) , JoinType.LEFT_OUTER,  'First_2', 'First_3'
                )
                ->extend(^BasicColumnSpecification<meta::pure::tds::TDSRow>(name='Restated' , func=r: TDSRow[1]|false))
              ->concatenate(
                     testJoinTDS_Person.all()
                      ->project([col({p:testJoinTDS_Person[1]|$p.firstName}, 'First_1'),
                          col({p:testJoinTDS_Person[1]|$p.age}, 'Age_1')])
                ->join(
                      testJoinTDS_Person.all()
                      ->project([col({p:testJoinTDS_Person[1]|$p.firstName}, 'First_2'),
                                col({p:testJoinTDS_Person[1]|$p.age}, 'Age_2')]), JoinType.LEFT_OUTER,  'First_1', 'First_2'
                )
              )
              ->join(
                  testJoinTDS_Person.all()->filter(x|$x.firstName->in('Pierre'))->project([x|$x.firstName, x|$x.age], ['fName', 'age']),
                  JoinType.LEFT_OUTER,  'First_1', 'fName'
              )};

  let mapping =  testJoinTDSMapping;
  let runtime =  meta::external::store::relational::tests::testRuntime();
  let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, relationalExtensions());
  let expectedTree = 'root\n'+
                      '  ------> (t) personTable [AGE, FIRSTNAME]\n'+
                      '    ------> (t) personTable(equal_"joinleft_"_dFirst_1_"joinright_"_dfName) [AGE, FIRSTNAME]\n'+
                      '    ------> (t) personTable(equal_"joinleft_"_d_d0_d#3First_2_"joinright_"_d_d0_d#3First_3) [AGE, FIRSTNAME]\n'+
                      '    ------> (t) personTable(equal_"joinleft_"_d_d0_d#3_d0_dFirst_1_"joinright_"_d_d0_d#3_d0_dFirst_2) [AGE, FIRSTNAME]\n'+
                      '  ------> (t) personTable [AGE, FIRSTNAME]\n'+
                      '    ------> (t) personTable(equal_"joinleft_"_dFirst_1_"joinright_"_dfName) [AGE, FIRSTNAME]\n'+
                      '    ------> (t) personTable(equal_"joinleft_"_d_d0_d#2First_1_"joinright_"_d_d0_d#2First_2) [AGE, FIRSTNAME]\n';

   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}
