// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::language::java::factory::*;
import meta::external::language::java::factory::project::*;
import meta::external::language::java::metamodel::*;
import meta::external::language::java::metamodel::project::*;
import meta::external::language::java::serialization::*;

function meta::external::language::java::factory::javaIllegalArgumentException():      meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.IllegalArgumentException'); }
function meta::external::language::java::factory::javaIllegalStateException():         meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.IllegalStateException'); }
function meta::external::language::java::factory::javaIllegalAccessException():        meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.IllegalAccessException'); }
function meta::external::language::java::factory::javaNumberFormatException():         meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.NumberFormatException'); }
function meta::external::language::java::factory::javaRuntimeException():              meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.RuntimeException'); }
function meta::external::language::java::factory::javaUnsupportedOperationException(): meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.UnsupportedOperationException'); }
function meta::external::language::java::factory::javaCharSequence():                  meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.CharSequence'); }
function meta::external::language::java::factory::javaMath():                          meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.Math'); }
function meta::external::language::java::factory::javaStrictMath():                    meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.StrictMath'); }
function meta::external::language::java::factory::javaSystem():                        meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.System'); }
function meta::external::language::java::factory::javaStringBuilder():                 meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.StringBuilder'); }
function meta::external::language::java::factory::javaAppendable():                    meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.Appendable'); }
function meta::external::language::java::factory::javaClassType():                     meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.Class'); }

function meta::external::language::java::factory::javaReflectType():           meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.reflect.Type'); }
function meta::external::language::java::factory::javaReflectMethod():         meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.reflect.Method'); }
function meta::external::language::java::factory::javaInvocationTargetException():         meta::external::language::java::metamodel::Class[1] { javaClass('java.lang.reflect.InvocationTargetException'); }

function meta::external::language::java::factory::javaMathContext():           meta::external::language::java::metamodel::Class[1] { javaClass('java.math.MathContext'); }
function meta::external::language::java::factory::javaRoundingMode():          meta::external::language::java::metamodel::Class[1] { javaEnum([], 'java.math.RoundingMode'); }

function meta::external::language::java::factory::javaIOException():           meta::external::language::java::metamodel::Class[1] { javaClass('java.io.IOException'); }
function meta::external::language::java::factory::javaBufferedInputStream():   meta::external::language::java::metamodel::Class[1] { javaClass('java.io.BufferedInputStream'); }
function meta::external::language::java::factory::javaByteArrayOutputStream(): meta::external::language::java::metamodel::Class[1] { javaClass('java.io.ByteArrayOutputStream'); }
function meta::external::language::java::factory::javaInputStreamReader():     meta::external::language::java::metamodel::Class[1] { javaClass('java.io.InputStreamReader'); }
function meta::external::language::java::factory::javaPrintStream():           meta::external::language::java::metamodel::Class[1] { javaClass('java.io.PrintStream'); }
function meta::external::language::java::factory::javaStringWriter():          meta::external::language::java::metamodel::Class[1] { javaClass('java.io.StringWriter'); }
function meta::external::language::java::factory::javaSerializable():          meta::external::language::java::metamodel::Class[1] { javaClass('java.io.Serializable'); }

function meta::external::language::java::factory::javaURL():  meta::external::language::java::metamodel::Class[1] { javaClass('java.net.URL'); }

function meta::external::language::java::factory::javaTemporal():  meta::external::language::java::metamodel::Class[1] { javaClass('java.time.temporal.Temporal'); }

function meta::external::language::java::factory::javaNoSuchElementException(): meta::external::language::java::metamodel::Class[1] { javaClass('java.util.NoSuchElementException'); }
function meta::external::language::java::factory::javaArrays():                 meta::external::language::java::metamodel::Class[1] { javaClass('java.util.Arrays'); }
function meta::external::language::java::factory::javaCollections():            meta::external::language::java::metamodel::Class[1] { javaClass('java.util.Collections'); }
function meta::external::language::java::factory::javaLocale():                 meta::external::language::java::metamodel::Class[1] { javaClass('java.util.Locale'); }
function meta::external::language::java::factory::javaObjects():                meta::external::language::java::metamodel::Class[1] { javaClass('java.util.Objects'); }
function meta::external::language::java::factory::javaList():                   meta::external::language::java::metamodel::Class[1] { javaClass('java.util.List'); }
function meta::external::language::java::factory::javaArrayList():              meta::external::language::java::metamodel::Class[1] { javaClass('java.util.ArrayList'); }
function meta::external::language::java::factory::javaLinkedList():             meta::external::language::java::metamodel::Class[1] { javaClass('java.util.LinkedList'); }
function meta::external::language::java::factory::javaSet():                    meta::external::language::java::metamodel::Class[1] { javaClass('java.util.Set'); }
function meta::external::language::java::factory::javaEnumSet():                meta::external::language::java::metamodel::Class[1] { javaClass('java.util.EnumSet'); }
function meta::external::language::java::factory::javaHashMap():                meta::external::language::java::metamodel::Class[1] { javaClass('java.util.HashMap'); }
function meta::external::language::java::factory::javaTreeMap():                meta::external::language::java::metamodel::Class[1] { javaClass('java.util.TreeMap'); }
function meta::external::language::java::factory::javaCalendar():               meta::external::language::java::metamodel::Class[1] { javaClass('java.util.Calendar'); }
function meta::external::language::java::factory::javaGregorianCalendar():      meta::external::language::java::metamodel::Class[1] { javaClass('java.util.GregorianCalendar'); }
function meta::external::language::java::factory::javaSpliterator():            meta::external::language::java::metamodel::Class[1] { javaClass('java.util.Spliterator'); }
function meta::external::language::java::factory::javaSpliterators():           meta::external::language::java::metamodel::Class[1] { javaClass('java.util.Spliterators'); }

function meta::external::language::java::factory::javaInstant():                meta::external::language::java::metamodel::Class[1] { javaClass('java.time.Instant'); }
function meta::external::language::java::factory::javaLocalDate():              meta::external::language::java::metamodel::Class[1] { javaClass('java.time.LocalDate'); }

function meta::external::language::java::factory::javaCollector():              meta::external::language::java::metamodel::Class[1] { javaClass('java.util.stream.Collector'); }
function meta::external::language::java::factory::javaCollectors():             meta::external::language::java::metamodel::Class[1] { javaClass('java.util.stream.Collectors'); }
function meta::external::language::java::factory::javaLongStream():             meta::external::language::java::metamodel::Class[1] { javaClass('java.util.stream.LongStream'); }
function meta::external::language::java::factory::javaStreamSupport():          meta::external::language::java::metamodel::Class[1] { javaClass('java.util.stream.StreamSupport'); }

function meta::external::language::java::factory::javaConcurrentHashMap():      meta::external::language::java::metamodel::Class[1] { javaClass('java.util.concurrent.ConcurrentHashMap'); }

function meta::external::language::java::factory::javaDecimalFormat():          meta::external::language::java::metamodel::Class[1] { javaClass('java.text.DecimalFormat'); }
function meta::external::language::java::factory::javaDecimalFormatSymbols():   meta::external::language::java::metamodel::Class[1] { javaClass('java.text.DecimalFormatSymbols'); }

function meta::external::language::java::factory::javaResultSet():              meta::external::language::java::metamodel::Class[1] { javaClass('java.sql.ResultSet'); }
function meta::external::language::java::factory::javaSqlDate():                meta::external::language::java::metamodel::Class[1] { javaClass('java.sql.Date'); }
function meta::external::language::java::factory::javaSqlTimestamp():                meta::external::language::java::metamodel::Class[1] { javaClass('java.sql.Timestamp'); }

function meta::external::language::java::factory::javaUUID():                   meta::external::language::java::metamodel::Class[1] { javaClass('java.util.UUID');}

function meta::external::language::java::factory::javaCollection(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Collection'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaList(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.List'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaQueue(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Queue'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaArrayList(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.ArrayList'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaLinkedList(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.LinkedList'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaSet(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaSet(), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaEnumSet(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaEnumSet(), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaMap(key:meta::external::language::java::metamodel::Type[1], value:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Map'), typeArguments=[$key->toBoxed(), $value->toBoxed()]);
}

function meta::external::language::java::factory::javaTreeMap(key:meta::external::language::java::metamodel::Type[1], value:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaTreeMap(), typeArguments=[$key->toBoxed(), $value->toBoxed()]);
}

function meta::external::language::java::factory::javaHashMap(key:meta::external::language::java::metamodel::Type[1], value:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaHashMap(), typeArguments=[$key->toBoxed(), $value->toBoxed()]);
}

function meta::external::language::java::factory::javaStack(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Stack'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaWildcard() : meta::external::language::java::metamodel::WildcardType[1]
{
   javaWildcardType([], []);
}

function meta::external::language::java::factory::javaWildcardExtends(extend:meta::external::language::java::metamodel::Type[*]) : meta::external::language::java::metamodel::WildcardType[1]
{
   javaWildcardType([], $extend);
}

function meta::external::language::java::factory::javaWildcardSuper(super:meta::external::language::java::metamodel::Type[*]) : meta::external::language::java::metamodel::WildcardType[1]
{
   javaWildcardType($super, []);
}

function meta::external::language::java::factory::javaWildcardType(super:meta::external::language::java::metamodel::Type[*], extend:meta::external::language::java::metamodel::Type[*]) : meta::external::language::java::metamodel::WildcardType[1]
{
   ^meta::external::language::java::metamodel::WildcardType(lowerBounds=$super, upperBounds=$extend);
}

function meta::external::language::java::factory::javaParameterizedType(rawType:meta::external::language::java::metamodel::Class[1], typeArguments:meta::external::language::java::metamodel::Type[*]) : meta::external::language::java::metamodel::ParameterizedType[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=$rawType, typeArguments=$typeArguments)
}

function meta::external::language::java::factory::javaArray(rawType:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Array[1]
{
   ^meta::external::language::java::metamodel::Array(rawType=$rawType)
}

function meta::external::language::java::factory::javaClassType(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::ParameterizedType[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.lang.Class'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaSpliterator(t:meta::external::language::java::metamodel::Type[1]): meta::external::language::java::metamodel::ParameterizedType[1]
{ 
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaSpliterator(), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaStream(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::ParameterizedType[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaStream(), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaStream() : meta::external::language::java::metamodel::Class[1]
{
   javaClass('java.util.stream.Stream');
}

function meta::external::language::java::factory::javaOptional() : meta::external::language::java::metamodel::Class[1]
{
   javaClass('java.util.Optional');
}

function meta::external::language::java::factory::javaOptional(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::ParameterizedType[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Optional'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaIterator(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Iterator'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaConsumer(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.Consumer'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaSupplier(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.Supplier'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaLongPredicate() : meta::external::language::java::metamodel::Type[1]
{
   javaClass('java.util.function.LongPredicate');
}

function meta::external::language::java::factory::javaPredicate(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
    ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.Predicate'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaBiPredicate(t:meta::external::language::java::metamodel::Type[1],u:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
    ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.BiPredicate'), typeArguments=[$t->toBoxed(), $u->toBoxed()]);
}

function meta::external::language::java::factory::javaLongUnaryOperator() : meta::external::language::java::metamodel::Type[1]
{
   javaClass('java.util.function.LongUnaryOperator');
}

function meta::external::language::java::factory::javaObject() : meta::external::language::java::metamodel::Class[1]
{
   ^meta::external::language::java::metamodel::Class(simpleName = 'Object', package = ^meta::external::language::java::metamodel::Package(name = 'lang', parent = ^meta::external::language::java::metamodel::Package(name = 'java')));
}

function meta::external::language::java::factory::javaComparable(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.lang.Comparable'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaComparable() : meta::external::language::java::metamodel::Type[1]
{
   javaClass('java.lang.Comparable');
}

function meta::external::language::java::factory::javaComparator(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Comparator'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaComparator() : meta::external::language::java::metamodel::Type[1]
{
   javaClass('java.util.Comparator');
}

function meta::external::language::java::factory::javaFunction(t:meta::external::language::java::metamodel::Type[1], r:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.Function'), typeArguments=[$t->toBoxed(), $r->toBoxed()]);
}

function meta::external::language::java::factory::javaBiFunction(t:meta::external::language::java::metamodel::Type[1], u:meta::external::language::java::metamodel::Type[1], r:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.BiFunction'), typeArguments=[$t->toBoxed(), $u->toBoxed(), $r->toBoxed()]);
}

function meta::external::language::java::factory::javaBinaryOperator(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.BinaryOperator'), typeArguments=[$t->toBoxed()]);
}

function meta::external::language::java::factory::javaInputStream() : meta::external::language::java::metamodel::Class[1]
{
   javaClass('java.io.InputStream');
}

function meta::external::language::java::factory::javaClass(t:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   ^meta::external::language::java::metamodel::ParameterizedType(rawType=javaClass('java.lang.Class'), typeArguments=$t->toBoxed());
}

function meta::external::language::java::factory::javaBufferedReader() : meta::external::language::java::metamodel::Class[1]
{
   ^meta::external::language::java::metamodel::Class(simpleName = 'BufferedReader', package = ^meta::external::language::java::metamodel::Package(name = 'io', parent = ^meta::external::language::java::metamodel::Package(name = 'java')));
}

function meta::external::language::java::factory::javaException() : meta::external::language::java::metamodel::Class[1]
{
   javaClass('java.lang.Exception');
}

function meta::external::language::java::factory::javaString() : meta::external::language::java::metamodel::Class[1]
{
   ^meta::external::language::java::metamodel::Class(simpleName = 'String', package = ^meta::external::language::java::metamodel::Package(name = 'lang', parent = ^meta::external::language::java::metamodel::Package(name = 'java')));
}

function meta::external::language::java::factory::javaVoid() : meta::external::language::java::metamodel::Class[1]
{
   ^meta::external::language::java::metamodel::Class(simpleName = 'Void', package = ^meta::external::language::java::metamodel::Package(name = 'lang', parent = ^meta::external::language::java::metamodel::Package(name = 'java')));
}

function meta::external::language::java::factory::javaByteClass() : meta::external::language::java::metamodel::Class[1]
{
   ^meta::external::language::java::metamodel::Class(simpleName = 'Byte', package = ^meta::external::language::java::metamodel::Package(name = 'lang', parent = ^meta::external::language::java::metamodel::Package(name = 'java')));
}

function meta::external::language::java::factory::javaByte() : meta::external::language::java::metamodel::PrimitiveType[1]
{
   ^meta::external::language::java::metamodel::PrimitiveType(simpleName = 'byte');
}

function meta::external::language::java::factory::javaShort() : meta::external::language::java::metamodel::PrimitiveType[1]
{
   ^meta::external::language::java::metamodel::PrimitiveType(simpleName = 'short');
}

function meta::external::language::java::factory::javaInt() : meta::external::language::java::metamodel::PrimitiveType[1]
{
   ^meta::external::language::java::metamodel::PrimitiveType(simpleName = 'int');
}

function meta::external::language::java::factory::javaLong() : meta::external::language::java::metamodel::PrimitiveType[1]
{
   ^meta::external::language::java::metamodel::PrimitiveType(simpleName = 'long');
}

function meta::external::language::java::factory::javaLongMax() : Code[1]
{
    javaLongBoxed()->j_field('MAX_VALUE', javaLong());
}

function meta::external::language::java::factory::javaLongMin() : Code[1]
{
    javaLongBoxed()->j_field('MIN_VALUE', javaLong());
}

function meta::external::language::java::factory::javaFloat() : meta::external::language::java::metamodel::PrimitiveType[1]
{
   ^meta::external::language::java::metamodel::PrimitiveType(simpleName = 'float');
}

function meta::external::language::java::factory::javaDouble() : meta::external::language::java::metamodel::PrimitiveType[1]
{
   ^meta::external::language::java::metamodel::PrimitiveType(simpleName = 'double');
}

function meta::external::language::java::factory::javaBoolean() : meta::external::language::java::metamodel::PrimitiveType[1]
{
   ^meta::external::language::java::metamodel::PrimitiveType(simpleName = 'boolean');
}

function meta::external::language::java::factory::javaChar() : meta::external::language::java::metamodel::PrimitiveType[1]
{
   ^meta::external::language::java::metamodel::PrimitiveType(simpleName = 'char');
}

function meta::external::language::java::factory::toBoxed(type:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   if($type == javaBoolean(),
      | javaClass('java.lang.Boolean'),
      |
   if($type == javaByte(),
      | javaClass('java.lang.Byte'),
      |
   if($type == javaChar(),
      | javaClass('java.lang.Character'),
      |
   if($type == javaFloat(),
      | javaClass('java.lang.Float'),
      |
   if($type == javaDouble(),
      | javaClass('java.lang.Double'),
      |
   if($type == javaInt(),
      | javaClass('java.lang.Integer'),
      |
   if($type == javaLong(),
      | javaClass('java.lang.Long'),
      |
   if($type == javaShort(),
      | javaClass('java.lang.Short'),
      | $type
   ))))))));
}

function meta::external::language::java::factory::toUnboxed(type:meta::external::language::java::metamodel::Type[1]) : meta::external::language::java::metamodel::Type[1]
{
   if($type == javaClass('java.lang.Boolean'),
      | javaBoolean(),
      |
   if($type == javaClass('java.lang.Byte'),
      | javaByte(),
      |
   if($type == javaClass('java.lang.Character'),
      | javaChar(),
      |
   if($type == javaClass('java.lang.Float'),
      | javaFloat(),
      |
   if($type == javaClass('java.lang.Double'),
      | javaDouble(),
      |
   if($type == javaClass('java.lang.Integer'),
      | javaInt(),
      |
   if($type == javaClass('java.lang.Long'),
      | javaLong(),
      |
   if($type == javaClass('java.lang.Short'),
      | javaShort(),
      | $type
   ))))))));
}

function meta::external::language::java::factory::javaBooleanBoxed() : meta::external::language::java::metamodel::Class[1] { javaBoolean()->toBoxed()->cast(@meta::external::language::java::metamodel::Class); }
function meta::external::language::java::factory::javaByteBoxed()    : meta::external::language::java::metamodel::Class[1] { javaByte()   ->toBoxed()->cast(@meta::external::language::java::metamodel::Class); }
function meta::external::language::java::factory::javaCharBoxed()    : meta::external::language::java::metamodel::Class[1] { javaChar()   ->toBoxed()->cast(@meta::external::language::java::metamodel::Class); }
function meta::external::language::java::factory::javaIntBoxed()     : meta::external::language::java::metamodel::Class[1] { javaInt()    ->toBoxed()->cast(@meta::external::language::java::metamodel::Class); }
function meta::external::language::java::factory::javaLongBoxed()    : meta::external::language::java::metamodel::Class[1] { javaLong()   ->toBoxed()->cast(@meta::external::language::java::metamodel::Class); }
function meta::external::language::java::factory::javaShortBoxed()   : meta::external::language::java::metamodel::Class[1] { javaShort()  ->toBoxed()->cast(@meta::external::language::java::metamodel::Class); }
function meta::external::language::java::factory::javaFloatBoxed()   : meta::external::language::java::metamodel::Class[1] { javaFloat()  ->toBoxed()->cast(@meta::external::language::java::metamodel::Class); }
function meta::external::language::java::factory::javaDoubleBoxed()  : meta::external::language::java::metamodel::Class[1] { javaDouble() ->toBoxed()->cast(@meta::external::language::java::metamodel::Class); }

function meta::external::language::java::factory::javaDate() : meta::external::language::java::metamodel::Class[1]
{
   javaClass('java.util.Date');
}

function meta::external::language::java::factory::javaNumber() : meta::external::language::java::metamodel::Class[1]
{
   javaClass('java.lang.Number');
}

function meta::external::language::java::factory::javaBigInteger() : meta::external::language::java::metamodel::Class[1]
{
   javaClass('java.math.BigInteger');
}

function meta::external::language::java::factory::javaBigDecimal() : meta::external::language::java::metamodel::Class[1]
{
   javaClass('java.math.BigDecimal');
}

function meta::external::language::java::factory::javaPackage(package:String[1]):meta::external::language::java::metamodel::Package[1]
{
   let dotPos = $package->lastIndexOf('.');
   if($dotPos == -1,
      |^meta::external::language::java::metamodel::Package(name=$package),
      |^meta::external::language::java::metamodel::Package(name=$package->substring($dotPos+1), parent=$package->substring(0, $dotPos)->javaPackage())
   );
}

function meta::external::language::java::factory::javaEnum(pkg:meta::external::language::java::metamodel::Package[1], name:String[1]): meta::external::language::java::metamodel::Enumeration[1]
{
   javaEnum([], $pkg, $name);
}

function meta::external::language::java::factory::javaEnum(modifiers:String[*], qualifiedName:String[1]): meta::external::language::java::metamodel::Enumeration[1]
{
   let dotPos  = $qualifiedName->lastIndexOf('.');
   let package = if($dotPos == -1, |^meta::external::language::java::metamodel::Package(name=''), |javaPackage($qualifiedName->substring(0, $dotPos)));
   let name    = if($dotPos == -1, |$qualifiedName,                           |$qualifiedName->substring($dotPos+1));

   javaEnum($modifiers, $package, $name);
}

function meta::external::language::java::factory::javaEnum(modifiers:String[*], pkg:meta::external::language::java::metamodel::Package[1], name:String[1]): meta::external::language::java::metamodel::Enumeration[1]
{
   ^meta::external::language::java::metamodel::Enumeration(modifiers=$modifiers->javaModifiers(), package=$pkg, simpleName=$name);
}

function meta::external::language::java::factory::addEntry(enum:meta::external::language::java::metamodel::Enumeration[1], entry:meta::external::language::java::metamodel::EnumerationEntry[1]): meta::external::language::java::metamodel::Enumeration[1]
{
   $enum->addEntries($entry);
}

function meta::external::language::java::factory::addEntries(enum:meta::external::language::java::metamodel::Enumeration[1], entries:meta::external::language::java::metamodel::EnumerationEntry[*]): meta::external::language::java::metamodel::Enumeration[1]
{
   ^$enum(enumeration=$enum.enumeration->concatenate($entries));
}

function meta::external::language::java::factory::javaEnumEntry(name:String[1]): meta::external::language::java::metamodel::EnumerationEntry[1]
{
   ^meta::external::language::java::metamodel::EnumerationEntry(name=$name);
}

function meta::external::language::java::factory::javaEnumEntry(name:String[1], args:Code[*]): meta::external::language::java::metamodel::EnumerationEntry[1]
{
   ^meta::external::language::java::metamodel::EnumerationEntry(name=$name, arguments=$args);
}

function meta::external::language::java::factory::javaEnumEntry(name:String[1], args:String[1]): meta::external::language::java::metamodel::EnumerationEntry[1]
{
   ^meta::external::language::java::metamodel::EnumerationEntry(name=$name, value=$args);
}

function meta::external::language::java::factory::javaClass(fullClassName:String[1]):meta::external::language::java::metamodel::Class[1]
{
   javaClass([], $fullClassName);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], fullClassName:String[1]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $fullClassName);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], proto:meta::external::language::java::metamodel::Class[1]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $proto->typeToString());
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], typeParams:meta::external::language::java::metamodel::TypeVariable[*], proto:meta::external::language::java::metamodel::Class[1]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, $typeParams, $proto->typeToString());
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], typeParams:meta::external::language::java::metamodel::TypeVariable[*], fullClassName:String[1]):meta::external::language::java::metamodel::Class[1]
{
   let dotPos  = $fullClassName->lastIndexOf('.');
   let package = if($dotPos == -1, |^meta::external::language::java::metamodel::Package(name=''), |javaPackage($fullClassName->substring(0, $dotPos)));
   let name    = if($dotPos == -1, |$fullClassName,                           |$fullClassName->substring($dotPos+1));

   javaClass($modifiers, $typeParams, $package, $name);
}

function meta::external::language::java::factory::javaClass(pkg:meta::external::language::java::metamodel::Package[1], name:String[1]):meta::external::language::java::metamodel::Class[1]
{
   javaClass([], $pkg, $name);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], pkg:meta::external::language::java::metamodel::Package[1], name:String[1]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $pkg, $name);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], typeParams:meta::external::language::java::metamodel::TypeVariable[*], pkg:meta::external::language::java::metamodel::Package[1], name:String[1]):meta::external::language::java::metamodel::Class[1]
{
   ^meta::external::language::java::metamodel::Class(modifiers=$modifiers->javaModifiers(), typeParameters=$typeParams, package=$pkg, simpleName=$name);
}

function meta::external::language::java::factory::javaClass(proto:meta::external::language::java::metamodel::Class[1], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($proto, [], $methods);
}

function meta::external::language::java::factory::javaClass(proto:meta::external::language::java::metamodel::Class[1], fields:meta::external::language::java::metamodel::Field[*], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass([]->cast(@meta::external::language::java::metamodel::TypeVariable), $proto, $fields, $methods);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], proto:meta::external::language::java::metamodel::Class[1], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, $proto, [], $methods);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], proto:meta::external::language::java::metamodel::Class[1], fields:meta::external::language::java::metamodel::Field[*], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $proto->typeToString(), $fields, $methods);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], fullClassName:String[1], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $fullClassName, [], $methods);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], fullClassName:String[1], fields:meta::external::language::java::metamodel::Field[*], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $fullClassName, $fields, $methods);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], typeParams:meta::external::language::java::metamodel::TypeVariable[*], fullClassName:String[1], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, $typeParams, $fullClassName, [], $methods);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], typeParams:meta::external::language::java::metamodel::TypeVariable[*], fullClassName:String[1], fields:meta::external::language::java::metamodel::Field[*], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   let dotPos  = $fullClassName->lastIndexOf('.');
   let package = if($dotPos == -1, |^meta::external::language::java::metamodel::Package(name=''), |javaPackage($fullClassName->substring(0, $dotPos)));
   let name    = if($dotPos == -1, |$fullClassName,                           |$fullClassName->substring($dotPos+1));

   javaClass($modifiers, $typeParams, $package, $name, $fields, $methods);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], typeParams:meta::external::language::java::metamodel::TypeVariable[*], pkg:meta::external::language::java::metamodel::Package[1], name:String[1], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($modifiers, $typeParams, $pkg, $name, [], $methods);
}

function meta::external::language::java::factory::javaClass(modifiers:String[*], typeParams:meta::external::language::java::metamodel::TypeVariable[*], pkg:meta::external::language::java::metamodel::Package[1], name:String[1], fields:meta::external::language::java::metamodel::Field[*], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($typeParams, javaClass($modifiers, [], $pkg, $name), $fields, $methods);
}

function meta::external::language::java::factory::javaClass(typeParams:meta::external::language::java::metamodel::TypeVariable[*], proto:meta::external::language::java::metamodel::Class[1], fields:meta::external::language::java::metamodel::Field[*], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass($typeParams, $proto, $fields, [], $methods);
}

function meta::external::language::java::factory::javaClass(proto:meta::external::language::java::metamodel::Class[1], fields:meta::external::language::java::metamodel::Field[*], constructors:Pair<meta::external::language::java::metamodel::Constructor,Code>[*], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   javaClass([], $proto, $fields, $constructors, $methods);
}

function meta::external::language::java::factory::javaClass(typeParams:meta::external::language::java::metamodel::TypeVariable[*], proto:meta::external::language::java::metamodel::Class[1], fields:meta::external::language::java::metamodel::Field[*], constructors:Pair<meta::external::language::java::metamodel::Constructor,Code>[*], methods:Pair<meta::external::language::java::metamodel::Method,Code>[*]):meta::external::language::java::metamodel::Class[1]
{
   let interfaces       = $proto.interfaces->typesToClasses();
   let fieldClasses     = $fields.type->typesToClasses();
   let signatureClasses = $methods.first->typesUsed()->typesToClasses();
   let codeClasses      = $constructors.second->concatenate($methods.second)->classesUsed();
   let classesUsed      = $interfaces->concatenate($fieldClasses)->concatenate($signatureClasses)->concatenate($codeClasses)->removeDuplicates();

   let withFields = $fields->fold({f, cl | $cl->addField($f)}, $proto->imports($classesUsed));
   
   let withConstructors = $constructors->fold(
      {c, cl | 
         let constuctor = $c.first;
         let bodyCode   = $c.second;
         $cl->addConstructor(^$constuctor(bodyCode=$bodyCode));
      }, 
      $withFields
   );

   $methods->fold(
      {m, cl | 
         let method   = $m.first;
         let bodyCode = $m.second;
         $cl->addMethod(^$method(bodyCode=$bodyCode));
      },
      $withConstructors
   );
}

function meta::external::language::java::factory::javaType(name:String[1]):meta::external::language::java::metamodel::Type[1]
{
   if($name->in(['boolean', 'byte', 'char', 'short', 'int', 'long', 'float', 'double', 'void']),
      | ^meta::external::language::java::metamodel::PrimitiveType(simpleName=$name),
      |  javaClass($name)
   );
}

function meta::external::language::java::factory::javaFunctionType(parameterTypes:meta::external::language::java::metamodel::Type[*], returnType:meta::external::language::java::metamodel::Type[1]):meta::external::language::java::metamodel::FunctionType[1]
{
   javaFunctionType($parameterTypes, $returnType, []);
}

function meta::external::language::java::factory::javaFunctionType(parameterTypes:meta::external::language::java::metamodel::Type[*], returnType:meta::external::language::java::metamodel::Type[1], nullResultPossible:Boolean[0..1]):meta::external::language::java::metamodel::FunctionType[1]
{
   ^meta::external::language::java::metamodel::FunctionType(parameterTypes=$parameterTypes, returnType=$returnType, nullResultPossible=$nullResultPossible);
}

function meta::external::language::java::factory::jextends(class:meta::external::language::java::metamodel::Class[1], t:meta::external::language::java::metamodel::Type[1]):meta::external::language::java::metamodel::Class[1]
{
   if($class.modifiers->contains(meta::external::language::java::metamodel::Modifier.Interface),
      | $class->implements($t),
      {|
         assert($class.superType->isEmpty(), |'All ready extended');
         ^$class(superType = $t);
      }
   );
}

function meta::external::language::java::factory::implements(class:meta::external::language::java::metamodel::Class[1], t:meta::external::language::java::metamodel::Type[*]):meta::external::language::java::metamodel::Class[1]
{
   ^$class(interfaces = $class.interfaces->concatenate($t));
}

function meta::external::language::java::factory::usingKnownPackages(class:meta::external::language::java::metamodel::Class[1], knownPackages:Function<{meta::external::language::java::metamodel::Package[1]->meta::external::language::java::factory::KnownPackage[1]}>[1]):meta::external::language::java::metamodel::Class[1]
{
   ^meta::external::language::java::factory::FactoryClass
   (
      knownPackages        = $knownPackages,
      typeParameters       = $class.typeParameters,
      annotations          = $class.annotations,
      javaDoc              = $class.javaDoc,
      simpleName           = $class.simpleName,
      package              = $class.package,
      modifiers            = $class.modifiers,
      interfaces           = $class.interfaces,
      superType            = $class.superType,
      constructors         = $class.constructors,
      fields               = $class.fields,
      methods              = $class.methods,
      additionalImports    = $class.additionalImports,
      projectionParentName = $class.projectionParentName
   )
}

function meta::external::language::java::factory::imports(class:meta::external::language::java::metamodel::Class[1], imports:meta::external::language::java::metamodel::Importable[*]):meta::external::language::java::metamodel::Class[1]
{
   let knownPackages = if($class->instanceOf(meta::external::language::java::factory::FactoryClass),
                          | $class->cast(@meta::external::language::java::factory::FactoryClass).knownPackages,
                          | meta::external::language::java::factory::knownPackage_Package_1__KnownPackage_1_
                       );

   let packages = $imports->filter(imp| $imp->instanceOf(meta::external::language::java::metamodel::Package))->cast(@meta::external::language::java::metamodel::Package)->filter(p| !$p->isJavaLang());
   let classes  = $imports->filter(imp| $imp->instanceOf(meta::external::language::java::metamodel::Class))->cast(@meta::external::language::java::metamodel::Class)->filter(c| !$c.package->isJavaLang());

   let existingImports = $class.additionalImports->map(imp| if($imp->endsWith('.*'),
                                                               |javaPackage($imp->substring(0, $imp->length()-2)),
                                                               |javaClass($imp)
                                                            )
                                                      );
   let withNewPackages = $existingImports->concatenate($packages)->removeDuplicates();
   let withoutSubsumed = $withNewPackages->filter(imp| $imp->match([
      pkg: meta::external::language::java::metamodel::Package[1] | true,
      cls: meta::external::language::java::metamodel::Class[1]   | !$cls.package->in($withNewPackages)
   ]));

   let importedNames = $class.simpleName
      ->concatenate($withoutSubsumed->map(imp| $imp->match([
           pkg: meta::external::language::java::metamodel::Package[1] | $knownPackages->eval($pkg).classNames,
           cls: meta::external::language::java::metamodel::Class[1]   | $cls.simpleName
        ])));

   let importableClasses = $classes->removeDuplicatesBy(c | $c.simpleName)->filter(cls| !$cls.package->in($withoutSubsumed) && !$cls.simpleName->in($importedNames));
   let newImports        = $withoutSubsumed->concatenate($importableClasses)->removeDuplicates();

   ^$class(
      additionalImports=$newImports
         ->map(imp| $imp->match([
             pkg: meta::external::language::java::metamodel::Package[1] | $pkg->packageToString()+'.*',
             cls: meta::external::language::java::metamodel::Class[1]   | $cls->typeToString()
           ]))
         ->sort()
   );
}

function meta::external::language::java::factory::annotate<T>(target:T[1], annotations:meta::external::language::java::metamodel::Annotation[*]):T[1]
{
   assert($target->instanceOf(meta::external::language::java::metamodel::AnnotatedElement), 'Cannot annotate ' + $target->type().name->toOne());
   let annotatedElement = $target->cast(@meta::external::language::java::metamodel::AnnotatedElement);
   let annotated = ^$annotatedElement(annotations=$annotatedElement.annotations->concatenate($annotations)->removeDuplicates());
   $annotated->cast(@T);
}

function meta::external::language::java::factory::javaDoc<T>(target:T[1], doc:String[1]):T[1]
{
   assert($target->instanceOf(meta::external::language::java::metamodel::AnnotatedElement), 'Cannot annotate ' + $target->type().name->toOne());
   let annotatedElement = $target->cast(@meta::external::language::java::metamodel::AnnotatedElement);
   let annotated = ^$annotatedElement(javaDoc=$doc);
   $annotated->cast(@T);
}

function meta::external::language::java::factory::addModifiers(class:meta::external::language::java::metamodel::Class[1], modifiers:String[*]):meta::external::language::java::metamodel::Class[1]
{
   ^$class(modifiers = $class.modifiers->concatenate(javaModifiers($modifiers))->removeDuplicates());
}

function meta::external::language::java::factory::addField(class:meta::external::language::java::metamodel::Class[1], field:meta::external::language::java::metamodel::Field[1]):meta::external::language::java::metamodel::Class[1]
{
   ^$class(fields = $class.fields->concatenate($field));
}

function meta::external::language::java::factory::addField(class:meta::external::language::java::metamodel::Class[1], builder:Function<{meta::external::language::java::metamodel::Class[1]->meta::external::language::java::metamodel::Field[1]}>[1]):meta::external::language::java::metamodel::Class[1]
{
   ^$class(fields = $class.fields->concatenate($builder->eval($class)));
}

function meta::external::language::java::factory::addFields(class:meta::external::language::java::metamodel::Class[1], fields:meta::external::language::java::metamodel::Field[*]):meta::external::language::java::metamodel::Class[1]
{
   ^$class(fields = $class.fields->concatenate($fields));
}

function meta::external::language::java::factory::addConstructor(class:meta::external::language::java::metamodel::Class[1], constructor:meta::external::language::java::metamodel::Constructor[1]):meta::external::language::java::metamodel::Class[1]
{
   ^$class(constructors = $class.constructors->concatenate($constructor));
}

function meta::external::language::java::factory::addConstructor(class:meta::external::language::java::metamodel::Class[1], builder:Function<{meta::external::language::java::metamodel::Class[1]->meta::external::language::java::metamodel::Constructor[1]}>[1]):meta::external::language::java::metamodel::Class[1]
{
   ^$class(constructors = $class.constructors->concatenate($builder->eval($class)));
}

// TODO This is only needed by API knowledge so we can eliminate this if we change that to a decision instead of data structure creation (and make it more efficient)
function meta::external::language::java::factory::addMethodIfMissing(class:meta::external::language::java::metamodel::Class[1], method:meta::external::language::java::metamodel::Method[1]):meta::external::language::java::metamodel::Class[1]
{
   let existing = $class.methods->filter({m| $m.name == $method.name && $m.parameters.type == $method.parameters.type});
   if($existing->isEmpty(),
      | ^$class(methods = $class.methods->concatenate($method->addFunctionType($class))),
      | $class
   );
}

function meta::external::language::java::factory::addMethod(class:meta::external::language::java::metamodel::Class[1], method:meta::external::language::java::metamodel::Method[1]):meta::external::language::java::metamodel::Class[1]
{
   let existing = $class.methods->filter({m| $m.name == $method.name && $m.parameters.type == $method.parameters.type});
   assert($existing->isEmpty(), |$class->println(); 'Method already exists: '+$method->methodSignature(););
   ^$class(methods = $class.methods->concatenate($method->addFunctionType($class)));
}

function meta::external::language::java::factory::addMethod(class:meta::external::language::java::metamodel::Class[1], builder:Function<{meta::external::language::java::metamodel::Class[1]->meta::external::language::java::metamodel::Method[1]}>[1]):meta::external::language::java::metamodel::Class[1]
{
   $class->addMethod($builder->eval($class));
}

function meta::external::language::java::factory::addMethods(class:meta::external::language::java::metamodel::Class[1], methods:meta::external::language::java::metamodel::Method[*]):meta::external::language::java::metamodel::Class[1]
{
   $methods->fold({m, c|$c->addMethod($m)}, $class);
}

function meta::external::language::java::factory::addMethods(class:meta::external::language::java::metamodel::Class[1], builder:Function<{meta::external::language::java::metamodel::Class[1]->meta::external::language::java::metamodel::Method[*]}>[1]):meta::external::language::java::metamodel::Class[1]
{
   $class->addMethods($builder->eval($class));
}

function <<access.private>> meta::external::language::java::factory::addFunctionType(method:meta::external::language::java::metamodel::Method[1], onClass:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Method[1]
{
   let isStatic   = $method.modifiers->contains(meta::external::language::java::metamodel::Modifier.Static);
   let paramTypes = if($isStatic, |[], |$onClass)->concatenate($method.parameters.type);
   ^$method(functionType=javaFunctionType($paramTypes, $method.returnType, $method.nullResultPossible));
}

function meta::external::language::java::factory::addAnnotation<T>(element: T[1], annotation:meta::external::language::java::metamodel::Annotation[1]):T[1]
{
   $element->match([
      ae: meta::external::language::java::metamodel::AnnotatedElement[1] | ^$ae(annotations = $ae.annotations->concatenate($annotation))->cast($element),
      a : Any[1] | fail('Can add annotations to only annotated elements'); $element;
   ])
}

// For Interfaces
function meta::external::language::java::factory::javaMethod(returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Any[*]) : meta::external::language::java::metamodel::Method[1]
{
   ^meta::external::language::java::metamodel::Method(
      name           = $name,
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters()
   )
}

// For Interfaces
function meta::external::language::java::factory::javaMethod(typeParameters:meta::external::language::java::metamodel::TypeVariable[1..*], returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Any[*]) : meta::external::language::java::metamodel::Method[1]
{
   ^meta::external::language::java::metamodel::Method(
      name           = $name,
      typeParameters = $typeParameters,
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters()
   )
}

function meta::external::language::java::factory::javaMethod(modifiers:String[*], returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Any[*]) : meta::external::language::java::metamodel::Method[1]
{
   ^meta::external::language::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters()
   )
}
   
function meta::external::language::java::factory::javaMethod(modifiers:String[*], typeParameters:meta::external::language::java::metamodel::TypeVariable[1..*], returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Any[*]) : meta::external::language::java::metamodel::Method[1]
{
   ^meta::external::language::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      typeParameters = $typeParameters,
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters()
   )
}

function meta::external::language::java::factory::javaMethod(modifiers:String[*], returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Any[*], body:String[1]) : meta::external::language::java::metamodel::Method[1]
{
   ^meta::external::language::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters(),
      body           = $body
   )
}

function meta::external::language::java::factory::javaMethod(modifiers:String[*], returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Any[*], bodyCode:Code[*]) : meta::external::language::java::metamodel::Method[1]
{
   ^meta::external::language::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters(),
      bodyCode       = if($bodyCode->size() == 1, |$bodyCode->toOne(), |j_block($bodyCode))
   )
}

function meta::external::language::java::factory::javaMethod(modifiers:String[*], typeParameters:meta::external::language::java::metamodel::TypeVariable[1..*], returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Any[*], body:String[1]) : meta::external::language::java::metamodel::Method[1]
{
   ^meta::external::language::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      typeParameters = $typeParameters,
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters(),
      body           = $body
   )
}

function meta::external::language::java::factory::javaMethod(modifiers:String[*], typeParameters:meta::external::language::java::metamodel::TypeVariable[1..*], returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Any[*], bodyCode:Code[*]) : meta::external::language::java::metamodel::Method[1]
{
   ^meta::external::language::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      typeParameters = $typeParameters,
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters(),
      bodyCode       = if($bodyCode->size() == 1, |$bodyCode->toOne(), |j_block($bodyCode))
   )
}

function <<access.private>> meta::external::language::java::factory::cannonicalParameters(parameters:Any[*]) : meta::external::language::java::metamodel::Parameter[*]
{
   $parameters->map(p | $p->match([
      p: meta::external::language::java::metamodel::Parameter[1] | $p,
      c: Code[1]                                                 | $c->asParameters()
   ]));
}

function meta::external::language::java::factory::nonNull(method:meta::external::language::java::metamodel::Method[1]) : meta::external::language::java::metamodel::Method[1]
{
   ^$method(nullResultPossible=false);
}

function meta::external::language::java::factory::nullable(method:meta::external::language::java::metamodel::Method[1]) : meta::external::language::java::metamodel::Method[1]
{
   ^$method(nullResultPossible=true);
}

function meta::external::language::java::factory::nonNull(type:meta::external::language::java::metamodel::FunctionType[1]) : meta::external::language::java::metamodel::FunctionType[1]
{
   ^$type(nullResultPossible=false);
}

function meta::external::language::java::factory::nullable(type:meta::external::language::java::metamodel::FunctionType[1]) : meta::external::language::java::metamodel::FunctionType[1]
{
   ^$type(nullResultPossible=true);
}

function meta::external::language::java::factory::javaModifiers(modifiers:String[*]): meta::external::language::java::metamodel::Modifier[*]
{
   $modifiers->map(m| $m->javaModifier());
}

function meta::external::language::java::factory::javaModifier(modifier:String[1]): meta::external::language::java::metamodel::Modifier[1]
{
   meta::external::language::java::metamodel::Modifier->enumValues()->filter(v|$v.name->toLower() == $modifier)->toOne()->cast(@meta::external::language::java::metamodel::Modifier);
}

function meta::external::language::java::factory::javaTypeVar(name:String[1]): meta::external::language::java::metamodel::TypeVariable[1]
{
   ^meta::external::language::java::metamodel::TypeVariable(name=$name);
}

function meta::external::language::java::factory::javaTypeVar(name:String[1], bounds:meta::external::language::java::metamodel::Type[*]): meta::external::language::java::metamodel::TypeVariable[1]
{
   ^meta::external::language::java::metamodel::TypeVariable(name=$name, bounds=$bounds);
}

function meta::external::language::java::factory::javaParam(type:meta::external::language::java::metamodel::Type[1], name:String[1]): meta::external::language::java::metamodel::Parameter[1]
{
   ^meta::external::language::java::metamodel::Parameter(name=$name, type=$type);
}

function meta::external::language::java::factory::javaField(modifiers:String[*], type:meta::external::language::java::metamodel::Type[1], name:String[1]): meta::external::language::java::metamodel::Field[1]
{
   ^meta::external::language::java::metamodel::Field(
      modifiers = $modifiers->javaModifiers(),
      name=$name,
      type=$type
   );
}

function meta::external::language::java::factory::javaField(modifiers:String[*], type:meta::external::language::java::metamodel::Type[1], name:String[1], initialiser:String[1]): meta::external::language::java::metamodel::Field[1]
{
   let uninited = javaField($modifiers, $type, $name);
   ^$uninited(value=$initialiser);
}

function meta::external::language::java::factory::javaField(modifiers:String[*], type:meta::external::language::java::metamodel::Type[1], name:String[1], initialiser:Code[1]): meta::external::language::java::metamodel::Field[1]
{
   let uninited = javaField($modifiers, $type, $name);
   ^$uninited(valueCode=$initialiser);
}

function meta::external::language::java::factory::javaConstructor(modifiers:String[*], parameters:Any[*]): meta::external::language::java::metamodel::Constructor[1]
{
   ^meta::external::language::java::metamodel::Constructor(
      modifiers  = $modifiers->javaModifiers(),
      parameters = $parameters->cannonicalParameters()
   );
}

function meta::external::language::java::factory::javaConstructor(modifiers:String[*], parameters:Any[*], body:String[1]): meta::external::language::java::metamodel::Constructor[1]
{
   ^meta::external::language::java::metamodel::Constructor(
      modifiers  = $modifiers->javaModifiers(),
      parameters = $parameters->cannonicalParameters(),
      body       = $body
   );
}

function meta::external::language::java::factory::javaConstructor(modifiers:String[*], parameters:Any[*], bodyCode:Code[*]): meta::external::language::java::metamodel::Constructor[1]
{
   ^meta::external::language::java::metamodel::Constructor(
      modifiers  = $modifiers->javaModifiers(),
      parameters = $parameters->cannonicalParameters(),
      bodyCode   = if($bodyCode->size() == 1, |$bodyCode->toOne(), |j_block($bodyCode))
   );
}

Class meta::external::language::java::factory::FactoryClass extends meta::external::language::java::metamodel::Class
{
   knownPackages:Function<{meta::external::language::java::metamodel::Package[1]->meta::external::language::java::factory::KnownPackage[1]}>[1];
}


function meta::external::language::java::factory::inferImports(class:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Class[1]
{
   let allCodes  = $class.fields.valueCode->concatenate($class.constructors.bodyCode)->concatenate($class.methods.bodyCode);
   let canInfer  = $class.additionalImports->isEmpty() && !$allCodes->containsSimpleCode();
   if($canInfer,
      {| 
          let annotationsTypes = $class.annotations
                                  ->concatenate($class.fields.annotations)
                                  ->concatenate($class.methods.annotations)
                                  ->concatenate($class.methods.parameters.annotations)
                                  ->concatenate($class.constructors.annotations)
                                  ->concatenate($class.constructors.parameters.annotations)
                                  ->concatenate($class->match([
                                     enm:meta::external::language::java::metamodel::Enumeration[1]| $enm.enumeration.annotations,
                                     oth:Any[1] | []
                                   ]))
                                  ->map(x|
                                          let javaClass = $x->genericType().rawType->toOne()->meta::pure::functions::meta::value4Tag('javaClass', meta::external::language::java::metamodel::annotations::AnnotationJavaInfo);
                                          assert(!$javaClass->isEmpty(), 'Error: Please provide the Java class that supports the annotation "'+$x->genericType().rawType->toOne()->elementToPath()+'"" using the profile "meta::external::language::java::metamodel::annotations::AnnotationJavaInfo"');
                                          $javaClass.value;
                                        )
                                  ->removeDuplicates()
                                  ->map(x|javaClass($x));
         let classesUsed = $allCodes->classesUsed()
                                    ->concatenate($class.interfaces)
                                    ->concatenate($class.superType)
                                    ->concatenate($class.fields.type)
                                    ->concatenate($class.methods.returnType)
                                    ->concatenate($class.methods.parameters.type)
                                    ->concatenate($class.constructors.parameters.type)
                                    ->typesToClasses()
                                    ->concatenate($annotationsTypes)
                                    ->filter(c| $c.package != anonymousPackage())
                                    ->removeDuplicates();
         let inSamePackage = $classesUsed->filter(c| $c.package == $class.package);
         let toImport      = $classesUsed->filter(c| !$c.simpleName->in($inSamePackage.simpleName));
         let withImports   = $toImport->fold({i, c| $c->imports($i)}, $class);
         ^$withImports(additionalImports=$withImports.additionalImports->sort());
      },
      |^$class(additionalImports=$class.additionalImports->map(c| javaClass($c))->filter(c| $c.package != $class.package)->map(c| $c->typeToString()));
   );   
}

function meta::external::language::java::factory::containsSimpleCode(codes:Code[*]): Boolean[1]
{
   $codes->exists(code| $code->match([
      c:InfixExpression[1]          | $c.left->containsSimpleCode() || $c.right->containsSimpleCode(),
      c:PrefixExpression[1]         | $c.expression->containsSimpleCode(),
      c:PostfixExpression[1]        | $c.expression->containsSimpleCode(),
      c:Conditional[1]              | $c.test->containsSimpleCode() || $c.then->containsSimpleCode() || $c.else->containsSimpleCode(),
      c:InstanceOf[1]               | $c.expression->containsSimpleCode(),
      c:ArrayAccess[1]              | $c.array->containsSimpleCode() || $c.index->containsSimpleCode(),
      c:CastProxy[1]                | $c.expression->containsSimpleCode() || $c.proxy->containsSimpleCode(),
      c:Cast[1]                     | $c.expression->containsSimpleCode(),
      c:LocalVariableDeclaration[1] | $c.initializer->containsSimpleCode(),
      c:ConstructorCall[1]          | $c.arguments->containsSimpleCode(),
      c:MethodCall[1]               | $c.instance->containsSimpleCode() || $c.arguments->containsSimpleCode(),
      c:FieldAccess[1]              | $c.instance->containsSimpleCode(),
      c:MethodReference[1]          | $c.instance->containsSimpleCode(),
      c:Block[1]                    | $c.statements->containsSimpleCode(),
      c:ExpressionStatement[1]      | $c.expression->containsSimpleCode(),
      c:If[1]                       | $c.test->containsSimpleCode() || $c.then->containsSimpleCode() || $c.else->containsSimpleCode(),
      c:For[1]                      | $c.init->containsSimpleCode() || $c.test->containsSimpleCode() || $c.update->containsSimpleCode(),
      c:ForEach[1]                  | $c.parameter->cast(@Code)->containsSimpleCode() || $c.collection->containsSimpleCode() || $c.body->containsSimpleCode(),
      c:While[1]                    | $c.test->containsSimpleCode() || $c.then->containsSimpleCode(),
      c:DoWhile[1]                  | $c.do->containsSimpleCode() || $c.while->containsSimpleCode(),
      c:Try[1]                      | $c.try->containsSimpleCode() || $c.catches->containsSimpleCode() || $c.finally->containsSimpleCode(),
      c:Catch[1]                    | $c.clause->containsSimpleCode(),
      c:Finally[1]                  | $c.clause->containsSimpleCode(),
      c:Return[1]                   | $c.expression->containsSimpleCode(),
      c:Throw[1]                    | $c.expression->containsSimpleCode(),
      c:NewAnonymous[1]             | $c.arguments->containsSimpleCode() || $c.methods->containsSimpleCode(),
      c:New[1]                      | $c.arguments->containsSimpleCode(),
      c:CodeMethod[1]               | $c.parameters->containsSimpleCode() || $c.body->containsSimpleCode(),
      c:StaticMethodCall[1]         | $c.arguments->containsSimpleCode(),
      c:DeferredStreamResolve[1]    | $c.stream->containsSimpleCode(),
      c:Lambda[1]                   | $c.expression->containsSimpleCode(),
      c:Code[1]                     | $c->instanceOf(SimpleCode)
   ]));
}


// TODO Eliminate this
function meta::external::language::java::factory::merge(codes: Code[1..*]):Code[1]
{
   let head = $codes->at(0);
   $codes->tail()->fold({c, a|^$a(requires=$a->dependencies()->concatenate($c->dependencies())->removeDuplicates())}, $head);
}

// TODO Remove once all streaming is via j_streamOf...js_resolve
function meta::external::language::java::factory::canOptimize(code: Code[1]):Boolean[1]
{
   $code->instanceOf(SimpleCode);
}



// --- To dependencies

function meta::external::language::java::factory::dependencies(codes: Code[*]):CodeDependency[*]
{
   $codes->map(code| $code->match([
      c:InfixExpression[1]          | $c.requires->concatenate($c.left->dependencies())->concatenate($c.right->dependencies()),
      c:PrefixExpression[1]         | $c.requires->concatenate($c.expression->dependencies()),
      c:PostfixExpression[1]        | $c.requires->concatenate($c.expression->dependencies()),
      c:Conditional[1]              | $c.requires->concatenate($c.test->concatenate($c.then)->concatenate($c.else)->map(x|$x->dependencies())),
      c:InstanceOf[1]               | $c.requires->concatenate($c.expression->dependencies()),
      c:ArrayAccess[1]              | $c.requires->concatenate($c.array->dependencies())->concatenate($c.index->dependencies()),
      c:CastProxy[1]                | $c.requires->concatenate($c.expression->concatenate($c.proxy)->dependencies()),
      c:Cast[1]                     | $c.requires->concatenate($c.expression->dependencies()),
      c:LocalVariableDeclaration[1] | $c.requires->concatenate($c.initializer->dependencies()),
      c:ConstructorCall[1]          | $c.requires->concatenate($c.arguments->map(a| $a->dependencies())),
      c:MethodCall[1]               | $c.requires->concatenate($c.instance->dependencies())->concatenate($c.arguments->map(a| $a->dependencies())),
      c:FieldAccess[1]              | $c.requires->concatenate($c.instance->dependencies()),
      c:MethodReference[1]          | $c.requires->concatenate($c.instance->dependencies()),
      c:Block[1]                    | $c.requires->concatenate($c.statements->dependencies()),
      c:ExpressionStatement[1]      | $c.requires->concatenate($c.expression->dependencies()),
      c:If[1]                       | $c.requires->concatenate($c.test->concatenate($c.then)->concatenate($c.else)->map(x|$x->dependencies())),
      c:For[1]                      | $c.requires->concatenate($c.init->concatenate($c.test)->concatenate($c.update)->concatenate($c.body)->map(x|$x->dependencies())),
      c:ForEach[1]                  | $c.requires->concatenate($c.parameter->cast(@Code)->concatenate($c.collection)->concatenate($c.body)->map(x|$x->dependencies())),
      c:While[1]                    | $c.requires->concatenate($c.test->concatenate($c.then)->map(x|$x->dependencies())),
      c:DoWhile[1]                  | $c.requires->concatenate($c.do->concatenate($c.while)->map(x|$x->dependencies())),
      c:Try[1]                      | $c.requires->concatenate($c.try->concatenate($c.catches)->concatenate($c.finally)->map(x|$x->dependencies())),
      c:Catch[1]                    | $c.requires->concatenate($c.clause->dependencies()),
      c:Finally[1]                  | $c.requires->concatenate($c.clause->dependencies()),
      c:Return[1]                   | $c.requires->concatenate($c.expression->dependencies()),
      c:Throw[1]                    | $c.requires->concatenate($c.expression->dependencies()),
      c:NewAnonymous[1]             | $c.requires->concatenate($c.arguments->dependencies())->concatenate($c.methods->dependencies()),
      c:New[1]                      | $c.requires->concatenate($c.arguments->dependencies()),
      c:CodeMethod[1]               | $c.requires->concatenate($c.parameters->map(p|$p->dependencies()))->concatenate($c.body->dependencies()),
      c:StaticMethodCall[1]         | $c.requires->concatenate($c.arguments->map(a| $a->dependencies())),
      c:DeferredStreamResolve[1]    | $c.requires->concatenate($c.stream->dependencies()),
      c:Lambda[1]                   | $c.requires->concatenate($c.expression->dependencies()),
      c:Code[1]                     | $c.requires
   ]))->removeDuplicates();
}

// --- Java coding

function meta::external::language::java::factory::j_code(code:String[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   j_code($code, $type, []);
}

function meta::external::language::java::factory::j_code(code:String[1], type:meta::external::language::java::metamodel::Type[1], dependencies:CodeDependency[*]):Code[1]
{
   ^SimpleCode(code=$code, type=$type, requires=$dependencies);
}

function meta::external::language::java::factory::j_null():Code[1]
{
   ^Null(type=javaVoid()); // void to represent bottom (Nil)
}

function meta::external::language::java::factory::j_null(type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   ^Null(type=$type);
}

/* Used to indicate a nested anonymous class (primarilly for j_this). Nesting level starts at 1:

   class X
   {
      ...
      new Something()
      {
         ...
         new SomethingElse()
         {
            ...
         }
      }
      new Another()
      {
         ...
      }
   }

  Something and Another are anonymousNestedClass(1), SomethingElse is anonymousNestedClass(2)

  This is different than the compiler which will make them: Something->$1, SomethingElse->$2, Another->$3
*/
function meta::external::language::java::factory::anonymousNestedClass(level:Integer[1]):meta::external::language::java::metamodel::Class[1]
{
   ^meta::external::language::java::metamodel::Class(simpleName='Level'+$level->toString(), package=anonymousPackage());
}

function meta::external::language::java::factory::anonymousPackage():meta::external::language::java::metamodel::Package[1]
{
   ^meta::external::language::java::metamodel::Package(name='__ANON__');
}

function meta::external::language::java::factory::j_this(type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   ^This(type=$type);
}

function meta::external::language::java::factory::j_variable(param:meta::external::language::java::metamodel::Parameter[1]):Code[1]
{
   ^Variable(name=$param.name, type=$param.type);
}

function meta::external::language::java::factory::j_variable(type:meta::external::language::java::metamodel::Type[1], name:String[1]):Code[1]
{
   ^Variable(name=$name, type=$type);
}

function meta::external::language::java::factory::j_parameter(param:meta::external::language::java::metamodel::Parameter[1]):Code[1]
{
   ^CodeParameter(name=$param.name, type=$param.type);
}

function meta::external::language::java::factory::j_parameter(type:meta::external::language::java::metamodel::Type[1], name:String[1]):Code[1]
{
   ^CodeParameter(name=$name, type=$type);
}

function meta::external::language::java::factory::j_arrayAccess(array:Code[1], index:Code[1]):Code[1]
{
   ^ArrayAccess(array=$array, index=$index, type=$array.type->elementTypeOfJavaArray());
}

function meta::external::language::java::factory::j_block(codes:Code[*]):Code[1]
{
   let statements = $codes->toStatements();
   let last       = $statements->last().type;
   ^Block(statements=$statements, type=if($last->isEmpty(), |javaVoid(), |$last->toOne()));
}

function meta::external::language::java::factory::j_expressionStatement(expression:Code[1]):Code[1]
{
   assert($expression->isValidExpressionAsStatement(), |'Not a valid expression to use as a statement');
   ^ExpressionStatement(expression=$expression, type=$expression.type);
}

function meta::external::language::java::factory::j_if(test:Code[1], then:Code[1..*]):Code[1]
{
   j_if($test, $then, []);
}

function meta::external::language::java::factory::j_if(test:Code[1], then:Code[1..*], else:Code[*]):Code[1]
{
   let canonicalThen = $then->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   let canonicalElse = $else->match([
      c0:Code[0] | [],
      c1:Code[1] | if($c1->instanceOf(If), |$c1, |$c1->blockIfNot()),
      cs:Code[*] | $cs->j_block()
   ]);

   ^If(test=$test, then=$canonicalThen, else=$canonicalElse, type=javaVoid());
}

function meta::external::language::java::factory::j_if(testsAndThens:List<Pair<Code,Code>>[1]):Code[1]
{
   j_if($testsAndThens, []);
}

function meta::external::language::java::factory::j_if(testsAndThens:List<Pair<Code,Code>>[1], else:Code[0..1]):Code[1]
{
   assert($testsAndThens.values->isNotEmpty(), |'No then clauses');
   $testsAndThens.values->reverse()->fold({tt, a| j_if($tt.first, $tt.second, $a)}, $else)->toOne();
}

function meta::external::language::java::factory::j_for(init:Code[0..1], test:Code[0..1], update:Code[0..1], body:Code[1..*]):Code[1]
{
   let canonicalBody = $body->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^For(init=$init, test=$test, update=$update, body=$canonicalBody, type=javaVoid());
}

function meta::external::language::java::factory::j_for(parameter:Code[1], collection:Code[1], body:Code[1..*]):Code[1]
{
   assert($parameter->instanceOf(CodeParameter), 'Parameter must be properly created (j_parameter)');
   let canonicalBody = $body->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^ForEach(parameter=$parameter->cast(@CodeParameter), collection=$collection, body=$canonicalBody, type=javaVoid());
}

function meta::external::language::java::factory::j_while(test:Code[1], then:Code[1..*]):Code[1]
{
   let canonicalThen = $then->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^While(test=$test, then=$canonicalThen, type=javaVoid());
}

function meta::external::language::java::factory::j_doWhile(do:Code[1..*], while:Code[1]):Code[1]
{
   let canonicalDo = $do->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^DoWhile(do=$canonicalDo, while=$while, type=javaVoid());
}

function meta::external::language::java::factory::j_catch(parameter:meta::external::language::java::metamodel::Parameter[1], clause:Code[1..*]):Code[1]
{
   j_catch($parameter->j_parameter(), $clause);
}

function meta::external::language::java::factory::j_catch(parameter:Code[1], clause:Code[1..*]):Code[1]
{
   assert($parameter->instanceOf(CodeParameter), 'Parameter must be properly created (j_parameter)');
   let canonicalClause = $clause->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^Catch(parameter=$parameter->cast(@CodeParameter), clause=$canonicalClause, type=javaVoid());
}

function meta::external::language::java::factory::j_finally(clause:Code[1..*]):Code[1]
{
   let canonicalClause = $clause->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^Finally(clause=$canonicalClause, type=javaVoid());
}

function meta::external::language::java::factory::j_try(try:Code[1..*], c1:Code[1]):Code[1]
{
   if($c1->instanceOf(Catch),
      |j_tryInternal($try, [$c1], []),
      |j_tryInternal($try, [],    $c1)
   );
}

function meta::external::language::java::factory::j_try(try:Code[1..*], c1:Code[1], c2:Code[1]):Code[1]
{
   if($c2->instanceOf(Catch),
      |j_tryInternal($try, [$c1, $c2], []),
      |j_tryInternal($try, [$c1],      $c2)
   );
}

function meta::external::language::java::factory::j_try(try:Code[1..*], c1:Code[1], c2:Code[1], c3:Code[1]):Code[1]
{
   if($c3->instanceOf(Catch),
      |j_tryInternal($try, [$c1, $c2, $c3], []),
      |j_tryInternal($try, [$c1, $c2],      $c3)
   );
}

function meta::external::language::java::factory::j_try(try:Code[1..*], c1:Code[1], c2:Code[1], c3:Code[1], c4:Code[1]):Code[1]
{
   if($c4->instanceOf(Catch),
      |j_tryInternal($try, [$c1, $c2, $c3, $c4], []),
      |j_tryInternal($try, [$c1, $c2, $c3],      $c4)
   );
}

function meta::external::language::java::factory::j_try(try:Code[1..*], c1:Code[1], c2:Code[1], c3:Code[1], c4:Code[1], c5:Code[1]):Code[1]
{
   if($c4->instanceOf(Catch),
      |j_tryInternal($try, [$c1, $c2, $c3, $c4, $c5], []),
      |j_tryInternal($try, [$c1, $c2, $c3, $c4],      $c5)
   );
}

function meta::external::language::java::factory::j_try(try:Code[1..*], catches:Code[*], finally:Code[0..1]):Code[1]
{
   j_tryInternal($try, $catches, $finally);
}

function <<access.private>> meta::external::language::java::factory::j_tryInternal(try:Code[1..*], catches:Code[*], finally:Code[0..1]):Code[1]
{
   assert($catches->forAll(c| $c->instanceOf(Catch)), 'catch clauses must be properly created (j_catch)');
   assert($finally->forAll(f| $f->instanceOf(Finally)), 'finally clause must be properly created (j_finally)');
   let canonicalTry = $try->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^Try(try=$canonicalTry, catches=$catches->cast(@Catch), finally=$finally->cast(@Finally), type=javaVoid());
}

function meta::external::language::java::factory::j_return():Code[1]
{
   ^Return(type=javaVoid());
}

function meta::external::language::java::factory::j_return(expression:Code[1]):Code[1]
{
   ^Return(expression=$expression, type=$expression.type);
}

function meta::external::language::java::factory::j_throw(expression:Code[1]):Code[1]
{
   ^Throw(expression=$expression, type=$expression.type);
}

function meta::external::language::java::factory::j_castWithoutChecks(expression:Code[1], castTo:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   ^Cast(expression=$expression, type=$castTo);
}

function meta::external::language::java::factory::j_cast(expression:Code[1], castTo:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   if($expression.type == $castTo,
     | $expression,
     |
   if($expression.type->isPrimitiveNumber() && ($castTo == javaNumber() || $castTo == javaObject()),
     | ^CastProxy(expression=$expression, proxy=$expression->j_box()->j_cast($castTo), type=$castTo),
     |
   if($expression->instanceOf(Cast),
     | $expression->cast(@Cast).expression->j_cast($castTo),
     |
   if($castTo == javaInt() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('intValue', [], javaInt()), type=$castTo),
     |
   if($castTo == javaLong() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('longValue', [], javaLong()), type=$castTo),
     |
   if($castTo == javaShort() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('shortValue', [], javaShort()), type=$castTo),
     |
   if($castTo == javaByte() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('byteValue', [], javaByte()), type=$castTo),
     |
   if($castTo == javaFloat() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('floatValue', [], javaFloat()), type=$castTo),
     |
   if($castTo == javaDouble() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('doubleValue', [], javaDouble()), type=$castTo),
     |
   if($expression.type->toBoxed() == $castTo || $expression.type == $castTo->toBoxed(),
     | ^CastProxy(expression=$expression, proxy=$expression, type=$castTo),
     |
   if($expression->isCollectionsEmptyList() && !$castTo->isJavaList(),
     | ^CastProxy(expression=$expression, proxy=j_null()->j_cast($castTo), type=$castTo),
     |
   if($expression.type->instanceOf(meta::external::language::java::metamodel::FunctionType) && $castTo->instanceOf(meta::external::language::java::metamodel::FunctionType),
      {|
         let ft = $expression.type->cast(@meta::external::language::java::metamodel::FunctionType);
         let ct = $castTo->cast(@meta::external::language::java::metamodel::FunctionType);
         assert($ft.parameterTypes->size() == $ct.parameterTypes->size(), 'Cannot cast to a differnt number of parameters');
         assert($expression->instanceOf(Lambda), 'Cannot cast other type to lambda of function type');
         
         let exp = $expression->cast(@Lambda);
         ^Lambda(
            parameters = range($exp.parameters->size())->map(n|j_parameter($ct.parameterTypes->at($n), $exp.parameters->at($n).name))->cast(@CodeParameter),
            expression = $exp.expression->j_cast($ct.returnType),
            type       = $castTo
         );
      },
      |
   if($expression.type->instanceOf(meta::external::language::java::metamodel::FunctionType),
      {|
         let ft = $expression.type->cast(@meta::external::language::java::metamodel::FunctionType);
         assert($castTo->isJavaSupplier() || $castTo->isJavaFunction(), 'Cannot cast \''+$expression.type->typeToString()+'\' to: ' + $castTo->typeToString());

         let funcResult = $ft.returnType;
         if ($castTo->isJavaFunction(), 
             | 
                let castResult       = $castTo->returnTypeOfJavaFunction();
                let inputType        = $castTo->inputTypeOfJavaFunction();
                let inputParameter   = $expression->cast(@Lambda).parameters->at(0);
             
                if($castResult->isJavaList() && !$funcResult->isJavaList(),
                  {|
                     let fResult = j_variable($funcResult, '_fResult');
                     let makeList = j_lambda($inputParameter, j_block([
                        $fResult->j_declare($expression->j_cast(javaFunction($inputType, $funcResult))->j_invoke('apply', [$inputParameter], $funcResult)),
                        $fResult->j_listOf(javaList($funcResult))->j_return()
                     ]));
                     ^Cast(expression=$makeList, type=$castTo);
                  },
               | ^Cast(expression=$expression, type=$castTo);
               );,| 
         if ($castTo->isJavaSupplier(), |             
               let castResult = $castTo->suppliedTypeOfJavaSupplier();

               if($castResult->isJavaList() && !$funcResult->isJavaList(),
                  {|
                     let fResult = j_variable($funcResult, '_fResult');
                     let makeList = j_lambda([]->cast(@Code), j_block([
                        $fResult->j_declare($expression->j_cast(javaSupplier($funcResult))->j_invoke('get', [], $funcResult)),
                        $fResult->j_listOf(javaList($funcResult))->j_return()
                     ]));
                     ^Cast(expression=$makeList, type=$castTo);
                  },
                  |
               if($funcResult->isJavaList() && !$castResult->isJavaList(),
                  {|
                     assert($expression->isLambdaReturningCollectionsEmptyList(), |'Should only happen for empty list');
                     ^Cast(expression=j_lambda([]->cast(@Code), j_null()->j_return()), type=$castTo);
                  },
                  | ^Cast(expression=$expression, type=$castTo);
               ));,
         |^Cast(expression=$expression, type=$castTo)););
      },
      |
   if($expression.type->isJavaStream() && $castTo->isJavaStream(),
      {|
         let fromStreamOf = $expression.type->elementTypeOfJavaStream();
         if ($castTo->elementTypeOfJavaStream()->instanceOf(meta::external::language::java::metamodel::Class),
            |  let toStreamOf   = $castTo->elementTypeOfJavaStream()->cast(@meta::external::language::java::metamodel::Class);
               $expression->j_invoke('map', j_methodReference(j_field($toStreamOf, 'class', javaClassType($toStreamOf)), 'cast', javaFunctionType($fromStreamOf, $toStreamOf)), $castTo);,
            |     if ($castTo->elementTypeOfJavaStream()->instanceOf(meta::external::language::java::metamodel::TypeVariable),|
                      let toStreamOf   = $castTo->elementTypeOfJavaStream()->cast(@meta::external::language::java::metamodel::TypeVariable);
                      let x = j_parameter(if($fromStreamOf->isJavaList(),|$fromStreamOf->elementType();,|$fromStreamOf;), 'x'); 
                     $expression->j_invoke('map', j_lambda($x, $x->j_cast($toStreamOf)), $castTo);,
                   | $expression));
      },
      |
   if($expression->instanceOf(DeferredStreamResolve) && $castTo->isJavaList(),
     {|
        let deferred = $expression->cast(@DeferredStreamResolve);
        ^$deferred(stream=$deferred.stream->j_cast(javaStream($castTo->elementTypeOfJavaList())), type=$castTo);
     },
     |^Cast(expression=$expression, type=$castTo)
   )))))))))))))));
}

function <<access.private>> meta::external::language::java::factory::isLambdaReturningCollectionsEmptyList(c:Code[1]):Boolean[1]
{
   $c->match([
      {l:Lambda[1] |
         $l.expression->match([
            b:Block[1]     | $b.statements->match([
               r:Return[1] | $r.expression->isNotEmpty() && $r.expression->toOne()->isCollectionsEmptyList(),
               c:Code[*]   | false
            ]),
            r:Return[1] | $r.expression->isNotEmpty() && $r.expression->toOne()->isCollectionsEmptyList(),
            c:Code[1]   | false
         ])         
      },
      c:Code[1] | false
   ])
}


function meta::external::language::java::factory::j_string(s:String[1]):Code[1]
{
   if($s->length() <= 65000,
      | ^Literal(literal=escapedString($s), type=javaString()),
      | ^Literal(literal=$s->chunk(65000)->map(c| escapedString($c))->joinStrings(' + '), type=javaString())
   );
}

function meta::external::language::java::factory::j_char(s:String[1]):Code[1]
{
   assert($s->length() == 1, 'char must be a single character');
   let esc = escapedString($s);
   ^Literal(literal='\''+$esc->substring(1, $esc->length()-1)+'\'', type=javaChar());
}

function meta::external::language::java::factory::j_false():Code[1]
{
   j_boolean('false');
}

function meta::external::language::java::factory::j_true():Code[1]
{
   j_boolean('true');
}

function meta::external::language::java::factory::j_boolean(b:Boolean[1]):Code[1]
{
   j_boolean($b->toString());
}

function meta::external::language::java::factory::j_boolean(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaBoolean());
}

function meta::external::language::java::factory::j_short(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaShort());
}

function meta::external::language::java::factory::j_int(i:Integer[1]):Code[1]
{
   ^Literal(literal=$i->toString(), type=javaInt());
}

function meta::external::language::java::factory::j_int(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaInt());
}

function meta::external::language::java::factory::j_long(i:Integer[1]):Code[1]
{
   ^Literal(literal=$i->toString()+'L', type=javaLong());
}

function meta::external::language::java::factory::j_long(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaLong());
}

function meta::external::language::java::factory::j_float(i:Integer[1]):Code[1]
{
   ^Literal(literal=$i->toString()+'.0F', type=javaFloat());
}

function meta::external::language::java::factory::j_float(f:Float[1]):Code[1]
{
   ^Literal(literal=$f->toString()+'F', type=javaFloat());
}

function meta::external::language::java::factory::j_float(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaFloat());
}

function meta::external::language::java::factory::j_double(i:Integer[1]):Code[1]
{
   ^Literal(literal=$i->toString()+'.0', type=javaDouble());
}

function meta::external::language::java::factory::j_double(f:Float[1]):Code[1]
{
   ^Literal(literal=$f->toString(), type=javaDouble());
}

function meta::external::language::java::factory::j_double(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaDouble());
}

function meta::external::language::java::factory::j_box(expression:Code[1]):Code[1]
{
   if($expression.type == javaBoolean(),
      | j_new(javaClass('java.lang.Boolean'), $expression),
      |
   if($expression.type == javaShort(),
      | j_new(javaClass('java.lang.Short'), $expression),
      |
   if($expression.type == javaInt(),
      | j_new(javaClass('java.lang.Integer'), $expression),
      |
   if($expression.type == javaLong(),
      | j_new(javaClass('java.lang.Long'), $expression),
      |
   if($expression.type == javaFloat(),
      | j_new(javaClass('java.lang.Float'), $expression),
      |
   if($expression.type == javaDouble(),
      | j_new(javaClass('java.lang.Double'), $expression),
      | $expression
   ))))));
}

function meta::external::language::java::factory::j_assign(variable:Code[1], expression:Code[1]):Code[1]
{
   ^InfixExpression(left=$variable, op='=', right=$expression, type=$variable.type);
}

function meta::external::language::java::factory::j_lt(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='<', right=$right, type=javaBoolean());
}

function meta::external::language::java::factory::j_le(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='<=', right=$right, type=javaBoolean());
}

function meta::external::language::java::factory::j_eq(left:Code[1], right:Code[1]):Code[1]
{
   if($left->instanceOf(Null) || $right->instanceOf(Null),
      | ^InfixExpression(left=$left, op='==', right=$right, type=javaBoolean()),
      {|
         let compatibility = bestCompatibility(castCompatibility($left.type, $right.type), castCompatibility($right.type, $left.type));
         if($compatibility == CastCompatibility.Disallowed,
            | j_false(),
            |
         if($compatibility == CastCompatibility.Unknown,
            | ^InfixExpression(left=$left->j_cast(javaObject()), op='==', right=$right, type=javaBoolean()),
            | ^InfixExpression(left=$left, op='==', right=$right, type=javaBoolean())
         ));
      }
   );
}

function meta::external::language::java::factory::j_ne(left:Code[1], right:Code[1]):Code[1]
{
   if($left->instanceOf(Null) || $right->instanceOf(Null),
      | ^InfixExpression(left=$left, op='!=', right=$right, type=javaBoolean()),
      {|
         let compatibility = bestCompatibility(castCompatibility($left.type, $right.type), castCompatibility($right.type, $left.type));
         if($compatibility == CastCompatibility.Disallowed,
            | j_true(),
            |
         if($compatibility == CastCompatibility.Unknown,
            | ^InfixExpression(left=$left->j_cast(javaObject()), op='!=', right=$right, type=javaBoolean()),
            | ^InfixExpression(left=$left, op='!=', right=$right, type=javaBoolean())
         ));
      }
   );
}

function meta::external::language::java::factory::j_ge(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='>=', right=$right, type=javaBoolean());
}

function meta::external::language::java::factory::j_gt(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='>', right=$right, type=javaBoolean());
}

function meta::external::language::java::factory::j_or(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='||', right=$right, type=javaBoolean());
}

function meta::external::language::java::factory::j_and(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='&&', right=$right, type=javaBoolean());
}

function meta::external::language::java::factory::j_not(expression:Code[1]):Code[1]
{
   ^PrefixExpression(op='!', expression=$expression, type=javaBoolean());
}

function meta::external::language::java::factory::j_bitwiseAnd(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='&', right=$right, type=$left.type);
}

function meta::external::language::java::factory::j_bitwiseOr(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='|', right=$right, type=$left.type);
}

function meta::external::language::java::factory::j_bitwiseXor(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='^', right=$right, type=$left.type);
}

function meta::external::language::java::factory::j_bitwiseNot(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='~', right=$right, type=$left.type);
}

function meta::external::language::java::factory::j_plus(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='+', right=$right, type=$left.type);
}

function meta::external::language::java::factory::j_minus(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='-', right=$right, type=$left.type);
}

function meta::external::language::java::factory::j_minus(expression:Code[1]):Code[1]
{
   ^PrefixExpression(op='-', expression=$expression, type=$expression.type);
}

function meta::external::language::java::factory::j_multiply(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='*', right=$right, type=$left.type);
}

function meta::external::language::java::factory::j_divide(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='/', right=$right, type=$left.type);
}

function meta::external::language::java::factory::j_remainder(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='%', right=$right, type=$left.type);
}

function meta::external::language::java::factory::j_inc(expression:Code[1]):Code[1]
{
   ^PostfixExpression(expression=$expression, op='++', type=$expression.type);
}

function meta::external::language::java::factory::j_dec(expression:Code[1]):Code[1]
{
   ^PostfixExpression(expression=$expression, op='--', type=$expression.type);
}

function meta::external::language::java::factory::j_preInc(expression:Code[1]):Code[1]
{
   ^PrefixExpression(expression=$expression, op='++', type=$expression.type);
}

function meta::external::language::java::factory::j_preDec(expression:Code[1]):Code[1]
{
   ^PrefixExpression(expression=$expression, op='--', type=$expression.type);
}

function meta::external::language::java::factory::j_instanceof(expression:Code[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   let class = $type->match([
      cl:meta::external::language::java::metamodel::Class[1]             | $cl,
      pt:meta::external::language::java::metamodel::ParameterizedType[1] | $pt.rawType->cast(@meta::external::language::java::metamodel::Class)
   ]);
   ^InstanceOf(expression=$expression->j_box(), class=$class, type=javaBoolean());
}

function meta::external::language::java::factory::j_conditional(test:Code[1], then:Code[1], else:Code[1]):Code[1]
{
   // TODO common interface inference
   let thenBoxed = if($then.type->isPrimitiveNumber() && $else.type->isBoxedNumberType(), | $then->j_box(), | []);
   let elseBoxed = if($else.type->isPrimitiveNumber() && $then.type->isBoxedNumberType(), | $else->j_box(), | []);

   let thenType = if($thenBoxed->isEmpty(), 
                    | if($then->instanceOf(Null) && $then.type == javaVoid(), |$else.type, |$then.type),
                    | $thenBoxed->toOne().type
                  );

   let elseType = if($elseBoxed->isEmpty(), 
                    | if($else->instanceOf(Null) && $else.type == javaVoid(), |$then.type, |$else.type),
                    | $elseBoxed->toOne().type
                  );

   assert($thenType == $elseType, 'Type not inferred: then: '+$thenType->typeToString()+' else: '+$elseType->typeToString());
   
   if($test->instanceOf(InfixExpression),
      | optimizeEqualityComparison($test->cast(@InfixExpression), $thenBoxed->orElse($then), $elseBoxed->orElse($else), $thenType),
      | ^Conditional(test=$test, then=$thenBoxed->orElse($then), else=$elseBoxed->orElse($else), type=$thenType)
   );   
}

function meta::external::language::java::factory::optimizeEqualityComparison(expr:InfixExpression[1], then:Code[1], else:Code[1], type:meta::external::language::java::metamodel::Type[1]): Code[1]
{
   if($expr.left->instanceOf(Null) && $expr.right->instanceOf(Null) && $expr.op == '==',
   | $then,
   |
   if($expr.left->instanceOf(Null) && $expr.right->instanceOf(Null) && $expr.op == '!=',
   | $else,
   |
   if($expr.left->isSameLiteral($expr.right) && $expr.op == '==',
   | $then,
   |
   if($expr.left->isSameLiteral($expr.right) && $expr.op == '!=',
   | $else,
   | ^Conditional(test=$expr, then=$then, else=$else, type=$type)
   ))))
}

function meta::external::language::java::factory::j_conditional(test:Code[1], then:Code[1], else:Code[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   ^Conditional(test=$test, then=$then, else=$else, type=$type);
}

function meta::external::language::java::factory::j_declare(variable:Code[1]):Code[1]
{
   j_declare([], $variable, []);
}

function meta::external::language::java::factory::j_declare(variable:Code[1], initializer:Code[1]):Code[1]
{
   j_declare([], $variable, $initializer);
}

function meta::external::language::java::factory::j_declare(modifiers:String[*], variable:Code[1]):Code[1]
{
   j_declare($modifiers, $variable, []);
}

function meta::external::language::java::factory::j_declare(modifiers:String[*], variable:Code[1], initializer:Code[0..1]):Code[1]
{
   let v = $variable->cast(@Variable);
   j_declare($modifiers, $v.type, $v.name, $initializer);
}

function meta::external::language::java::factory::j_declare(type:meta::external::language::java::metamodel::Type[1], variableName:String[1]):Code[1]
{
   j_declare([], $type, $variableName, []);
}

function meta::external::language::java::factory::j_declare(type:meta::external::language::java::metamodel::Type[1], variableName:String[1], initializer:Code[1]):Code[1]
{
   j_declare([], $type, $variableName, $initializer);
}

function meta::external::language::java::factory::j_declare(modifiers:String[*], type:meta::external::language::java::metamodel::Type[1], variableName:String[1]):Code[1]
{
   j_declare($modifiers, $type, $variableName, []);
}

function meta::external::language::java::factory::j_declare(modifiers:String[*], type:meta::external::language::java::metamodel::Type[1], variableName:String[1], initializer:Code[0..1]):Code[1]
{
   ^LocalVariableDeclaration(modifiers=$modifiers->javaModifiers(), type=$type, variableName=$variableName, initializer=$initializer);
}

function meta::external::language::java::factory::j_new(type:meta::external::language::java::metamodel::Type[1], args:Code[*]):Code[1]
{
   $type->match([
      pt:meta::external::language::java::metamodel::ParameterizedType[1] | ^New(type=$pt.rawType, typeArguments=$pt.typeArguments, arguments=$args),
      cl:meta::external::language::java::metamodel::Class[1]             | ^New(type=$cl, arguments=$args)
   ]);
}

function meta::external::language::java::factory::j_newAnon(type:meta::external::language::java::metamodel::Type[1], args:Code[*], methods:Code[*]):Code[1]
{
   assert($methods->forAll(m| $m->instanceOf(CodeMethod)), 'Methods must be properly created (j_method)');
   $type->match([
      pt:meta::external::language::java::metamodel::ParameterizedType[1] | ^NewAnonymous(type=$pt.rawType, typeArguments=$pt.typeArguments, arguments=$args, methods=$methods->cast(@CodeMethod)),
      cl:meta::external::language::java::metamodel::Class[1]             | ^NewAnonymous(type=$cl, arguments=$args, methods=$methods->cast(@CodeMethod))
   ]);
}

function meta::external::language::java::factory::j_method(modifiers:String[*], returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Code[*], body:Code[*]):Code[1]
{
   j_method($modifiers, $returnType, $name, $parameters, $body->j_block());
}

function meta::external::language::java::factory::j_method(modifiers:String[*], returnType:meta::external::language::java::metamodel::Type[1], name:String[1], parameters:Code[*], body:Code[1]):Code[1]
{
   assert($parameters->forAll(p| $p->instanceOf(CodeParameter)), 'Parameters must be properly created (j_parameter)');
   ^CodeMethod(modifiers=$modifiers->javaModifiers(), type=$returnType, name=$name, parameters=$parameters->cast(@CodeParameter), body=$body->blockIfNot());
}

function meta::external::language::java::factory::j_thisInvoke(ofType:meta::external::language::java::metamodel::Type[1], args:Code[*]):Code[1]
{
   ^ThisConstructorCall(arguments=$args, type=$ofType);
}

function meta::external::language::java::factory::j_superInvoke(ofType:meta::external::language::java::metamodel::Type[1], args:Code[*]):Code[1]
{
   ^SuperConstructorCall(arguments=$args, type=$ofType);
}

function meta::external::language::java::factory::j_invoke(instance:Code[1], method:meta::external::language::java::metamodel::Method[1], args:Code[*]):Code[1]
{
   j_invoke($instance, [], $method.name, $args, $method.returnType);
}

function meta::external::language::java::factory::j_invoke(instance:Code[1], methodName:String[1], args:Code[*]):Code[1]
{
   j_invoke($instance, [], $methodName, $args);
}

function meta::external::language::java::factory::j_invoke(instance:Code[1], typeArguments:meta::external::language::java::metamodel::Type[*], methodName:String[1], args:Code[*]):Code[1]
{
   j_invoke($instance, $typeArguments, $methodName, $args, $instance.type->methodReturnType($methodName));
}

function meta::external::language::java::factory::j_invoke(instance:Code[1], methodName:String[1], args:Code[*], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   j_invoke($instance, [], $methodName, $args, $type);
}

function meta::external::language::java::factory::j_invoke(instance:Code[1], typeArguments:meta::external::language::java::metamodel::Type[*], methodName:String[1], args:Code[*], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   ^MethodCall(instance=$instance, typeArguments=$typeArguments, methodName=$methodName, arguments=$args, type=$type);
}

function meta::external::language::java::factory::j_field(instance:Code[1], field:meta::external::language::java::metamodel::Field[1]):Code[1]
{
   j_field($instance, $field.name, $field.type);
}

function meta::external::language::java::factory::j_field(instance:Code[1], fieldName:String[1]):Code[1]
{
   j_field($instance, $fieldName, $instance.type->typeForField($fieldName));
}

function meta::external::language::java::factory::j_field(instance:Code[1], fieldName:String[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   ^FieldAccess(instance=$instance, fieldName=$fieldName, type=$type);
}

function meta::external::language::java::factory::j_methodReference(instance:Code[1], methodName:String[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   assert($type->instanceOf(meta::external::language::java::metamodel::FunctionType));
   ^MethodReference(instance=$instance, methodName=$methodName, type=$type);
}

function meta::external::language::java::factory::j_invoke(class:meta::external::language::java::metamodel::Type[1], methodName:String[1], args:Code[*]):Code[1]
{
   j_invoke($class, [], $methodName, $args);
}

function meta::external::language::java::factory::j_invoke(class:meta::external::language::java::metamodel::Type[1], typeArguments:meta::external::language::java::metamodel::Type[*], methodName:String[1], args:Code[*]):Code[1]
{
   j_invoke($class, $typeArguments, $methodName, $args, $class->methodReturnType($methodName));
}

function meta::external::language::java::factory::j_invoke(class:meta::external::language::java::metamodel::Type[1], methodName:String[1], args:Code[*], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   j_invoke($class, [], $methodName, $args, $type);
}

function meta::external::language::java::factory::j_invoke(class:meta::external::language::java::metamodel::Type[1], typeArguments:meta::external::language::java::metamodel::Type[*], methodName:String[1], args:Code[*], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   assert($class->instanceOf(meta::external::language::java::metamodel::Class) || $class->instanceOf(meta::external::language::java::metamodel::Array), |'Cannot use static method on type: ' + $class->typeToString());
   ^StaticMethodCall(class=$class, typeArguments=$typeArguments, methodName=$methodName, arguments=$args, type=$type);
}

function meta::external::language::java::factory::j_field(class:meta::external::language::java::metamodel::Type[1], field:meta::external::language::java::metamodel::Field[1]):Code[1]
{
   j_field($class, $field.name, $field.type);
}

function meta::external::language::java::factory::j_field(class:meta::external::language::java::metamodel::Type[1], fieldName:String[1]):Code[1]
{
   j_field($class, $fieldName, $class->typeForField($fieldName));
}

function meta::external::language::java::factory::j_field(class:meta::external::language::java::metamodel::Type[1], fieldName:String[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   assert($class->instanceOf(meta::external::language::java::metamodel::Class) || $class->instanceOf(meta::external::language::java::metamodel::Array), |'Cannot use static field on type: ' + $class->typeToString());
   ^StaticFieldAccess(class=$class, fieldName=$fieldName, type=$type);
}

function meta::external::language::java::factory::j_classField(type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   ^StaticFieldAccess(class=$type, fieldName='class', type=javaClassType());
}

function meta::external::language::java::factory::j_methodReference(class:meta::external::language::java::metamodel::Type[1], methodName:String[1]):Code[1]
{
   let refTo = $class->findMethod($methodName);
   j_methodReference($class, $methodName, $refTo.functionType->toOne());
}

function meta::external::language::java::factory::j_methodReference(class:meta::external::language::java::metamodel::Type[1], methodName:String[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   assert($class->instanceOf(meta::external::language::java::metamodel::Class) || $class->instanceOf(meta::external::language::java::metamodel::Array), |'Cannot use static method on type: ' + $class->typeToString());
   assert($type->instanceOf(meta::external::language::java::metamodel::FunctionType));
   ^StaticMethodReference(class=$class, methodName=$methodName, type=$type);
}

function meta::external::language::java::factory::j_lambda(parameters:meta::external::language::java::metamodel::Parameter[*], expression:Code[1]):Code[1]
{
   j_lambda($parameters->map(p| $p->j_parameter()), $expression);
}

function meta::external::language::java::factory::j_lambda(parameters:meta::external::language::java::metamodel::Parameter[*], expression:Code[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   j_lambda($parameters->map(p| $p->j_parameter()), $expression, $type);
}

function meta::external::language::java::factory::j_lambda(parameters:Code[*], expression:Code[1]):Code[1]
{
   j_lambda($parameters, $expression, javaFunctionType($parameters.type, $expression.type));
}

function meta::external::language::java::factory::j_lambda(parameters:Code[*], expression:Code[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   assert($parameters->forAll(p| $p->instanceOf(CodeParameter)), 'Parameters must be properly created (j_parameter)');
   ^Lambda(parameters=$parameters->cast(@CodeParameter), expression=$expression, type=$type);
}

function meta::external::language::java::factory::j_identity(type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   j_identity('x', $type);
}

function meta::external::language::java::factory::j_identity(varName:String[1], type:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   let p = j_parameter($type, $varName);
   j_lambda($p, $p);
}

function meta::external::language::java::factory::j_emptyList(listType:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   if($listType->elementType()->instanceOf(meta::external::language::java::metamodel::WildcardType),
      | javaCollections()->j_invoke('emptyList', [], $listType),
      | javaCollections()->j_invoke($listType->elementType(), 'emptyList', [], $listType)
   );
}

function meta::external::language::java::factory::j_listOf(of: Code[1], listType:meta::external::language::java::metamodel::Type[1]):Code[1]
{
   if($of.type == $listType,
      | $of,
      |
   if($of.type->isJavaList() && $of->isCollectionsEmptyList(),
      | j_emptyList($listType),
      |
   if($of.type->isJavaList(),
      | $of->j_streamOf()->j_cast(javaStream($listType->elementType()))->js_resolve($listType),
      |
   if($of.type->isJavaPrimitive(),
      | javaCollections()->j_invoke($listType->elementType(), 'singletonList', $of, $listType),
      | javaOptional()
           ->j_invoke('ofNullable', $of->j_cast($listType->elementType()), javaOptional($of.type))
           ->j_invoke('map', javaCollections()->j_methodReference('singletonList', javaFunctionType($of.type, $listType)), $listType)
           ->j_invoke('orElseGet', javaCollections()->j_methodReference('emptyList', javaFunctionType([], $listType)), $listType)
           ->j_cast($listType)
   ))));
}

function meta::external::language::java::factory::j_streamOf(of: Code[1]):Code[1]
{
   $of->match([
      {dsr:DeferredStreamResolve[1]| $dsr.stream; },
      {c:Code[1] |
         let streamType = if($c.type->isJavaList(), |javaStream($c.type->elementTypeOfJavaList()), |javaStream($c.type));
         if($of.type->isJavaStream(),
            | $of,
            |
         if($of.type->isJavaCollection(),
            | $of->j_invoke('stream', [], javaStream($c.type->elementType())),
            |
         if($of.type->isJavaPrimitive(),
            | javaStream()->j_invoke($of.type->toBoxed(), 'of', $of, javaStream($c.type->toBoxed())),
            | javaOptional()
                 ->j_invoke('ofNullable', $of, javaOptional($of.type))
                 ->j_invoke('map', javaStream()->j_methodReference('of', javaFunctionType($of.type, javaStream($of.type))), javaStream($of.type))
                 ->j_invoke('orElseGet', javaStream()->j_methodReference('empty', javaFunctionType([], javaStream($of.type))), javaStream($of.type))
         )));
      }
   ]);
}

function meta::external::language::java::factory::js_map(stream: Code[1], func: Code[1]):Code[1]
{
   let funcType   = $func.type->cast(@meta::external::language::java::metamodel::FunctionType);
   let funcReturn = $funcType.returnType;
   let map        = $stream->prepareStreamForCallWithLambda($func)->j_invoke('map', $func, javaStream($funcReturn));

   if($funcReturn->isJavaList(),
      | $map->js_flatMap(j_methodReference(javaClass('java.util.Collection'), 'stream', javaFunctionType($funcReturn, javaStream($funcReturn->elementTypeOfJavaList())))),
      {|
         let cannotBeNull = $funcType.nullResultPossible->isFalse() || $funcReturn->isJavaPrimitive();
         let x = j_parameter($funcReturn, 'x');
         if($cannotBeNull, | $map, |$map->js_filter(j_lambda($x, $x->j_ne(j_null()))));
      }
   );
}

function meta::external::language::java::factory::js_mapAllowingNullValues(stream: Code[1], func: Code[1]):Code[1]
{
   let funcType    = $func.type->cast(@meta::external::language::java::metamodel::FunctionType);
   let funcReturn  = $funcType.returnType;
   let updatedFunc = if($func->instanceOf(Lambda) && $func->cast(@Lambda).parameters->size() == 1
                        ,| let orgFunc       = $func->cast(@Lambda);
                           let newExpression = j_if($orgFunc.parameters->toOne()->j_eq(j_null()), j_null()->j_return(), $orgFunc.expression)->j_block();
                           ^$orgFunc(expression = $newExpression);
                        ,| $func);
   let map         = $stream->prepareStreamForCallWithLambda($updatedFunc)->j_invoke('map', $updatedFunc, javaStream($funcReturn));

   if($funcReturn->isJavaList(),
      | $map->js_flatMap(j_methodReference(javaClass('java.util.Collection'), 'stream', javaFunctionType($funcReturn, javaStream($funcReturn->elementTypeOfJavaList())))),
      | $map
   );
}

function meta::external::language::java::factory::js_flatMap(stream: Code[1], func: Code[1]):Code[1]
{
   let funcType   = $func.type->cast(@meta::external::language::java::metamodel::FunctionType);
   let funcReturn = $funcType.returnType;
   assert($funcReturn->isJavaStream(), 'Function should return streams');
   
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('flatMap', $func, javaStream($funcReturn->elementType()));
}

function meta::external::language::java::factory::js_filter(stream:Code[1], func:Code[1]):Code[1]
{
   let s = $stream->prepareStreamForCallWithLambda($func);
   $s->j_invoke('filter', $func, $s.type);
}

function meta::external::language::java::factory::js_distinct(stream:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('distinct', [], $stream.type);
}

function meta::external::language::java::factory::js_skip(stream:Code[1], limit:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('skip', $limit, $stream.type);
}

function meta::external::language::java::factory::js_limit(stream:Code[1], limit:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('limit', $limit, $stream.type);
}

function meta::external::language::java::factory::js_max(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('max', $func, javaOptional($stream.type->elementTypeOfJavaStream()));
}

function meta::external::language::java::factory::js_reduce(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('reduce', $func, javaOptional($stream.type->elementTypeOfJavaStream()));
}

function meta::external::language::java::factory::js_reduce(stream:Code[1], identity:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('reduce', [$identity, $func], $identity.type->toBoxed());
}

function meta::external::language::java::factory::js_findFirst(stream:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('findFirst', [], javaOptional($stream.type->elementTypeOfJavaStream()));
}

function meta::external::language::java::factory::js_count(stream:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('count', [], javaLong());
}

function meta::external::language::java::factory::js_forEach(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('forEach', $func, javaVoid());
}

function meta::external::language::java::factory::js_anyMatch(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('anyMatch', $func, javaBoolean());
}

function meta::external::language::java::factory::js_noneMatch(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('noneMatch', $func, javaBoolean());
}

function meta::external::language::java::factory::js_allMatch(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('allMatch', $func, javaBoolean());
}

function meta::external::language::java::factory::j_toString(c:Code[1]): Code[1]
{
   $c->j_invoke('toString', [], javaString());
}


function meta::external::language::java::factory::j_println(s:String[1]): Code[1]
{
   j_println(j_string($s));
}

function meta::external::language::java::factory::j_println(msg:Code[1]): Code[1]
{
   javaSystem()->j_field('out', javaPrintStream())->j_invoke('println', $msg, javaVoid());
}

function <<access.private>> meta::external::language::java::factory::prepareStreamForCallWithLambda(stream: Code[1], func: Code[1]):Code[1]
{
   
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   assert($func->instanceOf(StaticMethodCall) || $func->instanceOf(StaticMethodReference) || $func.type->instanceOf(meta::external::language::java::metamodel::FunctionType), 'Should apply a function');

   if ($func->instanceOf(StaticMethodCall),| $stream->j_cast(javaStream($func.type->cast(@meta::external::language::java::metamodel::ParameterizedType).typeArguments->at(0)));,
       | $stream->j_cast(javaStream($func.type->cast(@meta::external::language::java::metamodel::FunctionType).parameterTypes->at(0))););
}

function meta::external::language::java::factory::js_joining(stream: Code[1]):Code[1]
{
   $stream->js_joining(j_string(''));
}

function meta::external::language::java::factory::js_joining(stream: Code[1], delimiter: Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('collect', j_invoke(javaCollectors(), 'joining', $delimiter, javaCollector()), javaString());
}

function meta::external::language::java::factory::js_resolve(stream: Code[1], type: meta::external::language::java::metamodel::Type[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   assert($type->instanceOf(meta::external::language::java::metamodel::ParameterizedType) || $type->instanceOf(meta::external::language::java::metamodel::Class), |'Not yet handled: ' + $type->typeToString());
   ^DeferredStreamResolve(stream=$stream, type=$type);
}

function meta::external::language::java::factory::jo_get(optional: Code[1]):Code[1]
{
   assert($optional.type->isJavaOptional(), 'Should apply to an Optional');
   $optional->j_invoke('get', [], $optional.type->elementTypeOfJavaOptional());
}

function meta::external::language::java::factory::jo_orElse(optional: Code[1], else:Code[1]):Code[1]
{
   assert($optional.type->isJavaOptional(), 'Should apply to an Optional');
   $optional->j_invoke('orElse', $else, $optional.type->elementTypeOfJavaOptional());
}

function meta::external::language::java::factory::jo_orElseNull(optional: Code[1]):Code[1]
{
   assert($optional.type->isJavaOptional(), 'Should apply to an Optional');
   $optional->jo_orElse(j_null($optional.type->elementTypeOfJavaOptional()));
}

function meta::external::language::java::factory::j_sysout():Code[1]
{
   javaSystem()->j_field('out', javaPrintStream());
}

function meta::external::language::java::factory::j_syserr():Code[1]
{
   javaSystem()->j_field('out', javaPrintStream());
}

function meta::external::language::java::factory::j_exTryCatch(toTry:Code[1..*]): Code[1]
{ 
   let ex   = j_parameter(javaException(), 'e');
   let rtEx = j_parameter(javaRuntimeException(), 'e');

   j_try(
      $toTry,
      j_catch($rtEx, $rtEx->j_throw()),
      j_catch($ex, javaRuntimeException()->j_new($ex)->j_throw())
   );
}

function meta::external::language::java::factory::j_ioExTryCatch(toTry:Code[1..*]): Code[1]
{ 
   let ioEx = j_parameter(javaIOException(), 'e');

   j_try(
      $toTry,
      j_catch($ioEx, javaRuntimeException()->j_new($ioEx)->j_throw())
   );
}

function meta::external::language::java::factory::nonNull(code:Code[1]) : Code[1]
{
   assert($code.type->instanceOf(meta::external::language::java::metamodel::FunctionType), 'Expected function type');
   ^$code(type=$code.type->cast(@meta::external::language::java::metamodel::FunctionType)->nonNull());
}

function meta::external::language::java::factory::nullable(code:Code[1]) : Code[1]
{
   assert($code.type->instanceOf(meta::external::language::java::metamodel::FunctionType), 'Expected function type');
   ^$code(type=$code.type->cast(@meta::external::language::java::metamodel::FunctionType)->nullable());
}

// Utilities

function meta::external::language::java::factory::asParameters(parameters:Code[*]):meta::external::language::java::metamodel::Parameter[*]
{
   assert($parameters->forAll(p |$p->instanceOf(Parameter)), 'Parameters must be properly created (j_parameter)');
   $parameters->cast(@meta::external::language::java::metamodel::Parameter);
}

function meta::external::language::java::factory::classesUsed(codes: Code[*]):meta::external::language::java::metamodel::Class[*]
{
   $codes->typesUsed()->typesToClasses();
}

function meta::external::language::java::factory::typesUsed(codes: Code[*]):meta::external::language::java::metamodel::Type[*]
{
   $codes->map(code| $code->match([
      c:InfixExpression[1]          | $c.type->concatenate($c.left->typesUsed())->concatenate($c.right->typesUsed()),
      c:PrefixExpression[1]         | $c.type->concatenate($c.expression->typesUsed()),
      c:PostfixExpression[1]        | $c.type->concatenate($c.expression->typesUsed()),
      c:Conditional[1]              | $c.type->concatenate($c.test->concatenate($c.then)->concatenate($c.else)->typesUsed()),
      c:InstanceOf[1]               | $c.type->concatenate($c.class)->concatenate($c.expression->typesUsed()),
      c:ArrayAccess[1]              | $c.type->concatenate($c.array->typesUsed())->concatenate($c.index->typesUsed()),      
      c:CastProxy[1]                | $c.type->concatenate($c.expression->concatenate($c.proxy)->typesUsed()),
      c:Cast[1]                     | $c.type->concatenate($c.expression->typesUsed()),
      c:LocalVariableDeclaration[1] | $c.type->concatenate($c.initializer->typesUsed()),
      c:ConstructorCall[1]          | $c.type->concatenate($c.arguments->map(a| $a->typesUsed())),
      c:MethodCall[1]               | $c.type->concatenate($c.typeArguments)->concatenate($c.instance->typesUsed())->concatenate($c.arguments->map(a| $a->typesUsed())),
      c:FieldAccess[1]              | $c.type->concatenate($c.instance->typesUsed()),
      c:MethodReference[1]          | $c.type->concatenate($c.instance->typesUsed()),
      c:Block[1]                    | $c.type->concatenate($c.statements->typesUsed()),
      c:ExpressionStatement[1]      | $c.type->concatenate($c.expression->typesUsed()),
      c:If[1]                       | $c.type->concatenate($c.test->concatenate($c.then)->concatenate($c.else)->map(x|$x->typesUsed())),
      c:For[1]                      | $c.type->concatenate($c.init->concatenate($c.test)->concatenate($c.update)->concatenate($c.body)->map(x|$x->typesUsed())),
      c:ForEach[1]                  | $c.type->concatenate($c.parameter->cast(@Code)->concatenate($c.collection)->concatenate($c.body)->map(x|$x->typesUsed())),
      c:While[1]                    | $c.type->concatenate($c.test->concatenate($c.then)->map(x|$x->typesUsed())),
      c:DoWhile[1]                  | $c.type->concatenate($c.do->concatenate($c.while)->map(x|$x->typesUsed())),
      c:Try[1]                      | $c.type->concatenate($c.try->concatenate($c.catches)->concatenate($c.finally)->map(x|$x->typesUsed())),
      c:Catch[1]                    | $c.type->concatenate($c.clause->typesUsed()),
      c:Finally[1]                  | $c.type->concatenate($c.clause->typesUsed()),
      c:Return[1]                   | $c.type->concatenate($c.expression->typesUsed()),
      c:Throw[1]                    | $c.type->concatenate($c.expression->typesUsed()),      
      c:NewAnonymous[1]             | $c.type->concatenate($c.typeArguments)->concatenate($c.arguments->typesUsed())->concatenate($c.methods->typesUsed()),
      c:New[1]                      | $c.type->concatenate($c.typeArguments)->concatenate($c.arguments->typesUsed()),
      c:CodeMethod[1]               | $c.type->concatenate($c.parameters->map(p|$p->typesUsed()))->concatenate($c.body->typesUsed()),
      c:StaticMethodCall[1]         | $c.type->concatenate($c.class)->concatenate($c.typeArguments)->concatenate($c.arguments->map(a| $a->typesUsed())),
      c:StaticFieldAccess[1]        | $c.type->concatenate($c.class),
      c:StaticMethodReference[1]    | $c.type->concatenate($c.class),
      c:DeferredStreamResolve[1]    | $c.type->concatenate($c.stream->typesUsed())->concatenate($c->resolveDeferred()->typesUsed()),
      c:Lambda[1]                   | $c.type->concatenate($c.expression->typesUsed()),
      c:Code[1]                     | $c.type
   ]))->removeDuplicates();
}

function meta::external::language::java::factory::resolveDeferred(code: Code[1]):Code[1]
{
   $code->match([
      {dsr:DeferredStreamResolve[1]|
         if(isJavaList($dsr.type),
            | $dsr.stream->j_invoke('collect', j_invoke(javaClass('java.util.stream.Collectors'), 'toList', [], $dsr.type), $dsr.type),
            | $dsr.stream->j_invoke('findFirst', [], javaOptional($dsr.type))->jo_orElseNull()
         );
      },
      {c:Code[1] | $c }
   ])
}

function meta::external::language::java::factory::methodReturnType(from:meta::external::language::java::metamodel::Type[1], methodName:String[1]):meta::external::language::java::metamodel::Type[1]
{
   let types = $from->apiKnowledge().methods->filter(m|$m.name == $methodName).returnType->removeDuplicates();
   assert($types->size() > 0,  |'Type not found for method ' + $methodName + ' from ' + $from->typeToString());
   assert($types->size() == 1, |'Type ambiguous for method ' + $methodName + ' from ' + $from->typeToString());
   assert(!$types->at(0)->instanceOf(meta::external::language::java::metamodel::TypeVariable), |'Type unresolved for method ' + $methodName + ' from ' + $from->typeToString());
   $types->toOne();
}

function <<access.private>> meta::external::language::java::factory::findMethod(from:meta::external::language::java::metamodel::Type[1], methodName:String[1]):meta::external::language::java::metamodel::Method[1]
{
   let methods = $from->apiKnowledge().methods->filter(m|$m.name == $methodName);
   assert($methods->size() > 0,  |'Method details not found for inference ' + $methodName + ' from ' + $from->typeToString());
   assert($methods->size() == 1, |'Ambiguous details found for method ' + $methodName + ' from ' + $from->typeToString());
   assert($methods.functionType->size() == 1, |'Method found does not have function type ' + $methodName + ' from ' + $from->typeToString());
   $methods->toOne();
}

function meta::external::language::java::factory::typeForField(from:meta::external::language::java::metamodel::Type[1], fieldName:String[1]):meta::external::language::java::metamodel::Type[1]
{
   if($from->instanceOf(meta::external::language::java::metamodel::Enumeration),
      | $from,
      {|
         let types = $from->apiKnowledge().fields->filter(f|$f.name == $fieldName).type->removeDuplicates();
         assert($types->size() > 0,  |'Type not found for field ' + $fieldName + ' from ' + $from->typeToString());
         assert($types->size() == 1, |'Type ambiguous for field ' + $fieldName + ' from ' + $from->typeToString());
         assert(!$types->at(0)->instanceOf(meta::external::language::java::metamodel::TypeVariable), |'Type unresolved for field ' + $fieldName + ' from ' + $from->typeToString());
         $types->toOne();
      }
   );
}

Enum meta::external::language::java::factory::CastCompatibility
{
   Identity, Widening, WideningAndNarrowing, Boxing, BoxingAndWidening, Unboxing, UnboxingAndWidening, Narrowing, UnboxingAndNarrowing, Disallowed, Unknown
}

function <<access.private>> meta::external::language::java::factory::bestCompatibility(c1:CastCompatibility[1], c2:CastCompatibility[1]):CastCompatibility[1]
{
   let compatibilities = CastCompatibility->enumValues();
   let i1 = $compatibilities->indexOf($c1);
   let i2 = $compatibilities->indexOf($c2);
   $compatibilities->at(min($i1, $i2));
}

function <<access.private>> meta::external::language::java::factory::castCompatibility(from:meta::external::language::java::metamodel::Type[1], to:meta::external::language::java::metamodel::Type[1]):CastCompatibility[1]
{
   $from->match([
      {fromP:meta::external::language::java::metamodel::PrimitiveType[1] |
         $to->match([
            {toP:meta::external::language::java::metamodel::PrimitiveType[1] |
               if($fromP.simpleName == $toP.simpleName,
                  | CastCompatibility.Identity,
                  |
               if($fromP.simpleName == 'byte' && $toP.simpleName == 'char',
                  | CastCompatibility.WideningAndNarrowing,
                  |
               if($fromP.simpleName == 'byte' && $toP.simpleName->in(['short', 'int', 'long', 'float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'short' && $toP.simpleName->in(['byte', 'char']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'short' && $toP.simpleName->in(['int', 'long', 'float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'char' && $toP.simpleName->in(['byte', 'short']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'char' && $toP.simpleName->in(['int', 'long', 'float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'int' && $toP.simpleName->in(['byte', 'short', 'char']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'int' && $toP.simpleName->in(['long', 'float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'long' && $toP.simpleName->in(['byte', 'short', 'char', 'int']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'long' && $toP.simpleName->in(['float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'float' && $toP.simpleName->in(['byte', 'short', 'char', 'int', 'long']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'float' && $toP.simpleName->in(['double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'double' && $toP.simpleName->in(['byte', 'short', 'char', 'int', 'long', 'float']),
                  | CastCompatibility.Narrowing,
                  | CastCompatibility.Disallowed
               ))))))))))))));
            },
            {toC:meta::external::language::java::metamodel::Class[1] |
               if($fromP.simpleName == 'byte' && $toC->isClass('java.lang', 'Byte'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'byte' && $toC->isClass('java.lang', ['Short', 'Character', 'Integer', 'Long', 'Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'short' && $toC->isClass('java.lang', 'Short'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'short' && $toC->isClass('java.lang', ['Integer', 'Long', 'Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'char' && $toC->isClass('java.lang', 'Character'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'char' && $toC->isClass('java.lang', ['Integer', 'Long', 'Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'int' && $toC->isClass('java.lang', 'Integer'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'int' && $toC->isClass('java.lang', ['Long', 'Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'long' && $toC->isClass('java.lang', 'Long'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'long' && $toC->isClass('java.lang', ['Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'float' && $toC->isClass('java.lang', 'Float'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'float' && $toC->isClass('java.lang', ['Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'double' && $toC->isClass('java.lang', 'Double'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'double' && $toC->isClass('java.lang', ['Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'boolean' && $toC->isClass('java.lang', 'Boolean'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'boolean' && $toC->isClass('java.lang', 'Object'),
                  | CastCompatibility.BoxingAndWidening,
                  | CastCompatibility.Disallowed
               ))))))))))))))));
            },
            {a:Any[1] | CastCompatibility.Disallowed }
         ])
      },
      {fromC:meta::external::language::java::metamodel::Class[1] |
         $to->match([
            {toP:meta::external::language::java::metamodel::PrimitiveType[1] |
               if($fromC->isInPackage('java.lang'),
                  {| 
                     if($fromC.simpleName == 'Byte' && $toP.simpleName == 'byte',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Byte' && $toP.simpleName->in(['short', 'int', 'long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Short' && $toP.simpleName == 'short',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Short' && $toP.simpleName->in(['int', 'long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Character' && $toP.simpleName == 'char',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Character' && $toP.simpleName->in(['int', 'long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Integer' && $toP.simpleName == 'int',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Integer' && $toP.simpleName->in(['long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Long' && $toP.simpleName == 'long',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Long' && $toP.simpleName->in(['float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Float' && $toP.simpleName == 'float',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Float' && $toP.simpleName->in(['double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Double' && $toP.simpleName == 'double',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Boolean' && $toP.simpleName == 'boolean',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Number' && $toP.simpleName->in(['byte', 'short', 'char', 'int', 'long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndNarrowing,
                        |
                     if($fromC.simpleName == 'Object',
                        | CastCompatibility.UnboxingAndNarrowing,
                        | CastCompatibility.Disallowed
                     ))))))))))))))));
                  },
                  |  CastCompatibility.Disallowed
               );
            },
            {toC:meta::external::language::java::metamodel::Class[1] |
               if($fromC == $toC,
                  | CastCompatibility.Identity,
                  | 
               if($fromC->isSubclassOf($toC),
                  | CastCompatibility.Narrowing,
                  | 
               if($toC->isSubclassOf($fromC),
                  | CastCompatibility.Widening,
                  | CastCompatibility.Unknown    // If further sitauations can be reliably identified they can be added here but JLS (SE 8) 5.5.1 is difficult to implement with the criteria known here
               )));
            },
            {a:Any[1] | CastCompatibility.Unknown }
         ])
      },
      {a:Any[1] | CastCompatibility.Unknown }
   ]);
}

function <<access.private>> meta::external::language::java::factory::blockIfNot(code: Code[1]):Code[1]
{
   if($code->instanceOf(Block), |$code, |j_block($code));
}

function meta::external::language::java::factory::toStatement(code: Code[1]):Code[1]
{
   $code->toStatements()->toOne();
}

function meta::external::language::java::factory::toStatements(codes: Code[*]):Code[*]
{
   $codes->fold(
      {c, a|
         let l = $a.first;
         let n = $a.second;

         if($c->isStatement() || $c->instanceOf(Method),
            | pair(list($l.values->add($c)), $n),
            |
         if($c->isValidExpressionAsStatement(),
            | pair(list($l.values->add($c->j_expressionStatement())), $n),
            |
         if($c.type == javaVoid(),
            | $a,
            | pair(list($l.values->add(j_variable($c.type, '_dummy_'+$n->toString())->j_declare($c))), $n+1)
         )));
      },
      pair(^List<Code>(), 1)
   ).first.values;
}

function meta::external::language::java::factory::variableDeclared(c:Code[1]):Code[1]
{
   assert($c->isDeclaration(), 'Not a declaration');
   j_variable($c.type, $c->cast(@LocalVariableDeclaration).variableName);
}

function meta::external::language::java::factory::variableAssigned(c:Code[1]):Code[1]
{
   assert($c->isAssignment(), 'Not an assignment');
   $c->cast(@InfixExpression).left;
}

function meta::external::language::java::factory::expressionAssigned(c:Code[1]):Code[1]
{
   assert($c->isAssignment() || $c->isDeclarationWithAssignment(), 'Does not contain as assigned expression');
   $c->match([
      inf : InfixExpression[1]          | $inf.right,
      lvd : LocalVariableDeclaration[1] | $lvd.initializer->toOne()
   ]);
}

// Dependencies
function meta::external::language::java::factory::dependsOn(code:Code[1], dependencies:CodeDependency[*]):Code[1]
{
   ^$code(requires=$code.requires->concatenate($dependencies)->removeDuplicates());
}

function meta::external::language::java::factory::methodsDependency(class:meta::external::language::java::metamodel::Class[1], methodNames:String[*]):CodeDependency[1]
{
   let depClass = ^$class(methods=$class.methods->filter(m| $m.name->in($methodNames)));

   newDependency($class->typeToString()+$methodNames->joinStrings('[', '&', ']'), $depClass);
}

function meta::external::language::java::factory::newDependency(name:String[1], classes:meta::external::language::java::metamodel::Class[*]):CodeDependency[1]
{
   newDependency($name, newProject()->addClasses($classes));
}

function meta::external::language::java::factory::newDependency(name:String[1], project:Project[1]):CodeDependency[1]
{
   newDependency($name, {state| $state->addProjectIfMissing($name, {|$project})});
}

function meta::external::language::java::factory::newDependency(name:String[1], stateUpdater:Function<{CodeDependencyResolutionState[1]->CodeDependencyResolutionState[1]}>[1]):CodeDependency[1]
{
   ^CodeDependency(name=$name, stateUpdater=$stateUpdater);
}

function meta::external::language::java::factory::addProjectIfMissing(state:CodeDependencyResolutionState[1], name:String[1], projectSupplier:Function<{->Project[1]}>[1]):CodeDependencyResolutionState[1]
{
   if($state.projectsByDependency->keys()->contains($name),
      | $state,
      | $state->addDependencyProject($name, $projectSupplier->eval())
   );
}

function meta::external::language::java::factory::addDependencyProject(state:CodeDependencyResolutionState[1], name:String[1], project:Project[1]):CodeDependencyResolutionState[1]
{
   ^$state(projectsByDependency=$state.projectsByDependency->put($name, $project));
}

function meta::external::language::java::factory::resolveProjects(dependencies:CodeDependency[*]):CodeDependencyResolutionState[1]
{
   $dependencies->resolveProjects(^CodeDependencyResolutionState(projectsByDependency=^Map<String, Project>()));
}

function meta::external::language::java::factory::resolveProjects(dependencies:CodeDependency[*], state:CodeDependencyResolutionState[1]):CodeDependencyResolutionState[1]
{
   $dependencies->fold({d, s| $d.stateUpdater->eval($s)}, $state);
}

function meta::external::language::java::factory::getProjects(state:CodeDependencyResolutionState[1], dependencies:CodeDependency[*]):Project[*]
{
   $state.projectsByDependency->keyValues()->filter({kv|$kv.first->in($dependencies.name)}).second;
}

function meta::external::language::java::factory::getProjects(state:CodeDependencyResolutionState[1]):Project[*]
{
   $state.projectsByDependency->keyValues().second;
}

function meta::external::language::java::factory::resolveAndGetProjects(dependencies:CodeDependency[*]):Project[*]
{
   $dependencies->resolveProjects()->getProjects();
}



function meta::external::language::java::factory::escapedString(in: String[1]):String[1]
{
   '"' +
      $in->replace('\\','\\\\')
         ->replace('"','\\"')
         ->replace('\b','\\b')
         ->replace('\f','\\f')
         ->replace('\n','\\n')
         ->replace('\r','\\r')
         ->replace('\t','\\t') +
   '"';
}

function meta::external::language::java::factory::methodSignature(m: meta::external::language::java::metamodel::Method[1]): String[1]
{
   $m.name+'('+$m.parameters->map(p|$p.type->typeToString())->makeString(',')+')';
}

Class meta::external::language::java::factory::KnownPackage
{
   package: meta::external::language::java::metamodel::Package[1];
   classNames: String[*];
}

function meta::external::language::java::factory::knownPackage(pkg: meta::external::language::java::metamodel::Package[1]): KnownPackage[1]
{
   let pkgName = $pkg->packageToString();

   if($pkg->instanceOf(KnownPackage),
      | $pkg->cast(@KnownPackage),
      |
   if($pkgName == 'java.lang',
      | javaLangPackage(),
      |
   if($pkgName == 'java.util',
      | javaUtilPackage(),
      |
   if($pkgName == 'java.util.function',
      | javaUtilFunctionPackage(),
      |
   if($pkgName == 'java.util.stream',
      | javaUtilStreamPackage(),
      |
   if($pkgName == 'java.io',
      | javaIoPackage(),
      |
   if($pkgName == 'java.net',
      | javaNetPackage(),
      |
   if($pkgName == 'java.math',
      | javaMathPackage(),
      |
   if($pkgName == 'java.time',
      | javaTimePackage(),
      | fail('Package ' + $pkgName + ' is not well known'); ^KnownPackage(package=javaPackage(''));
   )))))))));
}

function meta::external::language::java::factory::javaLangPackage(): meta::external::language::java::factory::KnownPackage[1]
{
   ^meta::external::language::java::factory::KnownPackage(
      package    = javaPackage('java.lang'),
      classNames = [
         'AbstractMethodError',                  'Appendable',                           'ArithmeticException',                  'ArrayIndexOutOfBoundsException',
         'ArrayStoreException',                  'AssertionError',                       'AutoCloseable',                        'Boolean',
         'BootstrapMethodError',                 'Byte',                                 'Character',                            'Character.Subset',
         'Character.UnicodeBlock',               'Character.UnicodeScript',              'CharSequence',                         'Class',
         'ClassCastException',                   'ClassCircularityError',                'ClassFormatError',                     'ClassLoader',
         'ClassNotFoundException',               'ClassValue',                           'Cloneable',                            'CloneNotSupportedException',
         'Comparable',                           'Compiler',                             'Deprecated',                           'Double',
         'Enum',                                 'EnumConstantNotPresentException',      'Error',                                'Exception',
         'ExceptionInInitializerError',          'Float',                                'FunctionalInterface',                  'IllegalAccessError',
         'IllegalAccessException',               'IllegalArgumentException',             'IllegalMonitorStateException',         'IllegalStateException',
         'IllegalThreadStateException',          'IndexOutOfBoundsException',            'IncompatibleClassChangeError',         'InheritableThreadLocal',
         'InstantiationError',                   'InstantiationException',               'Integer',                              'InternalError',
         'InterruptedException',                 'Iterable',                             'LinkageError',                         'Long',
         'Math',                                 'NegativeArraySizeException',           'NoClassDefFoundError',                 'NoSuchFieldError',
         'NoSuchFieldException',                 'NoSuchMethodError',                    'NoSuchMethodException',                'NullPointerException',
         'Number',                               'NumberFormatException',                'Object',                               'OutOfMemoryError',
         'Override',                             'Package',                              'Process',                              'ProcessBuilder',
         'ProcessBuilder.Redirect',              'ProcessBuilder.Redirect.Type',         'Readable',                             'ReflectiveOperationException',
         'Runnable',                             'Runtime',                              'RuntimeException',                     'RuntimePermission',
         'SafeVarargs',                          'SecurityException',                    'SecurityManager',                      'Short',
         'StackOverflowError',                   'StackTraceElement',                    'StrictMath',                           'String',
         'StringBuffer',                         'StringBuilder',                        'StringIndexOutOfBoundsException',      'SuppressWarnings',
         'System',                               'Thread',                               'State',                                'UncaughtExceptionHandler',
         'ThreadDeath',                          'ThreadGroup',                          'ThreadLocal',                          'Throwable',
         'TypeNotPresentException',              'UnsatisfiedLinkError',                 'UnknownError',                         'UnsupportedClassVersionError',
         'UnsupportedOperationException',        'VerifyError',                          'VirtualMachineError',                  'Void'
      ]
   );
}

function meta::external::language::java::factory::javaUtilPackage(): meta::external::language::java::factory::KnownPackage[1]
{
   ^meta::external::language::java::factory::KnownPackage(
      package    = javaPackage('java.util'),
      classNames = [
         'AbstractCollection',                   'AbstractList',                         'AbstractMap',                          'AbstractMap.SimpleEntry',
         'AbstractMap.SimpleImmutableEntry',     'AbstractQueue',                        'AbstractSequentialList',               'AbstractSet',
         'ArrayDeque',                           'ArrayList',                            'Arrays',                               'Base64',
         'Base64.Decoder',                       'Base64.Encoder',                       'BitSet',                               'Calendar',
         'Calendar.Builder',                     'Collection',                           'Collections',                          'Comparator',
         'ConcurrentModificationException',      'Currency',                             'Date',                                 'Deque',
         'Dictionary',                           'DoubleSummaryStatistics',              'DuplicateFormatFlagsException',        'EmptyStackException',
         'EnumMap',                              'EnumSet',                              'Enumeration',                          'EventListener',
         'EventListenerProxy',                   'EventObject',                          'FormatFlagsConversionMismatchException',
         'Formattable',                          'FormattableFlags',                     'Formatter',                            'Formatter.BigDecimalLayoutForm',
         'FormatterClosedException',             'GregorianCalendar',                    'HashMap',                              'HashSet',
         'Hashtable',                            'IdentityHashMap',                      'IllegalFormatCodePointException',      'IllegalFormatConversionException',
         'IllegalFormatException',               'IllegalFormatFlagsException',          'IllegalFormatPrecisionException',      'IllegalFormatWidthException',
         'IllformedLocaleException',             'InputMismatchException',               'IntSummaryStatistics',                 'InvalidPropertiesFormatException',
         'Iterator',                             'LinkedHashMap',                        'LinkedHashSet',                        'LinkedList',
         'List',                                 'ListIterator',                         'ListResourceBundle',                   'Locale',
         'Locale.Builder',                       'Locale.Category',                      'Locale.FilteringMode',                 'Locale.LanguageRange',
         'LongSummaryStatistics',                'Map',                                  'Map.Entry',                            'MissingFormatArgumentException',
         'MissingFormatWidthException',          'MissingResourceException',             'NavigableMap',                         'NavigableSet',
         'NoSuchElementException',               'Objects',                              'Observable',                           'Observer',
         'Optional',                             'OptionalDouble',                       'OptionalInt',                          'OptionalLong',
         'PrimitiveIterator',                    'PrimitiveIterator.OfDouble',           'PrimitiveIterator.OfInt',              'PrimitiveIterator.OfLong',
         'PriorityQueue',                        'Properties',                           'PropertyPermission',                   'PropertyResourceBundle',
         'Queue',                                'Random',                               'RandomAccess',                         'ResourceBundle',
         'ResourceBundle.Control',               'Scanner',                              'ServiceConfigurationError',            'ServiceLoader',
         'Set',                                  'SimpleTimeZone',                       'SortedMap',                            'SortedSet',
         'Spliterator',                          'Spliterator.OfDouble',                 'Spliterator.OfInt',                    'Spliterator.OfLong',
         'Spliterator.OfPrimitive',              'Spliterators',                         'Spliterators.AbstractDoubleSpliterator',
         'Spliterators.AbstractIntSpliterator',  'Spliterators.AbstractLongSpliterator', 'Spliterators.AbstractSpliterator',     'SplittableRandom',
         'Stack',                                'StringJoiner',                         'StringTokenizer',                      'TimeZone',
         'Timer',                                'TimerTask',                            'TooManyListenersException',            'TreeMap',
         'TreeSet',                              'UUID',                                 'UnknownFormatConversionException',     'UnknownFormatFlagsException',
         'Vector',                               'WeakHashMap'
      ]
   );
}

function meta::external::language::java::factory::javaUtilFunctionPackage(): meta::external::language::java::factory::KnownPackage[1]
{
   ^meta::external::language::java::factory::KnownPackage(
      package    = javaPackage('java.util.function'),
      classNames = [
         'BiConsumer',                           'BiFunction',                           'BinaryOperator',                       'BiPredicate',
         'BooleanSupplier',                      'Consumer',                             'DoubleBinaryOperator',                 'DoubleConsumer',
         'DoubleFunction',                       'DoublePredicate',                      'DoubleSupplier',                       'DoubleToIntFunction',
         'DoubleToLongFunction',                 'DoubleUnaryOperator',                  'Function',                             'IntBinaryOperator',
         'IntConsumer',                          'IntFunction',                          'IntPredicate',                         'IntSupplier',
         'IntToDoubleFunction',                  'IntToLongFunction',                    'IntUnaryOperator',                     'LongBinaryOperator',
         'LongConsumer',                         'LongFunction',                         'LongPredicate',                        'LongSupplier',
         'LongToDoubleFunction',                 'LongToIntFunction',                    'LongUnaryOperator',                    'ObjDoubleConsumer',
         'ObjIntConsumer',                       'ObjLongConsumer',                      'Predicate',                            'Supplier',
         'ToDoubleBiFunction',                   'ToDoubleFunction',                     'ToIntBiFunction',                      'ToIntFunction',
         'ToLongBiFunction',                     'ToLongFunction',                       'UnaryOperator'
      ]
   );
}

function meta::external::language::java::factory::javaUtilStreamPackage(): meta::external::language::java::factory::KnownPackage[1]
{
   ^meta::external::language::java::factory::KnownPackage(
      package    = javaPackage('java.util.stream'),
      classNames = [
         'BaseStream',                           'Collector',                            'Collector.Characteristics',            'Collectors',
         'DoubleStream',                         'DoubleStream.Builder',                 'IntStream',                            'IntStream.Builder',
         'LongStream',                           'LongStream.Builder',                   'Stream',                               'Stream.Builder',
         'StreamSupport'
      ]
   );
}

function meta::external::language::java::factory::javaIoPackage(): meta::external::language::java::factory::KnownPackage[1]
{
   ^meta::external::language::java::factory::KnownPackage(
      package    = javaPackage('java.io'),
      classNames = [
         'BufferedInputStream',                  'BufferedOutputStream',                 'BufferedReader',                       'BufferedWriter',
         'ByteArrayInputStream',                 'ByteArrayOutputStream',                'CharArrayReader',                      'CharArrayWriter',
         'CharConversionException',              'Closeable',                            'Console',                              'DataInput',
         'DataInputStream',                      'DataOutput',                           'DataOutputStream',                     'EOFException',
         'Externalizable',                       'File',                                 'FileDescriptor',                       'FileFilter',
         'FileInputStream',                      'FilenameFilter',                       'FileNotFoundException',                'FileOutputStream',
         'FilePermission',                       'FileReader',                           'FileWriter',                           'FilterInputStream',
         'FilterOutputStream',                   'FilterReader',                         'FilterWriter',                         'Flushable',
         'InputStream',                          'InputStreamReader',                    'InterruptedIOException',               'InvalidClassException',
         'InvalidObjectException',               'IOError',                              'IOException',                          'LineNumberInputStream',
         'LineNumberReader',                     'NotActiveException',                   'NotSerializableException',             'ObjectInput',
         'ObjectInputStream',                    'ObjectInputStream.GetField',           'ObjectInputValidation',                'ObjectOutput',
         'ObjectOutputStream',                   'ObjectOutputStream.PutField',          'ObjectStreamClass',                    'ObjectStreamConstants',
         'ObjectStreamException',                'ObjectStreamField',                    'OptionalDataException',                'OutputStream',
         'OutputStreamWriter',                   'PipedInputStream',                     'PipedOutputStream',                    'PipedReader',
         'PipedWriter',                          'PrintStream',                          'PrintWriter',                          'PushbackInputStream',
         'PushbackReader',                       'RandomAccessFile',                     'Reader',                               'SequenceInputStream',
         'Serializable',                         'SerializablePermission',               'StreamCorruptedException',             'StreamTokenizer',
         'StringBufferInputStream',              'StringReader',                         'StringWriter',                         'SyncFailedException',
         'UncheckedIOException',                 'UnsupportedEncodingException',         'UTFDataFormatException',               'WriteAbortedException',
         'Writer'
      ]
   );
}

function meta::external::language::java::factory::javaNetPackage(): meta::external::language::java::factory::KnownPackage[1]
{
   ^meta::external::language::java::factory::KnownPackage(
      package    = javaPackage('java.net'),
      classNames = [
         'Authenticator',                        'Authenticator.RequestorType',          'BindException',                        'CacheRequest',
         'CacheResponse',                        'ConnectException',                     'ContentHandler',                       'ContentHandlerFactory',
         'CookieHandler',                        'CookieManager',                        'CookiePolicy',                         'CookieStore',
         'DatagramPacket',                       'DatagramSocket',                       'DatagramSocketImpl',                   'DatagramSocketImplFactory',
         'FileNameMap',                          'HttpCookie',                           'HttpRetryException',                   'HttpURLConnection',
         'IDN',                                  'Inet4Address',                         'Inet6Address',                         'InetAddress',
         'InetSocketAddress',                    'InterfaceAddress',                     'JarURLConnection',                     'MalformedURLException',
         'MulticastSocket',                      'NetPermission',                        'NetworkInterface',                     'NoRouteToHostException',
         'PasswordAuthentication',               'PortUnreachableException',             'ProtocolException',                    'ProtocolFamily',
         'Proxy',                                'Proxy.Type',                           'ProxySelector',                        'ResponseCache',
         'SecureCacheResponse',                  'ServerSocket',                         'Socket',                               'SocketAddress',
         'SocketException',                      'SocketImpl',                           'SocketImplFactory',                    'SocketOption',
         'SocketOptions',                        'SocketPermission',                     'SocketTimeoutException',               'StandardProtocolFamily',
         'StandardSocketOptions',                'UnknownHostException',                 'UnknownServiceException',              'URI',
         'URISyntaxException',                   'URL',                                  'URLClassLoader',                       'URLConnection',
         'URLDecoder',                           'URLEncoder',                           'URLPermission',                        'URLStreamHandler',
         'URLStreamHandlerFactory'
      ]
   );
}

function meta::external::language::java::factory::javaMathPackage(): meta::external::language::java::factory::KnownPackage[1]
{
   ^meta::external::language::java::factory::KnownPackage(
      package    = javaPackage('java.math'),
      classNames = [
         'BigDecimal',                           'BigInteger',                           'MathContext',                          'RoundingMode'
      ]
   );
}

function meta::external::language::java::factory::javaTimePackage(): meta::external::language::java::factory::KnownPackage[1]
{
   ^meta::external::language::java::factory::KnownPackage(
      package    = javaPackage('java.time'),
      classNames = [
         'Clock',                                'DateTimeException',                    'DayOfWeek',                            'Duration',
         'Instant',                              'LocalDate',                            'LocalDateTime',                        'LocalTime',
         'Month',                                'MonthDay',                             'OffsetDateTime',                       'OffsetTime',
         'ZoneId',                                'ZoneOffset'
      ]
   );
}

function meta::external::language::java::factory::apiKnowledge(from:meta::external::language::java::metamodel::Type[1]):meta::external::language::java::metamodel::Class[1]
{
   let inferFrom = $from->match([
      en:meta::external::language::java::metamodel::Enumeration[1]       | $en->apiKnowledge(),
      pt:meta::external::language::java::metamodel::ParameterizedType[1] | $pt->apiKnowledge(),
      cl:meta::external::language::java::metamodel::Class[1]             | $cl->apiKnowledge(),
      cl:meta::external::language::java::metamodel::Array[1]             | arrayKnowledge(),
      a :Any[1]                                                          | javaObject()
   ])->addObjectMethods();
}

function meta::external::language::java::factory::apiKnowledge(in:meta::external::language::java::metamodel::Enumeration[1]): meta::external::language::java::metamodel::Class[1]
{
   $in->addMethodIfMissing(javaMethod(javaString(), 'name',    []))
      ->addMethodIfMissing(javaMethod(javaInt(),    'ordinal', []))
}

function meta::external::language::java::factory::apiKnowledge(in:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Class[1]
{
   if($in.simpleName->endsWith('Exception'),
      | $in->addMethodIfMissing(javaMethod(javaString(), 'getMessage', [])),
      |
   if($in.package == javaPackage('java.lang'),
      | $in->smartJavaLang(),
      |
   if($in.package == javaPackage('java.math'),
      | $in->smartJavaMath(),
      |
   if($in.package == javaPackage('java.io'),
      | $in->smartJavaIO(),
      |
   if($in.package == javaPackage('java.net'),
      | $in->smartJavaNet(),
      |
   if($in.package == javaPackage('java.util.stream'),
      | $in->smartJavaUtilStream(),   
      | $in
   ))))));
}

function meta::external::language::java::factory::apiKnowledge(in:meta::external::language::java::metamodel::ParameterizedType[1]): meta::external::language::java::metamodel::Class[1]
{
   $in.rawType->match([
      {cl:meta::external::language::java::metamodel::Class[1] |
         if($cl.package == javaPackage('java.util'),
            | $in->smartJavaUtil(),
            |
         if($cl.package == javaPackage('java.util.function'),
            | $in->smartJavaUtilFunction(),
            |
         if($cl.package == javaPackage('java.util.stream'),
            | $in->smartJavaUtilStream(),
            | $cl->apiKnowledge()
         )))
      },
      t:meta::external::language::java::metamodel::Type[1] | $t->apiKnowledge()
   ])
}

function <<access.private>> meta::external::language::java::factory::arrayKnowledge(): meta::external::language::java::metamodel::Class[1]
{
   javaClass('java.lang._Array_')->addField(javaField([], javaInt(), 'length'));
}

function <<access.private>> meta::external::language::java::factory::smartJavaMath(in:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Class[1]
{
   if($in.simpleName == 'BigDecimal',
      | $in->addMethodIfMissing(javaMethod(javaBigDecimal(),   'add',           [javaParam(javaBigDecimal(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'subtract',      [javaParam(javaBigDecimal(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'multiply',      [javaParam(javaBigDecimal(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'divide',        [javaParam(javaBigDecimal(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'divide',        [javaParam(javaBigDecimal(), 'x'), javaParam(javaInt(), 'y')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'divide',        [javaParam(javaBigDecimal(), 'x'), javaParam(javaRoundingMode(), 'y')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'negate',        []))
           ->addMethodIfMissing(javaMethod(javaInt(),          'compareTo',     [javaParam(javaBigDecimal(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'remainder',     [javaParam(javaBigDecimal(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'round',         [javaParam(javaMathContext(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'setScale',      [javaParam(javaInt(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'setScale',      [javaParam(javaInt(), 'x'), javaParam(javaInt(), 'y')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'setScale',      [javaParam(javaInt(), 'x'), javaParam(javaRoundingMode(), 'y')]))
           ->addMethodIfMissing(javaMethod(javaString(),       'toPlainString', []))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'valueOf',       [javaParam(javaLong(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBigDecimal(),   'valueOf',       [javaParam(javaDouble(), 'x')]))
           ->addNumberMethods(),
      | $in
   );
}

function <<access.private>> meta::external::language::java::factory::smartJavaLang(in:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Class[1]
{
   if($in.simpleName == 'String',
      | $in->addMethodIfMissing(javaMethod(javaChar(),    'charAt',           [javaParam(javaInt(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBoolean(), 'contains',         [javaParam(javaString(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaInt(),     'compareTo',        [javaParam(javaString(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBoolean(), 'endsWith',         [javaParam(javaString(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaBoolean(), 'equalsIgnoreCase', [javaParam(javaString(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaArray(javaByte()), 'getBytes', []))
           ->addMethodIfMissing(javaMethod(javaInt(),     'indexOf',          [javaParam(javaString(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaInt(),     'length',           []))
           ->addMethodIfMissing(javaMethod(javaBoolean(), 'matches',          [javaParam(javaString(), 'str'), javaParam(javaString(), 'regexp')]))
           ->addMethodIfMissing(javaMethod(javaString(),  'replace',          [javaParam(javaString(), 'x'), javaParam(javaString(), 'y')]))
           ->addMethodIfMissing(javaMethod(javaString(),  'replaceAll',       [javaParam(javaString(), 'x'), javaParam(javaString(), 'y')]))
           ->addMethodIfMissing(javaMethod(javaBoolean(), 'startsWith',       [javaParam(javaString(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaString(),  'substring',        [javaParam(javaInt(), 'x')]))
           ->addMethodIfMissing(javaMethod(javaString(),  'substring',        [javaParam(javaInt(), 'x'), javaParam(javaInt(), 'y')]))
           ->addMethodIfMissing(javaMethod(javaString(),  'toLowerCase',      []))
           ->addMethodIfMissing(javaMethod(javaString(),  'toUpperCase',      []))
           ->addMethodIfMissing(javaMethod(javaString(),  'trim',             [])),
      |
   if($in.simpleName == 'Boolean',
      | $in->addMethodIfMissing(javaMethod(javaBoolean(), 'parseBoolean', javaParam(javaString(), 'x'))),
      |
   if($in.simpleName == 'Float',
      | $in->addMethodIfMissing(javaMethod(javaFloat(), 'parseFloat', javaParam(javaString(), 'x')))
           ->addMethodIfMissing(javaMethod(javaInt(),   'compareTo',  javaParam(javaFloat()->toBoxed(), 'x')))
           ->addNumberMethods(),
      |
   if($in.simpleName == 'Double',
      | $in->addMethodIfMissing(javaMethod('static', javaDouble(), 'parseDouble', javaParam(javaString(), 'x')))
           ->addMethodIfMissing(javaMethod(          javaInt(),    'compareTo',   javaParam(javaDouble()->toBoxed(), 'x')))
           ->addMethodIfMissing(javaMethod('static', javaInt(),    'compare',     [javaParam(javaDouble(), 'x'), javaParam(javaDouble(), 'y')]))
           ->addMethodIfMissing(javaMethod('static', javaDouble(), 'max',         [javaParam(javaDouble(), 'x'), javaParam(javaDouble(), 'y')]))
           ->addMethodIfMissing(javaMethod('static', javaDouble(), 'min',         [javaParam(javaDouble(), 'x'), javaParam(javaDouble(), 'y')]))
           ->addNumberMethods(),
      |
   if($in.simpleName == 'Integer',
      | $in->addMethod(javaMethod('static', javaInt(),      'parseInt',  javaParam(javaString(), 'x')))
           ->addMethod(javaMethod(          javaInt(),      'compareTo', javaParam(javaInt()->toBoxed(), 'x')))
           ->addMethod(javaMethod('static', javaIntBoxed(), 'valueOf',   javaParam(javaString(), 'x')))
           ->addNumberMethods(),
      |
   if($in.simpleName == 'Long',
      | $in->addMethodIfMissing(javaMethod('static', javaLong(),      'parseLong', javaParam(javaString(), 'x')))
           ->addMethodIfMissing(javaMethod(          javaInt(),       'compareTo', javaParam(javaLong()->toBoxed(), 'x')))
           ->addMethodIfMissing(javaMethod('static', javaLong(),      'max',       [javaParam(javaLong(), 'x'), javaParam(javaLong(), 'y')]))
           ->addMethodIfMissing(javaMethod('static', javaLong(),      'min',       [javaParam(javaLong(), 'x'), javaParam(javaLong(), 'y')]))
           ->addMethodIfMissing(javaMethod('static', javaLong(),      'sum',       [javaParam(javaLong(), 'x'), javaParam(javaLong(), 'y')]))
           ->addMethodIfMissing(javaMethod('static', javaLongBoxed(), 'valueOf',   javaParam(javaString(), 'x')))
           ->addNumberMethods(),
      |
   if($in.simpleName == 'Number',
      | $in->addNumberMethods(),
      |
   if($in.simpleName == 'StringBuilder',
      | $in->addMethodIfMissing(javaMethod(javaInt(),           'length',     []))
           ->addMethodIfMissing(javaMethod(javaStringBuilder(), 'append', javaParam(javaObject(), 'x')))
           ->addMethodIfMissing(javaMethod(javaChar(),          'charAt', javaParam(javaInt(), 'x'))),
      |
   if($in.simpleName == 'Class',
      | $in->addMethodIfMissing(javaMethod(javaString(),   'getName',       []))
           ->addMethodIfMissing(javaMethod(javaString(),   'getSimpleName', [])),
      | $in
   )))))))));
}

function <<access.private>> meta::external::language::java::factory::addNumberMethods(num:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Class[1]
{
   $num->addMethodIfMissing(javaMethod(javaByte(),    'byteValue',   []))
       ->addMethodIfMissing(javaMethod(javaInt(),     'intValue',    []))
       ->addMethodIfMissing(javaMethod(javaLong(),    'longValue',   []))
       ->addMethodIfMissing(javaMethod(javaShort(),   'shortValue',  []))
       ->addMethodIfMissing(javaMethod(javaFloat(),   'floatValue',  []))
       ->addMethodIfMissing(javaMethod(javaDouble(),  'doubleValue', []));
}

function <<access.private>> meta::external::language::java::factory::smartJavaIO(in:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Class[1]
{
   if($in.simpleName->endsWith('Reader'),
      | $in->addMethodIfMissing(javaMethod(javaInt(), 'read', []))
           ->addMethodIfMissing(javaMethod(javaInt(), 'read', [javaParam(javaArray(javaChar()), 'x')]))
           ->addMethodIfMissing(javaMethod(javaInt(), 'read', [javaParam(javaArray(javaChar()), 'x'), javaParam(javaInt(), 'y'), javaParam(javaInt(), 'z')]))
           ->addMethodIfMissing(javaMethod(javaInt(), 'read', [javaParam(javaClass('java.nio.CharBuffer'), 'x')])),
      |
   if($in.simpleName->endsWith('PrintStream'),
      | $in->addMethodIfMissing(javaMethod(javaVoid(), 'println', [])),
      | $in
   ));
}

function <<access.private>> meta::external::language::java::factory::smartJavaNet(in:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Class[1]
{
   if($in.simpleName->endsWith('URL'),
      | $in->addMethodIfMissing(javaMethod(javaInputStream(), 'openStream', [])),
      | $in
   );
}

function <<access.private>> meta::external::language::java::factory::smartJavaUtilStream(in:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Class[1]
{

   if($in.simpleName == 'LongStream',
      | $in->addMethodIfMissing(javaMethod(javaLongStream(), 'range',  [javaParam(javaLong(), 'startInclusive'), javaParam(javaLong(), 'endExclusive')]))
           ->addMethodIfMissing(javaMethod(javaLongStream(), 'filter', [javaParam(javaLongPredicate(), 'predicate')]))
           ->addMethodIfMissing(javaMethod(javaLongStream(), 'map',    [javaParam(javaLongUnaryOperator(), 'mapper')]))
           ->addMethodIfMissing(javaMethod(javaLongStream(), 'iterate',[javaParam(javaLong(), 'seed'), javaParam(javaLongUnaryOperator(), 'f')]))
           ->addMethodIfMissing(javaMethod(javaLongStream(), 'limit',  [javaParam(javaLong(), 'limit')]))
           ->addMethodIfMissing(javaMethod(javaStream(javaLong()), 'boxed', []));,
      | $in
   );
 
}

function <<access.private>> meta::external::language::java::factory::smartJavaUtil(in:meta::external::language::java::metamodel::ParameterizedType[1]): meta::external::language::java::metamodel::Class[1]
{
   let class       = $in.rawType->cast(@meta::external::language::java::metamodel::Class);
   let elementType = $in.typeArguments->at(0);

   if($class.simpleName->in(['List','ArrayList']),
      | $class->addMethodIfMissing(javaMethod(javaBoolean(), 'add',     javaParam($elementType, 'x')))
              ->addMethodIfMissing(javaMethod($elementType,  'get',     javaParam(javaInt(), 'x')))
              ->addMethodIfMissing(javaMethod(javaInt(),     'indexOf', javaParam($elementType, 'x')))
              ->addMethodIfMissing(javaMethod(javaBoolean(), 'isEmpty', []))
              ->addCollectionMethods($elementType),
      |
   if($class.simpleName->in(['Map','TreeMap','HashMap']),
      {| 
         let keyType   = $in.typeArguments->at(0);
         let valueType = $in.typeArguments->at(1);
         $class->addMethodIfMissing(javaMethod($valueType,    'put',         [javaParam($keyType, 'x'), javaParam($valueType, 'y')]))
               ->addMethodIfMissing(javaMethod(javaBoolean(), 'containsKey', [javaParam($keyType, 'x')]))
               ->addMethodIfMissing(javaMethod($valueType,    'get',         [javaParam($keyType, 'x')]));
      },
      |
   if($class.simpleName == 'Queue',
      | $class->addMethodIfMissing(javaMethod(javaBoolean(), 'add',     javaParam($elementType, 'x')))
              ->addMethodIfMissing(javaMethod(javaBoolean(), 'offer',   javaParam($elementType, 'x')))
              ->addMethodIfMissing(javaMethod($elementType,  'peek',    []))
              ->addMethodIfMissing(javaMethod($elementType,  'poll',    []))
              ->addMethodIfMissing(javaMethod($elementType,  'element', []))
              ->addMethodIfMissing(javaMethod($elementType,  'remove',  []))
              ->addCollectionMethods($elementType),
      |
   if($class.simpleName == 'Iterator',
      | $class->addMethodIfMissing(javaMethod(javaBoolean(), 'hasNext', []))
              ->addMethodIfMissing(javaMethod($elementType,  'next',    [])),
      |
   if($class.simpleName == 'Optional',
      | $class->addMethodIfMissing(javaMethod(javaVoid(), 'ifPresent', javaParam(javaConsumer($elementType), 'x'))),
      | $class
   )))));
}

function <<access.private>> meta::external::language::java::factory::smartJavaUtilStream(in:meta::external::language::java::metamodel::ParameterizedType[1]): meta::external::language::java::metamodel::Class[1]
{
   let class       = $in.rawType->cast(@meta::external::language::java::metamodel::Class);
   let elementType = $in.typeArguments->at(0);

   if($class.simpleName == 'Stream',
      | $class->addMethodIfMissing(javaMethod(javaIterator($elementType),  'iterator',    [])),
      | $class
   );
}

function <<access.private>> meta::external::language::java::factory::smartJavaUtilFunction(in:meta::external::language::java::metamodel::ParameterizedType[1]): meta::external::language::java::metamodel::Class[1]
{
   let class       = $in.rawType->cast(@meta::external::language::java::metamodel::Class);
   let elementType = $in.typeArguments->at(0);

   if($class.simpleName == 'Supplier',
      | $class->addMethodIfMissing(javaMethod($elementType,  'get',     [])),
      | $class
   );
}

function <<access.private>> meta::external::language::java::factory::addCollectionMethods(col:meta::external::language::java::metamodel::Class[1], element:meta::external::language::java::metamodel::Type[1]): meta::external::language::java::metamodel::Class[1]
{
   $col->addMethodIfMissing(javaMethod(javaBoolean(),          'addAll',      javaParam(javaCollection($element), 'x')))
       ->addMethodIfMissing(javaMethod(javaBoolean(),          'contains',    javaParam($element, 'x')))
       ->addMethodIfMissing(javaMethod(javaBoolean(),          'containsAll', javaParam(javaCollection($element), 'x')))
       ->addMethodIfMissing(javaMethod(javaIterator($element), 'iterator',    []))
       ->addMethodIfMissing(javaMethod(javaInt(),              'size',        []));
}

function <<access.private>> meta::external::language::java::factory::addObjectMethods(in:meta::external::language::java::metamodel::Class[1]): meta::external::language::java::metamodel::Class[1]
{
   $in->addMethodIfMissing(javaMethod(javaClass('java.lang.Class'), 'getClass', [])->nonNull())
      ->addMethodIfMissing(javaMethod(javaString(),                 'toString', [])->nonNull())
      ->addMethodIfMissing(javaMethod(javaInt(),                    'hashCode', []))
      ->addMethodIfMissing(javaMethod(javaBoolean(),                'equals', javaParam(javaObject(), 'o')));
}

function meta::external::language::java::factory::generateIfForCollection(emptyCase:String[1], singletonCase:String[1], nonEmptyCase:String[1]) : String[1]
{
   'if (in.isEmpty())\n'+
   '{\n'+
   '   ' + $emptyCase + '\n' +
   '}\n'+
   'else if (in.size() == 1)\n'+
   '{\n'+
   '   ' + $singletonCase + '\n'+
   '}\n'+
   'else\n'+
   '{\n'+
   '   ' + $nonEmptyCase + '\n'+
   '}'
}


function meta::external::language::java::factory::typesUsed(method: meta::external::language::java::metamodel::Method[*]):meta::external::language::java::metamodel::Type[*]
{
   $method.returnType->concatenate($method.parameters.type)->removeDuplicates();
}

function meta::external::language::java::factory::typesToClasses(types: meta::external::language::java::metamodel::Type[*]):meta::external::language::java::metamodel::Class[*]
{
   $types->map(t |$t->typeToClasses())->removeDuplicates();
}

function meta::external::language::java::factory::typeToClasses(type: meta::external::language::java::metamodel::Type[1]):meta::external::language::java::metamodel::Class[*]
{
   $type->match([
      c:meta::external::language::java::metamodel::Class[1]             | $c,
      p:meta::external::language::java::metamodel::ParameterizedType[1] | $p.rawType->typeToClasses()->concatenate($p.typeArguments->map(a|$a->typeToClasses())),
      v:meta::external::language::java::metamodel::TypeVariable[1]      | $v.bounds->map(a|$a->typeToClasses()),
      a:meta::external::language::java::metamodel::Array[1]             | $a.rawType->typeToClasses(),
      f:meta::external::language::java::metamodel::FunctionType[1]      | $f.returnType->typeToClasses()->concatenate($f.parameterTypes->map(p|$p->typeToClasses())),
      t:meta::external::language::java::metamodel::Type[1]              | []
   ])->removeDuplicates();        
}

function meta::external::language::java::factory::elementTypeOfJavaArray(type: meta::external::language::java::metamodel::Type[1]):meta::external::language::java::metamodel::Type[1]
{
   assert($type->isJavaArray(), |'Cannot obtain element type as not an array');
   $type->cast(@meta::external::language::java::metamodel::Array).rawType;
}




function meta::external::language::java::factory::project::newProject(): Project[1]
{
   newProject('dummy', 'dummy', 'dummy');
}

function meta::external::language::java::factory::project::newProject(group:String[1], artifact:String[1], version:String[1]): Project[1]
{
   newProject(^MavenReference(group=$group, artifact=$artifact, version=$version));
}

function meta::external::language::java::factory::project::newProject(id: MavenReference[1]): Project[1]
{
   ^Project(id=$id, root=^ProjectDirectory(name='ROOT'));
}

function meta::external::language::java::factory::project::addClasses(project: Project[1], classes: meta::external::language::java::metamodel::Class[*]): Project[1]
{
   $classes->fold({c,p| $p->addClass($c)}, $project);
}

function meta::external::language::java::factory::project::addClass(project: Project[1], class: meta::external::language::java::metamodel::Class[1]): Project[1]
{
   $project->addClass('src/main/java', $class);
}

function meta::external::language::java::factory::project::addFile(project: Project[1], path:String[1], file:File[1]): Project[1]
{
   ^$project(root=$project.root->ensurePathAndDo($path->split('/'), {d|$d->addToProjectDirectory($file)}));
}

function meta::external::language::java::factory::project::addMavenDependency(project:Project[1], group:String[1], artifact:String[1], version:String[1]): Project[1]
{
   ^$project(
      mainDependencies = $project.mainDependencies->concatenate(^MavenReference(group=$group, artifact=$artifact, version=$version))->removeDuplicates()
   )
}

function meta::external::language::java::factory::project::replaceClass(project: Project[1], class: meta::external::language::java::metamodel::Class[1]): Project[1]
{
   $project->replaceClass('src/main/java', $class);
}

function meta::external::language::java::factory::project::addClass(project: Project[1], path:String[1], class: meta::external::language::java::metamodel::Class[1]): Project[1]
{
   ^$project(root=$project.root->ensurePathAndDo($path->split('/'), {d|$d->addToProjectDirectory($class)}));
}

function meta::external::language::java::factory::project::replaceClass(project: Project[1], path:String[1], class: meta::external::language::java::metamodel::Class[1]): Project[1]
{
   ^$project(root=$project.root->ensurePathAndDo($path->split('/'), {d|$d->replaceInProjectDirectory($class)}));
}

function meta::external::language::java::factory::project::mergeProjects(projects: Project[1..*]): Project[1]
{
   let base = $projects->at(0);
   $projects->tail()->fold({p, b|$b->mergeProject($p)}, $base);
}

function meta::external::language::java::factory::project::mergeProjectsNullable(projects: Project[*]): Project[0..1]
{
   $projects->match([
      p : Project[0..1] | $p,
      ps: Project[1..*] | mergeProjects($ps)
   ]);
}

function <<access.private>> meta::external::language::java::factory::project::mergeProject(base: Project[1], addition: Project[1]): Project[1]
{
   let withDirsAdded = $addition->allDirectories()->fold({d, p|$p->mergeDirectory($d)}, $base);
   ^$withDirsAdded(mainDependencies=$base.mainDependencies->concatenate($addition.mainDependencies)->removeDuplicates());
}

function <<access.private>> meta::external::language::java::factory::project::mergeDirectory(base: Project[1], dir: ProjectDirectory[1]): Project[1]
{
   $dir.classes->fold({c, p|$p->mergeClass($dir, $c)}, $base);
}

function <<access.private>> meta::external::language::java::factory::project::mergeClass(base: Project[1], dir: ProjectDirectory[1], class: meta::external::language::java::metamodel::Class[1]): Project[1]
{
   let srcDirPath = findSrcDir($dir, $class.package).fullPath();
   let classFullName = $class.package->packageToString() + '.' + $class.simpleName;
   if(!$base->containsClass($srcDirPath, $classFullName),
      {| $base->addClass($srcDirPath, $class)},
      {|
         let existing = $base->getClass($srcDirPath, $classFullName)->toOne();
         
         let imports = $existing.additionalImports->concatenate($class.additionalImports)->removeDuplicates();

         let superType = if($existing.superType->isEmpty(),
                            {|$class.superType},
                            |
                         if($class.superType->isEmpty(),
                            {|$existing.superType},
                            {|
                               assert($existing.superType == $class.superType, |'Cannot change superType from ' + $existing.superType->toOne()->typeToString() + ' to ' + $class.superType->toOne()->typeToString());
                               $existing.superType;
                            }
                         ));

         let interfaces = $existing.interfaces->concatenate($class.interfaces)->removeDuplicates();
         
         let newlyDefinedFields = $class.fields->filter({newField |
            let existingField = $existing.fields->filter({m | $m.name == $newField.name});
            assert($existingField->isEmpty() || (($existingField.type == $newField.type) && ($existingField.value == $newField.value) && ($existingField.valueCode == $newField.valueCode)), | 'Cannot merge field ' + $newField.name + ' in ' + $classFullName);
            $existingField->isEmpty();
         });
         let fields = $existing.fields->concatenate($newlyDefinedFields);
         
         let newlyDefinedMethods = $class.methods->filter({newMethod|
            let existingMethod = $existing.methods->filter({m| $m.name == $newMethod.name && $m.parameters.type == $newMethod.parameters.type});
            assert($existingMethod->isEmpty() || ($existingMethod.body == $newMethod.body && $existingMethod.bodyCode == $newMethod.bodyCode), {| $existingMethod.bodyCode->match([
                                                                                                                                                 c:Code[1] | println($c->codeToString()),
                                                                                                                                                 x:Code[0] | println($existingMethod.body->toOne())
                                                                                                                                               ]);
                                                                                                                                               $newMethod.bodyCode->match([
                                                                                                                                                 c:Code[1] | println($c->codeToString()),
                                                                                                                                                 x:Code[0] | println($newMethod.body->toOne())
                                                                                                                                               ]);
                                                                                                                                              'Cannot merge implementations of ' + $newMethod->methodSignature() + ' in ' + $classFullName;});
            $existingMethod->isEmpty();
         });
         let methods = $existing.methods->concatenate($newlyDefinedMethods);

         $base->replaceClass(^$existing(additionalImports=$imports, superType=$superType, interfaces=$interfaces, fields=$fields, methods=$methods));
      }
   );
}

function <<access.private>> meta::external::language::java::factory::project::findSrcDir(dir: ProjectDirectory[1], pkg: meta::external::language::java::metamodel::Package[1]): ProjectDirectory[1]
{
   assert($dir.name == $pkg.name);
   $pkg.parent->match([
      p0: meta::external::language::java::metamodel::Package[0] | $dir.parent->toOne(),
      p : meta::external::language::java::metamodel::Package[1] | findSrcDir($dir.parent->toOne(), $p)
   ]);
}

function <<access.private>> meta::external::language::java::factory::project::addToProjectDirectory(dir: ProjectDirectory[1], class: meta::external::language::java::metamodel::Class[1]): ProjectDirectory[1]
{
   let dirNames = $class.package->packageToDirectoryNames();
   $dir->ensurePathAndDo($dirNames, d|^$d(classes=$d.classes->concatenate($class)->sortBy(c|$c.simpleName)));
}

function <<access.private>> meta::external::language::java::factory::project::addToProjectDirectory(dir: ProjectDirectory[1], file:File[1]): ProjectDirectory[1]
{
   assert(!$dir.files->exists(f| $f.name == $file.name), |$dir.fullPath() + ' already contains a file named ' + $file.name);
   ^$dir(files=$dir.files->concatenate($file)->sortBy(f|$f.name));
}

function <<access.private>> meta::external::language::java::factory::project::replaceInProjectDirectory(dir: ProjectDirectory[1], class: meta::external::language::java::metamodel::Class[1]): ProjectDirectory[1]
{
   let dirNames = $class.package->packageToDirectoryNames();
   $dir->ensurePathAndDo($dirNames, d|^$d(classes=$d.classes->filter(c|$c.simpleName != $class.simpleName)->concatenate($class)->sortBy(c|$c.simpleName)));
}

function <<access.private>> meta::external::language::java::factory::project::ensurePathAndDo(dir: ProjectDirectory[1], dirNames: String[*], action: Function<{ProjectDirectory[1]->ProjectDirectory[1]}>[1]): ProjectDirectory[1]
{
   let nextName = $dirNames->at(0);
   let tail     = $dirNames->tail();

   let nextDir = $dir.subdirectories->filter(sd|$sd.name == $nextName)->match([
      d0: ProjectDirectory[0] | ^ProjectDirectory(name=$nextName, parent=$dir),
      d : ProjectDirectory[1] | $d,
      ds: ProjectDirectory[*] | fail('Unexpectedly found duplicate dir: ' + $ds.name->makeString('[', ',' ,']')); $ds->at(0);
   ]);

   let newNextDir = $tail->match([
      n : String[0] | $action->eval($nextDir),
      ns: String[*] | $nextDir->ensurePathAndDo($ns, $action)
   ]);

   let newSubdirs = $dir.subdirectories->filter(sd|$sd.name != $nextName)->concatenate($newNextDir)->sortBy(d|$d.name);
   ^$dir(subdirectories=$newSubdirs);
}

function <<access.private>> meta::external::language::java::factory::project::packageToDirectoryNames(pkg: meta::external::language::java::metamodel::Package[1]): String[*]
{
   if($pkg.parent->isEmpty(), |[], |$pkg.parent->toOne()->packageToDirectoryNames())
      ->concatenate([$pkg.name]);
}
