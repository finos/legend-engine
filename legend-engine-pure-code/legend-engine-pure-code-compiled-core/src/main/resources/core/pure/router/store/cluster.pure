// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mutation::*;
import meta::pure::router::metamodel::*;
import meta::pure::mapping::*;
import meta::pure::mapping::xStore::*;
import meta::pure::metamodel::path::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::router::analytics::*;
import meta::pure::router::clustering::*;
import meta::pure::router::metamodel::clustering::*;
import meta::pure::router::platform::metamodel::clustering::*;
import meta::pure::router::printer::*;
import meta::pure::router::store::clustering::*;
import meta::pure::router::store::metamodel::*;
import meta::pure::router::store::metamodel::clustering::*;
import meta::pure::router::utils::*;
import meta::pure::runtime::*;
import meta::pure::store::*;

Class meta::pure::router::clustering::AnalyticsDecision
{
   targetStoreId : String[1];
   replacedSets  : Pair<SetImplementation, SetImplementation>[*];
   modifiedSets  : Pair<SetImplementation, SetImplementation>[*];
}

Class meta::pure::router::clustering::CrossSetImplementation extends InstanceSetImplementation
{
   targetStore : Store[1];
   varName     : String[1];
}

Class meta::pure::router::clustering::CrossSetImplementationPropertyMapping extends PropertyMapping
{
   sourcePropertyMapping: PropertyMapping[1];
}

Class meta::pure::router::clustering::CrossSetImplementationPrimtivePropertyMapping extends CrossSetImplementationPropertyMapping
{
   propertyPlaceHolder: String[1];
}

Class meta::pure::router::clustering::CrossSetImplementationComplexPropertyMapping extends CrossSetImplementationPropertyMapping
{
   crossExperssionPropertyPairs: Pair<Property<Nil,Any|*>, Property<Nil,Any|*>>[*];
}

Class meta::pure::router::clustering::CrossSetImplementationReverseComplexPropertyMapping extends CrossSetImplementationComplexPropertyMapping
{
   targetSet: SetImplementation[1];
}

Class  meta::pure::router::clustering::ClusterResponse
{
   cluster:ValueSpecification[1];
   letFunctions:ClusteredValueSpecification[*];
   executableSetOperations: Pair<SetImplementation, StoreMappingClusteredValueSpecification>[*];
}

function meta::pure::router::doCluster(enrichedExpression:StoreMappingRoutedValueSpecification[1], mapping:Mapping[1], runtime: Runtime[1], openVariables:Map<String, List<Any>>[1], exeCtx: ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):ClusteredValueSpecification[*]
{
   let clusterResult = $enrichedExpression->cluster($mapping, $runtime, $openVariables, $exeCtx, $extensions, $debug);
   if($clusterResult.cluster->instanceOf(ClusteredValueSpecification),
      | $clusterResult.letFunctions->concatenate($clusterResult.cluster->cast(@ClusteredValueSpecification)),
      | ^PlatformClusteredValueSpecification(
          genericType  = $clusterResult.cluster.genericType,
          multiplicity = $clusterResult.cluster.multiplicity,
          openVars = $openVariables,
          exeCtx = $exeCtx,
          val = $clusterResult.cluster,
          executable = true
        ));
}

function meta::pure::router::clustering::cluster(v:ValueSpecification[1], mapping:Mapping[1], runtime: Runtime[1], openVariables:Map<String, List<Any>>[1], exeCtx:ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):ClusterResponse[1]
{
   if($exeCtx->instanceOf(AnalyticsExecutionContext) && ($exeCtx->cast(@AnalyticsExecutionContext).useAnalytics == true),
      |  let allPropertyAccesses = meta::pure::router::analytics::getAllPropertyAccesses($v, $mapping, $extensions);
         let crossPropertyAccesses = $allPropertyAccesses->meta::pure::router::analytics::filterCrossPropertyAccesses();
         if($crossPropertyAccesses->size() == 0,
            | cluster($v, $mapping, $openVariables, $exeCtx, 0, $debug, [], $extensions),
            | let tgtStores = $crossPropertyAccesses->map(ac | let func = $exeCtx->cast(@AnalyticsExecutionContext).toFlowSetFunction;
                                                               let expr = $func.expressionSequence->evaluateAndDeactivate()->toOne();
                                                               let y = $expr->reactivate(newMap($func->openVariableValues()->keyValues()->concatenate(pair($func->functionType().parameters->evaluateAndDeactivate().name->toOne(), list($ac)))));
                                                               if($y == $ac.sourceSetId, |$ac.targetStore, |$ac.sourceStore););
      
              assert($tgtStores->removeDuplicates()->size() == 1, 'More than 1 data flow target stores, Not supported!');
                
              let tgtStore = $tgtStores->removeDuplicates()->toOne();
              let setIdStoreIdPairs = $crossPropertyAccesses->map(ac | [pair($ac.sourceSetId, $ac.sourceStore), pair($ac.targetSetId, $ac.targetStore)])->removeDuplicates();
              let targetStorePairs = $setIdStoreIdPairs->filter(x | $x.second == $tgtStore);
              let otherStorePairs = $setIdStoreIdPairs->filter(x | $x.second != $tgtStore);
      
              let replacedSets = $otherStorePairs->map(p |
                 let setId = $p.first;
                 let storeId = $p.second;
                 $mapping->classMappingById($setId)->toOne()->createCrossSetImplementation($mapping, $mapping->classMappingById($targetStorePairs.first->at(0))->toOne()->meta::pure::router::routing::getStoreFromSet($mapping, $extensions), $setId + '_gen_replaced_' +  toString($otherStorePairs->indexOf($p)), $crossPropertyAccesses->filter(x | $x.sourceSetId == $setId)->removeDuplicates(), $crossPropertyAccesses->filter(x | $x.targetSetId == $setId)->removeDuplicates(), $allPropertyAccesses->filter(x | $x.sourceSetId == $setId));
              );
                
              let modifiedSets = $targetStorePairs->map(p |
                 let setId = $p.first;
                 let storeId = $p.second;
                 let crossAccesses = $crossPropertyAccesses->filter(x | $x.sourceSetId == $setId)->removeDuplicatesBy({a|list([$a.property, $a.sourceSetId, $a.sourceStore, $a.targetSetId, $a.targetStore])});
                 if($crossAccesses->isNotEmpty(),
                    | let set = $mapping->classMappingById($setId)->toOne()->cast(@InstanceSetImplementation);
                      let newSetId = $set.id + '_gen_modified_target_' +  toString($targetStorePairs->indexOf($p));
                      let allPropertyMappings = $set->allPropertyMappings();
                      let nonReplacedPropMappings = $allPropertyMappings->filter(pm | !$crossAccesses->exists(ca | ($ca.property == $pm.property) && ($ca.sourceSetId == $pm.sourceSetImplementationId) && ($ca.targetSetId == $pm.targetSetImplementationId)))->map(pm | ^$pm(sourceSetImplementationId = $newSetId));
                      let replacedPropertyMappings = $crossAccesses->map(ca |
                         let newTargetSet = $replacedSets->filter(s | $s.first.id == $ca.targetSetId).second->toOne();
                         let crossMapping = $set->propertyMappingByPropertyNameAndTargetId($ca.property.name->toOne(), $ca.targetSetId)->toOne()->cast(@XStorePropertyMapping);
                         ^CrossSetImplementationReverseComplexPropertyMapping
                          (
                             property = $ca.property->cast(@Property<Nil,Any|*>), 
                             crossExperssionPropertyPairs = $crossMapping.crossExpression.expressionSequence->evaluateAndDeactivate()->at(0)->propertyPairsInMultiEqual(),
                             sourceSetImplementationId = $newSetId, 
                             targetSetImplementationId = $newTargetSet.id,
                             targetSet = $newTargetSet,
                             sourcePropertyMapping = $crossMapping
                          );
                      );
                      let newPropMappings = $nonReplacedPropMappings->concatenate($replacedPropertyMappings);
                      let newSet = ^$set(superSetImplementationId='', id=$newSetId, propertyMappings=[]);
                      let newPropMappingsWithOwner = $newPropMappings->map(pm | ^$pm(owner=$newSet));
                      $newSet->mutateAdd('propertyMappings', $newPropMappingsWithOwner);
                      pair($set, $newSet);,
                    | [] 
                 );
              );
                
              let otherStoreSets = $replacedSets.first;
              let finalCluster = cluster($v, $mapping, $openVariables, $exeCtx, 0, $debug, ^AnalyticsDecision(replacedSets=$replacedSets, modifiedSets=$modifiedSets, targetStoreId=$tgtStore), $extensions);
                  
              let executables = $finalCluster.executableSetOperations;
              let createdLetFns = $otherStoreSets->cast(@InstanceSetImplementation)->map(os |
                 let execs = $executables->filter(e | $e.first.id == $os.id);
                 let pre_cls = if($execs->size() == 1, | $execs->at(0).second, | $os->clusteredGetAll($mapping, $runtime, $exeCtx, $extensions));
                                                       
                 let newSetId = $os.id + '_gen_modified_flowing_' +  toString($otherStoreSets->indexOf($os));
                 let propertiesAccessed = $allPropertyAccesses->filter(s | $s.sourceSetId == $os.id).property;
                 let propertiesInSourceCrossExpressions = $crossPropertyAccesses->filter(s | $s.sourceSetId == $os.id)->map(cross | $os->cast(@InstanceSetImplementation)->propertyMappingByPropertyNameAndTargetId($cross.property.name->toOne(), $cross.targetSetId)->toOne()->cast(@XStorePropertyMapping).crossExpression.expressionSequence->evaluateAndDeactivate()->at(0)->propertyPairsInMultiEqual().first);
                 let propertiesInTargetCrossExpressions = $crossPropertyAccesses->filter(s | $s.targetSetId == $os.id)->map(cross | $mapping->classMappingById($cross.sourceSetId)->cast(@InstanceSetImplementation)->toOne()->propertyMappingByPropertyNameAndTargetId($cross.property.name->toOne(), $cross.targetSetId)->toOne()->cast(@XStorePropertyMapping).crossExpression.expressionSequence->evaluateAndDeactivate()->at(0)->propertyPairsInMultiEqual().second);
                 let requiredSimpleProperties = $propertiesAccessed->concatenate($propertiesInSourceCrossExpressions)->concatenate($propertiesInTargetCrossExpressions)->removeDuplicates();
                 
                 let allPropertyMappings = $os->allPropertyMappings()->filter(pm | $requiredSimpleProperties->contains($pm.property))->map(pm | ^$pm(sourceSetImplementationId = $newSetId));
                 let newSet = ^$os(superSetImplementationId='', id=$newSetId, propertyMappings=[]);
                 let newPropMappingsWithOwner = $allPropertyMappings->map(pm | ^$pm(owner=$newSet));
                 $newSet->mutateAdd('propertyMappings', $newPropMappingsWithOwner);

                 let cls = $pre_cls->doReplacementWithPairsForVS(pair($os, $newSet))->cast(@StoreMappingClusteredValueSpecification);

                 let newCls = ^StoreMappingClusteredValueSpecification
                              (
                                 genericType = $cls.genericType,
                                 multiplicity = $cls.multiplicity,
                                 s = $cls.s,
                                 store = $cls.store,
                                 val = $cls.val,
                                 openVars = $cls.openVars,
                                 runtime =  $cls.runtime,
                                 mapping = $cls.mapping,
                                 exeCtx = $cls.exeCtx,
                                 executable = $cls.executable
                              );
                 let fn = ^SimpleFunctionExpression
                           (
                              func = letFunction_String_1__T_m__T_m_,
                              functionName = 'letFunction',
                              genericType = $cls.genericType,
                              multiplicity = $cls.multiplicity,
                              importGroup = system::imports::coreImport,
                              parametersValues = [
                                 ^InstanceValue(values= $os.id + '_gen_replaced_' +  toString($otherStoreSets->indexOf($os)), genericType=^GenericType(rawType=String), multiplicity=PureOne),
                                 $newCls
                              ]
                           );
                 ^PlatformClusteredValueSpecification
                 (
                   genericType  = $cls.genericType,
                   multiplicity = $cls.multiplicity,
                   openVars     = $openVariables,
                   exeCtx       = $exeCtx,
                   val          = $fn,
                   executable   = true
                 );
              );
              ^$finalCluster(letFunctions = $createdLetFns->concatenate($finalCluster.letFunctions));
         );,
      |  cluster($v, $mapping, $openVariables, $exeCtx, 0, $debug, [], $extensions);
   );     
}

function meta::pure::router::clustering::specializedFunctionExpressionClustering() : Pair<Function<{FunctionExpression[1]->Boolean[1]}>, Function<{FunctionExpression[1], Mapping[1], Map<String, List<Any>>[1], ExecutionContext[1], Integer[1], DebugContext[1], AnalyticsDecision[0..1], meta::pure::extension::Extension[*]->ClusterResponse[1]}>>[*]
{
  [
    pair(fe:FunctionExpression[1] | $fe.func->in(mutationFunctions()),
        {f:FunctionExpression[1], mapping:Mapping[1], openVariables:Map<String, List<Any>>[1], exeCtx:ExecutionContext[1], depth:Integer[1], debug:DebugContext[1], analyticsDecision: AnalyticsDecision[0..1], extensions:meta::pure::extension::Extension[*] |
          let childClustersResponse = $f.parametersValues->evaluateAndDeactivate()->map(v | $v->cluster($mapping, $openVariables, $exeCtx,  $depth+1, $debug, $analyticsDecision, $extensions));
          let params = $childClustersResponse.cluster->evaluateAndDeactivate();

          let runtime = $f.parametersValues->at(3)->cast(@InstanceValue).values->cast(@Runtime)->toOne();
          let store = $runtime.connections.element->cast(@meta::pure::store::Store)->toOne();
          ^ClusterResponse(
            cluster = ^StoreMappingClusteredValueSpecification(
                        openVars = $openVariables,
                        multiplicity = $f.multiplicity,
                        store = $store,
                        runtime = $runtime,
                        s = $extensions->meta::pure::extension::storeContractFromStore($store),
                        genericType = $f.genericType,
                        mapping = $mapping,
                        val = ^$f(parametersValues = $params->evaluateAndDeactivate()->map(p|$p->match([c:StoreMappingClusteredValueSpecification[1]|$c.val;, a:ValueSpecification[1]|$a]))),
                        executable = $params->evaluateAndDeactivate()->map(p|$p->match([c:StoreMappingClusteredValueSpecification[1]|$c.executable;, a:ValueSpecification[1]|[]]))->concatenate(false)->toOneMany()->or()));
        }
    ),
    pair(fe:FunctionExpression[1] | $fe.func->in([agg_FunctionDefinition_1__FunctionDefinition_1__AggregateValue_1_,
                                                       agg_String_1__FunctionDefinition_1__FunctionDefinition_1__AggregateValue_1_,
                                                       col_Function_1__String_1__BasicColumnSpecification_1_,
                                                       col_Function_1__String_1__String_1__BasicColumnSpecification_1_]),
        {f:FunctionExpression[1], mapping:Mapping[1], openVariables:Map<String, List<Any>>[1], exeCtx:ExecutionContext[1], depth:Integer[1], debug:DebugContext[1], analyticsDecision: AnalyticsDecision[0..1], extensions:meta::pure::extension::Extension[*] |
          ^ClusterResponse(cluster=$f)
        }
    )
  ]
}


function meta::pure::router::clustering::cluster(v:ValueSpecification[1], mapping:Mapping[1], openVariables:Map<String, List<Any>>[1], exeCtx:ExecutionContext[1], depth:Integer[1], debug:DebugContext[1], analyticsDecision: AnalyticsDecision[0..1], extensions:meta::pure::extension::Extension[*]):ClusterResponse[1]
{
  cluster($v, $mapping, $openVariables, $exeCtx, [], $depth, $debug, $analyticsDecision, $extensions)
}

function meta::pure::router::clustering::cluster(v:ValueSpecification[1], mapping:Mapping[1], openVariables:Map<String, List<Any>>[1], exeCtx:ExecutionContext[1], paramIndex: Integer[0..1], depth:Integer[1], debug:DebugContext[1], analyticsDecision: AnalyticsDecision[0..1], extensions:meta::pure::extension::Extension[*]):ClusterResponse[1]
{
   $v->match([f:FunctionExpression[1]|
                                      let specializedFunctionProcessor = specializedFunctionExpressionClustering()->filter(spec | $spec.first->eval($f->evaluateAndDeactivate())).second;
                                      if($specializedFunctionProcessor->isNotEmpty(),
                                       | assert($specializedFunctionProcessor->size() == 1, | 'Only one match is authorized for specializedFunctionProcessor');
                                         $specializedFunctionProcessor->toOne()->evaluate([list($f->evaluateAndDeactivate()), list($mapping), list($openVariables), list($exeCtx), list($depth), list($debug), list($analyticsDecision), list($extensions)])->toOne()->cast(@ClusterResponse);,
                                       | let childClustersResponse = $f.parametersValues->evaluateAndDeactivate()->map(v|if($f.func->elementToPath()->equal('meta::pure::tds::concatenate_TabularDataSet_1__TabularDataSet_1__TabularDataSet_1_'),
                                                                                                                        |$v->cluster($mapping, $openVariables, $exeCtx,indexOf($f.parametersValues,$v), $depth+1, $debug, $analyticsDecision, $extensions),
                                                                                                                        |$v->cluster($mapping, $openVariables, $exeCtx, $paramIndex,$depth+1, $debug, $analyticsDecision, $extensions)));
                                         let pre_params = $childClustersResponse.cluster->evaluateAndDeactivate();
                                         let paramsExecutablePairs = if($analyticsDecision->isNotEmpty(),
                                            | let crossPropertyAccesses = meta::pure::router::analytics::getAllCrossPropertyAccesses($f, $mapping, $extensions);
                                              if($crossPropertyAccesses->isNotEmpty(), 
                                                 | let newExecutables = $pre_params->map(p | $p->match([
                                                      c:StoreMappingClusteredValueSpecification[1] | if($c.executable && $c.val->instanceOf(StoreMappingRoutedValueSpecification) && $c.val->cast(@StoreMappingRoutedValueSpecification).sets->size() == 1 && $analyticsDecision.replacedSets.first.id->contains($c.val->cast(@StoreMappingRoutedValueSpecification).sets.id->toOne()),
                                                                                            | pair($c.val->cast(@StoreMappingRoutedValueSpecification).sets->toOne(), $c);,
                                                                                            | []),
                                                      v:ValueSpecification[1] | []
                                                   ]));
                                                   let rewrittenParams = $f.parametersValues->evaluateAndDeactivate()->map(p |  $p->doReplacementWithPairsForVS($analyticsDecision.replacedSets->concatenate($analyticsDecision.modifiedSets))->cluster($mapping, $openVariables, $exeCtx,  $depth+1, $debug, [], $extensions)).cluster->evaluateAndDeactivate();
                                                   pair(list($rewrittenParams), list($newExecutables));, 
                                                 | pair(list($pre_params), list([]));
                                              );,
                                            | pair(list($pre_params), list([]));  
                                         );
                                         let params = $paramsExecutablePairs.first.values;
                                         let executables = $paramsExecutablePairs.second.values->cast(@Pair<SetImplementation, StoreMappingClusteredValueSpecification>);
                                         let letFunctions = $childClustersResponse.letFunctions;
                                         let childExecutables = $childClustersResponse.executableSetOperations;

                                         let unique = getDistinctClusterVSByStore($params, $extensions);
                                         if ($unique->size() == 1 && $unique->toOne()->instanceOf(StoreMappingClusteredValueSpecification) && ($f.func->instanceOf(Property) || $f.func->instanceOf(QualifiedProperty) || $unique->at(0)->cast(@StoreMappingClusteredValueSpecification).s.supports->toOne()->eval($f->evaluateAndDeactivate())),
                                          | let one = $unique->toOne();
                                            print(if($debug.debug,|$f->evaluateAndDeactivate()->asString()->debug($debug.space+'Func Expression(merge): '),|''));
                                            let res =^$one(
                                                      genericType  = $f.genericType,
                                                      multiplicity = $f.multiplicity,
                                                      val = ^$f(parametersValues = $params->evaluateAndDeactivate()->map(p|$p->match([c:StoreMappingClusteredValueSpecification[1]|$c.val;, a:ValueSpecification[1]|$a]))),
                                                      executable = $params->evaluateAndDeactivate()->map(p|$p->match([c:StoreMappingClusteredValueSpecification[1]|$c.executable;, a:ValueSpecification[1]|[]]))->concatenate(false)->toOneMany()->or() || $f.functionName == 'getAll'
                                            );
                                            print(if($debug.debug,|$res->evaluateAndDeactivate()->asString()->debug($debug.space+'~> '),|''));
                                            ^ClusterResponse(cluster=$res,letFunctions=$letFunctions,executableSetOperations=$executables->concatenate($childExecutables));,
                                          |  print(if($debug.debug,|$f->evaluateAndDeactivate()->asString()->debug($debug.space+'Func Expression(non unique: '+$unique->size()->toString()+'): '),|''));
                                             let k = if ($unique->size() == 0,
                                                | ^ClusterResponse(cluster=^$f(parametersValues = $params)),
                                                | let clustersToReplace = clusteredVSToBeReplaced($params);
                                                  if($clustersToReplace->isNotEmpty(),
                                                      | let updatedParams = $params->map(p| if($p->in($clustersToReplace),
                                                                                              | let varName = $p-> meta::pure::router::clustering::createVarExpName($params,$depth,$paramIndex);
                                                                                                meta::pure::router::clustering::createVariableExpression($p,$varName);,
                                                                                              | $p)->cast(@ValueSpecification));
    
                                                        print(if($debug.debug,| $updatedParams->map(l|$l->evaluateAndDeactivate()->asString()->debug($debug.space+' '))->joinStrings('  ')->debug($debug.space+'updated Function Parameters:'),|''));
                                                        let updatedUnique = getDistinctClusterVSByStore($updatedParams, $extensions);
                                                        if($updatedUnique->size()==1,
                                                            | let newLetFns = $params->map(p|if($p->in($clustersToReplace) ,
                                                                                                 | let varName    = $p->meta::pure::router::clustering::createVarExpName($params,$depth,$paramIndex);
                                                                                                   let rhsCluster = $p->cast(@StoreMappingClusteredValueSpecification);
                                                                                                   let letFxn     = createLetFunction($rhsCluster.val->byPassValueSpecificationWrapper()->cast(@FunctionExpression), $varName, $depth, $rhsCluster, $extensions)->evaluateAndDeactivate();
                                                                                                   ^PlatformClusteredValueSpecification(
                                                                                                      genericType  = $letFxn.genericType,
                                                                                                      multiplicity = $letFxn.multiplicity,
                                                                                                      openVars     = $openVariables,
                                                                                                      exeCtx       = $exeCtx,
                                                                                                      val          = $letFxn,
                                                                                                      executable   = true
                                                                                                    );,
                                                                                                 | [];));
    
                                                              print(if($debug.debug, |$newLetFns->map(l|$l->evaluateAndDeactivate()->asString()->debug($debug.space+'Generated Lets:'))->joinStrings(''), |''));
                                                              let updatedOne = $updatedUnique->toOne();
                                                              let updatedCluster = ^$updatedOne(
                                                                                      genericType  = $f.genericType,
                                                                                      multiplicity = $f.multiplicity,
                                                                                      val = ^$f(parametersValues = $updatedParams->evaluateAndDeactivate()->map(p|$p->match([c:StoreMappingClusteredValueSpecification[1]|$c.val;, a:ValueSpecification[1]|$a])))
                                                                                    )->cast(@StoreMappingClusteredValueSpecification);
                                                              ^ClusterResponse(cluster=$updatedCluster,letFunctions= $letFunctions->concatenate($newLetFns),executableSetOperations=$executables->concatenate($childExecutables));,
                                                            | ^ClusterResponse(cluster=^PlatformClusteredValueSpecification(
                                                                                          genericType  = $f.genericType,
                                                                                          multiplicity = $f.multiplicity,
                                                                                          openVars     = $openVariables,
                                                                                          exeCtx       = $exeCtx,
                                                                                          val          = ^$f(parametersValues = $params->map(p|if($p->instanceOf(StoreMappingClusteredValueSpecification) && $p->cast(@StoreMappingClusteredValueSpecification).val->isOneFunction(),
                                                                                                                                                  |$p->cast(@StoreMappingClusteredValueSpecification).val,
                                                                                                                                                  |$p))),
                                                                                          executable=true
                                                                                        ));
    
                                                          );,
                                                      | ^ClusterResponse(cluster=^PlatformClusteredValueSpecification(
                                                                                    genericType  = $f.genericType,
                                                                                    multiplicity = $f.multiplicity,
                                                                                    openVars     = $openVariables,
                                                                                    exeCtx       = $exeCtx,
                                                                                    val          = ^$f(parametersValues = $params->map(p|if($p->instanceOf(StoreMappingClusteredValueSpecification) && $p->cast(@StoreMappingClusteredValueSpecification).val->isOneFunction(),
                                                                                                                                            |$p->cast(@StoreMappingClusteredValueSpecification).val,
                                                                                                                                            |$p
                                                                                                                                          ))),
                                                                                    executable = true
                                                                                 ),
                                                                         letFunctions = $letFunctions,
                                                                         executableSetOperations = $executables->concatenate($childExecutables));
                                                   );
                                                 );
                                             print(if($debug.debug,|$k.cluster->last()->evaluateAndDeactivate()->cast(@ValueSpecification)->toOne()->asString()->debug($debug.space+'~> '),|''));
                                             $k;
                                       ););,

               r:StoreMappingRoutedValueSpecification[1]|
                                              print(if($debug.debug,|$r->evaluateAndDeactivate()->asString()->debug($debug.space+'Routed: '),|''));
                                              let crossPropertyAccesses = $analyticsDecision->isEmpty()->if(|[], |meta::pure::router::analytics::getAllCrossPropertyAccesses($r, $r.mapping, $extensions));
                                              let clusterResponse       = $r.value->cluster($r.mapping, $openVariables, $r.executionContext,$depth+1, ^$debug(space = $debug.space+'   '), $analyticsDecision, $extensions);
                                              let result                = $clusterResponse.cluster->evaluateAndDeactivate();
                                              let pre_y = $result->match([
                                                                           c: ClusteredValueSpecification[1]|^$c(val = ^$r(value = $c.val)),
                                                                           a: Any[1]| if($r.sets->isEmpty(),                                           // This check is needed for expressions (like : let x = 1->from($mapping, $runtime)) where there are no sets found
                                                                                         | $clusterResponse.cluster,
                                                                                         | $r->meta::pure::router::clustering::getClusterVSFromSets($r.sets, $openVariables, $mapping, $extensions));
                                                                         ]
                                                                    );
                                              let y = if($crossPropertyAccesses->isNotEmpty(),
                                                        | $pre_y->doReplacementWithPairsForVS($analyticsDecision.replacedSets->concatenate($analyticsDecision.modifiedSets)),
                                                        | $pre_y
                                                      );
                                              print(if($debug.debug,|$y->evaluateAndDeactivate()->asString()->debug($debug.space+'~> '),|''));
                                              ^ClusterResponse(cluster=$y, letFunctions= $clusterResponse.letFunctions, executableSetOperations= $clusterResponse.executableSetOperations);,
               i:InstanceValue[1]| if ($i->isOneFunctionDefinition(),
                                        | let f = $i.values->at(0)->cast(@FunctionDefinition<Any>)->evaluateAndDeactivate();
                                          let clusterResponses = $f.expressionSequence->evaluateAndDeactivate()->map(v|print(if($debug.debug,|'\n'+$v->asString()->debug($debug.space+'Processing: '),|''));
                                                                                                                       $v->cluster($mapping, $openVariables, $exeCtx, $depth+1,^$debug(space = $debug.space+'  '), $analyticsDecision, $extensions););
                                          let expressions      = $clusterResponses.cluster;
                                          let unique           = $expressions->filter(p|$p->instanceOf(StoreMappingClusteredValueSpecification))->cast(@StoreMappingClusteredValueSpecification)->removeDuplicatesBy(a | $a.store);
                                          if($unique->size() == 0,
                                             | ^ClusterResponse(cluster=^$i(values=^$f(expressionSequence = $expressions->toOneMany())),letFunctions = $clusterResponses.letFunctions, executableSetOperations= $clusterResponses.executableSetOperations),
                                             | if($unique->size() == 1,
                                                  | let one = $unique->toOne();
                                                    print(if($debug.debug, |$i->evaluateAndDeactivate()->asString()->debug($debug.space+'Func: '),|''));
                                                    let res = ^$one(
                                                                genericType  = $i.genericType,
                                                                multiplicity = $i.multiplicity,
                                                                val = ^$i(values=^$f(expressionSequence = $expressions->evaluateAndDeactivate()->map(p|$p->match([c:StoreMappingClusteredValueSpecification[1]|$c.val;, a:ValueSpecification[1]|$a]))->toOneMany()))
                                                              );
                                                    print(if($debug.debug, |$res->evaluateAndDeactivate()->asString()->debug($debug.space+'~> '),|''));
                                                    ^ClusterResponse(cluster=$res, letFunctions = $clusterResponses.letFunctions, executableSetOperations= $clusterResponses.executableSetOperations);,
                                                  | print(if($debug.debug, |$i->evaluateAndDeactivate()->asString()->debug($debug.space+'Func: '), |''));
                                                    let k = ^PlatformClusteredValueSpecification(
                                                                genericType = $i.genericType,
                                                                multiplicity = $i.multiplicity,
                                                                val = ^$i(values=^$f(expressionSequence = $expressions->toOneMany())),
                                                                openVars = $openVariables,
                                                                exeCtx = $exeCtx,
                                                                executable = true
                                                            );
                                                    print(if($debug.debug, |$k->evaluateAndDeactivate()->asString()->debug($debug.space+'~> '),|''));
                                                    ^ClusterResponse(cluster= $k, letFunctions = $clusterResponses.letFunctions, executableSetOperations= $clusterResponses.executableSetOperations);
                                               )
                                            );,
                                        | print(if($debug.debug,|$i->asString()->debug($debug.space+'Constant: '),|''));
                                          let potentialClusterResponses = $i.values->evaluateAndDeactivate()->map(m|if($m->instanceOf(ValueSpecification),
                                                                                                                       | $m->cast(@ValueSpecification)->cluster($mapping, $openVariables, $exeCtx, $depth+1, ^$debug(space = $debug.space+'  '), $analyticsDecision, $extensions),
                                                                                                                       | $m->match([
                                                                                                                            g : meta::pure::graphFetch::routing::RoutedGraphFetchTree[1] | $g->meta::pure::graphFetch::routing::clusterRoutedGraphFetchTree([], $mapping, [], $openVariables, $exeCtx, $extensions, $debug),
                                                                                                                            a : Any[1] | $a
                                                                                                                         ])));
                                          let values       = $potentialClusterResponses->map(r|if($r->instanceOf(ClusterResponse),| $r->cast(@ClusterResponse).cluster,|$r));
                                          let letFunctions = $potentialClusterResponses->map(r|if($r->instanceOf(ClusterResponse),| $r->cast(@ClusterResponse).letFunctions,|[]));
                                          let executables  = $potentialClusterResponses->map(r|if($r->instanceOf(ClusterResponse),| $r->cast(@ClusterResponse).executableSetOperations,|[]));

                                          let unique       = $values->filter(p|$p->instanceOf(StoreMappingClusteredValueSpecification))->cast(@StoreMappingClusteredValueSpecification)->removeDuplicatesBy(a | $a.store->elementToPath());
                                          let res          = if($unique->size() == 1 && $values->filter(p|$p->instanceOf(PlatformClusteredValueSpecification))->isEmpty(),
                                                                | let one = $unique->toOne();
                                                                  ^$one(
                                                                    genericType = $i.genericType,
                                                                    multiplicity = $i.multiplicity,
                                                                    val = ^$i(values = $values->evaluateAndDeactivate()->map(p|$p->match([c:StoreMappingClusteredValueSpecification[1]|$c.val;, a:Any[1]|$a])))
                                                                  );,
                                                                | ^$i(values = $values);
                                                             );
                                          print(if($debug.debug,|$res->asString()->debug($debug.space+'~> '),|''));
                                          ^ClusterResponse(cluster=$res, letFunctions = $letFunctions, executableSetOperations=$executables);
                                  );,
               r:FunctionRoutedValueSpecification[1]|let clusterResponse = $r.value->cluster($mapping, $openVariables, $exeCtx,$depth+1,^$debug(space = $debug.space+'  '), $analyticsDecision, $extensions);
                                                     let nc              = $clusterResponse.cluster->evaluateAndDeactivate();
                                                     ^ClusterResponse(cluster=$nc->match([nc:StoreMappingClusteredValueSpecification[1]|^$nc(val=^$r(value=$nc.val)), a:ValueSpecification[1]|$r]), letFunctions= $clusterResponse.letFunctions, executableSetOperations= $clusterResponse.executableSetOperations);,
               n:NoSetRoutedValueSpecification[1]| $n.value->cluster($mapping, $openVariables, $exeCtx, $depth, $debug, $analyticsDecision, $extensions), // TODO: cleanup needed
               v:VariableExpression[1]|print(if($debug.debug,|$v->asString()->debug($debug.space+'Var: '),|''));
                                       ^ClusterResponse(cluster=$v);,
               c:StoreMappingClusteredValueSpecification[1] | ^ClusterResponse(cluster = $c),
               t:TDSRoutedValueSpecification[1] | ^ClusterResponse(cluster = ^StoreMappingClusteredValueSpecification(
                                                                                genericType  = $t.genericType,
                                                                                multiplicity = $t.multiplicity,
                                                                                s = $extensions->meta::pure::extension::storeContractFromStore($t.store),
                                                                                store = $t.store,
                                                                                mapping = $t.mapping,
                                                                                runtime = $t.runtime,
                                                                                openVars = $openVariables,
                                                                                val = $t,
                                                                                exeCtx = $t.executionContext,
                                                                                executable = true
                                                                              )),
               e:ExtendedRoutedValueSpecification[1] | ^ClusterResponse(cluster=$e->clusterFunctionExpressions($openVariables, $exeCtx, $extensions, $debug)->toOne())
              
      ]
   )->cast(@ClusterResponse);
}

function meta::pure::router::clustering::getClusterVSFromSets(r:StoreMappingRoutedValueSpecification[1], setImpl:SetImplementation[*], openVariables:Map<String, List<Any>>[1], mapping:Mapping[1], extensions:meta::pure::extension::Extension[*]):StoreMappingClusteredValueSpecification[1]
{
  let res = $setImpl->toOne()->storeContractForSetImplementation($mapping, $extensions);
  buildCluster($r, $openVariables, $mapping, $res.first, $res.second, $extensions);
}

function meta::pure::router::clustering::storeContractForSetImplementation(setImpl:SetImplementation[1], mapping:Mapping[1], extensions:meta::pure::extension::Extension[*]):Pair<StoreContract, Store>[1]
{
  $setImpl->match([
      i: InstanceSetImplementation[1]|
         let storeContract = $extensions->meta::pure::extension::storeContractForSetImplementation($i->toOne());
         let store = $storeContract.resolveStoreFromSetImplementation->toOne()->eval($i);
         pair($storeContract, $mapping->resolveStore($store));,
      o: meta::pure::mapping::OperationSetImplementation[1]|
         let roots = $o->resolveInstanceSetImplementations();
         let storeContract = $roots->map(r|$extensions->meta::pure::extension::storeContractForSetImplementation($r))->removeDuplicates(x|$x.id,{a,b|$a==$b})->toOne();
         let store = $roots->map(r|$mapping->resolveStore($storeContract.resolveStoreFromSetImplementation->toOne()->eval($r)))->removeDuplicates(x|$x->elementToPath(),{a,b|$a==$b})->toOne();
         pair($storeContract, $mapping->resolveStore($store));
  ]);
}

function <<access.private>> meta::pure::router::clustering::buildCluster(r:StoreMappingRoutedValueSpecification[1], openVariables:Map<String, List<Any>>[1], mapping:Mapping[1], storeContract : StoreContract[1], store : Store[1], extensions:meta::pure::extension::Extension[*]):StoreMappingClusteredValueSpecification[1]
{
  ^StoreMappingClusteredValueSpecification(
    genericType  = $r.genericType,
    multiplicity = $r.multiplicity,
    s = $storeContract,
    store = $mapping->resolveStore($store),
    mapping = $r.mapping,
    runtime = $r.runtime,
    openVars = $openVariables,
    val = $r,
    exeCtx = $r.executionContext,
    executable = false
  )
}


function meta::pure::router::clustering::getDistinctClusterVSByStore(params:ValueSpecification[*], extensions:meta::pure::extension::Extension[*]):ClusteredValueSpecification[*]
{
   $params->meta::pure::router::clustering::getDistinctClusterVSByStore(false, $extensions);
}

function meta::pure::router::clustering::getDistinctClusterVSByStore(params:ValueSpecification[*], recurse:Boolean[1], extensions:meta::pure::extension::Extension[*]):ClusteredValueSpecification[*]
{
   let allClusters = if($recurse,
                        | $params->filter(p|$p->instanceOf(SimpleFunctionExpression))->fold({x, y | $x->cast(@SimpleFunctionExpression).parametersValues->getDistinctClusterVSByStore($recurse, $extensions)->concatenate($y->cast(@SimpleFunctionExpression).parametersValues->getDistinctClusterVSByStore($recurse, $extensions))},[]),
                        | []);
   
   let p_unique = $allClusters->concatenate($params)->filter(p|$p->instanceOf(ClusteredValueSpecification))->cast(@ClusteredValueSpecification)->removeDuplicates({x, y | ($x->instanceOf(PlatformClusteredValueSpecification) && $y->instanceOf(PlatformClusteredValueSpecification)) 
                                                                                                                                                                       || ($x->instanceOf(StoreMappingClusteredValueSpecification) && $y->instanceOf(StoreMappingClusteredValueSpecification) && areStoreMappingClustersCompatible($x->cast(@StoreMappingClusteredValueSpecification), $y->cast(@StoreMappingClusteredValueSpecification), $extensions))});
   let n_unique = if ($p_unique->size() > 1,|$p_unique->filter(p|!$p.val->isOneFunction()),|$p_unique);
   $n_unique;
}

function meta::pure::router::store::clustering::areStoreMappingClustersCompatible(cluster1:StoreMappingClusteredValueSpecification[1], cluster2:StoreMappingClusteredValueSpecification[1], extensions:meta::pure::extension::Extension[*]):Boolean[1]
{
   ($cluster1.store->elementToPath() == $cluster2.store->elementToPath()) && meta::pure::runtime::runtimeEquality($cluster1.runtime, $cluster2.runtime, $extensions) && ($cluster1.exeCtx == $cluster2.exeCtx);
}

function <<access.private>> meta::pure::router::clustering::createLetFunction(orginalFunction:FunctionExpression[1], varExpressionName:String[1], depth:Integer[1], parentCluster:StoreMappingClusteredValueSpecification[1], extensions:meta::pure::extension::Extension[*]):SimpleFunctionExpression[1]
{
   let varExp = ^InstanceValue(genericType  = ^GenericType(rawType= String),
                               multiplicity = PureOne,
                               values       = $varExpressionName);
   let newParams = $orginalFunction.parametersValues->map(p|if($p->willBeVarExp($orginalFunction, $extensions),| createVariableExpression($p,$orginalFunction,$depth+1),|$p ));
   let updatedFunction = ^$orginalFunction(parametersValues = $newParams);
   let updatedCluster = ^StoreMappingClusteredValueSpecification(
      genericType = $parentCluster.genericType,
      multiplicity = $parentCluster.multiplicity,
      s = $parentCluster.s,
      store = $parentCluster.store,
      val = $updatedFunction,
      openVars = $parentCluster.openVars,
      runtime =  $parentCluster.runtime,
      mapping = $parentCluster.mapping,
      exeCtx = $parentCluster.exeCtx,
      executable = $parentCluster.executable
   );
   ^SimpleFunctionExpression(func             = letFunction_String_1__T_m__T_m_,
                             functionName     = 'letFunction',
                             genericType      = $orginalFunction.genericType,
                             multiplicity     = $orginalFunction.multiplicity,
                             importGroup      = system::imports::coreImport,
                             parametersValues = [$varExp, $updatedCluster]
                          );
}


function <<access.private>> meta::pure::router::clustering::willBeVarExp(param:ValueSpecification[1], originalFn:FunctionExpression[1], extensions:meta::pure::extension::Extension[*]):Boolean[1]

{
   $param ->match( [ s:SimpleFunctionExpression[1] | if($s->getDistinctClusterVSByStore(true, $extensions)->size()>1,|true,|false),
                     c:StoreMappingClusteredValueSpecification[1]| $c->in($originalFn.parametersValues->clusteredVSToBeReplaced()),
                     a:Any[1]|false]);
}


function <<access.private>> meta::pure::router::clustering::clusteredVSToBeReplaced(allParams:ValueSpecification[*]):StoreMappingClusteredValueSpecification[*]
{
   let clusteredVSToBeReplaced = $allParams->filter(p|$p->instanceOf(StoreMappingClusteredValueSpecification))->cast(@StoreMappingClusteredValueSpecification)->filter(c|!$c.store->instanceOf( meta::pure::mapping::aggregationAware::AggregationAwareStore))->init();
   if($clusteredVSToBeReplaced->forAll(c | $c.val->byPassValueSpecificationWrapper()->instanceOf(FunctionExpression)
                                        && $c.val->byPassValueSpecificationWrapper()->cast(@FunctionExpression).func->functionReturnType().rawType->isNotEmpty()
                                        && $c.val->byPassValueSpecificationWrapper()->cast(@FunctionExpression).func->functionReturnType().rawType->toOne()->_subTypeOf(TabularDataSet)),
      | $clusteredVSToBeReplaced, 
      | []);
}


 function <<access.private>> meta::pure::router::clustering::createVarExpName(param:ValueSpecification[1],allParams:ValueSpecification[*],depth:Integer[1]):String[1]
{
  createVarExpName($param,$allParams,$depth,[]);
}

function <<access.private>> meta::pure::router::clustering::createVarExpName(param:ValueSpecification[1],allParams:ValueSpecification[*],depth:Integer[1],paramIndex:Integer[0..1]):String[1] 
{
  if($paramIndex->isNotEmpty(),
                                 |joinStrings(['tdsVar', $depth->toString(),'_', $allParams->indexOf($param)->toOne()->toString(),'_',$paramIndex->toOne()->toString()]),
                                 |joinStrings(['tdsVar', $depth->toString(),'_', $allParams->indexOf($param)->toOne()->toString()])
                                 );
}

 function <<access.private>> meta::pure::router::clustering::createVariableExpression(param:ValueSpecification[1],name:String[1]):VariableExpression[1]
{
 ^VariableExpression(genericType = $param.genericType,
                     multiplicity = $param.multiplicity,
                     name =$name
                     )
}


function <<access.private>> meta::pure::router::clustering::createVariableExpression(param:ValueSpecification[1],originalFn:FunctionExpression[1],depth:Integer[1]):VariableExpression[1]
{
 ^VariableExpression(genericType = $param.genericType,
                     multiplicity = $param.multiplicity,
                     name = createVarExpName($param,$originalFn,$depth)
                     )
}


function meta::pure::router::clustering::updateParameterValue(param:ValueSpecification[1], originalFn:SimpleFunctionExpression[1], depth:Integer[1], extensions:meta::pure::extension::Extension[*]):ValueSpecification[1]
{
    $param->match([s:SimpleFunctionExpression[1]| let siblingClusters = $originalFn->getDistinctClusterVSByStore(false, $extensions);
                                                  if($siblingClusters->isEmpty(),
                                                     |^$s(parametersValues = $s.parametersValues->map(p|$p->updateParameterValue($s,$depth+1, $extensions))),
                                                     |let childClusters = $s->getDistinctClusterVSByStore(true, $extensions);
                                                      if ($childClusters->size() >1,|^VariableExpression(genericType = $s.genericType,
                                                                                                         multiplicity = $s.multiplicity,
                                                                                                         name = $s->createVarExpName($originalFn,$depth)),
                                                                                    |$s
                                                          );
                                                    );,
                 c:StoreMappingClusteredValueSpecification[1]|if($c->in($originalFn.parametersValues->clusteredVSToBeReplaced()),
                                                     | ^VariableExpression(genericType = $c.genericType,
                                                                           multiplicity = $c.multiplicity,
                                                                           name = $c->createVarExpName($originalFn,$depth)),
                                                     |$c.val),
                 v:ValueSpecification[1]| $v
             ]);
}



function <<access.private>> meta::pure::router::clustering::propertyPairsInMultiEqual(v : ValueSpecification[1]):Pair<Property<Nil,Any|*>, Property<Nil,Any|*>>[*]
{
   $v->evaluateAndDeactivate()->match([
      f: FunctionExpression[1] | let params = $f.parametersValues->evaluateAndDeactivate()->map(x| $x->byPassRouterInfo());
                                 if($f.func->in([meta::pure::functions::boolean::equal_Any_MANY__Any_MANY__Boolean_1_, meta::pure::functions::boolean::eq_Any_1__Any_1__Boolean_1_]) ,
                                    | $params->match([
                                       sfes: SimpleFunctionExpression[*] | assert($sfes->at(0).func->instanceOf(Property) && $sfes->at(1).func->instanceOf(Property));
                                                                           if($sfes->at(0).parametersValues->evaluateAndDeactivate()->cast(@VariableExpression).name == 'this' &&
                                                                              $sfes->at(1).parametersValues->evaluateAndDeactivate()->cast(@VariableExpression).name == 'that',
                                                                              | pair($sfes->at(0).func->cast(@Property<Nil,Any|*>), $sfes->at(1).func->cast(@Property<Nil,Any|*>)),
                                                                              | if($sfes->at(0).parametersValues->evaluateAndDeactivate()->cast(@VariableExpression).name == 'that' &&
                                                                                   $sfes->at(1).parametersValues->evaluateAndDeactivate()->cast(@VariableExpression).name == 'this',
                                                                                   | pair($sfes->at(1).func->cast(@Property<Nil,Any|*>), $sfes->at(0).func->cast(@Property<Nil,Any|*>)),
                                                                                   | assert(false, 'Complex cross expressions not supported yet!'); [];
                                                                                )
                                                                           );,
                                       a: Any[*] | assert(false, 'Complex cross expressions not supported yet!'); [];
                                      ]),
                                    | if($f.functionName == 'and', 
                                         | $params->at(0)->propertyPairsInMultiEqual()->concatenate($params->at(1)->propertyPairsInMultiEqual()), 
                                         | assert(false, 'Complex cross expressions not supported yet!'); [];
                                      );
                                 );
   ])
}

function <<access.private>> meta::pure::router::clustering::createCrossSetImplementation(set:SetImplementation[1], mapping:Mapping[1], store: Store[1], varName: String[1], sourceCrossAcceses: meta::pure::router::analytics::PropertyAccess[*], targetCrossAcceses: meta::pure::router::analytics::PropertyAccess[*], allPropertyAccesses: PropertyAccess[*]):Pair<SetImplementation, CrossSetImplementation>[1]
{
   let newSetId = $varName;
   
   let propertiesAccessed = $allPropertyAccesses.property;
   let propertiesInSourceCrossExpressions = $sourceCrossAcceses->map(cross | $set->cast(@InstanceSetImplementation)->propertyMappingByPropertyNameAndTargetId($cross.property.name->toOne(), $cross.targetSetId)->toOne()->cast(@XStorePropertyMapping).crossExpression.expressionSequence->evaluateAndDeactivate()->at(0)->propertyPairsInMultiEqual().first);
   let propertiesInTargetCrossExpressions = $targetCrossAcceses->map(cross | $mapping->classMappingById($cross.sourceSetId)->cast(@InstanceSetImplementation)->toOne()->propertyMappingByPropertyNameAndTargetId($cross.property.name->toOne(), $cross.targetSetId)->toOne()->cast(@XStorePropertyMapping).crossExpression.expressionSequence->evaluateAndDeactivate()->at(0)->propertyPairsInMultiEqual().second);
   let requiredSimpleProperties = $propertiesAccessed->concatenate($propertiesInSourceCrossExpressions)->concatenate($propertiesInTargetCrossExpressions)->removeDuplicates();
   
   let simplePropertyMappings = $set->cast(@InstanceSetImplementation)->allPropertyMappings()
                                 ->filter(s| $s.property->genericType().typeArguments->at(1).rawType->toOne()->instanceOf(DataType))
                                 ->filter(s | $requiredSimpleProperties->contains($s.property))
                                 ->map(pm | ^CrossSetImplementationPrimtivePropertyMapping
                                             (
                                                property = $pm.property->cast(@Property<Nil,Any|*>), 
                                                propertyPlaceHolder = $pm.property.name->toOne(), 
                                                sourceSetImplementationId = $newSetId, 
                                                targetSetImplementationId = '',
                                                sourcePropertyMapping = $pm
                                             )
                                      );

   let complexPropertyMappings = $sourceCrossAcceses->map(cross | ^CrossSetImplementationComplexPropertyMapping
                                                                   (
                                                                      property = $cross.property->cast(@Property<Nil,Any|*>), 
                                                                      crossExperssionPropertyPairs = $set->cast(@InstanceSetImplementation)->propertyMappingByPropertyNameAndTargetId($cross.property.name->toOne(), $cross.targetSetId)->toOne()->cast(@XStorePropertyMapping).crossExpression.expressionSequence->evaluateAndDeactivate()->at(0)->propertyPairsInMultiEqual(),
                                                                      sourceSetImplementationId = $newSetId, 
                                                                      targetSetImplementationId = $cross.targetSetId,
                                                                      sourcePropertyMapping = $set->cast(@InstanceSetImplementation)->propertyMappingByPropertyNameAndTargetId($cross.property.name->toOne(), $cross.targetSetId)->toOne()
                                                                   )
                                                         );
   
   let allPropertyMappings = $simplePropertyMappings->concatenate($complexPropertyMappings);
                                  
   let crossSet =  ^CrossSetImplementation
                    (
                       targetStore = $store,
                       id = $newSetId,
                       class = $set.class,
                       root = true,
                       parent = $set.parent,
                       varName = $varName
                    );
   
   let allPropertyMappingsWithAddedOwner = $allPropertyMappings->map(a | ^$a(owner = $crossSet));
   $crossSet->mutateAdd('propertyMappings', $allPropertyMappingsWithAddedOwner);
   
   pair($set, $crossSet);
}

function meta::pure::router::clustering::doReplacementWithPairsForVS(vs: ValueSpecification[1], pairs: Pair<SetImplementation, SetImplementation>[*]): ValueSpecification[1]
{
   $vs->evaluateAndDeactivate()->match([
      fe:FunctionExpression[1]                | ^$fe(func = $fe.func->match([qp:QualifiedProperty<Any>[1] | $qp->doReplacementWithPairsForLambda($pairs), f: Function<Any>[1] | $f]), parametersValues=$fe.parametersValues->map(v|$v->doReplacementWithPairsForVS($pairs))),
      cvs:StoreMappingClusteredValueSpecification[1]      | ^$cvs(val = $cvs.val->doReplacementWithPairsForVS($pairs)->cast(@ValueSpecification)),
      evs:StoreMappingRoutedValueSpecification[1] | if($evs.sets->isNotEmpty() && $evs.sets->at(0)->instanceOf(CrossSetImplementation),
                                                   | $vs,
                                                   | ^$evs
                                                     (
                                                        value = $evs.value->doReplacementWithPairsForVS($pairs), 
                                                        sets = $evs.sets->map(ss | if($pairs.first.id->contains($ss.id), |$pairs->filter(s|$s.first.id == $ss.id)->at(0).second, |$ss)),
                                                        propertyMapping = $evs.propertyMapping->map(pm | 
                                                                             let set = $pm.owner.parent->toOne()->classMappingById(if($pm.sourceSetImplementationId == '',|$pm.owner->cast(@InstanceSetImplementation).id->toOne(), |$pm.sourceSetImplementationId));
                                                                             if($set->isEmpty(), | $pm, |
                                                                             let parent = $set->toOne();
                                                                             let newParent = if($pairs.first.id->contains($parent.id), |$pairs->filter(s|$s.first.id == $parent.id)->at(0).second, |$parent);
                                                                             let targetPairs = $pairs->map(p | pair($p.first.id, $p.second.id))->filter(s | $s.first == $pm.targetSetImplementationId).second;
                                                                             let newTargetSetId = $targetPairs->isEmpty()->if(|$pm.targetSetImplementationId, |$targetPairs->toOne());
                                                                             if($newParent != $parent, | $newParent->cast(@InstanceSetImplementation)->propertyMappingByPropertyNameAndTargetId($pm.property.name->toOne(), $newTargetSetId), | $pm););
                                                                          )
                                                     )
                                                ),
      i:InstanceValue[1]                      | ^$i
                                                (
                                                   values = $i.values->evaluateAndDeactivate()->map(v| $v->match([
                                                      e:ValueSpecification[1] | $e->doReplacementWithPairsForVS($pairs),
                                                      f:FunctionDefinition<Any>[1] | $f->doReplacementWithPairsForLambda($pairs),
                                                      a:Any[1] | $a
                                                   ]))
                                                ),
      rvs:RoutedValueSpecification[1]         | ^$rvs(value = $rvs.value->doReplacementWithPairsForVS($pairs)),
      val:ValueSpecification[1]               | $val
   ])
}

function meta::pure::router::clustering::doReplacementWithPairsForLambda(f:FunctionDefinition<Any>[1], pairs: Pair<SetImplementation, SetImplementation>[*]):FunctionDefinition<Any>[1]
{
   ^$f(expressionSequence = $f.expressionSequence->map(e|$e->doReplacementWithPairsForVS($pairs)));
}

function meta::pure::router::clustering::clusteredGetAll(set: SetImplementation[1], mapping: Mapping[1], runtime: Runtime[1], exeCtx: ExecutionContext[1], extensions:meta::pure::extension::Extension[*]):ClusteredValueSpecification[1]
{
   let analyticsContext = $exeCtx->cast(@AnalyticsExecutionContext);
   let sourceType = ^GenericType(rawType=if($set->instanceOf(InstanceSetImplementation) && $set->cast(@InstanceSetImplementation).mappingClass->isEmpty(),| $set.class, | $set->cast(@InstanceSetImplementation).mappingClass->toOne()));
   let newExpr = ^StoreMappingRoutedValueSpecification
   (
      genericType= $sourceType, id = '1', multiplicity = ZeroMany, runtime = $runtime, mapping = $mapping, executionContext = $exeCtx, sets = $set,
      value = ^SimpleFunctionExpression
              (
                func = getAll_Class_1__T_MANY_, functionName = 'getAll', importGroup = system.children->at(0)->cast(@Package).children->at(0)->cast(@ImportGroup), genericType = $sourceType, multiplicity = ZeroMany,
                parametersValues = ^StoreMappingRoutedValueSpecification
                (
                    genericType = ^GenericType(rawType=Class, typeArguments=$sourceType), id = '1', multiplicity = PureOne, runtime = $runtime, sets = $set, mapping = $mapping, executionContext = $exeCtx,
                    value = ^InstanceValue
                    (
                      genericType = ^GenericType(rawType=Class, typeArguments=$sourceType), multiplicity = PureOne, values = $sourceType.rawType
                    ),
                    routingStrategy = meta::pure::router::store::routing::getRoutingStrategyFromMappingAndRuntime($mapping, $runtime)
                )
              ),
      routingStrategy = meta::pure::router::store::routing::getRoutingStrategyFromMappingAndRuntime($mapping, $runtime)
   )->evaluateAndDeactivate();
   
   let clustered = list($newExpr)->doCluster(^LambdaFunction<{->Any[1]}>(expressionSequence=^InstanceValue(values='', genericType=^GenericType(rawType=String), multiplicity=PureOne)),
                                             $mapping,
                                             $runtime,
                                             ^$analyticsContext(useAnalytics=false),
                                             $extensions,
                                             noDebug());
   $clustered->at(0).expressionSequence->evaluateAndDeactivate()->cast(@ClusteredValueSpecification)->toOne();
}

function meta::pure::router::doCluster(built:List<ValueSpecification>[*], f:FunctionDefinition<Any>[1], mapping:Mapping[1], runtime: Runtime[1], exeCtx: ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):FunctionDefinition<Any>[*]
{
   // Cluster by stores (negotiate capabilities)
   print(if($debug.debug,|'\n'+$debug.space+'Clustering:\n',|''));
   let openVariables = $f->openVariableValues();
   $built->map(
         v|
            let clusteringDebug = ^$debug(space = $debug.space+'  ');
            let res = $v.values
                              ->cast(@ValueSpecification)->evaluateAndDeactivate()
                              ->map(
                                    c| print(if($clusteringDebug.debug,|'\n'+$c->asString()->debug($clusteringDebug.space+'Processing: '),|''));
                                       let res = $c->cluster($mapping, $runtime, $openVariables, $exeCtx, $extensions, $clusteringDebug);
                                     
                                       $res->map(clusterResult|
                                                 if($clusterResult.cluster->instanceOf(ClusteredValueSpecification),
                                                     |$clusterResult.letFunctions->concatenate($clusterResult.cluster),
                                                      |^PlatformClusteredValueSpecification(
                                                          genericType  = $clusterResult.cluster.genericType,
                                                          multiplicity = $clusterResult.cluster.multiplicity,
                                                          openVars = $openVariables,
                                                          exeCtx = $exeCtx,
                                                          val = $clusterResult.cluster,
                                                          executable = true
                                                        )
                                                   );
                                                ););
            
            let result = ^$f(expressionSequence = $res->toOneMany());
            print(if($debug.debug,|$result->asString()+'\n',|''));
            $result;
         );
}
