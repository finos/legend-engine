
import meta::legend::*;
import meta::external::ingest::barrier::*;
import meta::external::ingest::models::*;

function <<meta::pure::profiles::test.Test>> meta::external::ingest::tests::testAvailabilityForSingleDataset() : Boolean[1]
{
  //Test Data setup
  meta::external::ingest::tests::createTablesAndFillDb();

  let prevPublishedWatermark = ^Watermark(watermarkId='watermark1',
                          datasetMarks = [^DatasetMark(datasetName='Dataset1',batchId=1)]);
  
  let currentWM = ^Watermark(watermarkId='watermark2',
                          datasetMarks = [^DatasetMark(datasetName='Dataset1',batchId=3)]);
  
  let ingestConfig = ^IngestConfig<EodBatchMetadata>(datasetName = 'Dataset1', metadataType = EodBatchMetadata);
  
  let barrierQuery = {
    
      prevPublishedWatermark: Watermark[1] , currentWatermark: Watermark[1] | isDatasetAvailable($ingestConfig, $prevPublishedWatermark, $currentWatermark);

  };

  let result = executeLegendQuery($barrierQuery,[^Pair<String,Watermark>(first='prevPublishedWatermark',second=$prevPublishedWatermark),^Pair<String,Watermark>(first='currentWM',second=$currentWM)],^meta::pure::runtime::ExecutionContext(),meta::relational::extension::relationalExtensions());
  
  assertEquals(true,$result);
}

function <<meta::pure::profiles::test.Test>> meta::external::ingest::tests::testEODBatchForSingleDataset() : Boolean[1]
{
  //Test Data setup
  meta::external::ingest::tests::createTablesAndFillDb();

  let prevPublishedWatermark = ^Watermark(watermarkId='watermark1',
                          datasetMarks = [^DatasetMark(datasetName='Dataset1',batchId=1)]);
  
  let currentWM = ^Watermark(watermarkId='watermark2',
                          datasetMarks = [^DatasetMark(datasetName='Dataset1',batchId=3)]);
  
  let ingestConfig = ^IngestConfig<EodBatchMetadata>(datasetName = 'Dataset1', metadataType = EodBatchMetadata);
  
  let barrierQuery = {
    
      prevPublishedWatermark: Watermark[1] , currentWatermark: Watermark[1] | isDatasetAvailable($ingestConfig,x | $x.endOfDay, $prevPublishedWatermark, $currentWatermark);

  };

  let result = executeLegendQuery($barrierQuery,[^Pair<String,Watermark>(first='prevPublishedWatermark',second=$prevPublishedWatermark),^Pair<String,Watermark>(first='currentWM',second=$currentWM)],^meta::pure::runtime::ExecutionContext(),meta::relational::extension::relationalExtensions());
  
  assertEquals(true,$result);
}

function <<meta::pure::profiles::test.Test>> meta::external::ingest::tests::testEODBatchForMultipleDatasets() : Boolean[1]
{
  //Test Data setup
  meta::external::ingest::tests::createTablesAndFillDb();

  let prevPublishedWatermark = ^Watermark(watermarkId='watermark1',
                          datasetMarks = [^DatasetMark(datasetName='Dataset1',batchId=1)]);
  
  let currentWM = ^Watermark(watermarkId='watermark2',
                          datasetMarks = [^DatasetMark(datasetName='Dataset1',batchId=3)]);
  
  let ingestConfig1 = ^IngestConfig<EodBatchMetadata>(datasetName = 'Dataset1', metadataType = EodBatchMetadata);
  
  let ingestConfig2 = ^IngestConfig<EodBatchMetadata>(datasetName = 'Dataset2', metadataType = EodBatchMetadata);
  
  let barrierQuery = {
    
      prevPublishedWatermark: Watermark[1] , currentWatermark: Watermark[1] | isDatasetAvailable($ingestConfig1,x | $x.endOfDay, $prevPublishedWatermark, $currentWatermark)
                                                                  && isDatasetAvailable($ingestConfig2,x | $x.endOfDay, $prevPublishedWatermark, $currentWatermark);
  };

  let result = executeLegendQuery($barrierQuery,[^Pair<String,Watermark>(first='prevPublishedWatermark',second=$prevPublishedWatermark),^Pair<String,Watermark>(first='currentWM',second=$currentWM)],^meta::pure::runtime::ExecutionContext(),meta::relational::extension::relationalExtensions());
  
  assertEquals(true,$result);
}