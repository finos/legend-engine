// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::*;
import meta::external::store::elasticsearch::metamodel::*;
import meta::external::store::elasticsearch::tds::*;
import meta::external::store::elasticsearch::utils::*;

Class meta::external::store::elasticsearch::tds::IndexTDS extends TabularDataSetImplementation
{
  index: ElasticSearchStoreIndex[1];
}

function meta::external::store::elasticsearch::tds::indexToTDS(store: String[1], indexName: String[1]): IndexTDS[1]
{
  $store->pathToElement()->cast(@ElasticSearchStore)->indexToTDS($indexName);
}

function meta::external::store::elasticsearch::tds::indexToTDS(store: ElasticSearchStore[1], indexName: String[1]): IndexTDS[1]
{
  let index = $store.index($indexName);
  assert($index->isNotEmpty(), |'No index found on store: ' + $indexName);
  ^IndexTDS(
     store = $store,
     index = $index->toOne(),
     columns = $index->toOne()->collectScalarProperties()->toIndexed()->map(ip | $ip->indexPropertyToTdsColumn())
  );
}

function <<access.private>> meta::external::store::elasticsearch::tds::indexPropertyToTdsColumn(indexedProperty: Pair<Integer, ElasticSearchDocumentProperty>[1]):TDSColumn[1]
{
  let offset = $indexedProperty.first;
  let property = $indexedProperty.second;
  ^TDSColumn(
     name = $property.fullyQualifiedName(),
     offset = $offset,
     type = $property.type->toOne()->indexTypeToCompatiblePureType()
  );
}

function <<access.private>> meta::external::store::elasticsearch::tds::indexTypeToCompatiblePureType(indexType: ElasticSearchPropertyType[1]): DataType[1]
{
    $indexType->match([
        i : ElasticSearchPureIntegerPropertyType[1] | Integer,
        f : ElasticSearchPureFloatPropertyType[1] | Float,
        s : ElasticSearcStringPropertyType[1] | String,
        b : ElasticSearchBooleanPropertyType[1] | Boolean
        // todo add date support
    ]);
}