// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::modelToModel::test::createInstances::*;
import meta::relational::postProcessor::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::pure::mapping::modelToModel::test::shared::*;
import meta::pure::mapping::modelToModel::test::enumerationMapping::enumToEnum::mapping::*;
import meta::pure::mapping::modelToModel::test::enumerationMapping::enumToEnum::model::*;
import meta::pure::mapping::modelToModel::test::enumeration::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::executionPlan::tests::datetime::*;
import meta::relational::tests::tds::tabletds::*;
import meta::pure::mapping::*;
import meta::relational::mapping::*;
import meta::relational::runtime::*;
import meta::relational::tests::mapping::inheritance::relational::*;
import meta::relational::metamodel::join::*;
import meta::relational::tests::tds::tdsJoin::*;
import meta::pure::executionPlan::toString::*;
import meta::pure::executionPlan::tests::*;
import meta::relational::tests::groupBy::datePeriods::mapping::*;
import meta::relational::tests::groupBy::datePeriods::*;
import meta::relational::tests::groupBy::datePeriods::domain::*;
import meta::pure::executionPlan::*;
import meta::relational::tests::*;
import meta::relational::tests::model::simple::*;
import meta::pure::runtime::*;
import meta::pure::mapping::modelToModel::test::shared::src::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::pure::graphFetch::routing::*;
import meta::pure::functions::collection::*;
import meta::relational::executionPlan::platformBinding::legendJava::*;
import meta::relational::executionPlan::platformBinding::legendJava::tests::*;


function <<test.Test>> meta::relational::executionPlan::platformBinding::legendJava::tests::letVariableFunctionNow() : Boolean[1]
{
    let lambda = {| let x = now();
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>now()->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};

   let res = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   let expected =
   'Sequence\n'+
   '(\n'+
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '  (\n'+
   '    Allocation\n'+
   '    (\n'+
   '      type = DateTime\n'+
   '      resultSizeRange = 1\n'+
   '      name = x\n'+
   '      value = \n'+
   '        (\n'+
   '          PureExp\n'+
   '          (\n'+
   '            type = DateTime\n'+
   '            resultSizeRange = 1\n'+
   '            expression = now()\n'+
   '          )\n'+
   '        )\n'+
   '    )\n'+
   '    Relational\n'+
   '    (\n'+
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n'+
   '      connection = TestDatabaseConnection(type = "H2")\n'+
   '    )\n'+
   '  )\n'+
   ')\n';

   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));

   let withJava = $res->generatePlatformCode(meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(), ^meta::pure::executionPlan::platformBinding::legendJava::LegendJavaPlatformBindingConfig(), relationalExtensionsWithLegendJavaPlatformBinding());

   let expectedJava =
   'Sequence\n' +
   '(\n' +
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '  (\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = DateTime\n' +
   '      resultSizeRange = 1\n'+
   '      name = x\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = DateTime\n' +
   '            resultSizeRange = 1\n'+
   '            expression = now()\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = org.finos.legend.engine.plan.dependencies.store.platform.PredefinedExpressions.now\n' +
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n' +
   '      connection = TestDatabaseConnection(type = "H2")\n' +
   '    )\n' +
   '  )\n' +
   ')\n';

   assertEquals($expectedJava, $withJava->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::relational::executionPlan::platformBinding::legendJava::tests::withNestedSequenceNode() : Boolean[1]
{
   let tree = #{
      meta::relational::graphFetch::tests::chain::Target_Firm {
         firmName,
         employeeCount
      }
   }#;
   
   let query = {|meta::relational::graphFetch::tests::chain::Target_Firm.all()->graphFetch($tree)->serialize($tree)};
  
   let modelChainConnection = ^meta::pure::mapping::modelToModel::ModelChainConnection(
      element = ^meta::pure::mapping::modelToModel::ModelStore(),
      mappings = [meta::relational::tests::simpleRelationalMapping]
   );
   let runtime = ^meta::pure::runtime::Runtime(
      connections = meta::relational::tests::testRuntime().connections->concatenate($modelChainConnection)
   );

   let res = meta::pure::executionPlan::executionPlan($query, meta::relational::graphFetch::tests::chain::M2M_Mapping, $runtime, meta::relational::extension::relationalExtensions());

   let root = $res.rootExecutionNode->cast(@PureExpressionPlatformExecutionNode);
   let globalGraphFetch = $root.executionNodes->toOne()->cast(@GlobalGraphFetchExecutionNode);
   let localGraphFetch = $globalGraphFetch.localGraphFetchExecutionNode;

   let newLocalGraphFetchWithSequence = ^$localGraphFetch(executionNodes = ^SequenceExecutionNode(executionNodes = $localGraphFetch.executionNodes, resultType = $localGraphFetch.executionNodes->last()->toOne().resultType));
   let newGlobalGraphFetchWithSequence = ^$globalGraphFetch(localGraphFetchExecutionNode = $newLocalGraphFetchWithSequence);
   let newRoot = ^$root(executionNodes = $newGlobalGraphFetchWithSequence);

   let plan = ^$res(rootExecutionNode = $newRoot);  

   let expected =
    'PureExp\n'+
    '(\n'+
    '  type = String\n'+
    '  expression =  -> serialize(#{meta::relational::graphFetch::tests::chain::Target_Firm {firmName, employeeCount}}#)\n'+
    '  (\n'+
    '    StoreMappingGlobalGraphFetch\n'+
    '    (\n'+
    '      type = PartialClass[impls=[(meta::relational::graphFetch::tests::chain::Target_Firm | M2M_Mapping.meta_relational_graphFetch_tests_chain_Target_Firm)], propertiesWithParameters = [employeeCount, firmName]]\n'+
    '      resultSizeRange = *\n'+
    '      store = MODEL\n'+
    '      localGraphFetchExecutionNode = \n'+
    '         InMemoryRootGraphFetch\n'+
    '         (\n'+
    '           type = PartialClass[impls=[(meta::relational::graphFetch::tests::chain::Target_Firm | M2M_Mapping.meta_relational_graphFetch_tests_chain_Target_Firm)], propertiesWithParameters = [employeeCount, firmName]]\n'+
    '           graphFetchTree = [meta_relational_graphFetch_tests_chain_Target_Firm/meta::relational::graphFetch::tests::chain::Target_Firm]{@(meta_relational_graphFetch_tests_chain_Target_Firm->)@[/employeeCount],@(meta_relational_graphFetch_tests_chain_Target_Firm->)@[/firmName]}\n'+
    '           nodeIndex = 0\n'+
    '           batchSize = 1\n'+
    '           checked = false\n'+
    '           (\n'+
    '             Sequence\n'+
    '             (\n'+
    '               type = PartialClass[impls=[(meta::relational::tests::model::simple::Firm | simpleRelationalMappingInc.meta_relational_tests_model_simple_Firm)], propertiesWithParameters = [employees, legalName]]\n'+
    '               (\n'+
    '                 StoreMappingGlobalGraphFetch\n'+
    '                 (\n'+
    '                   type = PartialClass[impls=[(meta::relational::tests::model::simple::Firm | simpleRelationalMappingInc.meta_relational_tests_model_simple_Firm)], propertiesWithParameters = [employees, legalName]]\n'+
    '                   resultSizeRange = *\n'+
    '                   store = meta::relational::tests::db\n'+
    '                   localGraphFetchExecutionNode = \n'+
    '                      RelationalGraphFetch\n'+
    '                      (\n'+
    '                        type = PartialClass[impls=[(meta::relational::tests::model::simple::Firm | simpleRelationalMappingInc.meta_relational_tests_model_simple_Firm)], propertiesWithParameters = [employees, legalName]]\n'+
    '                        nodeIndex = 0\n'+
    '                        relationalNode = \n'+
    '                           SQL\n'+
    '                           (\n'+
    '                             type = meta::pure::metamodel::type::Any\n'+
    '                             resultColumns = [("pk_0", INT), ("legalName", VARCHAR(200))]\n'+
    '                             sql = select "root".ID as "pk_0", "root".LEGALNAME as "legalName" from firmTable as "root"\n'+
    '                             connection = TestDatabaseConnection(type = "H2")\n'+
    '                           )\n'+
    '                        children = [\n'+
    '                           RelationalGraphFetch\n'+
    '                           (\n'+
    '                             type = PartialClass[impls=[(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)], propertiesWithParameters = []]\n'+
    '                             nodeIndex = 1\n'+
    '                             relationalNode = \n'+
    '                                SQL\n'+
    '                                (\n'+
    '                                  type = meta::pure::metamodel::type::Any\n'+
    '                                  resultColumns = [("parent_key_gen_0", INT), ("pk_0", INT)]\n'+
    '                                  sql = select distinct "temp_table_node_0_0".pk_0 as "parent_key_gen_0", "persontable_0".ID as "pk_0" from (select * from (${temp_table_node_0}) as "root") as "temp_table_node_0_0" inner join firmTable as "root" on ("temp_table_node_0_0".pk_0 = "root".ID) left outer join personTable as "persontable_0" on ("root".ID = "persontable_0".FIRMID) where "persontable_0".ID is not null\n'+
    '                                  connection = TestDatabaseConnection(type = "H2")\n'+
    '                                )\n'+
    '                             children = [\n'+
    '                                \n'+
    '                             ]\n'+
    '                             implementation\n'+
    '                             (\n'+
    '                               calls = _pure.plan.root.n1.localGraph.n1.n1.localGraph.localChild0.Execute\n'+
    '                             )\n'+
    '                           )\n'+
    '\n'+
    '                        ]\n'+
    '                        implementation\n'+
    '                        (\n'+
    '                          calls = _pure.plan.root.n1.localGraph.n1.n1.localGraph.Execute\n'+
    '                        )\n'+
    '                      )\n'+
    '                   children = [\n'+
    '                      \n'+
    '                   ]\n'+
    '                   localTreeIndices = [0, 1, 2]\n'+
    '                   dependencyIndices = []\n'+
    '                 )\n'+
    '               )\n'+
    '             )\n'+
    '           )\n'+
    '           children = [\n'+
    '              \n'+
    '           ]\n'+
    '           implementation\n'+
    '           (\n'+
    '             calls = _pure.plan.root.n1.localGraph.Execute\n'+
    '           )\n'+
    '         )\n'+
    '      children = [\n'+
    '         \n'+
    '      ]\n'+
    '      localTreeIndices = [0, 1, 2]\n'+
    '      dependencyIndices = []\n'+
    '    )\n'+
    '  )\n'+
    '  implementation\n'+
    '  (\n'+
    '    calls = _pure.plan.root.Serialize\n'+
    '  )\n'+
    ')\n';

   let withJava = $plan->generatePlatformCode(meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(), ^meta::pure::executionPlan::platformBinding::legendJava::LegendJavaPlatformBindingConfig(), relationalExtensionsWithLegendJavaPlatformBinding());
   assertEquals($expected, $withJava->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::relational::executionPlan::platformBinding::legendJava::tests::letVariableFunctionAdjustNow() : Boolean[1]
{
   let lambda = {| let x = adjust(now(),1,DurationUnit.DAYS);
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>now()->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};
   let res = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let expected =
   'Sequence\n'+
   '(\n'+
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '  (\n'+
   '    Allocation\n'+
   '    (\n'+
   '      type = Date\n'+
   '      resultSizeRange = 1\n'+
   '      name = x\n'+
   '      value = \n'+
   '        (\n'+
   '          PureExp\n'+
   '          (\n'+
   '            type = Date\n'+
   '            resultSizeRange = 1\n'+
   '            expression = now() -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n'+
   '          )\n'+
   '        )\n'+
   '    )\n'+
   '    Relational\n'+
   '    (\n'+
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n'+
   '      connection = TestDatabaseConnection(type = "H2")\n'+
   '    )\n'+
   '  )\n'+
   ')\n';

   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));

   let withJava = $res->generatePlatformCode(meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(), ^meta::pure::executionPlan::platformBinding::legendJava::LegendJavaPlatformBindingConfig(), relationalExtensionsWithLegendJavaPlatformBinding());

   let expectedJava =
   'Sequence\n' +
   '(\n' +
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '  (\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = Date\n' +
   '      resultSizeRange = 1\n'+
   '      name = x\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = Date\n' +
   '            resultSizeRange = 1\n'+
   '            expression = now() -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = _pure.plan.root.n1.n1.Execute.execute\n' +
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n' +
   '      connection = TestDatabaseConnection(type = "H2")\n' +
   '    )\n' +
   '  )\n' +
   ')\n' +
   'globalImplementationSupport\n' +
   '(\n' +
   '  classes =\n' +
   '      _pure.plan.root.n1.n1.Execute\n' +
   '      0001 package _pure.plan.root.n1.n1;\n' +
   '      0002 \n' +
   '      0003 import java.util.Date;\n' +
   '      0004 import org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\n' +
   '      0005 import org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n' +
   '      0006 import org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n' +
   '      0007 import org.finos.legend.engine.plan.dependencies.util.Library;\n' +
   '      0008 \n' +
   '      0009 public class Execute\n' +
   '      0010 {\n' +
   '      0011     public static PureDate execute(IExecutionNodeContext context)\n' +
   '      0012     {\n' +
   '      0013         try\n' +
   '      0014         {\n' +
   '      0015             return Library.adjustDate(PureDate.fromDate(new Date()),\n' +
   '      0016                                       1L,\n' +
   '      0017                                       DurationUnit.getEnumFromPureName("DAYS"));\n' +
   '      0018         }\n' +
   '      0019         catch (Exception e)\n' +
   '      0020         {\n' +
   '      0021             throw new RuntimeException("Failed in node: root.n1.n1", e);\n' +
   '      0022         }\n' +
   '      0023     }\n' +
   '      0024 }\n' +
   ')\n';
   assertEquals($expectedJava, $withJava->planToString(true, meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::relational::executionPlan::platformBinding::legendJava::tests::letVariableFunctionAdjustDateLiteral() : Boolean[1]
{
   let lambda = {| let x = adjust(%2005-10-10,1,DurationUnit.DAYS);
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>%2005-10-10->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};

   let res = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let expected =
   'Sequence\n'+
   '(\n'+
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '  (\n'+
   '    Allocation\n'+
   '    (\n'+
   '      type = Date\n'+
   '      resultSizeRange = 1\n'+
   '      name = x\n'+
   '      value = \n'+
   '        (\n'+
   '          PureExp\n'+
   '          (\n'+
   '            type = Date\n'+
   '            resultSizeRange = 1\n'+
   '            expression = 2005-10-10 -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n'+
   '          )\n'+
   '        )\n'+
   '    )\n'+
   '    Relational\n'+
   '    (\n'+
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, \'2005-10-10\')\n'+
   '      connection = TestDatabaseConnection(type = "H2")\n'+
   '    )\n'+
   '  )\n'+
   ')\n';

   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));

   let withJava = $res->generatePlatformCode(meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(), ^meta::pure::executionPlan::platformBinding::legendJava::LegendJavaPlatformBindingConfig(), relationalExtensionsWithLegendJavaPlatformBinding());

   let expectedJava =
   'Sequence\n' +
   '(\n' +
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '  (\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = Date\n' +
   '      resultSizeRange = 1\n'+
   '      name = x\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = Date\n' +
   '            resultSizeRange = 1\n'+
   '            expression = 2005-10-10 -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = _pure.plan.root.n1.n1.Execute.execute\n' +
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, \'2005-10-10\')\n' +
   '      connection = TestDatabaseConnection(type = "H2")\n' +
   '    )\n' +
   '  )\n' +
   ')\n' +
   'globalImplementationSupport\n' +
   '(\n' +
   '  classes =\n' +
   '      _pure.plan.root.n1.n1.Execute\n' +
   '      0001 package _pure.plan.root.n1.n1;\n' +
   '      0002 \n' +
   '      0003 import org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\n' +
   '      0004 import org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n' +
   '      0005 import org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n' +
   '      0006 import org.finos.legend.engine.plan.dependencies.util.Library;\n' +
   '      0007 \n' +
   '      0008 public class Execute\n' +
   '      0009 {\n' +
   '      0010     public static PureDate execute(IExecutionNodeContext context)\n' +
   '      0011     {\n' +
   '      0012         try\n' +
   '      0013         {\n' +
   '      0014             return Library.adjustDate(PureDate.parsePureDate("2005-10-10"),\n' +
   '      0015                                       1L,\n' +
   '      0016                                       DurationUnit.getEnumFromPureName("DAYS"));\n' +
   '      0017         }\n' +
   '      0018         catch (Exception e)\n' +
   '      0019         {\n' +
   '      0020             throw new RuntimeException("Failed in node: root.n1.n1", e);\n' +
   '      0021         }\n' +
   '      0022     }\n' +
   '      0023 }\n' +
   ')\n';
   assertEquals($expectedJava, $withJava->planToString(true, meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::relational::executionPlan::platformBinding::legendJava::tests::javaGenerationLetVariablePureExpression() : Boolean[1]
{
   let lambda = {businessDate: StrictDate[0..1], CLSFtype: String[1]| let asOf = if($businessDate->isNotEmpty(), |$businessDate->toOne(), |now());
                                                                      meta::relational::tests::milestoning::Product.all($asOf)
                                                                      ->filter(p|$p.classification($asOf).type==$CLSFtype)
                                                                      ->project([x|$x.classification($asOf).type], ['classificationType'])->distinct();};

   let res = meta::pure::executionPlan::executionPlan($lambda,meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let withJava = $res->generatePlatformCode(meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(), ^meta::pure::executionPlan::platformBinding::legendJava::LegendJavaPlatformBindingConfig(), relationalExtensionsWithLegendJavaPlatformBinding());

   let expectedJava =
   'Sequence\n'+
   '(\n' +
   '  type = TDS[(classificationType, String, VARCHAR(200), \"\")]\n' +
   '  (\n' +
   '    FunctionParametersValidationNode\n' +
   '    (\n' +
   '      functionParameters = [businessDate:StrictDate[0..1], CLSFtype:String[1]]\n' +
   '    )\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = Date\n' +
   '      resultSizeRange = 1\n'+
   '      name = asOf\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = Date\n' +
   '            resultSizeRange = 1\n'+
   '            requires = [businessDate(StrictDate[0..1])]\n' +
   '            expression = $businessDate -> isNotEmpty() -> if([Routed Func: | $businessDate -> toOne();], [Routed Func: | now();])\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = _pure.plan.root.n2.n1.Execute.execute\n'+
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(classificationType, String, VARCHAR(200), \"\")]\n' +
   '      resultColumns = [(\"classificationType\", VARCHAR(200))]\n' +
   '      sql = select distinct \"productclassificationtable_0\".type as \"classificationType\" from ProductTable as \"root\" left outer join ProductClassificationTable as \"productclassificationtable_0\" on (\"root\".type = \"productclassificationtable_0\".type and \"productclassificationtable_0\".from_z <= \'${asOf}\' and \"productclassificationtable_0\".thru_z > \'${asOf}\') where \"productclassificationtable_0\".type = \'${CLSFtype?replace("\'", "\'\'")}\' and \"root\".from_z <= \'${asOf}\' and \"root\".thru_z > \'${asOf}\'\n' +
   '      connection = TestDatabaseConnection(type = \"H2\")\n' +
   '    )\n' +
   '  )\n' +
   ')\n' +
   'globalImplementationSupport\n' +
   '(\n' +
   '  classes =\n' +
   '      _pure.plan.root.n2.n1.Execute\n' +
   '      0001 package _pure.plan.root.n2.n1;\n' +
   '      0002 \n' +
   '      0003 import java.util.Date;\n' +
   '      0004 import java.util.function.Supplier;\n' +
   '      0005 import org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n' +
   '      0006 import org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n' +
   '      0007 import org.finos.legend.engine.plan.dependencies.util.Library;\n' +
   '      0008 \n' +
   '      0009 public class Execute\n' +
   '      0010 {\n' +
   '      0011     public static PureDate execute(IExecutionNodeContext context)\n' +
   '      0012     {\n' +
   '      0013         try\n' +
   '      0014         {\n' +
   '      0015             PureDate businessDate = context.getResult(\"businessDate\", PureDate.class);\n' +
   '      0016             return businessDate != null ? ((Supplier<PureDate>) () -> Library.toOne(businessDate))\n' +
   '      0017                                                                              .get()\n' +
   '      0018                                         : ((Supplier<PureDate>) () -> PureDate.fromDate(new Date()))\n' +
   '      0019                                                                               .get();\n' +
   '      0020         }\n' +
   '      0021         catch (Exception e)\n' +
   '      0022         {\n' +
   '      0023             throw new RuntimeException(\"Failed in node: root.n2.n1\", e);\n' +
   '      0024         }\n' +
   '      0025     }\n' +
   '      0026 }\n' +
   ')\n';
   assertEquals($expectedJava, $withJava->planToString(true, meta::relational::extension::relationalExtensions()));
}


function <<test.Test>> meta::relational::executionPlan::platformBinding::legendJava::tests::classPathsInfluencedByPlanId() : Boolean[1]
{
   let lambda = {| let x = adjust(%2005-10-10,1,DurationUnit.DAYS);
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>%2005-10-10->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};

   let unbound = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   let withoutPlanId        = $unbound->generatePlatformCode(meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(), ^meta::pure::executionPlan::platformBinding::legendJava::LegendJavaPlatformBindingConfig(), relationalExtensionsWithLegendJavaPlatformBinding());
   let withoutPlanIdPackage = $withoutPlanId.globalImplementationSupport->cast(@JavaPlatformImplementation).classes.package->removeDuplicates();

   let withPlanId           = $unbound->generatePlatformCode(meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(), ^meta::pure::executionPlan::platformBinding::legendJava::LegendJavaPlatformBindingConfig(planId='abc'), relationalExtensionsWithLegendJavaPlatformBinding());
   let withPlanIdPackage    = $withPlanId.globalImplementationSupport->cast(@JavaPlatformImplementation).classes.package->removeDuplicates();

   assertEquals('_pure.plan.root.n1.n1', $withoutPlanIdPackage);
   assertEquals('_pure.plan_abc.plan.root.n1.n1', $withPlanIdPackage);
}

function <<test.Test>> meta::relational::executionPlan::platformBinding::legendJava::tests::testSupportGraphFetchWithCircularConstraint():Boolean[1]
{
  let tree = #{
    meta::pure::executionPlan::constraints::tests::Person {
        firstName,
        firm {
          legalName
        }
    }
  }#;

  let query = {|meta::pure::executionPlan::constraints::tests::Person.all()->graphFetchChecked($tree)->serialize($tree)};
  let mapping = meta::pure::executionPlan::constraints::tests::simpleRel;
  let runtime = meta::relational::tests::testRuntime();

  let plan = executionPlan($query, $mapping, $runtime, meta::relational::extension::relationalExtensions());
  let withJava = $plan->generatePlatformCode(meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(), ^meta::pure::executionPlan::platformBinding::legendJava::LegendJavaPlatformBindingConfig(), relationalExtensionsWithLegendJavaPlatformBinding());
 
  let generatedTree = $withJava.rootExecutionNode->cast(@PureExpressionPlatformExecutionNode).executionNodes->at(0)->cast(@GlobalGraphFetchExecutionNode).graphFetchTree.tree;
  let firmTree = $generatedTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('firm'))->toOne();
  let employeesTree = $firmTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('employees'))->toOne()->cast(@RoutedPropertyGraphFetchTree);

  // toFix: after fixing isDistinct related bug this test should expect ['titleNotEmpty'] result
  assertSameElements(['0', '1', 'titleNotEmpty'], $employeesTree.constraintsExclusions);

}

function <<test.Test>> meta::relational::executionPlan::platformBinding::legendJava::tests::testSupportGraphFetchWithCircularConstraint2():Boolean[1]
{
  let tree = #{
    meta::pure::executionPlan::constraints::tests::Person {
        firstName,
        firm {
          legalName,
          employees {
            lastName
          }
        }
    }
  }#;

  let query = {|meta::pure::executionPlan::constraints::tests::Person.all()->graphFetchChecked($tree)->serialize($tree)};
  let mapping = meta::pure::executionPlan::constraints::tests::simpleRel;
  let runtime = meta::relational::tests::testRuntime();

  let plan = executionPlan($query, $mapping, $runtime, meta::relational::extension::relationalExtensions());
  let withJava = $plan->generatePlatformCode(meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(), ^meta::pure::executionPlan::platformBinding::legendJava::LegendJavaPlatformBindingConfig(), relationalExtensionsWithLegendJavaPlatformBinding());
   
 
  let generatedTree = $withJava.rootExecutionNode->cast(@PureExpressionPlatformExecutionNode).executionNodes->at(0)->cast(@GlobalGraphFetchExecutionNode).graphFetchTree.tree;
  let firmTree = $generatedTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('firm'))->toOne();
  let employeesTree = $firmTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('employees'))->toOne()->cast(@RoutedPropertyGraphFetchTree);
  let innerFirmTree = $employeesTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('firm'))->toOne()->cast(@RoutedPropertyGraphFetchTree);


  assertSameElements([], $employeesTree.constraintsExclusions);
  assertSameElements(['duplicateEmployee'], $innerFirmTree.constraintsExclusions);

}
