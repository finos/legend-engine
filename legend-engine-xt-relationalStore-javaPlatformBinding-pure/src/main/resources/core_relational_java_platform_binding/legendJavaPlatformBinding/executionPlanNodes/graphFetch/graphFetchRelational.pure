// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::language::java::factory::*;
import meta::external::language::java::factory::project::*;
import meta::external::language::java::metamodel::*;
import meta::external::language::java::metamodel::project::*;
import meta::external::language::java::serialization::*;
import meta::external::language::java::transform::*;
import meta::pure::executionPlan::*;
import meta::pure::executionPlan::platformBinding::legendJava::*;
import meta::pure::executionPlan::platformBinding::legendJava::graphFetch::common::*;
import meta::pure::executionPlan::platformBinding::legendJava::shared::*;
import meta::pure::executionPlan::platformBinding::legendJava::shared::constraints::*;
import meta::pure::executionPlan::platformBinding::legendJava::shared::naming::*;
import meta::relational::executionPlan::platformBinding::legendJava::*;
import meta::relational::executionPlan::platformBinding::legendJava::classResult::*;
import meta::relational::executionPlan::platformBinding::legendJava::graphFetch::*;
import meta::pure::executionPlan::platformBinding::typeInfo::*;
import meta::pure::graphFetch::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::pure::graphFetch::routing::*;
import meta::pure::mapping::*;
import meta::pure::mapping::xStore::*;
import meta::pure::milestoning::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::relational::graphFetch::executionPlan::*;
import meta::relational::mapping::*;
import meta::relational::milestoning::*;

function meta::relational::executionPlan::platformBinding::legendJava::graphFetch::prepareForRelationalGraphFetch(node: RelationalGraphFetchExecutionNode[1], path: String[1], context: GenerationContext[1], debug: DebugContext[1]):GenerationContext[1]
{
   $node->match([
      r : RelationalClassQueryTempTableGraphFetchExecutionNode[1] | $r->prepareForRelationalClassQueryTempTableGraphFetch($path, $context, $debug),
      p : RelationalGraphFetchExecutionNode[1]                    | $context
   ])
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::prepareForRelationalClassQueryTempTableGraphFetch(node: RelationalClassQueryTempTableGraphFetchExecutionNode[1], path: String[1], context: GenerationContext[1], debug: DebugContext[1]):GenerationContext[1]
{
   print(if($debug.debug,|$debug.space+'('+$path+') prepareForRelationalClassQueryTempTableGraphFetch\n', |''));

   let pureType = $node->typeFromStoreLocalNode();

   let simpleType = ^SimpleJavaType(pureType = $pureType, javaType = $context.conventions->className($pureType));

   let returnType = $node->match([
      r : RelationalRootQueryTempTableGraphFetchExecutionNode[1] | if($r.checked->isTrue(), | ^CheckedJavaType(checkedOf = $simpleType), | $simpleType),
      p : RelationalClassQueryTempTableGraphFetchExecutionNode[1]| $simpleType
   ]);

   ^$context
   (
      nodeInfos = $context.nodeInfos->concatenate(
         ^NodeInfo(path = $path, returnType = $returnType)
      )
   );
}

function meta::relational::executionPlan::platformBinding::legendJava::graphFetch::generateRelationalStoreGraphFetchProject(node: RelationalGraphFetchExecutionNode[1], path: String[1], context: GenerationContext[1], extensions: Extension[*], debug: DebugContext[1]):Project[1]
{
   let specificsClass = initializeSpecificsClass($node, $path, $context, $debug)
                           ->map(s | $s->addSpecificsPrepareMethod($node, $path, $context, $debug))
                           ->map(s | $s->addSpecificsGeneralMethods($node, $path, $context, $debug))
                           ->map(s | $s->addSpecificsCachingMethods($node, $path, $context, $debug));

   let executeClass   = initializeExecuteClass($node, $specificsClass, $path, $context, $debug)
                           ->map(e | $e->addExecuteGeneralMethods($node, $path, $context, $debug))
                           ->map(e | $e->addExecuteCachingMethods($node, $path, $context, $debug));

   newProject()->addClasses([$specificsClass, $executeClass]);
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::initializeExecuteClass(node:RelationalGraphFetchExecutionNode[1], specificsClass: meta::external::language::java::metamodel::Class[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions   = $context.conventions;
   let nodeSpecifics = $conventions->className($node->match([
      rr : RelationalPrimitiveQueryGraphFetchExecutionNode[1]          | IRelationalPrimitiveQueryGraphFetchExecutionNodeSpecifics,
      rr : RelationalRootQueryTempTableGraphFetchExecutionNode[1]      | IRelationalRootQueryTempTableGraphFetchExecutionNodeSpecifics,
      cr : RelationalCrossRootQueryTempTableGraphFetchExecutionNode[1] | IRelationalCrossRootQueryTempTableGraphFetchExecutionNodeSpecifics,
      rr : RelationalClassQueryTempTableGraphFetchExecutionNode[1]     | IRelationalClassQueryTempTableGraphFetchExecutionNodeSpecifics
   ]));

   let executeClass = $conventions->planNodeClass('public', $path, 'Execute');
   $executeClass
      ->imports(javaPackage('java.util'))
      ->imports(javaPackage('java.util.function'))
      ->imports(javaPackage('java.util.stream'))
      ->imports(javaReflectMethod())
      ->imports(javaResultSet())
      ->imports(javaClass('org.eclipse.collections.api.tuple.Pair'))
      ->imports($conventions->className(IExecutionNodeContext))
      ->imports($conventions->className(GraphInstance))
      ->imports($conventions->className(IReferencedObject))
      ->imports($nodeSpecifics)->implements($nodeSpecifics)
      ->addField(
         javaField(['private'], $specificsClass, 'specifics')
      )
      ->addConstructor(
         javaConstructor(
            ['public'], [],
            j_this($executeClass)->j_field('specifics', $specificsClass)->j_assign(j_new($specificsClass, []))
         )
      );
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::addExecuteGeneralMethods(executeClass: meta::external::language::java::metamodel::Class[1], node: RelationalGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions    = $context.conventions;
   let jThis          = j_this($executeClass);
   let specificsField = $jThis->j_field('specifics');
   let isPrimitive    = $node->instanceOf(RelationalPrimitiveQueryGraphFetchExecutionNode);
   let isClassResult  = $node->instanceOf(RelationalClassQueryTempTableGraphFetchExecutionNode) && !$node->instanceOf(RelationalRootQueryTempTableGraphFetchExecutionNode);
   let isLocalRoot    = $node->instanceOf(RelationalRootQueryTempTableGraphFetchExecutionNode);
   let isCrossRoot    = $node->instanceOf(RelationalCrossRootQueryTempTableGraphFetchExecutionNode);

   let nextType = if (!$isPrimitive,
                      | graphInstanceOf(javaWildcardExtends($conventions->className(IReferencedObject)), $conventions),
                      | graphInstanceOf(javaWildcard(), $conventions)
                  );

   $executeClass
      ->addMethod($executeClass->buildPrepareMethod(['public'], $specificsField->j_invoke('prepare', [j_parameter(javaResultSet(), 'resultSet'), j_parameter(javaString(), 'databaseTimeZone'), j_parameter(javaString(), 'databaseConnection')], javaVoid())))
      ->addMethod($executeClass->buildNextGraphInstanceMethod(['public'], $nextType, j_return($specificsField->j_invoke('nextGraphInstance', [], $nextType))))
      ->map({exe |
         if ($isClassResult || $isLocalRoot || $isCrossRoot,
             | $exe
                  ->addMethod($exe->buildPrimaryKeyGettersMethod(['public'], j_return($specificsField->j_invoke('primaryKeyGetters', [], javaList(javaReflectMethod()))))),
             | $exe
         )
      })
      ->map({exe |
         if ($isCrossRoot,
             | $exe
                  ->addMethod($exe->buildMappingIdMethod(['public'], j_return($specificsField->j_invoke('mappingId', [], javaString()))))
                  ->addMethod($exe->buildSourceInstanceSetIdMethod(['public'], j_return($specificsField->j_invoke('sourceInstanceSetId', [], javaString()))))
                  ->addMethod($exe->buildTargetInstanceSetIdMethod(['public'], j_return($specificsField->j_invoke('targetInstanceSetId', [], javaString())))),
             | if ($isClassResult || $isLocalRoot,
                   | $exe
                        ->addMethod($exe->buildAllInstanceSetImplementationsMethod(['public'], j_return($specificsField->j_invoke('allInstanceSetImplementations', [], javaList(javaParameterizedType(javaClass('org.eclipse.collections.api.tuple.Pair'), [javaString(), javaString()]))))))
                        ->addMethod($exe->buildPrimaryKeyColumnsMethod(['public'], j_return($specificsField->j_invoke('primaryKeyColumns', [j_parameter(javaInt(), 'setIndex')], javaList(javaString()))))),
                   | $exe
               )
         )
      })
      ->map({exe |
         if (!$isLocalRoot,
             | $exe->addMethod($exe->buildAddChildToParentMethod(['public'], $specificsField->j_invoke('addChildToParent', [j_parameter(javaObject(), 'parent'), j_parameter(javaObject(), 'child'), j_parameter($conventions->className(IExecutionNodeContext), 'executionNodeContext')], javaVoid()), $conventions)),
             | $exe
         )
      })
      ->map({exe |
         if ($isCrossRoot,
             | $exe->addMethod($exe->buildParentCrossKeyColumnsMethod(['public'], j_return($specificsField->j_invoke('parentCrossKeyColumns', [j_parameter(javaList(javaString()), 'queryResultColumns')], javaList(javaString()))))),
             | if ($isPrimitive || $isClassResult,
                   | $exe->addMethod($exe->buildParentPrimaryKeyColumnsMethod(['public'], j_return($specificsField->j_invoke('parentPrimaryKeyColumns', [j_parameter(javaList(javaString()), 'queryResultColumns')], javaList(javaString()))))),
                   | $exe
               )
         )
      })
      ->map({exe |
         if ($isCrossRoot,
             | $exe->addMethod($exe->buildParentCrossKeyGettersMethod(['public'], j_return($specificsField->j_invoke('parentCrossKeyGetters', [], javaList(javaReflectMethod()))))),
             | $exe
         )
      });
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::addExecuteCachingMethods(executeClass: meta::external::language::java::metamodel::Class[1], node: RelationalGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let jThis          = j_this($executeClass);
   let specificsField = $jThis->j_field('specifics');
   let isLocalRoot    = $node->instanceOf(RelationalRootQueryTempTableGraphFetchExecutionNode);
   let isCrossRoot    = $node->instanceOf(RelationalCrossRootQueryTempTableGraphFetchExecutionNode);

   $executeClass->map({exe |
      if ($isLocalRoot,
          | $exe
               ->addMethod($exe->buildSupportsCachingMethod(['public'], j_return(j_boolean(true)))),
          | if ($isCrossRoot,
                | $exe
                     ->addMethod($exe->buildSupportsCrossCachingMethod(['public'], j_return($specificsField->j_invoke('supportsCrossCaching', [], javaObject()))))
                     ->addMethod($exe->buildTargetPropertiesOrderedMethod(['public'], j_return($specificsField->j_invoke('targetPropertiesOrdered', [], javaList(javaString())))))
                     ->addMethod($exe->buildParentCrossKeyGettersOrderedByTargetPropertiesMethod(['public'], j_return($specificsField->j_invoke('parentCrossKeyGettersOrderedByTargetProperties', [], javaList(javaReflectMethod()))))),
                | $exe
            )
      )
   });
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::initializeSpecificsClass(node: RelationalGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions = $context.conventions;

   let specificsClass = $context.conventions->planNodeClass([], $path, 'Specifics')
      ->imports(javaPackage('java.util'))
      ->imports(javaPackage('java.util.function'))
      ->imports(javaPackage('java.util.stream'))
      ->imports(javaReflectMethod())
      ->imports(javaResultSet())
      ->imports(javaClass('java.sql.ResultSetMetaData'))
      ->imports(javaClass('java.sql.Types'))
      ->imports(javaClass('org.eclipse.collections.impl.tuple.Tuples'))
      ->imports(javaClass('org.eclipse.collections.api.tuple.Pair'))
      ->imports($conventions->className(IExecutionNodeContext))
      ->imports($conventions->className(IConstantResult))
      ->imports($conventions->className(GraphInstance))
      ->imports($conventions->className(PureDate))
      ->addFields([
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'STRING_TYPES', 'Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'INT_TYPES', 'Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'FLOAT_TYPES', 'Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'DECIMAL_TYPES', 'Arrays.asList(Types.DECIMAL, Types.NUMERIC, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'BOOL_TYPES', 'Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'STRICT_DATE_TYPES', 'Arrays.asList(Types.DATE, Types.NULL)'),
         javaField(['private', 'static', 'final'], javaList(javaClass('java.lang.Integer')), 'DATE_TIME_TYPES', 'Arrays.asList(Types.TIMESTAMP, Types.NULL)'),
         javaField(['private'], javaResultSet(), 'resultSet'),
         javaField(['private'], javaString(), 'databaseTimeZone'),
         javaField(['private'], javaString(), 'databaseConnection'),
         javaField(['private'], javaList(javaClass('java.lang.Integer')), 'columnTypes'),
         javaField(['private'], javaList(javaList(javaClass('java.lang.Integer'))), 'propertyIndices'),
         javaField(['private'], javaList(javaList(javaSupplier(javaObject()))), 'propertyGetters'),
         javaField(['private'], javaClass('java.util.Calendar'), 'calendar'),
         javaField(['private'], javaReflectMethod(), 'parentPropertyAdder'),
         javaField(['private'], javaReflectMethod(), 'parentEdgePointPropertyAdder')
      ])
      ->addMethods([
         getAlloyNativeValueFromResultSetMethod(),
         encodeHexMethod()
      ]);
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::addSpecificsPrepareMethod(specificsClass: meta::external::language::java::metamodel::Class[1], node: RelationalGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions   = $context.conventions;
   let isComplexNode = $node.resultType->instanceOf(PartialClassResultType);
   let typeInfos     = $context.typeInfos;

   let rsetParam = j_parameter(javaResultSet(), 'resultSet');
   let tzParam   = j_parameter(javaString(), 'databaseTimeZone');
   let cParam    = j_parameter(javaString(), 'databaseConnection');

   let jThis                = j_this($specificsClass);
   let resultSetField       = $jThis->j_field('resultSet');
   let dbTimeZoneField      = $jThis->j_field('databaseTimeZone');
   let dbConnectionField    = $jThis->j_field('databaseConnection');
   let calendarField        = $jThis->j_field('calendar');
   let columnTypesField     = $jThis->j_field('columnTypes');
   let propertyIndicesField = $jThis->j_field('propertyIndices');
   let propertyGettersField = $jThis->j_field('propertyGetters');

   let javaException    = j_parameter(javaException(), 'e');
   let runtimeException = j_parameter(javaRuntimeException(), 'e');

   let resultSetMetDataVar = j_variable(javaClass('java.sql.ResultSetMetaData'), 'resultSetMetaData');
   let columnCountVar      = j_variable(javaInt(), 'columnCount');
   let columnNamesVar      = j_variable(javaList(javaString()), 'columnNames');
   let columnLabelVar      = j_variable(javaString(), 'columnLabel');
   let propertyIndexVar    = j_variable(javaInt(), 'propertyIndex');
   let propertyGetterVar   = j_variable(javaSupplier(javaObject()), 'propertyGetter');

   let enumPropertyGetterCodes = {property:AbstractProperty<Any>[1], propertyType: meta::pure::metamodel::type::Enumeration<Any>[1], currentPropertyMapping: RelationalPropertyMapping[1] |
      let javaEnumeration       =  $conventions->className($propertyType);
      let enumValueMappings     = $currentPropertyMapping.transformer->cast(@EnumerationMapping<Any>).enumValueMappings;
      let enumReverseMapVar     = j_variable(javaMap(javaObject(), javaString()), 'enumReverseMap');
      let enumResVar            = j_variable($javaEnumeration, 'res');
      let transformedR          = j_variable(javaString(), 'transformedR');
      let finalPropertyIndexVar = j_variable(javaInt(), 'finalPropertyIndex');

      let r = j_variable(javaObject(), 'r');

      j_block(
         [
            j_declare(['final'], $finalPropertyIndexVar, $propertyIndexVar),
            j_declare(['final'], $enumReverseMapVar, j_new(javaParameterizedType(javaClass('java.util.HashMap'), [javaObject(), javaString()]), []))
         ]
         ->concatenate(
            $enumValueMappings->map({ev | $ev.sourceValues->map({x |
               $enumReverseMapVar->j_invoke('put', [
                  $x->match([
                     s:String[1] | j_string($s),
                     i:Integer[1] | javaClass('java.lang.Long')->j_invoke('valueOf', j_string($i->toString()), javaLong()),
                     f:Float[1] | javaClass('java.lang.Double')->j_invoke('valueOf', j_string($f->toString()), javaDouble())
                  ]),
                  j_string($ev.enum.name)
               ], javaVoid())
            })})
         )->concatenate(
            $propertyGetterVar->j_assign(j_lambda([]->cast(@Parameter), j_try(
               [
                  $enumResVar->j_declare(j_null()),
                  $r->j_declare($jThis->j_invoke('getAlloyNativeValueFromResultSet', [$resultSetField, $finalPropertyIndexVar, $columnTypesField->j_invoke('get', [$finalPropertyIndexVar->j_minus(j_int(1))], javaInt())], javaObject())),
                  j_if(
                     $r->j_ne(j_null()),
                     [
                        $transformedR->j_declare($enumReverseMapVar->j_invoke('get', [$r], javaString())),
                        j_if(
                           $transformedR->j_eq(j_null()),
                           j_throw(j_new(javaRuntimeException(), [
                              j_string('Enumeration mapping failure. Cannot find transformation for source value \'')
                              ->j_plus($r)
                              ->j_plus(j_string('\' for enumeration property \'' + $property.name->toOne() + '\' of type ' + $propertyType->elementToPath() + ' in enumeration mapping ' + $currentPropertyMapping.transformer->cast(@EnumerationMapping<Any>).name->concatenate('{missing enum mapping}')->first()->toOne() + '.'))
                           ]))
                        ),
                        $enumResVar->j_assign(javaClass('java.lang.Enum')->j_invoke('valueOf', [$javaEnumeration->j_classField(), $transformedR], $javaEnumeration))
                     ]
                  ),
                  j_return($enumResVar)
               ],
               j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
            )))
         )
      );
   };

   let i = j_variable(javaInt(), 'i');

   $specificsClass
      ->addMethods([
         getResultSetPropertyGetterForStringPropertyMethod(),
         getResultSetPropertyGetterForIntegerPropertyMethod(),
         getResultSetPropertyGetterForFloatPropertyMethod(),
         getResultSetPropertyGetterForDecimalPropertyMethod(),
         getResultSetPropertyGetterForBooleanPropertyMethod(),
         getResultSetPropertyGetterForStrictDatePropertyMethod(),
         getResultSetPropertyGetterForDateTimePropertyMethod(),
         getResultSetPropertyGetterForDatePropertyMethod()
      ])
      ->addMethod(
         $specificsClass->buildPrepareMethod(
            [],
            j_try(
               [
                  $resultSetField->j_assign($rsetParam),
                  $dbTimeZoneField->j_assign($tzParam),
                  $dbConnectionField->j_assign($cParam),
                  $calendarField->j_assign(j_new(javaClass('java.util.GregorianCalendar'), [javaClass('java.util.TimeZone')->j_invoke('getTimeZone', [$dbTimeZoneField], javaClass('java.util.TimeZone'))])),
                  $resultSetMetDataVar->j_declare($resultSetField->j_invoke('getMetaData', [], javaClass('java.sql.ResultSetMetaData'))),
                  $columnCountVar->j_declare($resultSetMetDataVar->j_invoke('getColumnCount', [], javaInt())),
                  $columnTypesField->j_assign(j_new(javaArrayList(javaClass('java.lang.Integer')), [])),
                  $columnNamesVar->j_declare(j_new(javaArrayList(javaString()), [])),
                  j_for($i->j_declare(j_int(1)), $i->j_le($columnCountVar), $i->j_inc(),
                     [
                        $columnLabelVar->j_declare($resultSetMetDataVar->j_invoke('getColumnLabel', [$i], javaString())),
                        $columnNamesVar->j_invoke(
                           'add',
                           $columnLabelVar->j_invoke('startsWith', [j_string('"')], javaBoolean())->j_and($columnLabelVar->j_invoke('endsWith', [j_string('"')], javaBoolean()))->j_conditional(
                              $columnLabelVar->j_invoke('substring', [j_int(1), $columnLabelVar->j_invoke('length', [], javaInt())->j_minus(j_int(1))], javaString())->j_invoke('toUpperCase', [], javaString()),
                              $columnLabelVar->j_invoke('toUpperCase', [], javaString())
                           ), javaVoid()),
                        $columnTypesField->j_invoke('add', [$resultSetMetDataVar->j_invoke('getColumnType', [$i], javaInt())], javaVoid())
                     ]
                  )
               ]->concatenate(
                  if ($isComplexNode,
                     {|
                        let partialClassResultType = $node.resultType->cast(@PartialClassResultType);
                        let resultClass = $node->typeFromStoreLocalNode()->cast(@meta::pure::metamodel::type::Class<Any>);
                        let sets = $partialClassResultType.setImplementations->cast(@RelationalInstanceSetImplementation);
                        let nonExplodingSimplePrimitiveProperties = $typeInfos->allProperties($typeInfos->forClass($resultClass))->filter(x | $x->isPrimitiveValueProperty() && (!$x->hasGeneratedMilestoningPropertyStereotype()) && $x->functionReturnMultiplicity()->hasToOneUpperBound())->filter(x | $x->in($partialClassResultType.propertiesWithParameters.property));

                        [
                           $propertyIndicesField->j_assign(j_new(javaArrayList(javaList(javaInt())), []))
                        ]->concatenate(
                           $sets->size()->range()->map({s |
                              let currentSet = $sets->at($s);
                              let currentSetPks = if (!$currentSet->instanceOf(RootRelationalInstanceSetImplementation) || ($currentSet->cast(@RootRelationalInstanceSetImplementation)->meta::relational::functions::pureToSqlQuery::getGroupBy()->isEmpty() && ($currentSet->cast(@RootRelationalInstanceSetImplementation)->meta::relational::functions::pureToSqlQuery::getDistinct()->isEmpty() || $currentSet->cast(@RootRelationalInstanceSetImplementation)->meta::relational::functions::pureToSqlQuery::getDistinct()->toOne() == false)),
                                                      | $currentSet->resolvePrimaryKey(),
                                                      | []);
                              let addMilestoningProps = getTemporalMilestoningStrategy($currentSet.class)->isNotEmpty() &&
                                                        getTemporalMilestoningStrategy($currentSet.class)->toOne()->expandToSingleTemporalStrategies()->forAll(s| $s->relationalElementCanSupportStrategy($currentSet->resolveMainTable()));

                              let index_s = j_variable(javaList(javaInt()), 'index_' + $s->toString());
                              [
                                 $index_s->j_declare(j_new(javaArrayList(javaInt()), []))
                              ]->concatenate(
                                 $nonExplodingSimplePrimitiveProperties
                                    ->map({p | $index_s->j_invoke('add', [$columnNamesVar->j_invoke('indexOf', [j_string($p.name->toOne()->toUpper())], javaInt())->j_plus(j_int(1))], javaVoid())})
                              )
                              ->concatenate($addMilestoningProps->if(
                                 | let milestonedPropertyAliases = getTemporalMilestoningStrategy($currentSet.class)->toOne()->expandToSingleTemporalStrategies()->map(x | $x->temporalColumnAliasProperties()).second->sort();
                                   $milestonedPropertyAliases->map({x | $index_s->j_invoke('add', [$columnNamesVar->j_invoke('indexOf', [j_string($x->toUpper())], javaInt())->j_plus(j_int(1))], javaVoid())});,
                                 | [])
                              )
                              ->concatenate(
                                 $currentSetPks->size()->range()
                                    ->map({pkIdx | $index_s->j_invoke('add', [$columnNamesVar->j_invoke('indexOf', [j_string('PK_' + $pkIdx->toString() + if($sets->size() == 1, | '', | '_' + $s->toString()))], javaInt())->j_plus(j_int(1))], javaVoid())})
                              )
                              ->concatenate(
                                 [
                                    $propertyIndicesField->j_invoke('add', [$index_s], javaVoid())
                                 ]
                              );
                           })
                        )->concatenate(
                           [
                              $node->graphImplClass($path, $context)->j_field(databaseConnectionPropertyName(), javaString())->j_assign($cParam),
                              $propertyGettersField->j_assign(j_new(javaArrayList(javaList(javaSupplier(javaObject()))), [])),
                              $propertyIndexVar->j_declare(),
                              $propertyGetterVar->j_declare(j_null())
                           ]
                        )->concatenate(
                           $sets->size()->range()->map({s |
                              let currentSet = $sets->at($s);
                              let currentSetPks = if (!$currentSet->instanceOf(RootRelationalInstanceSetImplementation) || ($currentSet->cast(@RootRelationalInstanceSetImplementation)->meta::relational::functions::pureToSqlQuery::getGroupBy()->isEmpty() && ($currentSet->cast(@RootRelationalInstanceSetImplementation)->meta::relational::functions::pureToSqlQuery::getDistinct()->isEmpty() || $currentSet->cast(@RootRelationalInstanceSetImplementation)->meta::relational::functions::pureToSqlQuery::getDistinct()->toOne() == false)),
                                                      | $currentSet->resolvePrimaryKey(),
                                                      | []);
                              let addMilestoningProps = getTemporalMilestoningStrategy($currentSet.class)->isNotEmpty() &&
                                                        getTemporalMilestoningStrategy($currentSet.class)->toOne()->expandToSingleTemporalStrategies()->forAll(s| $s->relationalElementCanSupportStrategy($currentSet->resolveMainTable()));
                              let allProperties = $nonExplodingSimplePrimitiveProperties->concatenate($addMilestoningProps->if(|$sets->at($s).class.properties->filter(p| $p->isPrimitiveValueProperty() && $p->hasGeneratedMilestoningPropertyStereotype()), |[])->sortBy(x | $x.name->toOne()));
                              let propertyGetter_s = j_variable(javaList(javaSupplier(javaObject())), 'propertyGetter_' + $s->toString());

                              [
                                 $propertyGetter_s->j_declare(j_new(javaArrayList(javaSupplier(javaObject())), []))
                              ]->concatenate(
                                 $allProperties->size()->range()->map({propIndex |
                                    let prop = $allProperties->at($propIndex);
                                    let propertyName = $prop.name->toOne();
                                    let propertyType = $prop->functionReturnType().rawType->toOne();
                                    let propertyMultiplicity = $prop.multiplicity;

                                    [
                                       $propertyIndexVar->j_assign($propertyIndicesField->j_invoke('get', [j_int($s)], javaList(javaInt()))->j_invoke('get', [j_int($propIndex)], javaInt()))
                                    ]->concatenate(
                                       if ($propertyType->in([String, Integer, Float, Decimal, Boolean, StrictDate, DateTime, Date]),
                                          {|
                                             $propertyGetterVar->j_assign($jThis->j_invoke('getResultSetPropertyGetterFor' + $propertyType.name->toOne() + 'Property', [
                                                $resultSetField,
                                                $propertyIndexVar,
                                                $resultSetMetDataVar->j_invoke('getColumnType', [$propertyIndexVar], javaInt()),
                                                j_string($propertyName)
                                             ], javaSupplier(javaObject())))
                                          },
                                          {|
                                             if ($propertyType->instanceOf(meta::pure::metamodel::type::Enumeration),
                                                {|
                                                   let allPropertyMappings = $sets->at($s)->cast(@InstanceSetImplementation).allPropertyMappings()->filter(pm | $pm.property->instanceOf(Property) && $pm.property->functionReturnType().rawType->toOne()->instanceOf(meta::pure::metamodel::type::DataType));
                                                   let currentPropertyMapping = $allPropertyMappings->filter(x | $x.property == $prop)->toOne()->cast(@RelationalPropertyMapping);
                                                   $enumPropertyGetterCodes->eval($prop, $propertyType, $currentPropertyMapping);
                                                },
                                                {|
                                                   [
                                                      j_throw(j_new(javaRuntimeException(), [j_string('Type : \'' + $propertyType->elementToPath() + '\' not supported yet!')]))
                                                   ]
                                                }
                                             );
                                          }
                                       )
                                    )->concatenate(
                                       [
                                          $propertyGetter_s->j_invoke('add', $propertyGetterVar, javaVoid())
                                       ]
                                    );
                                 })
                              )
                              ->concatenate(
                                 [
                                    $propertyGettersField->j_invoke('add', $propertyGetter_s, javaVoid())
                                 ]
                              );
                           })
                        );
                     },
                     {|
                        let property = $node.graphFetchTree->cast(@PropertyGraphFetchTree).property;
                        let propertyName = $property.name->toOne();
                        let propertyType = $property->functionReturnType().rawType->toOne();

                        [
                           $propertyIndexVar->j_declare($columnNamesVar->j_invoke('indexOf', [j_string('NODE_' + $node.nodeIndex->toString() + '_RESULT')], javaInt())->j_plus(j_int(1))),
                           $propertyIndicesField->j_assign(javaArrays()->j_invoke('asList', [javaArrays()->j_invoke('asList', [$propertyIndexVar], javaList(javaWildcard()))], javaList(javaWildcard()))),
                           $propertyGetterVar->j_declare(j_null())
                        ]->concatenate(
                           if ($propertyType->in([String, Integer, Float, Decimal, Boolean, StrictDate, DateTime, Date]),
                              {|
                                 $propertyGetterVar->j_assign($jThis->j_invoke('getResultSetPropertyGetterFor' + $propertyType.name->toOne() + 'Property', [
                                    $resultSetField,
                                    $propertyIndexVar,
                                    $resultSetMetDataVar->j_invoke('getColumnType', [$propertyIndexVar], javaInt()),
                                    j_string($propertyName)
                                 ], javaSupplier(javaObject())))
                              },
                              {|
                                 if ($propertyType->instanceOf(meta::pure::metamodel::type::Enumeration),
                                    {|
                                       let currentPropertyMapping = $node.graphFetchTree->cast(@RoutedPropertyGraphFetchTree).propertyMapping->at(0)->cast(@RelationalPropertyMapping);
                                       $enumPropertyGetterCodes->eval($property, $propertyType, $currentPropertyMapping);
                                    },
                                    {|
                                       [
                                          j_throw(j_new(javaRuntimeException(), [j_string('Type : \'' + $propertyType->elementToPath() + '\' not supported yet!')]))
                                       ]
                                    }
                                 );
                              }
                           )
                        )->concatenate(
                           [
                              $propertyGettersField->j_assign(javaArrays()->j_invoke('asList', [javaArrays()->j_invoke('asList', [$propertyGetterVar], javaList(javaWildcard()))], javaList(javaWildcard())))
                           ]
                        );
                     }
                  )
               )->toOneMany(),
               j_catch($runtimeException, j_throw($javaException)),
               j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
            )
         )
      );
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::addSpecificsGeneralMethods(specificsClass: meta::external::language::java::metamodel::Class[1], node: RelationalGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions    = $context.conventions;
   let isComplexNode  = $node.resultType->instanceOf(PartialClassResultType);
   let typeInfos      = $context.typeInfos;
   let isPrimitive    = $node->instanceOf(RelationalPrimitiveQueryGraphFetchExecutionNode);
   let isClassResult  = $node->instanceOf(RelationalClassQueryTempTableGraphFetchExecutionNode) && !$node->instanceOf(RelationalRootQueryTempTableGraphFetchExecutionNode);
   let isLocalRoot    = $node->instanceOf(RelationalRootQueryTempTableGraphFetchExecutionNode);
   let isCrossRoot    = $node->instanceOf(RelationalCrossRootQueryTempTableGraphFetchExecutionNode);
   let isComplex      = $isClassResult || $isLocalRoot || $isCrossRoot;

   let jThis                = j_this($specificsClass);
   let resultSetField       = $jThis->j_field('resultSet');
   let dbTimeZoneField      = $jThis->j_field('databaseTimeZone');
   let dbConnectionField    = $jThis->j_field('databaseConnection');
   let calendarField        = $jThis->j_field('calendar');
   let columnTypesField     = $jThis->j_field('columnTypes');
   let propertyIndicesField = $jThis->j_field('propertyIndices');
   let propertyGettersField = $jThis->j_field('propertyGetters');

   let javaException    = j_parameter(javaException(), 'e');
   let runtimeException = j_parameter(javaRuntimeException(), 'e');

   let nextType = if (!$isPrimitive,
                      | graphInstanceOf(javaWildcardExtends($conventions->className(IReferencedObject)), $conventions),
                      | graphInstanceOf(javaWildcard(), $conventions)
                  );

   $specificsClass
      ->addMethod(
         $specificsClass->buildNextGraphInstanceMethod(
            [],
            $nextType,
            j_try(
               if ($isComplex,
                  {|
                     let partialClassResultType    = $node.resultType->cast(@PartialClassResultType);
                     let resultClass               = $node->typeFromStoreLocalNode()->cast(@meta::pure::metamodel::type::Class<Any>);
                     let implClass                 = $node->graphImplClass($path, $context);
                     let sets                      = $partialClassResultType.setImplementations->cast(@RelationalInstanceSetImplementation);
                     let simplePrimitiveProperties = $typeInfos->allProperties($typeInfos->forClass($resultClass))->filter(x | $x->isPrimitiveValueProperty() && (!$x->hasGeneratedMilestoningPropertyStereotype()) && $x->functionReturnMultiplicity()->hasToOneUpperBound())->filter(x | $x->in($partialClassResultType.propertiesWithParameters.property));

                     if ($sets->size() == 1,
                        {|
                           let addMilestoningProps = getTemporalMilestoningStrategy($sets->at(0).class)->isNotEmpty() &&
                                                     getTemporalMilestoningStrategy($sets->at(0).class)->toOne()->expandToSingleTemporalStrategies()->forAll(s| $s->relationalElementCanSupportStrategy($sets->at(0)->resolveMainTable()));
                           $specificsClass->objectCreationCodes($implClass, $sets->at(0), $sets, $simplePrimitiveProperties->concatenate($addMilestoningProps->if(| $sets->at(0).class.properties->filter(x | $x->isPrimitiveValueProperty() && $x->hasGeneratedMilestoningPropertyStereotype())->sortBy(x | $x.name->toOne()) , | [])), 0, $context)
                              ->concatenate(
                                 [
                                    j_return(j_newAnon(graphInstanceOf($implClass, $conventions), [],
                                       [
                                          j_method(['public'], $implClass, 'getValue', [], [j_return(j_variable($implClass, 'object'))]),
                                          j_method(['public'], javaLong(), 'instanceSize', [], [j_return(j_variable($implClass, 'object')->j_invoke($conventions->getterName(instanceSizeIdentifier()), [], javaLong()))])
                                       ]
                                    ))
                                 ]
                              );
                        },
                        {|
                           $sets->size()->range()->map({s |
                              let addMilestoningProps = getTemporalMilestoningStrategy($sets->at($s).class)->isNotEmpty() &&
                                                        getTemporalMilestoningStrategy($sets->at($s).class)->toOne()->expandToSingleTemporalStrategies()->forAll(k| $k->relationalElementCanSupportStrategy($sets->at($s)->resolveMainTable()));

                              let objectCreationCodes = $specificsClass->objectCreationCodes($implClass, $sets->at($s), $sets, $simplePrimitiveProperties->concatenate($addMilestoningProps->if(| $sets->at($s).class.properties->filter(x | $x->isPrimitiveValueProperty() && $x->hasGeneratedMilestoningPropertyStereotype())->sortBy(x | $x.name->toOne()) , | [])), $s, $context);

                               [
                                  j_if(
                                     $resultSetField->j_invoke('getInt', j_int(1), javaInt())->j_eq(j_int($s)),
                                     $objectCreationCodes->concatenate(
                                        j_return(j_newAnon(graphInstanceOf($implClass, $conventions), [],
                                           [
                                              j_method(['public'], $implClass, 'getValue', [], [j_return(j_variable($implClass, 'object'))]),
                                              j_method(['public'], javaLong(), 'instanceSize', [], [j_return(j_variable($implClass, 'object')->j_invoke($conventions->getterName(instanceSizeIdentifier()), [], javaLong()))])
                                           ]
                                        ))
                                     )->toOneMany()
                                  )
                               ];
                            })->concatenate(
                               j_return(j_null())
                            );
                        }
                     );
                  },
                  {|
                     let property     = $node.graphFetchTree->cast(@PropertyGraphFetchTree).property;
                     let propertyName = $property.name->toOne();
                     let propertyType = $property->functionReturnType().rawType->toOne();

                     let typeMap = newMap([
                        pair(String,     pair(javaString(), j_long(20))),
                        pair(Integer,    pair(javaLong()->toBoxed(), j_long(20))),
                        pair(Float,      pair(javaDouble()->toBoxed(), j_long(20))),
                        pair(Decimal,    pair(javaBigDecimal(), j_long(88))),
                        pair(Boolean,    pair(javaBoolean()->toBoxed(), j_long(13))),
                        pair(StrictDate, pair($conventions->className(PureDate), j_long(60))),
                        pair(DateTime,   pair($conventions->className(PureDate), j_long(60))),
                        pair(Date,       pair($conventions->className(PureDate), j_long(60)))
                     ]);
                     if ($propertyType->in([String, Integer, Float, Decimal, Boolean, StrictDate, DateTime, Date]),
                        {|
                           let javaTypeAndSize = $typeMap->get($propertyType)->toOne();
                           let javaType        = $javaTypeAndSize.first;
                           let objectVar       = j_variable($javaType, 'object');
                           [
                              j_declare(['final'], $objectVar, [j_cast([$propertyGettersField->j_invoke('get', [j_int(0)], javaList(javaSupplier(javaObject())))->j_invoke('get', [j_int(0)], javaSupplier(javaObject()))->j_invoke('get', [], javaObject())], $javaType)]),
                              j_return(j_newAnon(graphInstanceOf($javaType, $conventions), [],
                                 [
                                    j_method(['public'], $javaType, 'getValue', [], [j_return($objectVar)]),
                                    j_method(['public'], javaLong(), 'instanceSize', [], [j_return($javaTypeAndSize.second)])
                                 ]
                              ))
                           ];
                        },
                        {|
                           if ($propertyType->instanceOf(meta::pure::metamodel::type::Enumeration),
                              {|
                                 let javaEnumeration = $conventions->className($propertyType);
                                 let objectVar       = j_variable($javaEnumeration, 'object');
                                 [
                                    j_declare(['final'], $objectVar, [j_cast([$propertyGettersField->j_invoke('get', [j_int(0)], javaList(javaSupplier(javaObject())))->j_invoke('get', [j_int(0)], javaSupplier(javaObject()))->j_invoke('get', [], javaObject())], $javaEnumeration)]),
                                    j_return(j_newAnon(graphInstanceOf($javaEnumeration, $conventions), [],
                                       [
                                          j_method(['public'], $javaEnumeration, 'getValue', [], [j_return($objectVar)]),
                                          j_method(['public'], javaLong(), 'instanceSize', [], [j_return(j_long(4))])
                                       ]
                                    ))
                                 ];
                              },
                              {|
                                 [
                                    j_throw(j_new(javaRuntimeException(), [j_string('Type : \'' + $propertyType->elementToPath() + '\' not supported yet!')]))
                                 ]
                              }
                           );
                        }
                     );
                  }
               )->toOneMany(),
               j_catch($runtimeException, j_throw($runtimeException)),
               j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
            )
         )
      )
      ->map({spe |
         if ($isComplex,
            {|
               let currentSets = $node.resultType->cast(@PartialClassResultType).setImplementations;
               let currentKeyStrings = $currentSets->map({set |
                  let setIdx = $currentSets->indexOf($set);
                  let setPk = $set->cast(@RelationalInstanceSetImplementation)->resolvePrimaryKey();
                  $setPk->map(x | 'pk$_' + $setPk->indexOf($x)->toString() + if($currentSets->size() == 1, | '', | '_' + $setIdx->toString()));
               });
               $spe->addMethod(
                  $spe->buildPrimaryKeyGettersMethod(
                     [],
                     [
                        j_try(
                           j_return(javaArrays()->j_invoke('asList', $currentKeyStrings->map({x | $node->graphImplClass($path, $context)->j_classField()->j_invoke('getMethod', [j_string($conventions->getterName($x))], javaReflectMethod())}), javaList(javaReflectMethod()))),
                           j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
                        )
                     ]
                  )
               );
            },
            {| $spe }
         )
      })
      ->map({spe |
         if (($isClassResult || $isLocalRoot) && !$isCrossRoot,
            {|
               let partialClassResultType = $node.resultType->cast(@PartialClassResultType);
               let resultClass            = $node->typeFromStoreLocalNode()->cast(@meta::pure::metamodel::type::Class<Any>);
               let sets                   = $partialClassResultType.setImplementations->cast(@RelationalInstanceSetImplementation);
               let pairType               = javaParameterizedType(javaClass('org.eclipse.collections.api.tuple.Pair'), [javaString(), javaString()]);

               let currentSets            = $node.resultType->cast(@PartialClassResultType).setImplementations;
               let setIndexParam          = j_parameter(javaInt(), 'setIndex');
               let keyStringsFunction     = {set: RelationalInstanceSetImplementation[1] |
                  let setIdx = $currentSets->indexOf($set);
                  let setPk  = $set->resolvePrimaryKey();
                  $setPk->map(x | 'pk_' + $setPk->indexOf($x)->toString() + if($currentSets->size() == 1, | '', | '_' + $setIdx->toString()))->map(x | j_string($x));
               };

               $spe
                  ->addMethod(
                     $spe->buildAllInstanceSetImplementationsMethod(
                        [],
                        j_return(javaArrays()->j_invoke('asList', $sets->map(s | javaClass('org.eclipse.collections.impl.tuple.Tuples')->j_invoke('pair', [j_string($s.parent->elementToPath()), j_string($s.id)], $pairType)), javaList($pairType)))
                     )
                  )
                  ->addMethod(
                     $spe->buildPrimaryKeyColumnsMethod(
                        [],
                        $sets->map(s | j_if($setIndexParam->j_eq(j_int($sets->indexOf($s))), j_return(javaArrays()->j_invoke('asList', $keyStringsFunction->eval($s), javaList(javaString())))))->concatenate(j_return(j_null()))
                     )
                  );
            },
            {| if ($isCrossRoot,
                  {|
                     let xStorePropertyMapping = $node->cast(@RelationalCrossRootQueryTempTableGraphFetchExecutionNode).graphFetchTree->cast(@RoutedPropertyGraphFetchTree).propertyMapping->toOne()->cast(@XStorePropertyMapping);
                     $spe
                        ->addMethod($spe->buildMappingIdMethod(['public'], j_return(j_string($xStorePropertyMapping.owner.parent->toOne()->elementToPath()))))
                        ->addMethod($spe->buildSourceInstanceSetIdMethod(['public'], j_return(j_string($xStorePropertyMapping.sourceSetImplementationId))))
                        ->addMethod($spe->buildTargetInstanceSetIdMethod(['public'], j_return(j_string($xStorePropertyMapping.targetSetImplementationId))));
                  },
                  {| $spe }
               )
            }
         )
      })
      ->map({spe |
         if (!$isLocalRoot,
            {|
               let property                   = $node.graphFetchTree->cast(@PropertyGraphFetchTree).property;
               let parentPropertyAdderField   = $jThis->j_field('parentPropertyAdder');
               let parentEdgePointAdder       = $jThis->j_field('parentEdgePointPropertyAdder');
               let contextParam               = j_parameter($conventions->className(IExecutionNodeContext), 'executionNodeContext');
               let parentParam                = j_parameter(javaObject(), 'parent');
               let childParam                 = j_parameter(javaObject(), 'child');

               let valueExtractor = {x: VariableExpression[1] |
                  let javaType = $conventions->pureTypeToJavaType($x.genericType.rawType->toOne(), PureOne);
                  let typeArg  = if($javaType->isJavaList(), |$contextParam->j_invoke('listType', $javaType->elementType()->toBoxed()->j_classField()), |$javaType->toBoxed()->j_classField());
                  j_cast(
                     $contextParam->j_invoke('getResult', [j_string($x.name), $typeArg], $javaType),
                     $javaType
                 );
               };

               let paramsCodes = $node.graphFetchTree->cast(@PropertyGraphFetchTree).parameters->evaluateAndDeactivate()->map({x |
                  let valCodes = $x->match([
                     iv : InstanceValue[1] | $iv.values->map(x | if($x->instanceOf(VariableExpression), | $valueExtractor->eval($x), | $conventions->primitiveLiteral($x))),
                     v  : VariableExpression[1] | $valueExtractor->eval($v)
                  ]);
                  let param = $property->functionType().parameters->evaluateAndDeactivate()->tail()->at($node.graphFetchTree->cast(@PropertyGraphFetchTree).parameters->evaluateAndDeactivate()->indexOf($x));
                  if($param.multiplicity->hasToOneUpperBound(), | $valCodes->isEmpty()->if(|j_null(), | $valCodes->toOne()), | javaArrays()->j_invoke('asList', $valCodes, javaList(javaObject())));
               });

               let primitiveTypes = [String, Boolean, Integer, Float, Decimal, Number, StrictDate, DateTime, Date];
               let boxedPrimitiveTypes = $primitiveTypes->map(x | $conventions->pureTypeToJavaType($x, ZeroOne));

               let paramsClassesCodes = $node.graphFetchTree->cast(@PropertyGraphFetchTree).parameters->evaluateAndDeactivate()->map({x |
                  let paramType = $x.genericType.rawType->toOne();
                  let param = $property->functionType().parameters->evaluateAndDeactivate()->tail()->at($node.graphFetchTree->cast(@PropertyGraphFetchTree).parameters->evaluateAndDeactivate()->indexOf($x));
                  if($param.multiplicity->hasToOneUpperBound(),
                     | $conventions->pureTypeToJavaType($paramType, $param.multiplicity),
                     | javaClass('java.util.List')
                  )->j_classField();
               });

               let fieldType = $conventions->pureTypeToJavaType($property);
               let singlePropertyType = if ($property->functionReturnMultiplicity()->hasToOneUpperBound(), | $fieldType, | $fieldType->cast(@meta::external::language::java::metamodel::ParameterizedType).typeArguments->at(0));

               $spe->addMethod(
                  $spe->buildAddChildToParentMethod(
                     [],
                     j_try(
                        [
                           j_if(
                              $parentPropertyAdderField->j_eq(j_null()),
                              $parentPropertyAdderField->j_assign($parentParam->j_invoke('getClass', [], javaClassType())->j_invoke('getMethod', [j_string('add' + $conventions->fieldName($property)->toUpperFirstCharacter()->toOne())]->concatenate($paramsClassesCodes)->concatenate($singlePropertyType->j_classField()), javaReflectMethod()))
                           ),
                           $parentPropertyAdderField->j_invoke('invoke', [$parentParam]->concatenate($paramsCodes)->concatenate($childParam), javaVoid())
                        ]->concatenate(
                           if ($property->instanceOf(QualifiedProperty) && $property->hasGeneratedMilestoningPropertyStereotype(),
                               | [
                                    j_if(
                                       $parentEdgePointAdder->j_eq(j_null()),
                                       $parentEdgePointAdder->j_assign($parentParam->j_invoke('getClass', [], javaClassType())->j_invoke('getMethod', [j_string('add' + $conventions->fieldName($property->edgePointPropertyName()->toOne())->toUpperFirstCharacter()->toOne())]->concatenate($singlePropertyType->j_classField()), javaReflectMethod()))
                                    ),
                                    $parentEdgePointAdder->j_invoke('invoke', [$parentParam]->concatenate($childParam), javaVoid())
                                 ],
                               | []
                           )
                        )->toOneMany(),
                        j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
                     ),
                     $conventions
                  )
               );
            },
            {| $spe }
         )
      })
      ->map({spe |
         let resultColumnsParam = j_parameter(javaList(javaString()), 'queryResultColumns');
         let lambda_x = j_parameter(javaString(), 'x');

         if (($isPrimitive || $isClassResult) && !$isCrossRoot,
             {|
                $spe->addMethod(
                   $spe->buildParentPrimaryKeyColumnsMethod(
                      [],
                      j_return($resultColumnsParam->j_streamOf()->js_filter(j_lambda($lambda_x, $lambda_x->j_invoke('toUpperCase', [], javaString())->j_invoke('startsWith', [j_string('PARENT_KEY_GEN_')], javaBoolean())))->j_invoke('collect', javaCollectors()->j_invoke('toList', [], javaCollector()), javaList(javaString())))
                   )
               )
            },
            {|
               if ($isCrossRoot,
                  {|
                     $spe->addMethod(
                        $spe->buildParentCrossKeyColumnsMethod(
                           [],
                           j_return($resultColumnsParam->j_streamOf()->js_filter(j_lambda($lambda_x, $lambda_x->j_invoke('toUpperCase', [], javaString())->j_invoke('startsWith', [j_string('PARENT_CROSS_KEY_')], javaBoolean())))->j_invoke('collect', javaCollectors()->j_invoke('toList', [], javaCollector()), javaList(javaString())))
                        )
                     )
                  },
                  {| $spe }
               )
            }
         );
      })
      ->map({spe |
         if ($isCrossRoot,
            {|
               let xStorePropertyMapping = $node->cast(@RelationalCrossRootQueryTempTableGraphFetchExecutionNode).graphFetchTree->cast(@RoutedPropertyGraphFetchTree).propertyMapping->toOne()->cast(@XStorePropertyMapping);
               let currentClass          = $node->typeFromStoreLocalNode()->cast(@meta::pure::metamodel::type::Class<Any>);
               let allProperties         = $xStorePropertyMapping.crossExpression.expressionSequence->evaluateAndDeactivate()->toOne()->findPropertiesInValueSpecification();
               let currentProperties     = $allProperties->filter(x | $x.owner->cast(@meta::pure::metamodel::type::Class<Any>)->_subTypeOf($currentClass) || $currentClass->_subTypeOf($x.owner->cast(@meta::pure::metamodel::type::Class<Any>)));
               let parentProperties      = $allProperties->filter(x | !$x->in($currentProperties));

               $spe->addMethod(
                  $spe->buildParentCrossKeyGettersMethod(
                     [],
                     j_try(
                        [
                           j_return(javaArrays()->j_invoke('asList', $parentProperties->map({x | $conventions->className($x.owner->cast(@meta::pure::metamodel::type::Class<Any>))->j_classField()->j_invoke('getMethod', [j_string($conventions->getterName($x))], javaReflectMethod())}), javaList(javaReflectMethod())))
                        ],
                        j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
                     )
                  )
               );
            },
            {| $spe }
         )
      });
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::addSpecificsCachingMethods(specificsClass: meta::external::language::java::metamodel::Class[1], node: RelationalGraphFetchExecutionNode[1], path:String[1], context:GenerationContext[1], debug:DebugContext[1]):meta::external::language::java::metamodel::Class[1]
{
   let conventions   = $context.conventions;
   let isLocalRoot   = $node->instanceOf(RelationalRootQueryTempTableGraphFetchExecutionNode);
   let isCrossRoot   = $node->instanceOf(RelationalCrossRootQueryTempTableGraphFetchExecutionNode);

   $specificsClass->map({exe |
      if ($isCrossRoot,
         {|
            let crossRootNode = $node->cast(@RelationalCrossRootQueryTempTableGraphFetchExecutionNode);
            let tree          = $crossRootNode.graphFetchTree;
            let xStoreMapping = $tree->cast(@RoutedPropertyGraphFetchTree).propertyMapping->toOne()->cast(@XStorePropertyMapping);
            let isMultiEqual  = $xStoreMapping.crossExpression.expressionSequence->evaluateAndDeactivate()->toOne()->isExpressionMultiEqual();
            let propertyPairs = if ($isMultiEqual, | $xStoreMapping.crossExpression.expressionSequence->evaluateAndDeactivate()->toOne()->propertyOrNoArgQualifierPairsInMultiEqual(), | []);
            let javaException = j_parameter(javaException(), 'e');

            $exe
               ->addMethod($specificsClass->buildSupportsCrossCachingMethod([],$isMultiEqual->j_boolean()->j_return()))
               ->addMethod(
                  $specificsClass->buildTargetPropertiesOrderedMethod(
                     [],
                     if ($isMultiEqual,
                         | javaArrays()->j_invoke('asList', $propertyPairs->sortBy(x | $x.second.name->toOne()).second->map(x | $x.name->toOne())->map(x | $x->j_string()), javaList(javaString()))->j_return(),
                         | j_null()->j_return()
                     )
                  )
               )
               ->addMethod(
                  $specificsClass->buildParentCrossKeyGettersOrderedByTargetPropertiesMethod(
                     [],
                     if ($isMultiEqual,
                         | j_try(
                              [
                                 javaArrays()->j_invoke('asList', $propertyPairs->sortBy(x | $x.second.name->toOne()).first->map({x | $conventions->className($x.owner->cast(@meta::pure::metamodel::type::Class<Any>))->j_classField()->j_invoke('getMethod', [j_string($conventions->getterName($x))], javaReflectMethod())}), javaList(javaReflectMethod()))->j_return()
                              ],
                              j_catch($javaException, j_throw(j_new(javaRuntimeException(), [$javaException])))
                           ),
                         | j_null()->j_return()
                     )
                  )
               );
         },
         {| $exe }
       )
   });
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::objectCreationCodes(specificsClass: meta::external::language::java::metamodel::Class[1], implClass: meta::external::language::java::metamodel::Class[1], set: RelationalInstanceSetImplementation[1], allSets: RelationalInstanceSetImplementation[*], properties: Property<Nil,Any|*>[*], index: Integer[1], context:GenerationContext[1]):Code[*]
{
   let conventions = $context.conventions;
   let jThis = j_this($specificsClass);
   let calendarField = $jThis->j_field('calendar');
   let columnTypesField = $jThis->j_field('columnTypes');
   let propertyIndicesField = $jThis->j_field('propertyIndices');
   let propertyGettersField = $jThis->j_field('propertyGetters');

   let resParam = j_parameter(javaType('java.sql.ResultSet'), 'resultSet');

   let currentSetPks = if (!$set->instanceOf(RootRelationalInstanceSetImplementation) || ($set->cast(@RootRelationalInstanceSetImplementation)->meta::relational::functions::pureToSqlQuery::getGroupBy()->isEmpty() && ($set->cast(@RootRelationalInstanceSetImplementation)->meta::relational::functions::pureToSqlQuery::getDistinct()->isEmpty() || $set->cast(@RootRelationalInstanceSetImplementation)->meta::relational::functions::pureToSqlQuery::getDistinct()->toOne() == false)),
                           | $set->resolvePrimaryKey(),
                           | []);

   let propertyCount = $properties->size();
   let pureTypeToJavaTypeMap = newMap([
      pair(String, javaString()),
      pair(Integer, javaLong()->toBoxed()),
      pair(Float, javaDouble()->toBoxed()),
      pair(Decimal, javaBigDecimal()),
      pair(Boolean, javaBoolean()->toBoxed()),
      pair(StrictDate, $conventions->className(PureDate)),
      pair(DateTime, $conventions->className(PureDate)),
      pair(Date, $conventions->className(PureDate))
   ]);

   let object = j_variable($implClass, 'object');
   let connectionParam = j_parameter(javaString(), 'databaseConnection');
   let pkColIndex = j_variable(javaInt(), 'pkColIndex');
   let propertyIndex = j_variable(javaInt(), 'propertyIndex');

   [
      j_declare(['final'], $object, j_new($implClass, [])),
      $object->j_invoke($conventions->setterName(setIdPropertyName()), [j_string($set.id)], javaVoid()),
      $pkColIndex->j_declare(),
      $propertyIndex->j_declare()
   ]->concatenate(
      $currentSetPks->size()->range()->map({pkIdx |
         let pkStr = 'pk$_' + $pkIdx->toString() + if($allSets->size() == 1, | '', | '_' + $allSets->indexOf($set)->toString());
         let pkVar = j_variable(javaObject(), $pkStr);
         [
            $pkColIndex->j_assign($propertyIndicesField->j_invoke('get', [j_int($index)], javaList(javaInt()))->j_invoke('get', [j_int($propertyCount + $pkIdx)], javaInt())),
            $pkVar->j_declare($jThis->j_invoke('getAlloyNativeValueFromResultSet', [$resParam, $pkColIndex, $columnTypesField->j_invoke('get', [$pkColIndex->j_minus(j_int(1))], javaInt())], javaObject())),
            $object->j_invoke($conventions->setterName($pkStr), [$pkVar], javaVoid())
         ];
      })
   )->concatenate(
      $propertyCount->range()->map({propIndex |
      let prop = $properties->at($propIndex);
      let propertyName = $prop.name->toOne();
      let propertyType = $prop->genericType().typeArguments->at(1).rawType->toOne();
      let propertyMultiplicity = $prop.multiplicity;
      let javaType = if ($propertyType->instanceOf(meta::pure::metamodel::type::Enumeration),
                         | $conventions->className($propertyType),
                         | let jt = $pureTypeToJavaTypeMap->get($propertyType);
                           assert($jt->isNotEmpty(), | 'Property type \'' + $propertyType->elementToPath() + '\' not supported yet. Property name: \'' + $propertyName + '\'');
                           $jt->toOne();
                     );
      let resVar = j_variable($javaType, 'res');

      [
         $propertyIndex->j_assign($propertyIndicesField->j_invoke('get', [j_int($index)], javaList(javaInt()))->j_invoke('get', [j_int($propIndex)], javaInt())),
         j_block(
            [
               $resVar->j_declare(j_cast($propertyGettersField->j_invoke('get', [j_int($index)], javaList(javaSupplier(javaObject())))->j_invoke('get', [j_int($propIndex)], javaSupplier(javaObject()))->j_invoke('get', [], javaObject()), $javaType))
            ]->concatenate(
               if ($propertyMultiplicity->getLowerBound() == 1,
                   | j_if($resVar->j_eq(j_null()), j_throw(j_new(javaRuntimeException(),[j_string('Error reading in property \'' + $propertyName + '\'. Property of multiplicity [1] can not be null')]))),
                   | []
               )
            )->concatenate(
               [
                  $object->j_invoke($conventions->setterName($prop), [$resVar], javaVoid())
               ]
            )
         )
      ];
   }));
}

function meta::relational::executionPlan::platformBinding::legendJava::graphFetch::enrichForRelationalGraphExecution(cl: meta::external::language::java::metamodel::Class[1], node: RelationalGraphFetchExecutionNode[1], context: GenerationContext[1], extensions: meta::pure::extension::Extension[*], debug: DebugContext[1]):Project[1]
{
   let constraintsToExclude = $node.graphFetchTree.constraintsExclusions;
   let qpGetterProject    = $cl->updateImplementationClassWithQualifiedPropertyGetters($node->typeFromStoreLocalNode(), $context);
   let constraintsProject = $cl->createConstraintCheckingForClass($node->typeFromStoreLocalNode(), $constraintsToExclude, $context, $debug->indent());
   let primaryKeyProject  = $cl->updateImplementationClassWithPrimaryKeys($node, $context);
   let additionalProject  = $cl->updateImplementationClassWithSetConnectionAndReference($node, $context);
   mergeProjects([$qpGetterProject, $constraintsProject, $primaryKeyProject, $additionalProject]);
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::updateImplementationClassWithQualifiedPropertyGetters(implClass: meta::external::language::java::metamodel::Class[1], nodeType: meta::pure::metamodel::type::Class<Any>[1], context: GenerationContext[1]): Project[1]
{
   let conventions = $context.conventions;
   let typeInfo = $context.typeInfos->forClass($nodeType);
   let jThis     = j_this($implClass);

   let updatedClass = $context.typeInfos->allQualifiedProperties($typeInfo)->fold({q, cl |
      let fieldName = $conventions->fieldName($q);
      let mapName = $fieldName + '_QualifierMap';
      let keyType = javaList(javaList(javaWildcard()));
      let fieldType = $conventions->pureTypeToJavaType($q);

      let field     = $jThis->j_field($fieldName, $fieldType);
      let mapField     = $jThis->j_field($mapName, javaMap($keyType, $fieldType));
      let keyVar = $keyType->j_variable('qualifierKey$');

      $cl
         ->addMethod(
            javaMethod(
               ['public'], $fieldType, $conventions->getterName($q), [$q->functionType().parameters->evaluateAndDeactivate()->tail()->map(p | javaParam($conventions->pureTypeToJavaType($p.genericType.rawType->toOne(), $p.multiplicity), $p.name))],
               [
                  $keyVar->j_declare(javaArrays()->j_invoke([javaList(javaWildcard())], 'asList', $q->functionType().parameters->evaluateAndDeactivate()->tail()->map(p | let param = j_parameter($conventions->pureTypeToJavaType($p.genericType.rawType->toOne(), $p.multiplicity), $p.name); if($p.multiplicity->hasToOneUpperBound(), | javaArrays()->j_invoke('asList', $param, javaList(javaWildcard())), | $param);), $keyType)),
                  j_return($mapField->j_invoke('get', [$keyVar], $fieldType))
               ]
            )
         );
   }, $implClass);

   newProject()->addClasses($updatedClass);
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::updateImplementationClassWithPrimaryKeys(implClass: meta::external::language::java::metamodel::Class[1], node: RelationalGraphFetchExecutionNode[1], context: GenerationContext[1]): Project[1]
{
   let conventions = $context.conventions;
   let sets        = $node.resultType->cast(@ClassResultType).setImplementations->cast(@RelationalInstanceSetImplementation);

   let withKeys = $sets->fold({set, cl |
      let setIdx = $sets->indexOf($set);
      let pks    = $set->resolvePrimaryKey();
      $pks->fold({pk, clWithKeys |
         let pkIdx    = $pks->indexOf($pk);
         let pkString = 'pk$_' + $pkIdx->toString() + if($sets->size() == 1, | '', | '_' + $setIdx->toString());
         let pkField  = $conventions->fieldName($pkString);

         $clWithKeys
            ->addField(javaField(['private'], javaObject(), $pkField))
            ->addMethod(javaMethod(['public'], javaObject(), $conventions->getterName($pkString), [], 'return this.' + $pkField + ';'))
            ->addMethod(javaMethod(['public'], javaVoid(), $conventions->setterName($pkString), [javaParam(javaObject(), $pkField)], 'this.' + $pkField + ' = ' + $pkField + ';'));
      }, $cl);
   }, $implClass);

   newProject()->addClasses($withKeys);
}


function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::updateImplementationClassWithSetConnectionAndReference(implClass: meta::external::language::java::metamodel::Class[1], node: RelationalGraphFetchExecutionNode[1], context: GenerationContext[1]): Project[1]
{
   let conventions     = $context.conventions;
   let setIdProp       = setIdPropertyName();
   let setIdField      = $conventions->fieldName($setIdProp);
   let connectionProp  = databaseConnectionPropertyName();
   let connectionField = $conventions->fieldName($connectionProp);
   let referenceProp   = $conventions->referencedObjectReference();
   let referenceField  = $conventions->fieldName($referenceProp);

   let updatedClass =
      $implClass
         ->addObjectMapperField($conventions)
         ->addFields([
            javaField(['private'], javaString(), $setIdField),
            javaField(['public', 'static'], javaString(), $connectionField),
            javaField(['private'], javaString(), $referenceField)
         ])
         ->addMethods([
            javaMethod(['public'], javaString(), $conventions->getterName($setIdProp), [], 'return this.' + $setIdField + ';'),
            javaMethod(['public'], javaVoid(), $conventions->setterName($setIdProp), [javaParam(javaString(), 'setId')], 'this.' + $setIdField + ' = setId;'),
            relationalReferenceIdentifierGetterMethodForImplementation($node.resultType->cast(@ClassResultType).setImplementations->cast(@RelationalInstanceSetImplementation), $implClass, $conventions),
            javaMethod(['public'], javaVoid(), $conventions->setterName($referenceProp), [javaParam(javaString(), 'reference')], 'this.' + $referenceField + ' = reference;')
         ]);

   newProject()->addClasses($updatedClass);
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildPrepareMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaVoid(), 'prepare', [javaParam(javaResultSet(), 'resultSet'), javaParam(javaString(), 'databaseTimeZone'), javaParam(javaString(), 'databaseConnection')], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildNextGraphInstanceMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], type: meta::external::language::java::metamodel::Type[1], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, $type, 'nextGraphInstance', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildPrimaryKeyGettersMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaReflectMethod()), 'primaryKeyGetters', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildAllInstanceSetImplementationsMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaParameterizedType(javaClass('org.eclipse.collections.api.tuple.Pair'), [javaString(), javaString()])), 'allInstanceSetImplementations', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildPrimaryKeyColumnsMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaString()), 'primaryKeyColumns', [javaParam(javaInt(), 'setIndex')], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildParentPrimaryKeyColumnsMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaString()), 'parentPrimaryKeyColumns', [javaParam(javaList(javaString()), 'queryResultColumns')], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildAddChildToParentMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*], conventions: Conventions[1]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaVoid(), 'addChildToParent', [javaParam(javaObject(), 'parent'), javaParam(javaObject(), 'child'), javaParam($conventions->className(IExecutionNodeContext), 'executionNodeContext')], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildMappingIdMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaString(), 'mappingId', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildSourceInstanceSetIdMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaString(), 'sourceInstanceSetId', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildTargetInstanceSetIdMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaString(), 'targetInstanceSetId', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildParentCrossKeyColumnsMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaString()), 'parentCrossKeyColumns', [javaParam(javaList(javaString()), 'queryResultColumns')], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildParentCrossKeyGettersMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaReflectMethod()), 'parentCrossKeyGetters', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildSupportsCachingMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaBoolean(), 'supportsCaching', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildSupportsCrossCachingMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaBoolean(), 'supportsCrossCaching', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildTargetPropertiesOrderedMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaString()), 'targetPropertiesOrdered', [], $code)
}

function <<access.private>> meta::relational::executionPlan::platformBinding::legendJava::graphFetch::buildParentCrossKeyGettersOrderedByTargetPropertiesMethod(class: meta::external::language::java::metamodel::Class[1], modifiers: String[*], code: Code[*]):meta::external::language::java::metamodel::Method[1]
{
   javaMethod($modifiers, javaList(javaReflectMethod()), 'parentCrossKeyGettersOrderedByTargetProperties', [], $code)
}
