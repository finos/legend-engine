// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::modelToModel::graphFetch::executionPlan::*;
import meta::pure::graphFetch::*;
import meta::pure::executionPlan::*;
import meta::external::store::mongodb::metamodel::mapping::*;
import meta::external::store::mongodb::graphFetch::executionPlan::*;
import meta::external::store::mongodb::metamodel::aggregation::*;
import meta::external::store::mongodb::functions::pureToDatabaseCommand::*;
import meta::external::store::mongodb::metamodel::pure::runtime::*;
import meta::external::store::mongodb::metamodel::pure::*;
import meta::pure::extension::*;
import meta::pure::runtime::*;
import meta::pure::graphFetch::routing::*;
import meta::pure::mapping::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::external::store::mongodb::metamodel::pure::graphFetch::executionPlan::*;
import meta::external::shared::format::executionPlan::*;

function meta::external::store::mongodb::graphFetch::executionPlan::planRootGraphFetchExecutionMongoDb(sq: StoreQuery[1], ext: RoutedValueSpecification[0..1], clusteredTree: StoreMappingClusteredGraphFetchTree[1], orderedPaths: String[*], mapping: Mapping[1], runtime: Runtime[1], exeCtx: ExecutionContext[1], enableConstraints: Boolean[1], checked: Boolean[1], extensions: Extension[*], debug: DebugContext[1]): LocalGraphFetchExecutionNode[1]
{
  let fe = $sq.fe->evaluateAndDeactivate();
  let lhsFe = $fe.parametersValues->evaluateAndDeactivate()->at(0)->byPassRouterInfo()->cast(@FunctionExpression);
  let rootTree = $clusteredTree->byPassClusteringInfo()->cast(@RoutedRootGraphFetchTree<Any>);
  let store = $sq.store->cast(@MongoDatabase);

  let domainFieldsToProject = $rootTree.subTrees->cast(@meta::pure::graphFetch::PropertyGraphFetchTree).property->filter(x | $x->instanceOf(Property))->cast(@Property<Nil,Any|*>).name;

  let databaseCommand = $lhsFe->toDatabaseCommand($mapping, $sq.inScopeVars, $debug, $extensions)->cast(@DatabaseCommand)->filterOutProjectedFields($domainFieldsToProject);

  let connection = $runtime->toOne()->connectionByElement($store)->cast(@MongoDBConnection);

  let binding = $mapping.classMappings->cast(@MongoDBSetImplementation).binding->toOne();
  

  ^InMemoryRootGraphFetchExecutionNode(
    resultType = $rootTree->resultTypeFromGraphFetchTree(),
    nodeIndex = 0,
    graphFetchTree = $rootTree,
    checked = $checked,
    executionNodes = [
      ^ExternalFormatInternalizeExecutionNode(
        resultType = ^PartialClassResultType(
                            type = $rootTree.class->toOne(),
                            propertiesWithParameters = $rootTree.subTrees->cast(@PropertyGraphFetchTree)->map(x | $x->map(x | ^PropertyWithParameters(property = $x.property, parameters = $x.parameters)))
                          ),
        // Do we need config??
        //config = $config,
        checked = $checked,
        enableConstraints = false,
        tree = $rootTree,
        binding = $binding,
        executionNodes = [
          ^MongoDBExecutionNode(
            resultType = ^meta::pure::executionPlan::ResultType(type = Any),
            databaseCommand = $databaseCommand,
            connection = $connection
          )
        ]
      )
    ]
  );
}


function meta::external::store::mongodb::graphFetch::executionPlan::filterOutProjectedFields(databaseCommand: DatabaseCommand[1], fieldNames: String[*]): DatabaseCommand[1]
{
  let matchStage = $databaseCommand.aggregationPipeline.stages->filter(x | $x->instanceOf(MatchStage))->cast(@MatchStage);

  let keyValuesToProject = $databaseCommand.aggregationPipeline.stages->filter(x | $x->instanceOf(ProjectStage))->toOne()->cast(@ProjectStage).projections->cast(@ObjectQueryExpression).keyValues->filter(k | $k->cast(@QueryExprKeyValue).key->cast(@FieldPathExpression).fieldPath->in($fieldNames));

  ^$databaseCommand(
    aggregationPipeline = ^AggregationPipeline(
      stages = $matchStage->concatenate(^ProjectStage(projections=^ObjectQueryExpression(keyValues = $keyValuesToProject)))
    )
  );
}