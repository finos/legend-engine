/**
  * Intermediate representation (IR) for PURE queries
  *
  * Here we define classes that model the part of PURE expressions
  * which are supported for compilation into Rel code. Most of this file
  * consists of functions that take instances of `ValueSpecification` and 
  * translate these instances into IR objects. IR objects exist so that
  * subsequent compilation can rely on well-defined type signatures without
  * having to manually parse `ValueSpecification`s first.
  */


import meta::rel::compile::ir::*;
import meta::rel::mapping::*;
import meta::rel::utils::*;
import meta::rel::utils::lang::*;
import meta::rel::lib::*;
import meta::rel::metamodel::*;
import meta::pure::router::metamodel::*;

/**
  * Abstract type representing PURE query expressions. Expressions evaluate to values.
  */
Class <<typemodifiers.abstract>> meta::rel::compile::ir::PExpr { }

Class <<typemodifiers.abstract>> meta::rel::compile::ir::Constant extends PExpr { }

Class meta::rel::compile::ir::VariablePlaceholder extends PExpr {
  identifier: String[1];
}

Class meta::rel::compile::ir::StringConst extends meta::rel::compile::ir::Constant {
  value: String[1];
}

Class meta::rel::compile::ir::IntegerConst extends meta::rel::compile::ir::Constant {
  value: Integer[1];
}

Class meta::rel::compile::ir::FloatConst extends meta::rel::compile::ir::Constant {
  value: Float[1];
}

Class meta::rel::compile::ir::BooleanConst extends meta::rel::compile::ir::Constant {
  value: Boolean[1];
}

Class meta::rel::compile::ir::StrictDateConst extends meta::rel::compile::ir::Constant {
  value: StrictDate[1];
}

Class meta::rel::compile::ir::DateTimeConst extends meta::rel::compile::ir::Constant {
  value: DateTime[1];
}

/**
  * Expression asking to fetch all elements of a certain type.
  */
Class meta::rel::compile::ir::All extends PExpr {
  set: RelSetImplementation[1];
}

/**
  * Expression asking to filter another query node by a given predicate.
  */
Class meta::rel::compile::ir::Filter extends PExpr {
  parent: PExpr[1];
  predicate: Scoped[1];
}

/**
  * Type denoting an application of a function to multiple expressions.
  */
Class meta::rel::compile::ir::FunctionExpr<|n> extends PExpr {
  arguments: PExpr[n];
  fn: FunctionDefinition<{meta::rel::metamodel::Expr[n]->meta::rel::metamodel::Expr[1]}>[1];
}

/**
  * Type denoting `exists` expressions.
  */
Class meta::rel::compile::ir::Exists extends PExpr {
  parent: PExpr[1];
  predicate: Scoped[1];
}

/**
  * Type denoting `forAll` expressions.
  */
Class meta::rel::compile::ir::ForAll extends PExpr {
  parent: PExpr[1];
  predicate: Scoped[1];
}

/**
  * Type for expressions which denote access to a variable
  * representing a Rel set.
  */
Class meta::rel::compile::ir::SetAccess extends PExpr {
  set: RelSetImplementation[1];
  variable: String[1];
}

/**
  * Type representing access to a property.
  */
Class meta::rel::compile::ir::PropertyAccess extends PExpr {
  parent: PExpr[1];
  property: Property<Nil, Any|*>[1];
  set: RelSetImplementation[0..1];
}

/**
  * Type representing an access to a column of a row.
  * Such calls can only occur if the `parent` expression represents
  * a `TDSRow`.
  */
Class meta::rel::compile::ir::ColumnAccess extends PExpr {
  parent: PExpr[1];
  column: String[1];
}

/**
  * Helper type for representing variable scopes.
  */ 
Class meta::rel::compile::ir::Scoped extends PExpr {
  variables: String[*];
  inner: PExpr[1];
  parent: PExpr[0..1];
}

/**
  * Type denoting `map` expressions.
  */
Class meta::rel::compile::ir::MapExpr extends PExpr {
  parent: PExpr[1];
  body: Scoped[1];
}

/**
  * Type denoting projections.
  */
Class meta::rel::compile::ir::Project extends PExpr {
  parent: PExpr[1];
  projections: Pair<String,Scoped>[*];
}

/**
  * Denotes an aggregation function.
  */
Class meta::rel::compile::ir::Aggregate {
  map: Scoped[1];
  aggregateFunction: Scoped[1];
  name: String[0..1];
}

Class <<typemodifiers.abstract>> meta::rel::compile::ir::GroupBy extends PExpr {
  parent: PExpr[1];
  aggregates: Aggregate[*];
}

/**
  * Expression type denting `group by` expressions.
  */
Class meta::rel::compile::ir::GroupByScopes extends GroupBy {
  group: Scoped[*];
  names: String[*];

  group() {
    $this.group;
  }: Any[*];

  names() {
    $this.names;
  }: String[*];
}

/**
  * Expression type denting `group by` expressions.
  */
Class meta::rel::compile::ir::GroupByColumns extends GroupBy {
  group: String[*];

  group() {
    $this.group;
  }: Any[*];

  names() {
    $this.group->concatenate($this.aggregates.name);
  }: String[*];
}

/**
  * If-then-else expression.
  */
Class meta::rel::compile::ir::IfThenElse extends PExpr {
  condition: PExpr[1];
  then: Scoped[1];
  else: Scoped[1];
}

/**
  * Helper class for implementing a custom compilation step without the need
  * to represent IR objects explicitly.
  */
Class meta::rel::compile::ir::CompilationStep extends PExpr {
  logic: FunctionDefinition<{
    FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1],
    meta::rel::compile::CompilationState[1]
      ->Result<meta::rel::compile::CompilationState|0..1>[1]
  }>[1];

  property: FunctionDefinition<{String[1], Any[*]->Any[*]}>[0..1];
}

////////////////////////
/// Constructor methods
////////////////////////

function meta::rel::compile::ir::const(value: String[1]): StringConst[1] {
  string($value);
}

function meta::rel::compile::ir::const(value: Integer[1]): IntegerConst[1] {
  integer($value);
}

function meta::rel::compile::ir::const(value: Float[1]): FloatConst[1] {
  float($value);
}

function meta::rel::compile::ir::const(value: Boolean[1]): BooleanConst[1] {
  boolean($value);
}

function meta::rel::compile::ir::const(value: StrictDate[1]): StrictDateConst[1] {
  strictDate($value);
}

function meta::rel::compile::ir::const(value: DateTime[1]): DateTimeConst[1] {
  dateTime($value);
}

function meta::rel::compile::ir::string(value: String[1]): StringConst[1] {
  ^StringConst(value=$value);
}

function meta::rel::compile::ir::integer(value: Integer[1]): IntegerConst[1] {
  ^IntegerConst(value=$value);
}

function meta::rel::compile::ir::float(value: Float[1]): FloatConst[1] {
  ^FloatConst(value=$value);
}

function meta::rel::compile::ir::boolean(value: Boolean[1]): BooleanConst[1] {
  ^BooleanConst(value=$value);
}

function meta::rel::compile::ir::strictDate(value: StrictDate[1]): StrictDateConst[1] {
  ^StrictDateConst(value=$value);
}

function meta::rel::compile::ir::dateTime(value: DateTime[1]): DateTimeConst[1] {
  ^DateTimeConst(value=$value);
}

function meta::rel::compile::ir::variablePlaceholder(identifier: String[1]): VariablePlaceholder[1] {
  ^VariablePlaceholder(identifier=$identifier);
}

function meta::rel::compile::ir::fexpr<|n>(
  arguments: PExpr[n], 
  fn: FunctionDefinition<{meta::rel::metamodel::Expr[n]->meta::rel::metamodel::Expr[1]}>[1]
): FunctionExpr<|n>[1] {
  ^FunctionExpr<|n>(arguments=$arguments, fn=$fn);
}

function meta::rel::compile::ir::setAccess(set: RelSetImplementation[1], variable: String[1]): SetAccess[1] {
  ^SetAccess(set=$set, variable=$variable);
}

function meta::rel::compile::ir::propertyAccess(
  parent: PExpr[1], 
  property: Property<Nil, Any|*>[1],
  set: RelSetImplementation[0..1]
): PropertyAccess[1] {
  ^PropertyAccess(parent=$parent, property=$property, set=$set);
}


function meta::rel::compile::ir::columnAccess(parent: PExpr[1], column: String[1]): ColumnAccess[1] {
  ^ColumnAccess(parent=$parent, column=$column);
}

function meta::rel::compile::ir::all(set: RelSetImplementation[1]): All[1] {
  ^All(set=$set);
}

function meta::rel::compile::ir::filter(parent: PExpr[1], predicate: Scoped[1]): Filter[1] {
  ^Filter(parent=$parent, predicate=$predicate);
}

function meta::rel::compile::ir::scoped(inner: PExpr[1], variable: String[*]): Scoped[1] {
  scoped($inner, $variable, []);
}

function meta::rel::compile::ir::scoped(inner: PExpr[1], variables: String[*], parent: PExpr[0..1]): Scoped[1] {
  ^Scoped(inner=$inner, variables=$variables, parent=$parent);
}

function meta::rel::compile::ir::withParent(scoped: Scoped[1], parent: PExpr[0..1]): Scoped[1] {
  ^$scoped(parent=$parent);
}

function meta::rel::compile::ir::mapExpr(parent: PExpr[1], body: Scoped[1]): MapExpr[1] {
  ^MapExpr(parent=$parent, body=$body);
}

function meta::rel::compile::ir::exists(parent: PExpr[1], predicate: Scoped[1]): meta::rel::compile::ir::Exists[1] {
  ^meta::rel::compile::ir::Exists(parent=$parent, predicate=$predicate);
}

function meta::rel::compile::ir::forAll(parent: PExpr[1], predicate: Scoped[1]): meta::rel::compile::ir::ForAll[1] {
  ^meta::rel::compile::ir::ForAll(parent=$parent, predicate=$predicate);
}

function meta::rel::compile::ir::project(parent: PExpr[1], projections: Pair<String,Scoped>[*]): Project[1] {
  ^Project(parent=$parent, projections=$projections);
}

function meta::rel::compile::ir::aggregate(map: Scoped[1], aggregateFunction: Scoped[1]): Aggregate[1] {
  ^Aggregate(map=$map, aggregateFunction=$aggregateFunction);
}

function meta::rel::compile::ir::aggregate(map: Scoped[1], aggregateFunction: Scoped[1], name: String[1]): Aggregate[1] {
  let agg = aggregate($map, $aggregateFunction);
  ^$agg(name=$name);
}

function meta::rel::compile::ir::groupBy(parent: PExpr[1], group: Scoped[*], aggregates: Aggregate[*], names: String[*]): GroupByScopes[1] {
  ^GroupByScopes(parent=$parent, group=$group, aggregates=$aggregates, names=$names);
}

function meta::rel::compile::ir::groupBy(parent: PExpr[1], group: String[*], aggregates: Aggregate[*]): GroupByColumns[1] {
  ^GroupByColumns(parent=$parent, group=$group, aggregates=$aggregates);
}

function meta::rel::compile::ir::compilationStep(
  logic: FunctionDefinition<{
    FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1],
    meta::rel::compile::CompilationState[1]
      ->Result<meta::rel::compile::CompilationState|0..1>[1]
  }>[1]
): CompilationStep[1] {
  compilationStep($logic, []);
}

function meta::rel::compile::ir::compilationStep(
  logic: FunctionDefinition<{
    FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1],
    meta::rel::compile::CompilationState[1]
      ->Result<meta::rel::compile::CompilationState|0..1>[1]
  }>[1],
  property: FunctionDefinition<{String[1], Any[*]->Any[*]}>[0..1]
): CompilationStep[1] {
  ^CompilationStep(logic=$logic, property=$property);
}

function meta::rel::compile::ir::ifThenElse(condition: PExpr[1], then: Scoped[1], else: Scoped[1]): meta::rel::compile::ir::IfThenElse[1] {
  ^meta::rel::compile::ir::IfThenElse(condition=$condition, then=$then, else=$else);
}

////////////////////////
/// API methods
////////////////////////

function meta::rel::compile::ir::set(expr: PExpr[1]): RelSetImplementation[0..1] {
  $expr->match([
    {access: SetAccess[1] | $access.set},
    {scoped: Scoped[1] | $scoped.parent->map(p | $p->set()); },
    {all: All[1] | $all.set},
    {access: PropertyAccess[1] | $access.set},
    {map: MapExpr[1] | $map.parent->set()},
    {filter: Filter[1] | $filter.parent->set()},
    {exists: meta::rel::compile::ir::Exists[1] | $exists.parent->set()},
    {forAll: meta::rel::compile::ir::ForAll[1] | $forAll.parent->set()},
    {project: Project[1] | $project.parent->set()},
    {groupBy: GroupBy[1] | $groupBy.parent->set()},
    {step: CompilationStep[1] | $step.property->map(fun | $fun->eval('set', []))->first()->cast(@RelSetImplementation)},
    {other: Any[1] | []}
  ]);
}

function meta::rel::compile::ir::root(expr: PExpr[1]): PExpr[1] {
  $expr->match([
    {access: SetAccess[1] | $access},
    {scoped: Scoped[1] | $scoped.parent->map(p | $p->root())->orElse($scoped)},
    {variable: VariablePlaceholder[1] | $variable},
    {access: PropertyAccess[1] | $access.parent->root()},
    {access: ColumnAccess[1] | $access.parent->root()}
  ])
}

////////////////////////
/// Translation methods
////////////////////////

function meta::rel::compile::ir::intoPExpr(spec: ValueSpecification[1]): Result<PExpr|0..1>[1] {
  $spec->intoPExpr([]);
}

function meta::rel::compile::ir::intoPExpr(spec: ValueSpecification[1], set: RelSetImplementation[0..1]): Result<PExpr|0..1>[1] {
  $spec->match([
    {routed: meta::pure::router::store::metamodel::StoreMappingRoutedValueSpecification[1] |
      $routed.sets
        ->first()
        ->okOr(| 'No set implementation supplied for value specification ' + $routed.id->quote())
        ->tryCast(@RelSetImplementation)
        ->andThen({this: RelSetImplementation[1] |
          $routed.value->match([
            {func: FunctionExpression[1] | $func->intoPExpr($this); },
            {var: VariableExpression[1] | $this->setAccess($var.name)->ok(); },
            {other: ValueSpecification[1] | $other->intoPExpr($this); }
          ]);
        });
    },
    {value: InstanceValue[1] | $value->intoPExpr($set); },
    {func: FunctionExpression[1] | $func->intoPExpr($set); },
    {variable: VariableExpression[1] | variablePlaceholder($variable.name)->ok(); },
    {other: Any[1] | $other->intoPExpr($set); }
  ])
}

function meta::rel::compile::ir::intoPExpr(func: FunctionExpression[1], set: RelSetImplementation[0..1]): Result<PExpr|0..1>[1] {
  $func.func->match([
    {property: Property<Nil, Any|*>[1] |
      $property.name
        ->okOr(| 'Encountered empty name for property.')
        ->andThen({name: String[1] |
          $func.parametersValues
            ->at(0)
            ->tryCast(@ExtendedRoutedValueSpecification)
            ->andThen({paramSpec: RoutedValueSpecification[1] |
              $set
                ->okOr(| 'No set specified for property ' + $name->quote())
                ->andThen({set: RelSetImplementation[1] |
                  $paramSpec
                    ->intoPExpr()
                    ->then(inner | $inner->propertyAccess($property, $set));
                });
            });
        });
    },
    {property: QualifiedProperty<Any>[1] |
      $func.parametersValues
        ->at(0)
        ->intoPExpr()
        ->andThen({parent: PExpr[1] |
          switch([
            // TODO check whether the first argument is a `TDSRow`
            case($property.name == 'getString' || $property.name == 'getInteger' || $property.name == 'getDate', {|
              // Existence of these values guaranteed by signature
              let column = $func.parametersValues
                ->at(1)
                ->cast(@InstanceValue)
                .values
                ->toOne()
                ->cast(@String);

              $parent->columnAccess($column)->ok();
            })
          ], {|
            let exprs = $func.func->cast(@FunctionDefinition<Any>).expressionSequence->evaluateAndDeactivate();
            if ($exprs->size() == 1, {| 
              compilationStep({callback: FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1], state: meta::rel::compile::CompilationState[1] |
                $parent
                  ->meta::rel::compile::compile($callback, $state)
                  ->andThen({prev: meta::rel::compile::CompilationState[1] | 
                    let parent = $prev.current->toOne();

                    $exprs
                      ->at(0)
                      ->intoPExpr()
                      ->andThen({pexpr: PExpr[1] | 
                        $pexpr->meta::rel::compile::compile({a: Any[1] | 
                          if ($a == 'this', | $parent->ok(), | $callback->eval($a));
                        }, $prev);
                      });
                  });
              })
              ->ok();
            }, {|
              let error = error(| 
                format('Encountered unknown qualified property while translating: `%s`', $property.name)
              );
              error($error);
            });
          });
        });
    },
    {other: Function<Any>[1] |
      switch([
        case($other == filter_T_MANY__Function_1__T_MANY_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({parent: PExpr[1] |
              $func.parametersValues
                ->at(1)
                ->intoScoped($parent)
                ->then(scoped: Scoped[1] | $parent->filter($scoped));
            });
        }),
        case($other == getAll_Class_1__T_MANY_, {|
          $func.parametersValues
            ->at(0)
            ->map(vs: meta::pure::router::store::metamodel::StoreMappingRoutedValueSpecification[1] |
              $vs.sets
                ->first()
                ->okOr(| 'No set implementation supplied.')
                ->tryCast(@RelSetImplementation);
            )
            ->then(set | all($set));
        }),
        case($other == map_T_m__Function_1__V_m_ || $other == map_T_MANY__Function_1__V_MANY_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({parent: PExpr[1] |
              $func.parametersValues
                ->at(1)
                ->intoScoped($parent)
                ->then(scoped: Scoped[1] | $parent->mapExpr($scoped));
            });
        }),
        case($other == exists_T_MANY__Function_1__Boolean_1_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({parent: PExpr[1] |
              $func.parametersValues
                ->at(1)
                ->intoScoped($parent)
                ->then({predicate: Scoped[1] | $parent->exists($predicate); });
            })
        }),
        case($other == forAll_T_MANY__Function_1__Boolean_1_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({parent: PExpr[1] |
              $func.parametersValues
                ->at(1)
                ->intoScoped($parent)
                ->then({predicate: Scoped[1] | $parent->forAll($predicate); });
            })
        }),
        case($other == project_T_MANY__Path_MANY__TabularDataSet_1_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({parent: PExpr[1] |
              let paths = $func.parametersValues
                ->at(1);

              switch([
                case($paths->instanceOf(ExtendedRoutedValueSpecification), 
                  | $paths
                      ->cast(@ExtendedRoutedValueSpecification)
                      .value
                      ->cast(@InstanceValue)
                      .values
                      ->cast(@meta::pure::metamodel::path::Path<Nil,Any|1>)
                ),
                case($paths->instanceOf(InstanceValue), | 
                  $paths
                    ->cast(@InstanceValue)
                    .values
                    ->cast(@meta::pure::metamodel::path::Path<Nil,Any|1>)
                )
              ], {| $paths->reactivate(); })
              ->okOr(| 'Encountered unknown argument during compilation of `project_T_MANY__Path_MANY__TabularDataSet_1_`.')
              ->andThem({paths: meta::pure::metamodel::path::Path<Nil,Any|1>[*] |
                $parent
                  ->set()
                  ->okOr(| 'Expected set in parent expression of `project_T_MANY__Path_MANY__TabularDataSet_1_`.')
                  ->andThen({set: RelSetImplementation[1] |
                    $paths
                      ->map({path |
                        $path.path
                          ->fold({element, accum |
                            $accum
                              ->andThen({expr: PExpr[1] |
                                $element
                                  ->tryCast(@meta::pure::metamodel::path::PropertyPathElement)
                                  ->andThen(p: meta::pure::metamodel::path::PropertyPathElement[1] | $p.property->tryCast(@Property<Nil,Any|*>))
                                  ->andThen({property: Property<Nil,Any|*>[1] | 
                                    $property
                                      .genericType
                                      .rawType
                                      ->okOr(| format('No type information for property `%s`.', $property.name))
                                      ->then({type: Type[1] |
                                        let next = 
                                          $set
                                            .parent
                                            ->meta::pure::mapping::classMappingById($type->elementToPath('_'))
                                            ->map(set | $set->cast(@RelSetImplementation));
                                        
                                        $expr->propertyAccess($property, $next);
                                      })
                                  });
                              });
                          }, ok(setAccess($set, 'x')))
                          ->then(expr: PExpr[1] | 
                            let name = 
                              if ($path.name->isEmpty() || $path.name == '', {| 
                                $path.path
                                  ->last()
                                  ->map({last | 
                                    if ($last->instanceOf(meta::pure::metamodel::path::PropertyPathElement), {|
                                      $last
                                        ->cast(@meta::pure::metamodel::path::PropertyPathElement)
                                        .property
                                        .name
                                        ->orElse('')
                                    }, | '')
                                  })
                                  ->orElse('');
                              }, | $path.name)
                              ->orElse('');

                            pair($name, $expr->scoped('x')->withParent($parent));
                          );
                      })
                      ->collect()
                      ->them({pairs: Pair<String, Scoped>[*] |
                        $parent->project($pairs);
                      });
                  });
              });
            });
        }),
        case($other == project_T_MANY__ColumnSpecification_MANY__TabularDataSet_1_ ||
             $other == project_TabularDataSet_1__ColumnSpecification_MANY__TabularDataSet_1_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({parent: PExpr[1] |
              $func.parametersValues
                ->at(1)
                ->tryCast(@InstanceValue)
                ->andThen({params: InstanceValue[1] |
                  $params.values
                    ->map({v | 
                      $v->tryCast(@InstanceValue)
                        ->then(i: InstanceValue[1] | 
                          // Values guaranteed by function signature
                          $i.values
                            ->toOne()
                            ->cast(@BasicColumnSpecification<Any>)
                        );
                    })
                    ->collect()
                    ->andThem({columns: BasicColumnSpecification<Any>[*] |
                      $columns.func
                        ->map(f | 
                          $f->tryCast(@FunctionDefinition<Any>)
                            ->andThen(fexpr: FunctionDefinition<Any>[1] | $fexpr->intoScoped($parent))
                        )
                        ->collect()
                        ->them(fexprs | $parent->project($columns.name->zip($fexprs)));
                    });
                });
            });
        }),
        case($other == groupBy_K_MANY__Function_MANY__AggregateValue_MANY__String_MANY__TabularDataSet_1_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({parent: PExpr[1] |
              $func.parametersValues
                ->at(1)
                ->intoScopes($parent)
                ->collect()
                ->andThem({group: Scoped[*] |
                  $func.parametersValues
                    ->at(2)
                    ->intoAggregates($parent)
                    ->collect()
                    ->andThem({aggregates: Aggregate[*] | 
                      $func.parametersValues
                        ->at(3)
                        ->tryCast(@InstanceValue)
                        ->andThen(i: InstanceValue[1] | 
                          $i.values
                            ->map(v | $v->tryCast(@String))
                            ->collect()
                        )
                        ->andThem({names: String[*] | 
                          if ($names->size() != $group->size() + $aggregates->size(),
                            | error('Number of specified columns does not match the arity of the `group by` expression.'),
                            {|
                              let namedAggregates = 
                                $aggregates
                                  ->toNumbered()
                                  ->map({pair: Pair<Integer, Aggregate>[1] | 
                                    let agg = $pair.second;
                                    ^$agg(name=$names->at($group->size() + $pair.first - 1));
                                  });
                              $parent
                                ->groupBy($group, $namedAggregates, $names)
                                ->ok();
                            }
                          );
                        })
                    })
                });
            });
        }),
        case($other == groupBy_TabularDataSet_1__String_MANY__AggregateValue_MANY__TabularDataSet_1_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({parent: PExpr[1] |
              $func.parametersValues
                ->at(1)
                ->tryCast(@InstanceValue)
                ->andThen(v: InstanceValue[1] | 
                  $v.values
                    ->map(s | $s->tryCast(@String))
                    ->collect()
                )
                ->andThem({columns: String[*] |
                  $func.parametersValues
                    ->at(2)
                    ->map(vs: ValueSpecification[1] | $vs->intoAggregates($parent)->collect())
                    ->them({aggregates: Aggregate[*] | 
                      $parent->groupBy($columns, $aggregates);
                    });
                })
            });
        }),
        case($other == and_Boolean_1__Boolean_1__Boolean_1_ || 
             $other == or_Boolean_1__Boolean_1__Boolean_1_ ||
             $other == equal_Any_MANY__Any_MANY__Boolean_1_ ||
             $other == greaterThan_Number_1__Number_1__Boolean_1_ ||
             $other == greaterThanEqual_Number_1__Number_1__Boolean_1_ ||
             $other == greaterThan_Date_1__Date_1__Boolean_1_ ||
             $other == greaterThanEqual_Date_1__Date_1__Boolean_1_ ||
             $other == lessThan_Number_1__Number_1__Boolean_1_ ||
             $other == lessThanEqual_Number_1__Number_1__Boolean_1_ ||
             $other == lessThan_Date_1__Date_1__Boolean_1_ ||
             $other == lessThanEqual_Date_1__Date_1__Boolean_1_ ||
             $other == divide_Number_1__Number_1__Float_1_, {|
          let left = $func.parametersValues->at(0);
          let right = $func.parametersValues->at(1);

          [$left, $right]
            ->evaluateAndDeactivate()
            ->tryCastm(@ValueSpecification)
            ->andThem({specs: ValueSpecification[*] |
              $specs
                ->map(spec | $spec->intoPExpr())
                ->collect()
            })
            ->andThem({arguments: PExpr[*] |
              $func
                ->getFunctionExpr()
                ->then(fn | $arguments->fexpr($fn));
            });
        }),
        case($other == not_Boolean_1__Boolean_1_ || $other == isEmpty_Any_$0_1$__Boolean_1_ ||
             $other == toOne_T_MANY__T_1_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({inner: PExpr[1] |
              $func
                ->getFunctionExpr()
                ->then(fn | $inner->fexpr($fn));
            });
        }),
        case($other == plus_Number_MANY__Number_1_ || $other == plus_String_MANY__String_1_ || 
             $other == plus_Integer_MANY__Integer_1_ || $other == plus_Float_MANY__Float_1_ || 
             $other == times_Number_MANY__Number_1_ || $other == times_Integer_MANY__Integer_1_ ||
             $other == times_Float_MANY__Float_1_ || $other == minus_Number_MANY__Number_1_ ||
             $other == minus_Integer_MANY__Integer_1_ || $other == minus_Float_MANY__Float_1_, {|
          $func.parametersValues
            ->at(0)
            ->tryCast(@InstanceValue)
            ->andThen({spec: InstanceValue[1] | 
              $spec.values
                ->map(v: ValueSpecification[1] | $v->intoPExpr())
                ->collect(); 
            })
            ->andThem({params: PExpr[*] |
              $func
                ->getFunctionExpr()
                ->then(fn | $params->fexpr($fn));
            });
        }),
        case($other == sum_Integer_MANY__Integer_1_ || $other == sum_Float_MANY__Float_1_ || $other == sum_Number_MANY__Number_1_ ||
             $other == count_Any_MANY__Integer_1_ ||
             $other == max_Integer_MANY__Integer_$0_1$_ || $other == max_Float_MANY__Float_$0_1$_ ||
             $other == min_Integer_MANY__Integer_$0_1$_ || $other == min_Float_MANY__Float_$0_1$_ ||
             $other == toString_Any_1__String_1_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({parent: PExpr[1] | 
              $func
                ->getFunctionExpr()
                ->then(fun | $parent->fexpr($fun));
            });
        }),
        case($other == if_Boolean_1__Function_1__Function_1__T_m_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({condition: PExpr[1] |
              $func.parametersValues
                ->at(1)
                ->intoScoped()
                ->andThen({then: Scoped[1] |
                  $func.parametersValues
                    ->at(2)
                    ->intoScoped()
                    ->then(else: Scoped[1] | $condition->ifThenElse($then, $else));
                });
            });
        }),
        case($other == instanceOf_Any_1__Type_1__Boolean_1_, {|
          let object = $func.parametersValues->at(0);
          let type = $func.parametersValues->at(1);

          $object
            ->intoPExpr()
            ->andThen({obj: PExpr[1] |
              $type
                ->tryCast(@ExtendedRoutedValueSpecification)
                ->andThen({spec: ExtendedRoutedValueSpecification[1] |
                  $spec
                    ->intoPExpr()
                    ->then({class: PExpr[1] |
                      compilationStep({callback: FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1], state: meta::rel::compile::CompilationState[1] |
                        $obj
                          ->meta::rel::compile::compile($callback, $state)
                          ->andThen({state: meta::rel::compile::CompilationState[1] |
                            let objExpr = $state.current->toOne();
                            $class
                              ->meta::rel::compile::compile($callback, $state)
                              ->then({next: meta::rel::compile::CompilationState[1] |
                                let typeExpr = $next.current->toOne();
                                let current = $typeExpr->atom($objExpr);

                                ^$next(current=$current->annotate(Boolean));
                              });
                          });
                      });
                    });
                });
            });
        }),
        /*case($other == cast_Any_m__T_1__T_m_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->andThen({obj: PExpr[1] |
              $func.parametersValues
                ->at(1)
                ->tryCast(@ExtendedRoutedValueSpecification)
                ->andThen({spec: ExtendedRoutedValueSpecification[1] |
                  $spec.sets
                    ->first()
                    ->okOr(| 'No set implementation specified for argument of `cast`.')
                    ->tryCast(@RelSetImplementation)
                    ->then({set: RelSetImplementation[1] |
                        compilationStep({callback: FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1], state: meta::rel::compile::CompilationState[1] |
                          $obj
                            ->meta::rel::compile::compile($callback, $state)
                            ->then({next: meta::rel::compile::CompilationState[1] |
                              let obj = $next.current->toOne();
                              let var = $next.variableFactory->meta::rel::compile::utils::next('x')->var();
                              let current = 
                                $var
                                  ->from($var->in($obj)->where($set.classExpr->atom($var)));

                              ^$next(current=$current->annotate($set.class));
                              //$next;
                            })
                        }, 
                        {property: String[1], params: Any[*] |
                          if ($property == 'set', | $set, | []);
                        });
                    })
                });
            });
        }),*/ //TODO
        case($other == meta::pure::graphFetch::execution::serialize_T_MANY__RootGraphFetchTree_1__String_1_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->then({parent: PExpr[1] | 
              compilationStep({callback: FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1], state: meta::rel::compile::CompilationState[1] |
                $parent
                  ->meta::rel::compile::compile($callback, $state)
                  ->then({state: meta::rel::compile::CompilationState[1] | $state});
              });
            });
        }),
        case($other == meta::pure::graphFetch::execution::graphFetch_T_MANY__RootGraphFetchTree_1__T_MANY_, {|
          $func.parametersValues
            ->at(0)
            ->intoPExpr()
            ->then({parent: PExpr[1] | 
              compilationStep({callback: FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1], state: meta::rel::compile::CompilationState[1] |
                // TODO: Implement!
                $parent
                  ->meta::rel::compile::compile($callback, $state)
                  ->then({state: meta::rel::compile::CompilationState[1] | $state});
              });
            });
        }),
        case($other == meta::pure::functions::lang::extractEnumValue_Enumeration_1__String_1__T_1_, {|
          $func.parametersValues
            ->at(0)
            ->tryCast(@InstanceValue)
            ->andThen({value: InstanceValue[1] |
              let enum = $value.values
                ->at(0)
                ->cast(@Enumeration<Any>);

              $func.parametersValues
                ->at(1)
                ->tryCast(@InstanceValue)
                ->then({val: InstanceValue[1] |
                  let enumValue = $val.values
                    ->at(0)
                    ->cast(@String);

                  compilationStep({callback: FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1], state: meta::rel::compile::CompilationState[1] |
                    ^$state(current=
                      $enum
                        ->enumName()
                        ->meta::rel::metamodel::rel()
                        ->appl(meta::rel::metamodel::label($enumValue))
                    )
                    ->ok();
                  });
                });
            });
        }),
        case($other == meta::pure::tds::join_TabularDataSet_1__TabularDataSet_1__JoinType_1__Function_1__TabularDataSet_1_, {| 
          meta::rel::compile::ir::tds::intoPExpr($func);
        }),
        case($other == meta::pure::tds::filter_TabularDataSet_1__Function_1__TabularDataSet_1_, {|
          meta::rel::compile::ir::tds::intoPExpr($func);
//
// FIXME: Commented out to fix the build.
//        }),
//        case($other == meta::rel::query::def_String_1__FunctionDefinition_1__Any_MANY_, {| 
//          // TODO not implemented yet
//          let query = $func.parametersValues->at(1)->intoScoped()->unwrap()->inspect();
//
//          meta::rel::compile::ir::const(1)->ok();
//
        })
      ], {|
        let error = error(| 
          'Encountered unknown instance while translating: ' +
            $other
              ->elementToPath()
              ->else(| '<<unknown>>')
              ->quote();
        );
        error($error);
      });
    }
  ]);
}

function meta::rel::compile::ir::intoPExpr(spec: InstanceValue[1], set: RelSetImplementation[0..1]): Result<PExpr|0..1>[1] {
  $spec.values
    ->okOr(| 'Expected value within `InstanceValue`.')
    ->andThem({values: Any[*] | 
      if ($values->size() != 1,
        | error(error(| 'Expected exactly one value in `InstanceValue`.')),
        | $values->toOne()->ok()
      );
    })
    ->andThen(value: Any[1] | $value->intoPExpr($set));
}

function meta::rel::compile::ir::intoPExpr(value: Any[1], set: RelSetImplementation[0..1]): Result<PExpr|0..1>[1] {
  $value->match([
    s: String[1] | ok(string($s)),
    i: Integer[1] | ok(integer($i)),
    f: Float[1] | ok(float($f)),
    b: Boolean[1] | ok(boolean($b)),
    d: StrictDate[1] | ok(strictDate($d)),
    d: DateTime[1] | ok(dateTime($d)),
    {class: Class<Any>[1] |
      $set
        ->map({set: RelSetImplementation[1] |
          compilationStep({callback: FunctionDefinition<{Any[1]->Result<Expr|0..1>[1]}>[1], state: meta::rel::compile::CompilationState[1] |
            ^$state(current=$set.classExpr)
              ->ok();
          });
        })
        ->okOr(| format('Encountered class `%s` but no set implementation has been provided.', $class.name));
    },
    {a: Any[1] | 
      let error = error(| 
        'Encountered unknown instance while translating: ' +
          $a
            ->type()
            ->elementToPath()
            ->else(| '<<unknown>>')
            ->quote();
      );
      error($error);
    }
  ])
}

function meta::rel::compile::ir::intoScoped(spec: ValueSpecification[1]): Result<Scoped|0..1>[1] {
  $spec->intoScoped([]);
}

function meta::rel::compile::ir::intoScoped(spec: ValueSpecification[1], parent: PExpr[0..1]): Result<Scoped|0..1>[1] {
  $spec->match([
    {spec: FunctionRoutedValueSpecification[1] |
      $spec.value
        ->tryCast(@InstanceValue)
        ->andThen({value: InstanceValue[1] | 
          $value.values
            ->first()
            ->okOr(| 'Expected one value in `InstanceValue`.')
            ->tryCast(@FunctionDefinition<Any>)
        })
        ->andThen(func: FunctionDefinition<Any>[1] | $func->intoScoped($parent));
    },
    {spec: RoutedValueSpecification[1] |
      $spec.value
        ->tryCast(@FunctionRoutedValueSpecification)
        ->andThen({inner: FunctionRoutedValueSpecification[1] | $inner->intoScoped($parent)});
    }
  ]);
}

function meta::rel::compile::ir::intoScoped(func: FunctionDefinition<Any>[1], parent: PExpr[0..1]): Result<Scoped|0..1>[1] {
  $func.expressionSequence
    ->evaluateAndDeactivate()
    ->okOr(|'Encountered empty function body while evaluating expression.')
    ->andThem({exprs: ValueSpecification[*] |
      if ($exprs->size() != 1,
        | error(error(| 'More than one expression in function body not supported yet.')),
        | $exprs->toOne()->ok()
      );
    })
    ->andThen({spec: ValueSpecification[1] | 
      $spec
        ->intoPExpr()
        ->andThen({inner: PExpr[1] |
          $func
            ->functionType()
            .parameters
            ->evaluateAndDeactivate()
            ->tryCastm(@VariableExpression)
            ->them(vars: VariableExpression[*] | $inner->scoped($vars.name, $parent));
        });
    });
}

function meta::rel::compile::ir::intoScopes(spec: ValueSpecification[1]): Result<Scoped|0..1>[*] {
  $spec->intoScopes([])
}

function meta::rel::compile::ir::intoScopes(spec: ValueSpecification[1], parent: PExpr[0..1]): Result<Scoped|0..1>[*] {
  $spec->match([
    {spec: InstanceValue[1] | 
      $spec.values
        ->map({v | 
          $v->map(f: ValueSpecification[1] | $f->intoScoped($parent));
        })
    },
    {spec: ExtendedRoutedValueSpecification[1] | $spec.value->intoScopes($parent); },
    {other: ValueSpecification[1] | $other->intoScoped($parent); }
  ]);
}

function meta::rel::compile::ir::intoAggregates(spec: ValueSpecification[1], parent: PExpr[1]): Result<Aggregate|0..1>[*] {
  $spec->match([
    {fexpr: SimpleFunctionExpression[1] |
      switch([
        case($fexpr.func == agg_FunctionDefinition_1__FunctionDefinition_1__AggregateValue_1_, {|
          $fexpr.parametersValues
            ->at(0)
            ->intoScoped($parent)
            ->andThen({map: Scoped[1] | 
              $fexpr.parametersValues
                ->at(1)
                ->intoScoped($parent)
                ->then(aggFn: Scoped[1] | aggregate($map, $aggFn));
            });
        }),
        case($fexpr.func == agg_String_1__FunctionDefinition_1__FunctionDefinition_1__AggregateValue_1_, {|
          $fexpr.parametersValues
            ->at(0)
            ->tryCast(@InstanceValue)
            ->andThen(v: InstanceValue[1] | 
              $v.values
                ->toOne()
                ->tryCast(@String)
            )
            ->andThen({name: String[1] |
              $fexpr.parametersValues
                ->at(1)
                ->intoScoped($parent)
                ->andThen({map: Scoped[1] |
                  $fexpr.parametersValues
                    ->at(2)
                    ->intoScoped($parent)
                    ->then(aggFn: Scoped[1] | aggregate($map, $aggFn, $name))
                });
            });
        })
      ], {|
        let error = error(| 
          format('Encountered unexpected aggregation function during translation: `%s`', $fexpr.func->elementToPath())
        );
        error($error);
      });
    },
    {value: InstanceValue[1] |
      $value.values
        ->map({v | 
          let casted = $v->tryCast(@ValueSpecification);
          if ($casted->isOk(), | $casted.values->toOne()->intoAggregates($parent), | error($casted.errors));
        });
    }
  ]);
}

function meta::rel::compile::ir::getFunctionExpr(
  fn: FunctionExpression[1]
): Result<FunctionDefinition<{Expr[*]->Expr[1]}>|0..1>[1] {

  let eval = 
    switch([
      case($fn.func == sum_Integer_MANY__Integer_1_ || $fn.func == sum_Float_MANY__Float_1_ || $fn.func == sum_Number_MANY__Number_1_, {| 
        {exprs: Expr[*] | 
          $exprs
            ->at(0)
            ->sum();
        }->ok();
      }),
      case($fn.func == count_Any_MANY__Integer_1_, {|
        {exprs: Expr[*] | 
          $exprs
            ->at(0)
            ->count();
        }
        ->ok();
      }),
      case($fn.func == max_Integer_MANY__Integer_$0_1$_ || $fn.func == max_Float_MANY__Float_$0_1$_,  {|
        {exprs: Expr[*] | 
          $exprs
            ->at(0)
            ->max();
        }
        ->ok();
      }),
      case($fn.func == min_Integer_MANY__Integer_$0_1$_ || $fn.func == min_Float_MANY__Float_$0_1$_,  {|
        {exprs: Expr[*] | 
          $exprs
            ->at(0)
            ->min();
        }
        ->ok();
      }),
      case($fn.func == equal_Any_MANY__Any_MANY__Boolean_1_, {|
        {exprs: Expr[*] |
          $exprs
            ->at(0)
            ->equals($exprs->at(1));
        }
        ->ok();
      }),
      case($fn.func == and_Boolean_1__Boolean_1__Boolean_1_, {|
        {exprs: Expr[*] |
          $exprs
            ->at(0)
            ->and($exprs->at(1));
        }
        ->ok();
      }),
      case($fn.func == or_Boolean_1__Boolean_1__Boolean_1_, {|
        {exprs: Expr[*] | 
          $exprs
            ->at(0)
            ->or($exprs->at(1))
            ->annotate(Boolean); 
        }
        ->ok();
      }),
      case($fn.func == greaterThan_Number_1__Number_1__Boolean_1_ || $fn.func == greaterThan_Date_1__Date_1__Boolean_1_, {|
        {exprs: Expr[*] |
          $exprs
            ->at(0)
            ->greaterThan($exprs->at(1));
        }
        ->ok();
      }),
      case($fn.func == greaterThanEqual_Number_1__Number_1__Boolean_1_ || $fn.func == greaterThanEqual_Date_1__Date_1__Boolean_1_, {|
        {exprs: Expr[*] |
          $exprs
            ->at(0)
            ->greaterThanEqual($exprs->at(1));
        }
        ->ok();
      }),
      case($fn.func == lessThan_Number_1__Number_1__Boolean_1_ || $fn.func == lessThan_Date_1__Date_1__Boolean_1_, {|
        {exprs: Expr[*] |
          $exprs
            ->at(0)
            ->lessThan($exprs->at(1));
        }
        ->ok();
      }),
      case($fn.func == lessThanEqual_Number_1__Number_1__Boolean_1_ || $fn.func == lessThanEqual_Date_1__Date_1__Boolean_1_, {|
        {exprs: Expr[*] |
          $exprs
            ->at(0)
            ->lessThanEqual($exprs->at(1));
        }
        ->ok();
      }),
      case($fn.func == plus_Number_MANY__Number_1_ || $fn.func == plus_Integer_MANY__Integer_1_ ||
          $fn.func == plus_Float_MANY__Float_1_, {|
        {exprs: Expr[*] | 
          $exprs->plus();
        }
        ->ok();
      }),
      case($fn.func == minus_Number_MANY__Number_1_ || $fn.func == minus_Integer_MANY__Integer_1_ ||
          $fn.func == minus_Float_MANY__Float_1_, {|
        {exprs: Expr[*] | 
          $exprs->minus();
        }
        ->ok();
      }),
      case($fn.func == plus_String_MANY__String_1_, {|
        {exprs: Expr[*] | 
          $exprs->concat();
        }
        ->ok();
      }),
      case($fn.func == times_Number_MANY__Number_1_ || $fn.func == times_Integer_MANY__Integer_1_ ||
          $fn.func == times_Float_MANY__Float_1_, {|
        {exprs: Expr[*] | 
          $exprs->times();
        }
        ->ok();
      }),
      case($fn.func == divide_Number_1__Number_1__Float_1_, {|
        {exprs: Expr[*] |
          $exprs->at(0)->divide($exprs->at(1));
        }
        ->ok();
      }),
      case($fn.func == not_Boolean_1__Boolean_1_, {|
        {exprs: Expr[*] | 
          $exprs
            ->at(0)
            ->not(); 
        }
        ->ok();
      }),
      case($fn.func == isEmpty_Any_$0_1$__Boolean_1_, {|
        {exprs: Expr[*] |
          $exprs
            ->at(0)
            ->group()
            ->exists()
            ->not();
        }
        ->ok();
      }),
      case($fn.func == toOne_T_MANY__T_1_, {|
        {exprs: Expr[*] |
          $exprs
            ->at(0);
        }
        ->ok();
      }),
      case($fn.func == toString_Any_1__String_1_, {|
        {exprs: Expr[*] |
          $exprs
            ->at(0)
            ->string();
        }
        ->ok();
      })
    ], {|
      let error = error(| 
        'Encountered unknown instance while translating: ' +
          $fn.func
            ->elementToPath()
            ->else(| '<<unknown>>')
            ->quote();
      );
      error($error);
    });
  
  let type = $fn.genericType.rawType;
  
  // Annotate function result with `type`.
  $eval
    ->then(inner: FunctionDefinition<{Expr[*]->Expr[1]}>[1] |
      {exprs: Expr[*] |
        $inner
          ->eval($exprs)
          ->annotate($type);
      };
    );
}
