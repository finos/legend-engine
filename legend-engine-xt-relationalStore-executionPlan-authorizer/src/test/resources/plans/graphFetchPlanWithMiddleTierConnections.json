{
  "_type" : "simple",
  "authDependent" : false,
  "globalImplementationSupport" : {
    "_type" : "java",
    "classes" : [ {
      "name" : "Address",
      "package" : "_pure.app.test",
      "source" : "package _pure.app.test;\n\nimport java.math.*;\nimport java.util.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n\npublic interface Address extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject\n{\n    String getName();\n    List<Person> getPersons();\n    List<Firm> getFirms();\n    String getAlloyStoreObjectReference$();\n}"
    }, {
      "name" : "Firm",
      "package" : "_pure.app.test",
      "source" : "package _pure.app.test;\n\nimport java.math.*;\nimport java.util.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n\npublic interface Firm extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject\n{\n    String getName();\n    List<Person> getEmployees();\n    Address getAddress();\n    String getAlloyStoreObjectReference$();\n}"
    }, {
      "name" : "Firm_Map_test_Firm",
      "package" : "_pure.app.test",
      "source" : "package _pure.app.test;\n\nimport java.math.*;\nimport java.util.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n\npublic interface Firm_Map_test_Firm extends Firm, org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject\n{\n    String getAddressName();\n    String getAlloyStoreObjectReference$();\n}"
    }, {
      "name" : "Person",
      "package" : "_pure.app.test",
      "source" : "package _pure.app.test;\n\nimport java.math.*;\nimport java.util.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n\npublic interface Person extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject\n{\n    String getFullName();\n    Firm getFirm();\n    Address getAddress();\n    String getAlloyStoreObjectReference$();\n}"
    }, {
      "name" : "Person_Map_test_Person",
      "package" : "_pure.app.test",
      "source" : "package _pure.app.test;\n\nimport java.math.*;\nimport java.util.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n\npublic interface Person_Map_test_Person extends Person, org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject\n{\n    String getFirmName();\n    String getAddressName();\n    String getAlloyStoreObjectReference$();\n}"
    }, {
      "name" : "Serialize",
      "package" : "_pure.plan.root",
      "source" : "package _pure.plan.root;\n\nimport org.finos.legend.engine.plan.dependencies.store.platform.IGraphSerializer;\nimport org.finos.legend.engine.plan.dependencies.store.platform.IPlatformPureExpressionExecutionNodeSerializeSpecifics;\nimport org.finos.legend.engine.plan.dependencies.store.platform.ISerializationWriter;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n\npublic class Serialize implements IPlatformPureExpressionExecutionNodeSerializeSpecifics\n{\n    public IGraphSerializer<?> serializer(ISerializationWriter writer,\n                                          IExecutionNodeContext context)\n    {\n        return new Serializer(writer, context);\n    }\n}"
    }, {
      "name" : "Serializer",
      "package" : "_pure.plan.root",
      "source" : "package _pure.plan.root;\n\nimport _pure.app.test.Address;\nimport _pure.app.test.Firm;\nimport _pure.app.test.Person;\nimport org.finos.legend.engine.plan.dependencies.store.platform.IGraphSerializer;\nimport org.finos.legend.engine.plan.dependencies.store.platform.ISerializationWriter;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject;\n\npublic class Serializer implements IGraphSerializer<Person>\n{\n    private ISerializationWriter writer;\n    private IExecutionNodeContext context;\n\n    Serializer(ISerializationWriter writer, IExecutionNodeContext context)\n    {\n        this.writer = writer;\n        this.context = context;\n    }\n\n    public void serialize(Person value)\n    {\n        if (value instanceof IReferencedObject)\n        {\n            this.writer\n                .startObject(\"test::Person\",\n                             ((IReferencedObject) value).getAlloyStoreObjectReference$());\n        }\n        else\n        {\n            this.writer.startObject(\"test::Person\");\n        }\n        this.writer.writeStringProperty(\"fullName\", value.getFullName());\n        this.writer\n            .writeComplexProperty(\"firm\",\n                                  value.getFirm(),\n                                  this::writeFirm_firm);\n        this.writer\n            .writeComplexProperty(\"address\",\n                                  value.getAddress(),\n                                  this::writeAddress_address);\n        this.writer.endObject();\n    }\n\n    public void writeFirm_firm(Firm value)\n    {\n        this.writer.startObject(\"test::Firm\");\n        this.writer.writeStringProperty(\"name\", value.getName());\n        this.writer\n            .writeComplexProperty(\"address\",\n                                  value.getAddress(),\n                                  this::writeAddress_firm_address);\n        this.writer.endObject();\n    }\n\n    public void writeAddress_firm_address(Address value)\n    {\n        this.writer.startObject(\"test::Address\");\n        this.writer.writeStringProperty(\"name\", value.getName());\n        this.writer.endObject();\n    }\n\n    public void writeAddress_address(Address value)\n    {\n        this.writer.startObject(\"test::Address\");\n        this.writer.writeStringProperty(\"name\", value.getName());\n        this.writer.endObject();\n    }\n}"
    }, {
      "name" : "Execute",
      "package" : "_pure.plan.root.n1.globalChild0.globalChild0.localGraph",
      "source" : "package _pure.plan.root.n1.globalChild0.globalChild0.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.relational.graphFetch.IRelationalCrossRootQueryTempTableGraphFetchExecutionNodeSpecifics;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject;\n\npublic class Execute implements IRelationalCrossRootQueryTempTableGraphFetchExecutionNodeSpecifics\n{\n    private Specifics specifics;\n\n    public Execute()\n    {\n        this.specifics = new Specifics();\n    }\n\n    public void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        this.specifics.prepare(resultSet, databaseTimeZone, databaseConnection);\n    }\n\n    public IGraphInstance<? extends IReferencedObject> nextGraphInstance()\n    {\n        return this.specifics.nextGraphInstance();\n    }\n\n    public List<Method> primaryKeyGetters()\n    {\n        return this.specifics.primaryKeyGetters();\n    }\n\n    public String mappingId()\n    {\n        return this.specifics.mappingId();\n    }\n\n    public String sourceInstanceSetId()\n    {\n        return this.specifics.sourceInstanceSetId();\n    }\n\n    public String targetInstanceSetId()\n    {\n        return this.specifics.targetInstanceSetId();\n    }\n\n    public void addChildToParent(Object parent,\n                                 Object child,\n                                 IExecutionNodeContext executionNodeContext)\n    {\n        this.specifics.addChildToParent(parent, child, executionNodeContext);\n    }\n\n    public List<String> parentCrossKeyColumns(List<String> queryResultColumns)\n    {\n        return this.specifics.parentCrossKeyColumns(queryResultColumns);\n    }\n\n    public List<Method> parentCrossKeyGetters()\n    {\n        return this.specifics.parentCrossKeyGetters();\n    }\n\n    public boolean supportsCrossCaching()\n    {\n        return this.specifics.supportsCrossCaching();\n    }\n\n    public List<String> targetPropertiesOrdered()\n    {\n        return this.specifics.targetPropertiesOrdered();\n    }\n\n    public List<Method> parentCrossKeyGettersOrderedByTargetProperties()\n    {\n        return this.specifics.parentCrossKeyGettersOrderedByTargetProperties();\n    }\n}"
    }, {
      "name" : "GraphFetch_Node4_Address_Impl",
      "package" : "_pure.plan.root.n1.globalChild0.globalChild0.localGraph",
      "source" : "package _pure.plan.root.n1.globalChild0.globalChild0.localGraph;\n\nimport java.math.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DayOfWeek;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.util.Library;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport java.io.IOException;\n\npublic class GraphFetch_Node4_Address_Impl implements _pure.app.test.Address, org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.test.Address>, java.io.Serializable\n{\n    private String name;\n    private List<_pure.app.test.Person> persons;\n    private List<_pure.app.test.Firm> firms;\n    private Object pk$_0;\n    private static final ObjectMapper objectMapper$ = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).registerModule(new SimpleModule().addSerializer(PureDate.class, new JsonSerializer<PureDate>() { @Override public void serialize(PureDate value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeRawValue(\"\\\"\" + value.toString() + \"\\\"\"); } }));\n    private String setId$;\n    public static String databaseConnection$;\n    private String alloyStoreObjectReference$;\n    private static final long serialVersionUID = 613881433L;\n\n    public String getName()\n    {\n        return this.name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n\n    public void addName(String object)\n    {\n        if ((Object) this.name != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'name' of multiplicity with bound 1\");\n        }\n        this.name = object;\n    }\n\n    public List<_pure.app.test.Person> getPersons()\n    {\n        return this.persons == null ? Collections.<_pure.app.test.Person>emptyList() : this.persons;\n    }\n\n    public void setPersons(List<_pure.app.test.Person> persons)\n    {\n        this.persons = persons;\n    }\n\n    public void addPersons(_pure.app.test.Person object)\n    {\n        if (this.persons == null)\n        {\n            this.persons = new ArrayList<_pure.app.test.Person>();\n        }\n        this.persons.add(object);\n    }\n\n    public List<_pure.app.test.Firm> getFirms()\n    {\n        return this.firms == null ? Collections.<_pure.app.test.Firm>emptyList() : this.firms;\n    }\n\n    public void setFirms(List<_pure.app.test.Firm> firms)\n    {\n        this.firms = firms;\n    }\n\n    public void addFirms(_pure.app.test.Firm object)\n    {\n        if (this.firms == null)\n        {\n            this.firms = new ArrayList<_pure.app.test.Firm>();\n        }\n        this.firms.add(object);\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints()\n    {\n        return this.allConstraints(new org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext());\n    }\n\n    public _pure.app.test.Address withConstraintsApplied()\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = allConstraints();\n        if (!defects.isEmpty())\n        {\n            throw new IllegalStateException(defects.stream().map(org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect::getMessage).collect(java.util.stream.Collectors.joining(\"\\n\")));\n        }\n        return this;\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address> toChecked()\n    {\n        return this.toChecked(null, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address> toChecked(boolean applyConstraints)\n    {\n        return this.toChecked(null, applyConstraints);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address> toChecked(Object source)\n    {\n        return this.toChecked(source, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address> toChecked(Object source,\n                                                                                                                   boolean applyConstraints)\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = applyConstraints ? allConstraints() : java.util.Collections.emptyList();\n        return new org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address>() {\n            public java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> getDefects() { return defects; }\n            public Object getSource() { return source; }\n            public _pure.app.test.Address getValue() { return GraphFetch_Node4_Address_Impl.this; }\n        };\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints(org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext context)\n    {\n        List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> result = new ArrayList<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect>();\n        if (!context.visited.contains(this))\n        {\n            context.visited.add(this);\n            if (this.getFirms() != null)\n            {\n                for (int i = 0; i < this.getFirms().size(); i++)\n                {\n                    final int index = i;\n                    result.addAll(((org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.test.Firm>) this.getFirms()\n                                                                                                                                       .get(i))\n                                                                                                                                       .allConstraints(context)\n                                                                                                                                       .stream()\n                                                                                                                                       .map((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect d) -> org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicDefect.prefixPath(d,\n                                                                                                                                                                                                                                                                                                            org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicRelativePathNode.newRelativePathNode(\"firms\", index)))\n                                                                                                                                       .filter((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect x) -> x != null)\n                                                                                                                                       .collect(Collectors.toList()));\n                }\n            }\n            if (this.getPersons() != null)\n            {\n                for (int i = 0; i < this.getPersons().size(); i++)\n                {\n                    final int index = i;\n                    result.addAll(((org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.test.Person>) this.getPersons()\n                                                                                                                                         .get(i))\n                                                                                                                                         .allConstraints(context)\n                                                                                                                                         .stream()\n                                                                                                                                         .map((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect d) -> org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicDefect.prefixPath(d,\n                                                                                                                                                                                                                                                                                                              org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicRelativePathNode.newRelativePathNode(\"persons\", index)))\n                                                                                                                                         .filter((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect x) -> x != null)\n                                                                                                                                         .collect(Collectors.toList()));\n                }\n            }\n        }\n        return result;\n    }\n\n    public Object getPk$_0()\n    {\n        return this.pk$_0;\n    }\n\n    public void setPk$_0(Object pk$_0)\n    {\n        this.pk$_0 = pk$_0;\n    }\n\n    public String getSetId$()\n    {\n        return this.setId$;\n    }\n\n    public void setSetId$(String setId)\n    {\n        this.setId$ = setId;\n    }\n\n    public String getAlloyStoreObjectReference$()\n    {\n        if (this.alloyStoreObjectReference$ == null)\n        {\n            try\n            {\n                StringBuilder referenceBuilder = new StringBuilder();\n                referenceBuilder.append(\"001:\");\n                referenceBuilder.append(\"010:\");\n\n                referenceBuilder.append(\"0000000010:\");\n                referenceBuilder.append(\"Relational:\");\n\n                referenceBuilder.append(\"0000000009:\");\n                referenceBuilder.append(\"test::Map:\");\n\n                referenceBuilder.append(\"0000000012:\");\n                referenceBuilder.append(\"test_Address:\");\n\n                String setId = this.getSetId$();\n                referenceBuilder.append(String.format(\"%010d\", setId.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(setId);\n                referenceBuilder.append(\":\");\n\n                String databaseConnectionString = _pure.plan.root.n1.globalChild0.globalChild0.localGraph.GraphFetch_Node4_Address_Impl.databaseConnection$;\n                referenceBuilder.append(String.format(\"%010d\", databaseConnectionString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(databaseConnectionString);\n                referenceBuilder.append(\":\");\n\n                Map<String, Object> pkMap = new HashMap<>();\n\n                pkMap.put(\"pk$_0\", this.getPk$_0());\n                String pkMapString = objectMapper$.writeValueAsString(pkMap);\n                referenceBuilder.append(String.format(\"%010d\", pkMapString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(pkMapString);\n\n                this.alloyStoreObjectReference$ = \"ASOR:\" + org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(referenceBuilder.toString().getBytes());\n            }\n            catch (Exception e)\n            {\n               throw new RuntimeException(e);\n            }\n        }\n\n        return this.alloyStoreObjectReference$;\n    }\n\n    public void setAlloyStoreObjectReference$(String reference)\n    {\n        this.alloyStoreObjectReference$ = reference;\n    }\n\n    private static long getClassSize$()\n    {\n        return 156L;\n    }\n\n    public long getInstanceSize$()\n    {\n        long size = GraphFetch_Node4_Address_Impl.getClassSize$();\n        if (this.name != null)\n        {\n            size = size + this.name.length();\n        }\n        if (this.setId$ != null)\n        {\n            size = size + this.setId$.length();\n        }\n        if (this.alloyStoreObjectReference$ != null)\n        {\n            size = size + this.alloyStoreObjectReference$.length();\n        }\n        if (this.persons != null)\n        {\n            for (_pure.app.test.Person i: this.persons)\n            {\n                if (i != null)\n                {\n                    size = size + 20L;\n                }\n            }\n        }\n        if (this.firms != null)\n        {\n            for (_pure.app.test.Firm i: this.firms)\n            {\n                if (i != null)\n                {\n                    size = size + 20L;\n                }\n            }\n        }\n        return size;\n    }\n}"
    }, {
      "name" : "Specifics",
      "package" : "_pure.plan.root.n1.globalChild0.globalChild0.localGraph",
      "source" : "package _pure.plan.root.n1.globalChild0.globalChild0.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.Types;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.eclipse.collections.impl.tuple.Tuples;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IConstantResult;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n\nclass Specifics\n{\n    private static final List<Integer> STRING_TYPES = Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL);\n    private static final List<Integer> INT_TYPES = Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL);\n    private static final List<Integer> FLOAT_TYPES = Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> DECIMAL_TYPES = Arrays.asList(Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> BOOL_TYPES = Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL);\n    private static final List<Integer> STRICT_DATE_TYPES = Arrays.asList(Types.DATE, Types.NULL);\n    private static final List<Integer> DATE_TIME_TYPES = Arrays.asList(Types.TIMESTAMP, Types.NULL);\n    private ResultSet resultSet;\n    private String databaseTimeZone;\n    private String databaseConnection;\n    private List<Integer> columnTypes;\n    private List<List<Integer>> propertyIndices;\n    private List<List<Supplier<Object>>> propertyGetters;\n    private Calendar calendar;\n    private Method parentPropertyAdder;\n    private Method parentEdgePointPropertyAdder;\n\n    private Object getAlloyNativeValueFromResultSet(ResultSet resultSet,\n                                                    int columnIndex,\n                                                    int columnType)\n    {\n        try\n        {\n            Object result = null;\n            switch (columnType)\n            {\n                case Types.DATE:\n                {\n                    java.sql.Date date = resultSet.getDate(columnIndex);\n                    if (date != null)\n                    {\n                        result = PureDate.fromSQLDate(date);\n                    }\n                    break;\n                }\n                case Types.TIMESTAMP:\n                {\n                    java.sql.Timestamp timestamp = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (timestamp != null)\n                    {\n                        result = PureDate.fromSQLTimestamp(timestamp);\n                    }\n                    break;\n                }\n                case Types.TINYINT:\n                case Types.SMALLINT:\n                case Types.INTEGER:\n                case Types.BIGINT:\n                {\n                    long num = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Long.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.REAL:\n                case Types.FLOAT:\n                case Types.DOUBLE:\n                {\n                    double num = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Double.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.DECIMAL:\n                case Types.NUMERIC:\n                {\n                    result = resultSet.getBigDecimal(columnIndex);\n                    break;\n                }\n                case Types.CHAR:\n                case Types.VARCHAR:\n                case Types.LONGVARCHAR:\n                case Types.NCHAR:\n                case Types.NVARCHAR:\n                case Types.LONGNVARCHAR:\n                case Types.OTHER:\n                {\n                    result = resultSet.getString(columnIndex);\n                    break;\n                }\n                case Types.BIT:\n                case Types.BOOLEAN:\n                {\n                    boolean bool = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Boolean.valueOf(bool);\n                    }\n                }\n                case Types.BINARY:\n                case Types.VARBINARY:\n                case Types.LONGVARBINARY:\n                {\n                    byte[] bytes = resultSet.getBytes(columnIndex);\n                    if (bytes != null)\n                    {\n                        result = this.encodeHex(bytes);\n                    }\n                    break;\n                }\n                case Types.NULL:\n                {\n                    // do nothing: value is already assigned to null\n                    break;\n                }\n                default:\n                {\n                    result = resultSet.getObject(columnIndex);\n                }\n            }\n            return result;}\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String encodeHex(byte[] data)\n    {\n        final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n        final int l = data.length;\n        final char[] out = new char[l << 1];\n        for (int i = 0, j = 0; i < l; i++)\n        {\n            out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS_LOWER[0x0F & data[i]];\n        }\n        return new String(out);\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStringProperty(ResultSet resultSet,\n                                                                         int columnIndex,\n                                                                         int columnType,\n                                                                         String propertyName)\n    {\n        if (STRING_TYPES.contains(columnType))\n        {\n           return () -> {\n                try\n                {\n                    return resultSet.getString(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        else\n        {\n            throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type String from SQL column of type '\" + columnType + \"'.\");\n        }\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForIntegerProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Long res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Long.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Integer from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForFloatProperty(ResultSet resultSet,\n                                                                        int columnIndex,\n                                                                        int columnType,\n                                                                        String propertyName)\n    {\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Float from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDecimalProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (DECIMAL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    return resultSet.getBigDecimal(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Decimal from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForBooleanProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (BOOL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    boolean r = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r == 1);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Boolean from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStrictDateProperty(ResultSet resultSet,\n                                                                             int columnIndex,\n                                                                             int columnType,\n                                                                             String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type StrictDate from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateTimeProperty(ResultSet resultSet,\n                                                                           int columnIndex,\n                                                                           int columnType,\n                                                                           String propertyName)\n    {\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type DateTime from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateProperty(ResultSet resultSet,\n                                                                       int columnIndex,\n                                                                       int columnType,\n                                                                       String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException1)\n                        {\n                            try\n                            {\n                                res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                            }\n                            catch (java.time.format.DateTimeParseException dateTimeParseException2)\n                            {\n                                res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                            }\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Date from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        try\n        {\n            this.resultSet = resultSet;\n            this.databaseTimeZone = databaseTimeZone;\n            this.databaseConnection = databaseConnection;\n            this.calendar = new GregorianCalendar(TimeZone.getTimeZone(this.databaseTimeZone));\n            ResultSetMetaData resultSetMetaData = this.resultSet.getMetaData();\n            int columnCount = resultSetMetaData.getColumnCount();\n            this.columnTypes = new ArrayList<Integer>();\n            List<String> columnNames = new ArrayList<String>();\n            for (int i = 1; i <= columnCount; i++)\n            {\n                String columnLabel = resultSetMetaData.getColumnLabel(i);\n                columnNames.add(columnLabel.startsWith(\"\\\"\") && columnLabel\n                                           .endsWith(\"\\\"\")\n                                           ? columnLabel.substring(1, columnLabel.length() - 1)\n                                                        .toUpperCase()\n                                           : columnLabel.toUpperCase());\n                this.columnTypes.add(resultSetMetaData.getColumnType(i));\n            }\n            this.propertyIndices = new ArrayList<List<Integer>>();\n            List<Integer> index_0 = new ArrayList<Integer>();\n            index_0.add(columnNames.indexOf(\"NAME\") + 1);\n            index_0.add(columnNames.indexOf(\"PK_0\") + 1);\n            this.propertyIndices.add(index_0);\n            GraphFetch_Node4_Address_Impl.databaseConnection$ = databaseConnection;\n            this.propertyGetters = new ArrayList<List<Supplier<Object>>>();\n            int propertyIndex;\n            Supplier<Object> propertyGetter = null;\n            List<Supplier<Object>> propertyGetter_0 = new ArrayList<Supplier<Object>>();\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"name\");\n            propertyGetter_0.add(propertyGetter);\n            this.propertyGetters.add(propertyGetter_0);\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    IGraphInstance<? extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject> nextGraphInstance()\n    {\n        try\n        {\n            final GraphFetch_Node4_Address_Impl object = new GraphFetch_Node4_Address_Impl();\n            object.setSetId$(\"test_Address\");\n            int pkColIndex;\n            int propertyIndex;\n            pkColIndex = this.propertyIndices.get(0).get(1);\n            Object pk$_0 = this.getAlloyNativeValueFromResultSet(resultSet,\n                                                                 pkColIndex,\n                                                                 this.columnTypes.get(pkColIndex - 1));\n            object.setPk$_0(pk$_0);\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            {\n                String res = (String) this.propertyGetters.get(0).get(0).get();\n                if (res == null)\n                {\n                    throw new RuntimeException(\"Error reading in property 'name'. Property of multiplicity [1] can not be null\");\n                }\n                object.setName(res);\n            }\n            return new IGraphInstance<GraphFetch_Node4_Address_Impl>()\n            {\n                public GraphFetch_Node4_Address_Impl getValue()\n                {\n                    return object;\n                }\n                public long instanceSize()\n                {\n                    return object.getInstanceSize$();\n                }\n            };\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<Method> primaryKeyGetters()\n    {\n        try\n        {\n            return Arrays.asList(GraphFetch_Node4_Address_Impl.class.getMethod(\"getPk$_0\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String mappingId()\n    {\n        return \"test::Map\";\n    }\n\n    public String sourceInstanceSetId()\n    {\n        return \"test_Firm\";\n    }\n\n    public String targetInstanceSetId()\n    {\n        return \"test_Address\";\n    }\n\n    void addChildToParent(Object parent, Object child, IExecutionNodeContext executionNodeContext)\n    {\n        try\n        {\n            if (this.parentPropertyAdder == null)\n            {\n                this.parentPropertyAdder = parent\n                    .getClass()\n                    .getMethod(\"addAddress\", _pure.app.test.Address.class);\n            }\n            this.parentPropertyAdder.invoke(parent, child);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<String> parentCrossKeyColumns(List<String> queryResultColumns)\n    {\n        return queryResultColumns.stream()\n                                 .filter((String x) -> x.toUpperCase()\n                                                        .startsWith(\"PARENT_CROSS_KEY_\"))\n                                 .collect(Collectors.toList());\n    }\n\n    List<Method> parentCrossKeyGetters()\n    {\n        try\n        {\n            return Arrays.asList(_pure.app.test.Firm_Map_test_Firm.class\n                                                                  .getMethod(\"getAddressName\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    boolean supportsCrossCaching()\n    {\n        return true;\n    }\n\n    List<String> targetPropertiesOrdered()\n    {\n        return Arrays.asList(\"name\");\n    }\n\n    List<Method> parentCrossKeyGettersOrderedByTargetProperties()\n    {\n        try\n        {\n            return Arrays.asList(_pure.app.test.Firm_Map_test_Firm.class\n                                                                  .getMethod(\"getAddressName\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n}"
    }, {
      "name" : "Execute",
      "package" : "_pure.plan.root.n1.globalChild0.localGraph",
      "source" : "package _pure.plan.root.n1.globalChild0.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.relational.graphFetch.IRelationalCrossRootQueryTempTableGraphFetchExecutionNodeSpecifics;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject;\n\npublic class Execute implements IRelationalCrossRootQueryTempTableGraphFetchExecutionNodeSpecifics\n{\n    private Specifics specifics;\n\n    public Execute()\n    {\n        this.specifics = new Specifics();\n    }\n\n    public void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        this.specifics.prepare(resultSet, databaseTimeZone, databaseConnection);\n    }\n\n    public IGraphInstance<? extends IReferencedObject> nextGraphInstance()\n    {\n        return this.specifics.nextGraphInstance();\n    }\n\n    public List<Method> primaryKeyGetters()\n    {\n        return this.specifics.primaryKeyGetters();\n    }\n\n    public String mappingId()\n    {\n        return this.specifics.mappingId();\n    }\n\n    public String sourceInstanceSetId()\n    {\n        return this.specifics.sourceInstanceSetId();\n    }\n\n    public String targetInstanceSetId()\n    {\n        return this.specifics.targetInstanceSetId();\n    }\n\n    public void addChildToParent(Object parent,\n                                 Object child,\n                                 IExecutionNodeContext executionNodeContext)\n    {\n        this.specifics.addChildToParent(parent, child, executionNodeContext);\n    }\n\n    public List<String> parentCrossKeyColumns(List<String> queryResultColumns)\n    {\n        return this.specifics.parentCrossKeyColumns(queryResultColumns);\n    }\n\n    public List<Method> parentCrossKeyGetters()\n    {\n        return this.specifics.parentCrossKeyGetters();\n    }\n\n    public boolean supportsCrossCaching()\n    {\n        return this.specifics.supportsCrossCaching();\n    }\n\n    public List<String> targetPropertiesOrdered()\n    {\n        return this.specifics.targetPropertiesOrdered();\n    }\n\n    public List<Method> parentCrossKeyGettersOrderedByTargetProperties()\n    {\n        return this.specifics.parentCrossKeyGettersOrderedByTargetProperties();\n    }\n}"
    }, {
      "name" : "GraphFetch_Node2_Firm_Map_test_Firm_Impl",
      "package" : "_pure.plan.root.n1.globalChild0.localGraph",
      "source" : "package _pure.plan.root.n1.globalChild0.localGraph;\n\nimport java.math.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DayOfWeek;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.util.Library;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport java.io.IOException;\n\npublic class GraphFetch_Node2_Firm_Map_test_Firm_Impl implements _pure.app.test.Firm_Map_test_Firm, org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.test.Firm_Map_test_Firm>, java.io.Serializable\n{\n    private String addressName;\n    private String name;\n    private List<_pure.app.test.Person> employees;\n    private _pure.app.test.Address address;\n    private Object pk$_0;\n    private static final ObjectMapper objectMapper$ = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).registerModule(new SimpleModule().addSerializer(PureDate.class, new JsonSerializer<PureDate>() { @Override public void serialize(PureDate value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeRawValue(\"\\\"\" + value.toString() + \"\\\"\"); } }));\n    private String setId$;\n    public static String databaseConnection$;\n    private String alloyStoreObjectReference$;\n    private static final long serialVersionUID = 1207541065L;\n\n    public String getAddressName()\n    {\n        return this.addressName;\n    }\n\n    public void setAddressName(String addressName)\n    {\n        this.addressName = addressName;\n    }\n\n    public void addAddressName(String object)\n    {\n        if ((Object) this.addressName != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'addressName' of multiplicity with bound 1\");\n        }\n        this.addressName = object;\n    }\n\n    public String getName()\n    {\n        return this.name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n\n    public void addName(String object)\n    {\n        if ((Object) this.name != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'name' of multiplicity with bound 1\");\n        }\n        this.name = object;\n    }\n\n    public List<_pure.app.test.Person> getEmployees()\n    {\n        return this.employees == null\n                   ? Collections.<_pure.app.test.Person>emptyList()\n                   : this.employees;\n    }\n\n    public void setEmployees(List<_pure.app.test.Person> employees)\n    {\n        this.employees = employees;\n    }\n\n    public void addEmployees(_pure.app.test.Person object)\n    {\n        if (this.employees == null)\n        {\n            this.employees = new ArrayList<_pure.app.test.Person>();\n        }\n        this.employees.add(object);\n    }\n\n    public _pure.app.test.Address getAddress()\n    {\n        return this.address;\n    }\n\n    public void setAddress(_pure.app.test.Address address)\n    {\n        this.address = address;\n    }\n\n    public void addAddress(_pure.app.test.Address object)\n    {\n        if ((Object) this.address != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'address' of multiplicity with bound 1\");\n        }\n        this.address = object;\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints()\n    {\n        return this.allConstraints(new org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext());\n    }\n\n    public _pure.app.test.Firm_Map_test_Firm withConstraintsApplied()\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = allConstraints();\n        if (!defects.isEmpty())\n        {\n            throw new IllegalStateException(defects.stream().map(org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect::getMessage).collect(java.util.stream.Collectors.joining(\"\\n\")));\n        }\n        return this;\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Firm_Map_test_Firm> toChecked()\n    {\n        return this.toChecked(null, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Firm_Map_test_Firm> toChecked(boolean applyConstraints)\n    {\n        return this.toChecked(null, applyConstraints);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Firm_Map_test_Firm> toChecked(Object source)\n    {\n        return this.toChecked(source, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Firm_Map_test_Firm> toChecked(Object source,\n                                                                                                                              boolean applyConstraints)\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = applyConstraints ? allConstraints() : java.util.Collections.emptyList();\n        return new org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Firm_Map_test_Firm>() {\n            public java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> getDefects() { return defects; }\n            public Object getSource() { return source; }\n            public _pure.app.test.Firm_Map_test_Firm getValue() { return GraphFetch_Node2_Firm_Map_test_Firm_Impl.this; }\n        };\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints(org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext context)\n    {\n        List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> result = new ArrayList<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect>();\n        if (!context.visited.contains(this))\n        {\n            context.visited.add(this);\n        }\n        return result;\n    }\n\n    public Object getPk$_0()\n    {\n        return this.pk$_0;\n    }\n\n    public void setPk$_0(Object pk$_0)\n    {\n        this.pk$_0 = pk$_0;\n    }\n\n    public String getSetId$()\n    {\n        return this.setId$;\n    }\n\n    public void setSetId$(String setId)\n    {\n        this.setId$ = setId;\n    }\n\n    public String getAlloyStoreObjectReference$()\n    {\n        if (this.alloyStoreObjectReference$ == null)\n        {\n            try\n            {\n                StringBuilder referenceBuilder = new StringBuilder();\n                referenceBuilder.append(\"001:\");\n                referenceBuilder.append(\"010:\");\n\n                referenceBuilder.append(\"0000000010:\");\n                referenceBuilder.append(\"Relational:\");\n\n                referenceBuilder.append(\"0000000009:\");\n                referenceBuilder.append(\"test::Map:\");\n\n                referenceBuilder.append(\"0000000009:\");\n                referenceBuilder.append(\"test_Firm:\");\n\n                String setId = this.getSetId$();\n                referenceBuilder.append(String.format(\"%010d\", setId.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(setId);\n                referenceBuilder.append(\":\");\n\n                String databaseConnectionString = _pure.plan.root.n1.globalChild0.localGraph.GraphFetch_Node2_Firm_Map_test_Firm_Impl.databaseConnection$;\n                referenceBuilder.append(String.format(\"%010d\", databaseConnectionString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(databaseConnectionString);\n                referenceBuilder.append(\":\");\n\n                Map<String, Object> pkMap = new HashMap<>();\n\n                pkMap.put(\"pk$_0\", this.getPk$_0());\n                String pkMapString = objectMapper$.writeValueAsString(pkMap);\n                referenceBuilder.append(String.format(\"%010d\", pkMapString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(pkMapString);\n\n                this.alloyStoreObjectReference$ = \"ASOR:\" + org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(referenceBuilder.toString().getBytes());\n            }\n            catch (Exception e)\n            {\n               throw new RuntimeException(e);\n            }\n        }\n\n        return this.alloyStoreObjectReference$;\n    }\n\n    public void setAlloyStoreObjectReference$(String reference)\n    {\n        this.alloyStoreObjectReference$ = reference;\n    }\n\n    private static long getClassSize$()\n    {\n        return 180L;\n    }\n\n    public long getInstanceSize$()\n    {\n        long size = GraphFetch_Node2_Firm_Map_test_Firm_Impl.getClassSize$();\n        if (this.addressName != null)\n        {\n            size = size + this.addressName.length();\n        }\n        if (this.name != null)\n        {\n            size = size + this.name.length();\n        }\n        if (this.setId$ != null)\n        {\n            size = size + this.setId$.length();\n        }\n        if (this.alloyStoreObjectReference$ != null)\n        {\n            size = size + this.alloyStoreObjectReference$.length();\n        }\n        if (this.employees != null)\n        {\n            for (_pure.app.test.Person i: this.employees)\n            {\n                if (i != null)\n                {\n                    size = size + 20L;\n                }\n            }\n        }\n        return size;\n    }\n}"
    }, {
      "name" : "Specifics",
      "package" : "_pure.plan.root.n1.globalChild0.localGraph",
      "source" : "package _pure.plan.root.n1.globalChild0.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.Types;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.eclipse.collections.impl.tuple.Tuples;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IConstantResult;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n\nclass Specifics\n{\n    private static final List<Integer> STRING_TYPES = Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL);\n    private static final List<Integer> INT_TYPES = Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL);\n    private static final List<Integer> FLOAT_TYPES = Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> DECIMAL_TYPES = Arrays.asList(Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> BOOL_TYPES = Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL);\n    private static final List<Integer> STRICT_DATE_TYPES = Arrays.asList(Types.DATE, Types.NULL);\n    private static final List<Integer> DATE_TIME_TYPES = Arrays.asList(Types.TIMESTAMP, Types.NULL);\n    private ResultSet resultSet;\n    private String databaseTimeZone;\n    private String databaseConnection;\n    private List<Integer> columnTypes;\n    private List<List<Integer>> propertyIndices;\n    private List<List<Supplier<Object>>> propertyGetters;\n    private Calendar calendar;\n    private Method parentPropertyAdder;\n    private Method parentEdgePointPropertyAdder;\n\n    private Object getAlloyNativeValueFromResultSet(ResultSet resultSet,\n                                                    int columnIndex,\n                                                    int columnType)\n    {\n        try\n        {\n            Object result = null;\n            switch (columnType)\n            {\n                case Types.DATE:\n                {\n                    java.sql.Date date = resultSet.getDate(columnIndex);\n                    if (date != null)\n                    {\n                        result = PureDate.fromSQLDate(date);\n                    }\n                    break;\n                }\n                case Types.TIMESTAMP:\n                {\n                    java.sql.Timestamp timestamp = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (timestamp != null)\n                    {\n                        result = PureDate.fromSQLTimestamp(timestamp);\n                    }\n                    break;\n                }\n                case Types.TINYINT:\n                case Types.SMALLINT:\n                case Types.INTEGER:\n                case Types.BIGINT:\n                {\n                    long num = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Long.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.REAL:\n                case Types.FLOAT:\n                case Types.DOUBLE:\n                {\n                    double num = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Double.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.DECIMAL:\n                case Types.NUMERIC:\n                {\n                    result = resultSet.getBigDecimal(columnIndex);\n                    break;\n                }\n                case Types.CHAR:\n                case Types.VARCHAR:\n                case Types.LONGVARCHAR:\n                case Types.NCHAR:\n                case Types.NVARCHAR:\n                case Types.LONGNVARCHAR:\n                case Types.OTHER:\n                {\n                    result = resultSet.getString(columnIndex);\n                    break;\n                }\n                case Types.BIT:\n                case Types.BOOLEAN:\n                {\n                    boolean bool = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Boolean.valueOf(bool);\n                    }\n                }\n                case Types.BINARY:\n                case Types.VARBINARY:\n                case Types.LONGVARBINARY:\n                {\n                    byte[] bytes = resultSet.getBytes(columnIndex);\n                    if (bytes != null)\n                    {\n                        result = this.encodeHex(bytes);\n                    }\n                    break;\n                }\n                case Types.NULL:\n                {\n                    // do nothing: value is already assigned to null\n                    break;\n                }\n                default:\n                {\n                    result = resultSet.getObject(columnIndex);\n                }\n            }\n            return result;}\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String encodeHex(byte[] data)\n    {\n        final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n        final int l = data.length;\n        final char[] out = new char[l << 1];\n        for (int i = 0, j = 0; i < l; i++)\n        {\n            out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS_LOWER[0x0F & data[i]];\n        }\n        return new String(out);\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStringProperty(ResultSet resultSet,\n                                                                         int columnIndex,\n                                                                         int columnType,\n                                                                         String propertyName)\n    {\n        if (STRING_TYPES.contains(columnType))\n        {\n           return () -> {\n                try\n                {\n                    return resultSet.getString(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        else\n        {\n            throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type String from SQL column of type '\" + columnType + \"'.\");\n        }\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForIntegerProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Long res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Long.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Integer from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForFloatProperty(ResultSet resultSet,\n                                                                        int columnIndex,\n                                                                        int columnType,\n                                                                        String propertyName)\n    {\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Float from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDecimalProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (DECIMAL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    return resultSet.getBigDecimal(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Decimal from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForBooleanProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (BOOL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    boolean r = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r == 1);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Boolean from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStrictDateProperty(ResultSet resultSet,\n                                                                             int columnIndex,\n                                                                             int columnType,\n                                                                             String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type StrictDate from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateTimeProperty(ResultSet resultSet,\n                                                                           int columnIndex,\n                                                                           int columnType,\n                                                                           String propertyName)\n    {\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type DateTime from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateProperty(ResultSet resultSet,\n                                                                       int columnIndex,\n                                                                       int columnType,\n                                                                       String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException1)\n                        {\n                            try\n                            {\n                                res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                            }\n                            catch (java.time.format.DateTimeParseException dateTimeParseException2)\n                            {\n                                res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                            }\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Date from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        try\n        {\n            this.resultSet = resultSet;\n            this.databaseTimeZone = databaseTimeZone;\n            this.databaseConnection = databaseConnection;\n            this.calendar = new GregorianCalendar(TimeZone.getTimeZone(this.databaseTimeZone));\n            ResultSetMetaData resultSetMetaData = this.resultSet.getMetaData();\n            int columnCount = resultSetMetaData.getColumnCount();\n            this.columnTypes = new ArrayList<Integer>();\n            List<String> columnNames = new ArrayList<String>();\n            for (int i = 1; i <= columnCount; i++)\n            {\n                String columnLabel = resultSetMetaData.getColumnLabel(i);\n                columnNames.add(columnLabel.startsWith(\"\\\"\") && columnLabel\n                                           .endsWith(\"\\\"\")\n                                           ? columnLabel.substring(1, columnLabel.length() - 1)\n                                                        .toUpperCase()\n                                           : columnLabel.toUpperCase());\n                this.columnTypes.add(resultSetMetaData.getColumnType(i));\n            }\n            this.propertyIndices = new ArrayList<List<Integer>>();\n            List<Integer> index_0 = new ArrayList<Integer>();\n            index_0.add(columnNames.indexOf(\"ADDRESSNAME\") + 1);\n            index_0.add(columnNames.indexOf(\"NAME\") + 1);\n            index_0.add(columnNames.indexOf(\"PK_0\") + 1);\n            this.propertyIndices.add(index_0);\n            GraphFetch_Node2_Firm_Map_test_Firm_Impl.databaseConnection$ = databaseConnection;\n            this.propertyGetters = new ArrayList<List<Supplier<Object>>>();\n            int propertyIndex;\n            Supplier<Object> propertyGetter = null;\n            List<Supplier<Object>> propertyGetter_0 = new ArrayList<Supplier<Object>>();\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"addressName\");\n            propertyGetter_0.add(propertyGetter);\n            propertyIndex = this.propertyIndices.get(0).get(1);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"name\");\n            propertyGetter_0.add(propertyGetter);\n            this.propertyGetters.add(propertyGetter_0);\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    IGraphInstance<? extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject> nextGraphInstance()\n    {\n        try\n        {\n            final GraphFetch_Node2_Firm_Map_test_Firm_Impl object = new GraphFetch_Node2_Firm_Map_test_Firm_Impl();\n            object.setSetId$(\"test_Firm\");\n            int pkColIndex;\n            int propertyIndex;\n            pkColIndex = this.propertyIndices.get(0).get(2);\n            Object pk$_0 = this.getAlloyNativeValueFromResultSet(resultSet,\n                                                                 pkColIndex,\n                                                                 this.columnTypes.get(pkColIndex - 1));\n            object.setPk$_0(pk$_0);\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            {\n                String res = (String) this.propertyGetters.get(0).get(0).get();\n                object.setAddressName(res);\n            }\n            propertyIndex = this.propertyIndices.get(0).get(1);\n            {\n                String res = (String) this.propertyGetters.get(0).get(1).get();\n                if (res == null)\n                {\n                    throw new RuntimeException(\"Error reading in property 'name'. Property of multiplicity [1] can not be null\");\n                }\n                object.setName(res);\n            }\n            return new IGraphInstance<GraphFetch_Node2_Firm_Map_test_Firm_Impl>()\n            {\n                public GraphFetch_Node2_Firm_Map_test_Firm_Impl getValue()\n                {\n                    return object;\n                }\n                public long instanceSize()\n                {\n                    return object.getInstanceSize$();\n                }\n            };\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<Method> primaryKeyGetters()\n    {\n        try\n        {\n            return Arrays.asList(GraphFetch_Node2_Firm_Map_test_Firm_Impl.class\n                                                                         .getMethod(\"getPk$_0\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String mappingId()\n    {\n        return \"test::Map\";\n    }\n\n    public String sourceInstanceSetId()\n    {\n        return \"test_Person\";\n    }\n\n    public String targetInstanceSetId()\n    {\n        return \"test_Firm\";\n    }\n\n    void addChildToParent(Object parent, Object child, IExecutionNodeContext executionNodeContext)\n    {\n        try\n        {\n            if (this.parentPropertyAdder == null)\n            {\n                this.parentPropertyAdder = parent\n                    .getClass()\n                    .getMethod(\"addFirm\", _pure.app.test.Firm.class);\n            }\n            this.parentPropertyAdder.invoke(parent, child);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<String> parentCrossKeyColumns(List<String> queryResultColumns)\n    {\n        return queryResultColumns.stream()\n                                 .filter((String x) -> x.toUpperCase()\n                                                        .startsWith(\"PARENT_CROSS_KEY_\"))\n                                 .collect(Collectors.toList());\n    }\n\n    List<Method> parentCrossKeyGetters()\n    {\n        try\n        {\n            return Arrays.asList(_pure.app.test.Person_Map_test_Person.class\n                                                                      .getMethod(\"getFirmName\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    boolean supportsCrossCaching()\n    {\n        return true;\n    }\n\n    List<String> targetPropertiesOrdered()\n    {\n        return Arrays.asList(\"name\");\n    }\n\n    List<Method> parentCrossKeyGettersOrderedByTargetProperties()\n    {\n        try\n        {\n            return Arrays.asList(_pure.app.test.Person_Map_test_Person.class\n                                                                      .getMethod(\"getFirmName\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n}"
    }, {
      "name" : "Execute",
      "package" : "_pure.plan.root.n1.globalChild1.localGraph",
      "source" : "package _pure.plan.root.n1.globalChild1.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.relational.graphFetch.IRelationalCrossRootQueryTempTableGraphFetchExecutionNodeSpecifics;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject;\n\npublic class Execute implements IRelationalCrossRootQueryTempTableGraphFetchExecutionNodeSpecifics\n{\n    private Specifics specifics;\n\n    public Execute()\n    {\n        this.specifics = new Specifics();\n    }\n\n    public void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        this.specifics.prepare(resultSet, databaseTimeZone, databaseConnection);\n    }\n\n    public IGraphInstance<? extends IReferencedObject> nextGraphInstance()\n    {\n        return this.specifics.nextGraphInstance();\n    }\n\n    public List<Method> primaryKeyGetters()\n    {\n        return this.specifics.primaryKeyGetters();\n    }\n\n    public String mappingId()\n    {\n        return this.specifics.mappingId();\n    }\n\n    public String sourceInstanceSetId()\n    {\n        return this.specifics.sourceInstanceSetId();\n    }\n\n    public String targetInstanceSetId()\n    {\n        return this.specifics.targetInstanceSetId();\n    }\n\n    public void addChildToParent(Object parent,\n                                 Object child,\n                                 IExecutionNodeContext executionNodeContext)\n    {\n        this.specifics.addChildToParent(parent, child, executionNodeContext);\n    }\n\n    public List<String> parentCrossKeyColumns(List<String> queryResultColumns)\n    {\n        return this.specifics.parentCrossKeyColumns(queryResultColumns);\n    }\n\n    public List<Method> parentCrossKeyGetters()\n    {\n        return this.specifics.parentCrossKeyGetters();\n    }\n\n    public boolean supportsCrossCaching()\n    {\n        return this.specifics.supportsCrossCaching();\n    }\n\n    public List<String> targetPropertiesOrdered()\n    {\n        return this.specifics.targetPropertiesOrdered();\n    }\n\n    public List<Method> parentCrossKeyGettersOrderedByTargetProperties()\n    {\n        return this.specifics.parentCrossKeyGettersOrderedByTargetProperties();\n    }\n}"
    }, {
      "name" : "GraphFetch_Node7_Address_Impl",
      "package" : "_pure.plan.root.n1.globalChild1.localGraph",
      "source" : "package _pure.plan.root.n1.globalChild1.localGraph;\n\nimport java.math.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DayOfWeek;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.util.Library;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport java.io.IOException;\n\npublic class GraphFetch_Node7_Address_Impl implements _pure.app.test.Address, org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.test.Address>, java.io.Serializable\n{\n    private String name;\n    private List<_pure.app.test.Person> persons;\n    private List<_pure.app.test.Firm> firms;\n    private Object pk$_0;\n    private static final ObjectMapper objectMapper$ = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).registerModule(new SimpleModule().addSerializer(PureDate.class, new JsonSerializer<PureDate>() { @Override public void serialize(PureDate value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeRawValue(\"\\\"\" + value.toString() + \"\\\"\"); } }));\n    private String setId$;\n    public static String databaseConnection$;\n    private String alloyStoreObjectReference$;\n    private static final long serialVersionUID = 158558467L;\n\n    public String getName()\n    {\n        return this.name;\n    }\n\n    public void setName(String name)\n    {\n        this.name = name;\n    }\n\n    public void addName(String object)\n    {\n        if ((Object) this.name != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'name' of multiplicity with bound 1\");\n        }\n        this.name = object;\n    }\n\n    public List<_pure.app.test.Person> getPersons()\n    {\n        return this.persons == null ? Collections.<_pure.app.test.Person>emptyList() : this.persons;\n    }\n\n    public void setPersons(List<_pure.app.test.Person> persons)\n    {\n        this.persons = persons;\n    }\n\n    public void addPersons(_pure.app.test.Person object)\n    {\n        if (this.persons == null)\n        {\n            this.persons = new ArrayList<_pure.app.test.Person>();\n        }\n        this.persons.add(object);\n    }\n\n    public List<_pure.app.test.Firm> getFirms()\n    {\n        return this.firms == null ? Collections.<_pure.app.test.Firm>emptyList() : this.firms;\n    }\n\n    public void setFirms(List<_pure.app.test.Firm> firms)\n    {\n        this.firms = firms;\n    }\n\n    public void addFirms(_pure.app.test.Firm object)\n    {\n        if (this.firms == null)\n        {\n            this.firms = new ArrayList<_pure.app.test.Firm>();\n        }\n        this.firms.add(object);\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints()\n    {\n        return this.allConstraints(new org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext());\n    }\n\n    public _pure.app.test.Address withConstraintsApplied()\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = allConstraints();\n        if (!defects.isEmpty())\n        {\n            throw new IllegalStateException(defects.stream().map(org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect::getMessage).collect(java.util.stream.Collectors.joining(\"\\n\")));\n        }\n        return this;\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address> toChecked()\n    {\n        return this.toChecked(null, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address> toChecked(boolean applyConstraints)\n    {\n        return this.toChecked(null, applyConstraints);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address> toChecked(Object source)\n    {\n        return this.toChecked(source, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address> toChecked(Object source,\n                                                                                                                   boolean applyConstraints)\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = applyConstraints ? allConstraints() : java.util.Collections.emptyList();\n        return new org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Address>() {\n            public java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> getDefects() { return defects; }\n            public Object getSource() { return source; }\n            public _pure.app.test.Address getValue() { return GraphFetch_Node7_Address_Impl.this; }\n        };\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints(org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext context)\n    {\n        List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> result = new ArrayList<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect>();\n        if (!context.visited.contains(this))\n        {\n            context.visited.add(this);\n            if (this.getFirms() != null)\n            {\n                for (int i = 0; i < this.getFirms().size(); i++)\n                {\n                    final int index = i;\n                    result.addAll(((org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.test.Firm>) this.getFirms()\n                                                                                                                                       .get(i))\n                                                                                                                                       .allConstraints(context)\n                                                                                                                                       .stream()\n                                                                                                                                       .map((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect d) -> org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicDefect.prefixPath(d,\n                                                                                                                                                                                                                                                                                                            org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicRelativePathNode.newRelativePathNode(\"firms\", index)))\n                                                                                                                                       .filter((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect x) -> x != null)\n                                                                                                                                       .collect(Collectors.toList()));\n                }\n            }\n            if (this.getPersons() != null)\n            {\n                for (int i = 0; i < this.getPersons().size(); i++)\n                {\n                    final int index = i;\n                    result.addAll(((org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.test.Person>) this.getPersons()\n                                                                                                                                         .get(i))\n                                                                                                                                         .allConstraints(context)\n                                                                                                                                         .stream()\n                                                                                                                                         .map((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect d) -> org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicDefect.prefixPath(d,\n                                                                                                                                                                                                                                                                                                              org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicRelativePathNode.newRelativePathNode(\"persons\", index)))\n                                                                                                                                         .filter((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect x) -> x != null)\n                                                                                                                                         .collect(Collectors.toList()));\n                }\n            }\n        }\n        return result;\n    }\n\n    public Object getPk$_0()\n    {\n        return this.pk$_0;\n    }\n\n    public void setPk$_0(Object pk$_0)\n    {\n        this.pk$_0 = pk$_0;\n    }\n\n    public String getSetId$()\n    {\n        return this.setId$;\n    }\n\n    public void setSetId$(String setId)\n    {\n        this.setId$ = setId;\n    }\n\n    public String getAlloyStoreObjectReference$()\n    {\n        if (this.alloyStoreObjectReference$ == null)\n        {\n            try\n            {\n                StringBuilder referenceBuilder = new StringBuilder();\n                referenceBuilder.append(\"001:\");\n                referenceBuilder.append(\"010:\");\n\n                referenceBuilder.append(\"0000000010:\");\n                referenceBuilder.append(\"Relational:\");\n\n                referenceBuilder.append(\"0000000009:\");\n                referenceBuilder.append(\"test::Map:\");\n\n                referenceBuilder.append(\"0000000012:\");\n                referenceBuilder.append(\"test_Address:\");\n\n                String setId = this.getSetId$();\n                referenceBuilder.append(String.format(\"%010d\", setId.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(setId);\n                referenceBuilder.append(\":\");\n\n                String databaseConnectionString = _pure.plan.root.n1.globalChild1.localGraph.GraphFetch_Node7_Address_Impl.databaseConnection$;\n                referenceBuilder.append(String.format(\"%010d\", databaseConnectionString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(databaseConnectionString);\n                referenceBuilder.append(\":\");\n\n                Map<String, Object> pkMap = new HashMap<>();\n\n                pkMap.put(\"pk$_0\", this.getPk$_0());\n                String pkMapString = objectMapper$.writeValueAsString(pkMap);\n                referenceBuilder.append(String.format(\"%010d\", pkMapString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(pkMapString);\n\n                this.alloyStoreObjectReference$ = \"ASOR:\" + org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(referenceBuilder.toString().getBytes());\n            }\n            catch (Exception e)\n            {\n               throw new RuntimeException(e);\n            }\n        }\n\n        return this.alloyStoreObjectReference$;\n    }\n\n    public void setAlloyStoreObjectReference$(String reference)\n    {\n        this.alloyStoreObjectReference$ = reference;\n    }\n\n    private static long getClassSize$()\n    {\n        return 156L;\n    }\n\n    public long getInstanceSize$()\n    {\n        long size = GraphFetch_Node7_Address_Impl.getClassSize$();\n        if (this.name != null)\n        {\n            size = size + this.name.length();\n        }\n        if (this.setId$ != null)\n        {\n            size = size + this.setId$.length();\n        }\n        if (this.alloyStoreObjectReference$ != null)\n        {\n            size = size + this.alloyStoreObjectReference$.length();\n        }\n        if (this.persons != null)\n        {\n            for (_pure.app.test.Person i: this.persons)\n            {\n                if (i != null)\n                {\n                    size = size + 20L;\n                }\n            }\n        }\n        if (this.firms != null)\n        {\n            for (_pure.app.test.Firm i: this.firms)\n            {\n                if (i != null)\n                {\n                    size = size + 20L;\n                }\n            }\n        }\n        return size;\n    }\n}"
    }, {
      "name" : "Specifics",
      "package" : "_pure.plan.root.n1.globalChild1.localGraph",
      "source" : "package _pure.plan.root.n1.globalChild1.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.Types;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.eclipse.collections.impl.tuple.Tuples;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IConstantResult;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n\nclass Specifics\n{\n    private static final List<Integer> STRING_TYPES = Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL);\n    private static final List<Integer> INT_TYPES = Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL);\n    private static final List<Integer> FLOAT_TYPES = Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> DECIMAL_TYPES = Arrays.asList(Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> BOOL_TYPES = Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL);\n    private static final List<Integer> STRICT_DATE_TYPES = Arrays.asList(Types.DATE, Types.NULL);\n    private static final List<Integer> DATE_TIME_TYPES = Arrays.asList(Types.TIMESTAMP, Types.NULL);\n    private ResultSet resultSet;\n    private String databaseTimeZone;\n    private String databaseConnection;\n    private List<Integer> columnTypes;\n    private List<List<Integer>> propertyIndices;\n    private List<List<Supplier<Object>>> propertyGetters;\n    private Calendar calendar;\n    private Method parentPropertyAdder;\n    private Method parentEdgePointPropertyAdder;\n\n    private Object getAlloyNativeValueFromResultSet(ResultSet resultSet,\n                                                    int columnIndex,\n                                                    int columnType)\n    {\n        try\n        {\n            Object result = null;\n            switch (columnType)\n            {\n                case Types.DATE:\n                {\n                    java.sql.Date date = resultSet.getDate(columnIndex);\n                    if (date != null)\n                    {\n                        result = PureDate.fromSQLDate(date);\n                    }\n                    break;\n                }\n                case Types.TIMESTAMP:\n                {\n                    java.sql.Timestamp timestamp = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (timestamp != null)\n                    {\n                        result = PureDate.fromSQLTimestamp(timestamp);\n                    }\n                    break;\n                }\n                case Types.TINYINT:\n                case Types.SMALLINT:\n                case Types.INTEGER:\n                case Types.BIGINT:\n                {\n                    long num = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Long.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.REAL:\n                case Types.FLOAT:\n                case Types.DOUBLE:\n                {\n                    double num = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Double.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.DECIMAL:\n                case Types.NUMERIC:\n                {\n                    result = resultSet.getBigDecimal(columnIndex);\n                    break;\n                }\n                case Types.CHAR:\n                case Types.VARCHAR:\n                case Types.LONGVARCHAR:\n                case Types.NCHAR:\n                case Types.NVARCHAR:\n                case Types.LONGNVARCHAR:\n                case Types.OTHER:\n                {\n                    result = resultSet.getString(columnIndex);\n                    break;\n                }\n                case Types.BIT:\n                case Types.BOOLEAN:\n                {\n                    boolean bool = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Boolean.valueOf(bool);\n                    }\n                }\n                case Types.BINARY:\n                case Types.VARBINARY:\n                case Types.LONGVARBINARY:\n                {\n                    byte[] bytes = resultSet.getBytes(columnIndex);\n                    if (bytes != null)\n                    {\n                        result = this.encodeHex(bytes);\n                    }\n                    break;\n                }\n                case Types.NULL:\n                {\n                    // do nothing: value is already assigned to null\n                    break;\n                }\n                default:\n                {\n                    result = resultSet.getObject(columnIndex);\n                }\n            }\n            return result;}\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String encodeHex(byte[] data)\n    {\n        final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n        final int l = data.length;\n        final char[] out = new char[l << 1];\n        for (int i = 0, j = 0; i < l; i++)\n        {\n            out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS_LOWER[0x0F & data[i]];\n        }\n        return new String(out);\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStringProperty(ResultSet resultSet,\n                                                                         int columnIndex,\n                                                                         int columnType,\n                                                                         String propertyName)\n    {\n        if (STRING_TYPES.contains(columnType))\n        {\n           return () -> {\n                try\n                {\n                    return resultSet.getString(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        else\n        {\n            throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type String from SQL column of type '\" + columnType + \"'.\");\n        }\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForIntegerProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Long res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Long.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Integer from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForFloatProperty(ResultSet resultSet,\n                                                                        int columnIndex,\n                                                                        int columnType,\n                                                                        String propertyName)\n    {\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Float from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDecimalProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (DECIMAL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    return resultSet.getBigDecimal(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Decimal from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForBooleanProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (BOOL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    boolean r = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r == 1);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Boolean from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStrictDateProperty(ResultSet resultSet,\n                                                                             int columnIndex,\n                                                                             int columnType,\n                                                                             String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type StrictDate from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateTimeProperty(ResultSet resultSet,\n                                                                           int columnIndex,\n                                                                           int columnType,\n                                                                           String propertyName)\n    {\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type DateTime from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateProperty(ResultSet resultSet,\n                                                                       int columnIndex,\n                                                                       int columnType,\n                                                                       String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException1)\n                        {\n                            try\n                            {\n                                res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                            }\n                            catch (java.time.format.DateTimeParseException dateTimeParseException2)\n                            {\n                                res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                            }\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Date from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        try\n        {\n            this.resultSet = resultSet;\n            this.databaseTimeZone = databaseTimeZone;\n            this.databaseConnection = databaseConnection;\n            this.calendar = new GregorianCalendar(TimeZone.getTimeZone(this.databaseTimeZone));\n            ResultSetMetaData resultSetMetaData = this.resultSet.getMetaData();\n            int columnCount = resultSetMetaData.getColumnCount();\n            this.columnTypes = new ArrayList<Integer>();\n            List<String> columnNames = new ArrayList<String>();\n            for (int i = 1; i <= columnCount; i++)\n            {\n                String columnLabel = resultSetMetaData.getColumnLabel(i);\n                columnNames.add(columnLabel.startsWith(\"\\\"\") && columnLabel\n                                           .endsWith(\"\\\"\")\n                                           ? columnLabel.substring(1, columnLabel.length() - 1)\n                                                        .toUpperCase()\n                                           : columnLabel.toUpperCase());\n                this.columnTypes.add(resultSetMetaData.getColumnType(i));\n            }\n            this.propertyIndices = new ArrayList<List<Integer>>();\n            List<Integer> index_0 = new ArrayList<Integer>();\n            index_0.add(columnNames.indexOf(\"NAME\") + 1);\n            index_0.add(columnNames.indexOf(\"PK_0\") + 1);\n            this.propertyIndices.add(index_0);\n            GraphFetch_Node7_Address_Impl.databaseConnection$ = databaseConnection;\n            this.propertyGetters = new ArrayList<List<Supplier<Object>>>();\n            int propertyIndex;\n            Supplier<Object> propertyGetter = null;\n            List<Supplier<Object>> propertyGetter_0 = new ArrayList<Supplier<Object>>();\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"name\");\n            propertyGetter_0.add(propertyGetter);\n            this.propertyGetters.add(propertyGetter_0);\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    IGraphInstance<? extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject> nextGraphInstance()\n    {\n        try\n        {\n            final GraphFetch_Node7_Address_Impl object = new GraphFetch_Node7_Address_Impl();\n            object.setSetId$(\"test_Address\");\n            int pkColIndex;\n            int propertyIndex;\n            pkColIndex = this.propertyIndices.get(0).get(1);\n            Object pk$_0 = this.getAlloyNativeValueFromResultSet(resultSet,\n                                                                 pkColIndex,\n                                                                 this.columnTypes.get(pkColIndex - 1));\n            object.setPk$_0(pk$_0);\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            {\n                String res = (String) this.propertyGetters.get(0).get(0).get();\n                if (res == null)\n                {\n                    throw new RuntimeException(\"Error reading in property 'name'. Property of multiplicity [1] can not be null\");\n                }\n                object.setName(res);\n            }\n            return new IGraphInstance<GraphFetch_Node7_Address_Impl>()\n            {\n                public GraphFetch_Node7_Address_Impl getValue()\n                {\n                    return object;\n                }\n                public long instanceSize()\n                {\n                    return object.getInstanceSize$();\n                }\n            };\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<Method> primaryKeyGetters()\n    {\n        try\n        {\n            return Arrays.asList(GraphFetch_Node7_Address_Impl.class.getMethod(\"getPk$_0\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String mappingId()\n    {\n        return \"test::Map\";\n    }\n\n    public String sourceInstanceSetId()\n    {\n        return \"test_Person\";\n    }\n\n    public String targetInstanceSetId()\n    {\n        return \"test_Address\";\n    }\n\n    void addChildToParent(Object parent, Object child, IExecutionNodeContext executionNodeContext)\n    {\n        try\n        {\n            if (this.parentPropertyAdder == null)\n            {\n                this.parentPropertyAdder = parent\n                    .getClass()\n                    .getMethod(\"addAddress\", _pure.app.test.Address.class);\n            }\n            this.parentPropertyAdder.invoke(parent, child);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<String> parentCrossKeyColumns(List<String> queryResultColumns)\n    {\n        return queryResultColumns.stream()\n                                 .filter((String x) -> x.toUpperCase()\n                                                        .startsWith(\"PARENT_CROSS_KEY_\"))\n                                 .collect(Collectors.toList());\n    }\n\n    List<Method> parentCrossKeyGetters()\n    {\n        try\n        {\n            return Arrays.asList(_pure.app.test.Person_Map_test_Person.class\n                                                                      .getMethod(\"getAddressName\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    boolean supportsCrossCaching()\n    {\n        return true;\n    }\n\n    List<String> targetPropertiesOrdered()\n    {\n        return Arrays.asList(\"name\");\n    }\n\n    List<Method> parentCrossKeyGettersOrderedByTargetProperties()\n    {\n        try\n        {\n            return Arrays.asList(_pure.app.test.Person_Map_test_Person.class\n                                                                      .getMethod(\"getAddressName\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n}"
    }, {
      "name" : "Execute",
      "package" : "_pure.plan.root.n1.localGraph",
      "source" : "package _pure.plan.root.n1.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.relational.graphFetch.IRelationalRootQueryTempTableGraphFetchExecutionNodeSpecifics;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject;\n\npublic class Execute implements IRelationalRootQueryTempTableGraphFetchExecutionNodeSpecifics\n{\n    private Specifics specifics;\n\n    public Execute()\n    {\n        this.specifics = new Specifics();\n    }\n\n    public void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        this.specifics.prepare(resultSet, databaseTimeZone, databaseConnection);\n    }\n\n    public IGraphInstance<? extends IReferencedObject> nextGraphInstance()\n    {\n        return this.specifics.nextGraphInstance();\n    }\n\n    public List<Method> primaryKeyGetters()\n    {\n        return this.specifics.primaryKeyGetters();\n    }\n\n    public List<Pair<String, String>> allInstanceSetImplementations()\n    {\n        return this.specifics.allInstanceSetImplementations();\n    }\n\n    public List<String> primaryKeyColumns(int setIndex)\n    {\n        return this.specifics.primaryKeyColumns(setIndex);\n    }\n\n    public boolean supportsCaching()\n    {\n        return true;\n    }\n}"
    }, {
      "name" : "GraphFetch_Node0_Person_Map_test_Person_Impl",
      "package" : "_pure.plan.root.n1.localGraph",
      "source" : "package _pure.plan.root.n1.localGraph;\n\nimport java.math.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DayOfWeek;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.util.Library;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport java.io.IOException;\n\npublic class GraphFetch_Node0_Person_Map_test_Person_Impl implements _pure.app.test.Person_Map_test_Person, org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.test.Person_Map_test_Person>, java.io.Serializable\n{\n    private String firmName;\n    private String addressName;\n    private String fullName;\n    private _pure.app.test.Firm firm;\n    private _pure.app.test.Address address;\n    private Object pk$_0;\n    private static final ObjectMapper objectMapper$ = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).registerModule(new SimpleModule().addSerializer(PureDate.class, new JsonSerializer<PureDate>() { @Override public void serialize(PureDate value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeRawValue(\"\\\"\" + value.toString() + \"\\\"\"); } }));\n    private String setId$;\n    public static String databaseConnection$;\n    private String alloyStoreObjectReference$;\n    private static final long serialVersionUID = 702858519L;\n\n    public String getFirmName()\n    {\n        return this.firmName;\n    }\n\n    public void setFirmName(String firmName)\n    {\n        this.firmName = firmName;\n    }\n\n    public void addFirmName(String object)\n    {\n        if ((Object) this.firmName != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'firmName' of multiplicity with bound 1\");\n        }\n        this.firmName = object;\n    }\n\n    public String getAddressName()\n    {\n        return this.addressName;\n    }\n\n    public void setAddressName(String addressName)\n    {\n        this.addressName = addressName;\n    }\n\n    public void addAddressName(String object)\n    {\n        if ((Object) this.addressName != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'addressName' of multiplicity with bound 1\");\n        }\n        this.addressName = object;\n    }\n\n    public String getFullName()\n    {\n        return this.fullName;\n    }\n\n    public void setFullName(String fullName)\n    {\n        this.fullName = fullName;\n    }\n\n    public void addFullName(String object)\n    {\n        if ((Object) this.fullName != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'fullName' of multiplicity with bound 1\");\n        }\n        this.fullName = object;\n    }\n\n    public _pure.app.test.Firm getFirm()\n    {\n        return this.firm;\n    }\n\n    public void setFirm(_pure.app.test.Firm firm)\n    {\n        this.firm = firm;\n    }\n\n    public void addFirm(_pure.app.test.Firm object)\n    {\n        if ((Object) this.firm != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'firm' of multiplicity with bound 1\");\n        }\n        this.firm = object;\n    }\n\n    public _pure.app.test.Address getAddress()\n    {\n        return this.address;\n    }\n\n    public void setAddress(_pure.app.test.Address address)\n    {\n        this.address = address;\n    }\n\n    public void addAddress(_pure.app.test.Address object)\n    {\n        if ((Object) this.address != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'address' of multiplicity with bound 1\");\n        }\n        this.address = object;\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints()\n    {\n        return this.allConstraints(new org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext());\n    }\n\n    public _pure.app.test.Person_Map_test_Person withConstraintsApplied()\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = allConstraints();\n        if (!defects.isEmpty())\n        {\n            throw new IllegalStateException(defects.stream().map(org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect::getMessage).collect(java.util.stream.Collectors.joining(\"\\n\")));\n        }\n        return this;\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Person_Map_test_Person> toChecked()\n    {\n        return this.toChecked(null, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Person_Map_test_Person> toChecked(boolean applyConstraints)\n    {\n        return this.toChecked(null, applyConstraints);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Person_Map_test_Person> toChecked(Object source)\n    {\n        return this.toChecked(source, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Person_Map_test_Person> toChecked(Object source,\n                                                                                                                                  boolean applyConstraints)\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = applyConstraints ? allConstraints() : java.util.Collections.emptyList();\n        return new org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.test.Person_Map_test_Person>() {\n            public java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> getDefects() { return defects; }\n            public Object getSource() { return source; }\n            public _pure.app.test.Person_Map_test_Person getValue() { return GraphFetch_Node0_Person_Map_test_Person_Impl.this; }\n        };\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints(org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext context)\n    {\n        List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> result = new ArrayList<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect>();\n        if (!context.visited.contains(this))\n        {\n            context.visited.add(this);\n        }\n        return result;\n    }\n\n    public Object getPk$_0()\n    {\n        return this.pk$_0;\n    }\n\n    public void setPk$_0(Object pk$_0)\n    {\n        this.pk$_0 = pk$_0;\n    }\n\n    public String getSetId$()\n    {\n        return this.setId$;\n    }\n\n    public void setSetId$(String setId)\n    {\n        this.setId$ = setId;\n    }\n\n    public String getAlloyStoreObjectReference$()\n    {\n        if (this.alloyStoreObjectReference$ == null)\n        {\n            try\n            {\n                StringBuilder referenceBuilder = new StringBuilder();\n                referenceBuilder.append(\"001:\");\n                referenceBuilder.append(\"010:\");\n\n                referenceBuilder.append(\"0000000010:\");\n                referenceBuilder.append(\"Relational:\");\n\n                referenceBuilder.append(\"0000000009:\");\n                referenceBuilder.append(\"test::Map:\");\n\n                referenceBuilder.append(\"0000000011:\");\n                referenceBuilder.append(\"test_Person:\");\n\n                String setId = this.getSetId$();\n                referenceBuilder.append(String.format(\"%010d\", setId.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(setId);\n                referenceBuilder.append(\":\");\n\n                String databaseConnectionString = _pure.plan.root.n1.localGraph.GraphFetch_Node0_Person_Map_test_Person_Impl.databaseConnection$;\n                referenceBuilder.append(String.format(\"%010d\", databaseConnectionString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(databaseConnectionString);\n                referenceBuilder.append(\":\");\n\n                Map<String, Object> pkMap = new HashMap<>();\n\n                pkMap.put(\"pk$_0\", this.getPk$_0());\n                String pkMapString = objectMapper$.writeValueAsString(pkMap);\n                referenceBuilder.append(String.format(\"%010d\", pkMapString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(pkMapString);\n\n                this.alloyStoreObjectReference$ = \"ASOR:\" + org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(referenceBuilder.toString().getBytes());\n            }\n            catch (Exception e)\n            {\n               throw new RuntimeException(e);\n            }\n        }\n\n        return this.alloyStoreObjectReference$;\n    }\n\n    public void setAlloyStoreObjectReference$(String reference)\n    {\n        this.alloyStoreObjectReference$ = reference;\n    }\n\n    private static long getClassSize$()\n    {\n        return 204L;\n    }\n\n    public long getInstanceSize$()\n    {\n        long size = GraphFetch_Node0_Person_Map_test_Person_Impl.getClassSize$();\n        if (this.firmName != null)\n        {\n            size = size + this.firmName.length();\n        }\n        if (this.addressName != null)\n        {\n            size = size + this.addressName.length();\n        }\n        if (this.fullName != null)\n        {\n            size = size + this.fullName.length();\n        }\n        if (this.setId$ != null)\n        {\n            size = size + this.setId$.length();\n        }\n        if (this.alloyStoreObjectReference$ != null)\n        {\n            size = size + this.alloyStoreObjectReference$.length();\n        }\n        return size;\n    }\n}"
    }, {
      "name" : "Specifics",
      "package" : "_pure.plan.root.n1.localGraph",
      "source" : "package _pure.plan.root.n1.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.Types;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.eclipse.collections.impl.tuple.Tuples;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IConstantResult;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n\nclass Specifics\n{\n    private static final List<Integer> STRING_TYPES = Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL);\n    private static final List<Integer> INT_TYPES = Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL);\n    private static final List<Integer> FLOAT_TYPES = Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> DECIMAL_TYPES = Arrays.asList(Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> BOOL_TYPES = Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL);\n    private static final List<Integer> STRICT_DATE_TYPES = Arrays.asList(Types.DATE, Types.NULL);\n    private static final List<Integer> DATE_TIME_TYPES = Arrays.asList(Types.TIMESTAMP, Types.NULL);\n    private ResultSet resultSet;\n    private String databaseTimeZone;\n    private String databaseConnection;\n    private List<Integer> columnTypes;\n    private List<List<Integer>> propertyIndices;\n    private List<List<Supplier<Object>>> propertyGetters;\n    private Calendar calendar;\n    private Method parentPropertyAdder;\n    private Method parentEdgePointPropertyAdder;\n\n    private Object getAlloyNativeValueFromResultSet(ResultSet resultSet,\n                                                    int columnIndex,\n                                                    int columnType)\n    {\n        try\n        {\n            Object result = null;\n            switch (columnType)\n            {\n                case Types.DATE:\n                {\n                    java.sql.Date date = resultSet.getDate(columnIndex);\n                    if (date != null)\n                    {\n                        result = PureDate.fromSQLDate(date);\n                    }\n                    break;\n                }\n                case Types.TIMESTAMP:\n                {\n                    java.sql.Timestamp timestamp = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (timestamp != null)\n                    {\n                        result = PureDate.fromSQLTimestamp(timestamp);\n                    }\n                    break;\n                }\n                case Types.TINYINT:\n                case Types.SMALLINT:\n                case Types.INTEGER:\n                case Types.BIGINT:\n                {\n                    long num = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Long.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.REAL:\n                case Types.FLOAT:\n                case Types.DOUBLE:\n                {\n                    double num = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Double.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.DECIMAL:\n                case Types.NUMERIC:\n                {\n                    result = resultSet.getBigDecimal(columnIndex);\n                    break;\n                }\n                case Types.CHAR:\n                case Types.VARCHAR:\n                case Types.LONGVARCHAR:\n                case Types.NCHAR:\n                case Types.NVARCHAR:\n                case Types.LONGNVARCHAR:\n                case Types.OTHER:\n                {\n                    result = resultSet.getString(columnIndex);\n                    break;\n                }\n                case Types.BIT:\n                case Types.BOOLEAN:\n                {\n                    boolean bool = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Boolean.valueOf(bool);\n                    }\n                }\n                case Types.BINARY:\n                case Types.VARBINARY:\n                case Types.LONGVARBINARY:\n                {\n                    byte[] bytes = resultSet.getBytes(columnIndex);\n                    if (bytes != null)\n                    {\n                        result = this.encodeHex(bytes);\n                    }\n                    break;\n                }\n                case Types.NULL:\n                {\n                    // do nothing: value is already assigned to null\n                    break;\n                }\n                default:\n                {\n                    result = resultSet.getObject(columnIndex);\n                }\n            }\n            return result;}\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String encodeHex(byte[] data)\n    {\n        final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n        final int l = data.length;\n        final char[] out = new char[l << 1];\n        for (int i = 0, j = 0; i < l; i++)\n        {\n            out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS_LOWER[0x0F & data[i]];\n        }\n        return new String(out);\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStringProperty(ResultSet resultSet,\n                                                                         int columnIndex,\n                                                                         int columnType,\n                                                                         String propertyName)\n    {\n        if (STRING_TYPES.contains(columnType))\n        {\n           return () -> {\n                try\n                {\n                    return resultSet.getString(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        else\n        {\n            throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type String from SQL column of type '\" + columnType + \"'.\");\n        }\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForIntegerProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Long res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Long.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Integer from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForFloatProperty(ResultSet resultSet,\n                                                                        int columnIndex,\n                                                                        int columnType,\n                                                                        String propertyName)\n    {\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Float from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDecimalProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (DECIMAL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    return resultSet.getBigDecimal(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Decimal from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForBooleanProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (BOOL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    boolean r = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r == 1);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Boolean from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStrictDateProperty(ResultSet resultSet,\n                                                                             int columnIndex,\n                                                                             int columnType,\n                                                                             String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type StrictDate from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateTimeProperty(ResultSet resultSet,\n                                                                           int columnIndex,\n                                                                           int columnType,\n                                                                           String propertyName)\n    {\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type DateTime from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateProperty(ResultSet resultSet,\n                                                                       int columnIndex,\n                                                                       int columnType,\n                                                                       String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException1)\n                        {\n                            try\n                            {\n                                res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                            }\n                            catch (java.time.format.DateTimeParseException dateTimeParseException2)\n                            {\n                                res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                            }\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Date from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        try\n        {\n            this.resultSet = resultSet;\n            this.databaseTimeZone = databaseTimeZone;\n            this.databaseConnection = databaseConnection;\n            this.calendar = new GregorianCalendar(TimeZone.getTimeZone(this.databaseTimeZone));\n            ResultSetMetaData resultSetMetaData = this.resultSet.getMetaData();\n            int columnCount = resultSetMetaData.getColumnCount();\n            this.columnTypes = new ArrayList<Integer>();\n            List<String> columnNames = new ArrayList<String>();\n            for (int i = 1; i <= columnCount; i++)\n            {\n                String columnLabel = resultSetMetaData.getColumnLabel(i);\n                columnNames.add(columnLabel.startsWith(\"\\\"\") && columnLabel\n                                           .endsWith(\"\\\"\")\n                                           ? columnLabel.substring(1, columnLabel.length() - 1)\n                                                        .toUpperCase()\n                                           : columnLabel.toUpperCase());\n                this.columnTypes.add(resultSetMetaData.getColumnType(i));\n            }\n            this.propertyIndices = new ArrayList<List<Integer>>();\n            List<Integer> index_0 = new ArrayList<Integer>();\n            index_0.add(columnNames.indexOf(\"FIRMNAME\") + 1);\n            index_0.add(columnNames.indexOf(\"ADDRESSNAME\") + 1);\n            index_0.add(columnNames.indexOf(\"FULLNAME\") + 1);\n            index_0.add(columnNames.indexOf(\"PK_0\") + 1);\n            this.propertyIndices.add(index_0);\n            GraphFetch_Node0_Person_Map_test_Person_Impl.databaseConnection$ = databaseConnection;\n            this.propertyGetters = new ArrayList<List<Supplier<Object>>>();\n            int propertyIndex;\n            Supplier<Object> propertyGetter = null;\n            List<Supplier<Object>> propertyGetter_0 = new ArrayList<Supplier<Object>>();\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"firmName\");\n            propertyGetter_0.add(propertyGetter);\n            propertyIndex = this.propertyIndices.get(0).get(1);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"addressName\");\n            propertyGetter_0.add(propertyGetter);\n            propertyIndex = this.propertyIndices.get(0).get(2);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"fullName\");\n            propertyGetter_0.add(propertyGetter);\n            this.propertyGetters.add(propertyGetter_0);\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    IGraphInstance<? extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject> nextGraphInstance()\n    {\n        try\n        {\n            final GraphFetch_Node0_Person_Map_test_Person_Impl object = new GraphFetch_Node0_Person_Map_test_Person_Impl();\n            object.setSetId$(\"test_Person\");\n            int pkColIndex;\n            int propertyIndex;\n            pkColIndex = this.propertyIndices.get(0).get(3);\n            Object pk$_0 = this.getAlloyNativeValueFromResultSet(resultSet,\n                                                                 pkColIndex,\n                                                                 this.columnTypes.get(pkColIndex - 1));\n            object.setPk$_0(pk$_0);\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            {\n                String res = (String) this.propertyGetters.get(0).get(0).get();\n                object.setFirmName(res);\n            }\n            propertyIndex = this.propertyIndices.get(0).get(1);\n            {\n                String res = (String) this.propertyGetters.get(0).get(1).get();\n                object.setAddressName(res);\n            }\n            propertyIndex = this.propertyIndices.get(0).get(2);\n            {\n                String res = (String) this.propertyGetters.get(0).get(2).get();\n                if (res == null)\n                {\n                    throw new RuntimeException(\"Error reading in property 'fullName'. Property of multiplicity [1] can not be null\");\n                }\n                object.setFullName(res);\n            }\n            return new IGraphInstance<GraphFetch_Node0_Person_Map_test_Person_Impl>()\n            {\n                public GraphFetch_Node0_Person_Map_test_Person_Impl getValue()\n                {\n                    return object;\n                }\n                public long instanceSize()\n                {\n                    return object.getInstanceSize$();\n                }\n            };\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<Method> primaryKeyGetters()\n    {\n        try\n        {\n            return Arrays.asList(GraphFetch_Node0_Person_Map_test_Person_Impl.class\n                                                                             .getMethod(\"getPk$_0\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<Pair<String, String>> allInstanceSetImplementations()\n    {\n        return Arrays.asList(Tuples.pair(\"test::Map\", \"test_Person\"));\n    }\n\n    List<String> primaryKeyColumns(int setIndex)\n    {\n        if (setIndex == 0)\n        {\n            return Arrays.asList(\"pk_0\");\n        }\n        return null;\n    }\n}"
    } ]
  },
  "rootExecutionNode" : {
    "_type" : "platform",
    "authDependent" : false,
    "executionNodes" : [ {
      "_type" : "globalGraphFetchExecutionNode",
      "authDependent" : false,
      "checked" : false,
      "children" : [ {
        "_type" : "globalGraphFetchExecutionNode",
        "authDependent" : false,
        "children" : [ {
          "_type" : "globalGraphFetchExecutionNode",
          "authDependent" : false,
          "executionNodes" : [ ],
          "graphFetchTree" : {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "address",
            "subTrees" : [ {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "name",
              "subTrees" : [ ]
            } ]
          },
          "localGraphFetchExecutionNode" : {
            "_type" : "relationalCrossRootQueryTempTableGraphFetch",
            "authDependent" : false,
            "columns" : [ {
              "dataType" : "VARCHAR(100)",
              "label" : "pk_0"
            } ],
            "executionNodes" : [ {
              "_type" : "sql",
              "authDependent" : false,
              "connection" : {
                "_type" : "RelationalDatabaseConnection",
                "authenticationStrategy" : {
                  "_type" : "middleTierUserNamePassword",
                  "vaultReference" : "reference1"
                },
                "datasourceSpecification" : {
                  "_type" : "static",
                  "databaseName" : "name1",
                  "host" : "host1.com",
                  "port" : 1234
                },
                "element" : "test::DB",
                "postProcessorWithParameter" : [ ],
                "postProcessors" : [ ],
                "type" : "MemSQL"
              },
              "executionNodes" : [ ],
              "resultColumns" : [ {
                "dataType" : "BIT",
                "label" : "\"cross_join_op$\""
              }, {
                "dataType" : "VARCHAR(100)",
                "label" : "\"pk_0\""
              }, {
                "dataType" : "VARCHAR(100)",
                "label" : "\"name\""
              }, {
                "dataType" : "VARCHAR(4000)",
                "label" : "\"parent_cross_key_0\""
              } ],
              "resultType" : {
                "_type" : "dataType",
                "dataType" : "meta::pure::metamodel::type::Any"
              },
              "sqlQuery" : "select distinct \"cross_temp_table_node_2_0\".addressName = \"root\".name as \"cross_join_op$\", \"root\".name as \"pk_0\", \"root\".name as \"name\", \"cross_temp_table_node_2_0\".addressName as \"parent_cross_key_0\" from (select * from (${cross_temp_table_node_2}) as \"root\") as \"cross_temp_table_node_2_0\" inner join addressTable as \"root\" on (1 = 1) where \"cross_temp_table_node_2_0\".addressName = \"root\".name"
            } ],
            "graphFetchTree" : {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "address",
              "subTrees" : [ {
                "_type" : "propertyGraphFetchTree",
                "_type" : "propertyGraphFetchTree",
                "parameters" : [ ],
                "property" : "name",
                "subTrees" : [ ]
              } ]
            },
            "implementation" : {
              "_type" : "java",
              "executionClassFullName" : "_pure.plan.root.n1.globalChild0.globalChild0.localGraph.Execute"
            },
            "nodeIndex" : 4,
            "parentIndex" : 2,
            "parentTempTableColumns" : [ {
              "dataType" : "VARCHAR(4000)",
              "label" : "addressName"
            } ],
            "parentTempTableName" : "cross_temp_table_node_2",
            "resultType" : {
              "_type" : "partialClass",
              "class" : "test::Address",
              "propertiesWithParameters" : [ {
                "property" : "name"
              } ],
              "setImplementations" : [ {
                "class" : "test::Address",
                "id" : "test_Address",
                "mapping" : "test::Map",
                "propertyMappings" : [ {
                  "enumMapping" : { },
                  "property" : "name",
                  "type" : "String"
                } ]
              } ]
            },
            "tempTableName" : "temp_table_node_4"
          },
          "parentIndex" : 2,
          "resultType" : {
            "_type" : "partialClass",
            "class" : "test::Address",
            "propertiesWithParameters" : [ {
              "property" : "name"
            } ],
            "setImplementations" : [ {
              "class" : "test::Address",
              "id" : "test_Address",
              "mapping" : "test::Map",
              "propertyMappings" : [ {
                "enumMapping" : { },
                "property" : "name",
                "type" : "String"
              } ]
            } ]
          },
          "store" : "test::DB3",
          "xStorePropertyFetchDetails" : {
            "propertyPath" : "root.firm.address",
            "sourceMappingId" : "test::Map",
            "sourceSetId" : "test_Firm",
            "subTree" : "{@(test_Address->)@ [ / name]}",
            "supportsCaching" : true,
            "targetMappingId" : "test::Map",
            "targetPropertiesOrdered" : [ "name" ],
            "targetSetId" : "test_Address"
          },
          "xStorePropertyMapping" : {
            "_type" : "xStorePropertyMapping",
            "crossExpression" : {
              "_type" : "lambda",
              "body" : [ {
                "_type" : "func",
                "fControl" : "equal_Any_MANY__Any_MANY__Boolean_1_",
                "function" : "equal",
                "parameters" : [ {
                  "_type" : "property",
                  "parameters" : [ {
                    "_type" : "var",
                    "name" : "this"
                  } ],
                  "property" : "addressName"
                }, {
                  "_type" : "property",
                  "parameters" : [ {
                    "_type" : "var",
                    "name" : "that"
                  } ],
                  "property" : "name"
                } ]
              } ],
              "parameters" : [ {
                "_type" : "var",
                "name" : "this"
              }, {
                "_type" : "var",
                "class" : "test::Address",
                "multiplicity" : {
                  "lowerBound" : 1,
                  "upperBound" : 1
                },
                "name" : "that"
              } ]
            },
            "property" : {
              "class" : "test::Firm",
              "property" : "address"
            },
            "source" : "test_Firm",
            "target" : "test_Address"
          }
        } ],
        "executionNodes" : [ ],
        "graphFetchTree" : {
          "_type" : "propertyGraphFetchTree",
          "_type" : "propertyGraphFetchTree",
          "parameters" : [ ],
          "property" : "firm",
          "subTrees" : [ {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "name",
            "subTrees" : [ ]
          }, {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "address",
            "subTrees" : [ {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "name",
              "subTrees" : [ ]
            } ]
          }, {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "addressName",
            "subTrees" : [ ]
          } ]
        },
        "localGraphFetchExecutionNode" : {
          "_type" : "relationalCrossRootQueryTempTableGraphFetch",
          "authDependent" : false,
          "columns" : [ {
            "dataType" : "VARCHAR(100)",
            "label" : "pk_0"
          } ],
          "executionNodes" : [ {
            "_type" : "sql",
            "authDependent" : false,
            "connection" : {
              "_type" : "RelationalDatabaseConnection",
              "authenticationStrategy" : {
                "_type" : "middleTierUserNamePassword",
                "vaultReference" : "reference1"
              },
              "datasourceSpecification" : {
                "_type" : "static",
                "databaseName" : "name1",
                "host" : "host1.com",
                "port" : 1234
              },
              "element" : "test::DB",
              "postProcessorWithParameter" : [ ],
              "postProcessors" : [ ],
              "type" : "MemSQL"
            },
            "executionNodes" : [ ],
            "resultColumns" : [ {
              "dataType" : "BIT",
              "label" : "\"cross_join_op$\""
            }, {
              "dataType" : "VARCHAR(100)",
              "label" : "\"pk_0\""
            }, {
              "dataType" : "VARCHAR(100)",
              "label" : "\"addressName\""
            }, {
              "dataType" : "VARCHAR(100)",
              "label" : "\"name\""
            }, {
              "dataType" : "VARCHAR(4000)",
              "label" : "\"parent_cross_key_0\""
            } ],
            "resultType" : {
              "_type" : "dataType",
              "dataType" : "meta::pure::metamodel::type::Any"
            },
            "sqlQuery" : "select distinct \"cross_temp_table_node_0_0\".firmName = \"root\".name as \"cross_join_op$\", \"root\".name as \"pk_0\", \"root\".addressName as \"addressName\", \"root\".name as \"name\", \"cross_temp_table_node_0_0\".firmName as \"parent_cross_key_0\" from (select * from (${cross_temp_table_node_0}) as \"root\") as \"cross_temp_table_node_0_0\" inner join firmTable as \"root\" on (1 = 1) where \"cross_temp_table_node_0_0\".firmName = \"root\".name"
          } ],
          "graphFetchTree" : {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "firm",
            "subTrees" : [ {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "name",
              "subTrees" : [ ]
            }, {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "addressName",
              "subTrees" : [ ]
            } ]
          },
          "implementation" : {
            "_type" : "java",
            "executionClassFullName" : "_pure.plan.root.n1.globalChild0.localGraph.Execute"
          },
          "nodeIndex" : 2,
          "parentIndex" : 0,
          "parentTempTableColumns" : [ {
            "dataType" : "VARCHAR(4000)",
            "label" : "firmName"
          } ],
          "parentTempTableName" : "cross_temp_table_node_0",
          "resultType" : {
            "_type" : "partialClass",
            "class" : "test::Firm",
            "propertiesWithParameters" : [ {
              "property" : "name"
            }, {
              "property" : "addressName"
            } ],
            "setImplementations" : [ {
              "class" : "test::Firm",
              "id" : "test_Firm",
              "mapping" : "test::Map",
              "propertyMappings" : [ {
                "enumMapping" : { },
                "property" : "name",
                "type" : "String"
              } ]
            } ]
          },
          "tempTableName" : "temp_table_node_2"
        },
        "parentIndex" : 0,
        "resultType" : {
          "_type" : "partialClass",
          "class" : "test::Firm",
          "propertiesWithParameters" : [ {
            "property" : "name"
          }, {
            "property" : "addressName"
          } ],
          "setImplementations" : [ {
            "class" : "test::Firm",
            "id" : "test_Firm",
            "mapping" : "test::Map",
            "propertyMappings" : [ {
              "enumMapping" : { },
              "property" : "name",
              "type" : "String"
            } ]
          } ]
        },
        "store" : "test::DB2",
        "xStorePropertyFetchDetails" : {
          "propertyPath" : "root.firm",
          "sourceMappingId" : "test::Map",
          "sourceSetId" : "test_Person",
          "subTree" : "{@(test_Firm->)@ [ / name],{test::DB3> @(test_Firm->test_Address)@ [test_Address / address] {@(test_Address->)@ [ / name]}},@(test_Firm->)@ [ / addressName]}",
          "supportsCaching" : true,
          "targetMappingId" : "test::Map",
          "targetPropertiesOrdered" : [ "name" ],
          "targetSetId" : "test_Firm"
        },
        "xStorePropertyMapping" : {
          "_type" : "xStorePropertyMapping",
          "crossExpression" : {
            "_type" : "lambda",
            "body" : [ {
              "_type" : "func",
              "fControl" : "equal_Any_MANY__Any_MANY__Boolean_1_",
              "function" : "equal",
              "parameters" : [ {
                "_type" : "property",
                "parameters" : [ {
                  "_type" : "var",
                  "name" : "this"
                } ],
                "property" : "firmName"
              }, {
                "_type" : "property",
                "parameters" : [ {
                  "_type" : "var",
                  "name" : "that"
                } ],
                "property" : "name"
              } ]
            } ],
            "parameters" : [ {
              "_type" : "var",
              "name" : "this"
            }, {
              "_type" : "var",
              "class" : "Firm_Map_test_Firm",
              "multiplicity" : {
                "lowerBound" : 1,
                "upperBound" : 1
              },
              "name" : "that"
            } ]
          },
          "property" : {
            "class" : "test::Person",
            "property" : "firm"
          },
          "source" : "test_Person",
          "target" : "test_Firm"
        }
      }, {
        "_type" : "globalGraphFetchExecutionNode",
        "authDependent" : false,
        "executionNodes" : [ ],
        "graphFetchTree" : {
          "_type" : "propertyGraphFetchTree",
          "_type" : "propertyGraphFetchTree",
          "parameters" : [ ],
          "property" : "address",
          "subTrees" : [ {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "name",
            "subTrees" : [ ]
          } ]
        },
        "localGraphFetchExecutionNode" : {
          "_type" : "relationalCrossRootQueryTempTableGraphFetch",
          "authDependent" : false,
          "columns" : [ {
            "dataType" : "VARCHAR(100)",
            "label" : "pk_0"
          } ],
          "executionNodes" : [ {
            "_type" : "sql",
            "authDependent" : false,
            "connection" : {
              "_type" : "RelationalDatabaseConnection",
              "authenticationStrategy" : {
                "_type" : "middleTierUserNamePassword",
                "vaultReference" : "reference1"
              },
              "datasourceSpecification" : {
                "_type" : "static",
                "databaseName" : "name1",
                "host" : "host1.com",
                "port" : 1234
              },
              "element" : "test::DB",
              "postProcessorWithParameter" : [ ],
              "postProcessors" : [ ],
              "type" : "MemSQL"
            },
            "executionNodes" : [ ],
            "resultColumns" : [ {
              "dataType" : "BIT",
              "label" : "\"cross_join_op$\""
            }, {
              "dataType" : "VARCHAR(100)",
              "label" : "\"pk_0\""
            }, {
              "dataType" : "VARCHAR(100)",
              "label" : "\"name\""
            }, {
              "dataType" : "VARCHAR(4000)",
              "label" : "\"parent_cross_key_0\""
            } ],
            "resultType" : {
              "_type" : "dataType",
              "dataType" : "meta::pure::metamodel::type::Any"
            },
            "sqlQuery" : "select distinct \"cross_temp_table_node_0_0\".addressName = \"root\".name as \"cross_join_op$\", \"root\".name as \"pk_0\", \"root\".name as \"name\", \"cross_temp_table_node_0_0\".addressName as \"parent_cross_key_0\" from (select * from (${cross_temp_table_node_0}) as \"root\") as \"cross_temp_table_node_0_0\" inner join addressTable as \"root\" on (1 = 1) where \"cross_temp_table_node_0_0\".addressName = \"root\".name"
          } ],
          "graphFetchTree" : {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "address",
            "subTrees" : [ {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "name",
              "subTrees" : [ ]
            } ]
          },
          "implementation" : {
            "_type" : "java",
            "executionClassFullName" : "_pure.plan.root.n1.globalChild1.localGraph.Execute"
          },
          "nodeIndex" : 7,
          "parentIndex" : 0,
          "parentTempTableColumns" : [ {
            "dataType" : "VARCHAR(4000)",
            "label" : "addressName"
          } ],
          "parentTempTableName" : "cross_temp_table_node_0",
          "resultType" : {
            "_type" : "partialClass",
            "class" : "test::Address",
            "propertiesWithParameters" : [ {
              "property" : "name"
            } ],
            "setImplementations" : [ {
              "class" : "test::Address",
              "id" : "test_Address",
              "mapping" : "test::Map",
              "propertyMappings" : [ {
                "enumMapping" : { },
                "property" : "name",
                "type" : "String"
              } ]
            } ]
          },
          "tempTableName" : "temp_table_node_7"
        },
        "parentIndex" : 0,
        "resultType" : {
          "_type" : "partialClass",
          "class" : "test::Address",
          "propertiesWithParameters" : [ {
            "property" : "name"
          } ],
          "setImplementations" : [ {
            "class" : "test::Address",
            "id" : "test_Address",
            "mapping" : "test::Map",
            "propertyMappings" : [ {
              "enumMapping" : { },
              "property" : "name",
              "type" : "String"
            } ]
          } ]
        },
        "store" : "test::DB3",
        "xStorePropertyFetchDetails" : {
          "propertyPath" : "root.address",
          "sourceMappingId" : "test::Map",
          "sourceSetId" : "test_Person",
          "subTree" : "{@(test_Address->)@ [ / name]}",
          "supportsCaching" : true,
          "targetMappingId" : "test::Map",
          "targetPropertiesOrdered" : [ "name" ],
          "targetSetId" : "test_Address"
        },
        "xStorePropertyMapping" : {
          "_type" : "xStorePropertyMapping",
          "crossExpression" : {
            "_type" : "lambda",
            "body" : [ {
              "_type" : "func",
              "fControl" : "equal_Any_MANY__Any_MANY__Boolean_1_",
              "function" : "equal",
              "parameters" : [ {
                "_type" : "property",
                "parameters" : [ {
                  "_type" : "var",
                  "name" : "this"
                } ],
                "property" : "addressName"
              }, {
                "_type" : "property",
                "parameters" : [ {
                  "_type" : "var",
                  "name" : "that"
                } ],
                "property" : "name"
              } ]
            } ],
            "parameters" : [ {
              "_type" : "var",
              "name" : "this"
            }, {
              "_type" : "var",
              "class" : "test::Address",
              "multiplicity" : {
                "lowerBound" : 1,
                "upperBound" : 1
              },
              "name" : "that"
            } ]
          },
          "property" : {
            "class" : "test::Person",
            "property" : "address"
          },
          "source" : "test_Person",
          "target" : "test_Address"
        }
      } ],
      "enableConstraints" : true,
      "executionNodes" : [ ],
      "graphFetchTree" : {
        "_type" : "rootGraphFetchTree",
        "_type" : "rootGraphFetchTree",
        "class" : "test::Person",
        "subTrees" : [ {
          "_type" : "propertyGraphFetchTree",
          "_type" : "propertyGraphFetchTree",
          "parameters" : [ ],
          "property" : "fullName",
          "subTrees" : [ ]
        }, {
          "_type" : "propertyGraphFetchTree",
          "_type" : "propertyGraphFetchTree",
          "parameters" : [ ],
          "property" : "firm",
          "subTrees" : [ {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "name",
            "subTrees" : [ ]
          }, {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "address",
            "subTrees" : [ {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "name",
              "subTrees" : [ ]
            } ]
          }, {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "addressName",
            "subTrees" : [ ]
          } ]
        }, {
          "_type" : "propertyGraphFetchTree",
          "_type" : "propertyGraphFetchTree",
          "parameters" : [ ],
          "property" : "address",
          "subTrees" : [ {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "name",
            "subTrees" : [ ]
          } ]
        }, {
          "_type" : "propertyGraphFetchTree",
          "_type" : "propertyGraphFetchTree",
          "parameters" : [ ],
          "property" : "firmName",
          "subTrees" : [ ]
        }, {
          "_type" : "propertyGraphFetchTree",
          "_type" : "propertyGraphFetchTree",
          "parameters" : [ ],
          "property" : "addressName",
          "subTrees" : [ ]
        } ]
      },
      "localGraphFetchExecutionNode" : {
        "_type" : "relationalRootQueryTempTableGraphFetch",
        "authDependent" : false,
        "batchSize" : 1,
        "checked" : false,
        "columns" : [ {
          "dataType" : "VARCHAR(100)",
          "label" : "pk_0"
        } ],
        "executionNodes" : [ {
          "_type" : "sql",
          "authDependent" : false,
          "connection" : {
            "_type" : "RelationalDatabaseConnection",
            "authenticationStrategy" : {
              "_type" : "middleTierUserNamePassword",
              "vaultReference" : "reference1"
            },
            "datasourceSpecification" : {
              "_type" : "static",
              "databaseName" : "name1",
              "host" : "host1.com",
              "port" : 1234
            },
            "element" : "test::DB",
            "postProcessorWithParameter" : [ ],
            "postProcessors" : [ ],
            "type" : "MemSQL"
          },
          "executionNodes" : [ ],
          "resultColumns" : [ {
            "dataType" : "VARCHAR(100)",
            "label" : "\"pk_0\""
          }, {
            "dataType" : "VARCHAR(100)",
            "label" : "\"firmName\""
          }, {
            "dataType" : "VARCHAR(100)",
            "label" : "\"addressName\""
          }, {
            "dataType" : "VARCHAR(100)",
            "label" : "\"fullName\""
          } ],
          "resultType" : {
            "_type" : "dataType",
            "dataType" : "meta::pure::metamodel::type::Any"
          },
          "sqlQuery" : "select \"root\".fullName as \"pk_0\", \"root\".firmName as \"firmName\", \"root\".addressName as \"addressName\", \"root\".fullName as \"fullName\" from personTable as \"root\""
        } ],
        "graphFetchTree" : {
          "_type" : "rootGraphFetchTree",
          "_type" : "rootGraphFetchTree",
          "class" : "test::Person",
          "subTrees" : [ {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "fullName",
            "subTrees" : [ ]
          }, {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "firmName",
            "subTrees" : [ ]
          }, {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "addressName",
            "subTrees" : [ ]
          } ]
        },
        "implementation" : {
          "_type" : "java",
          "executionClassFullName" : "_pure.plan.root.n1.localGraph.Execute"
        },
        "nodeIndex" : 0,
        "resultType" : {
          "_type" : "partialClass",
          "class" : "test::Person",
          "propertiesWithParameters" : [ {
            "property" : "fullName"
          }, {
            "property" : "firmName"
          }, {
            "property" : "addressName"
          } ],
          "setImplementations" : [ {
            "class" : "test::Person",
            "id" : "test_Person",
            "mapping" : "test::Map",
            "propertyMappings" : [ {
              "enumMapping" : { },
              "property" : "fullName",
              "type" : "String"
            } ]
          } ]
        },
        "tempTableName" : "temp_table_node_0"
      },
      "resultSizeRange" : {
        "lowerBound" : 0
      },
      "resultType" : {
        "_type" : "partialClass",
        "class" : "test::Person",
        "propertiesWithParameters" : [ {
          "property" : "fullName"
        }, {
          "property" : "firm"
        }, {
          "property" : "address"
        }, {
          "property" : "firmName"
        }, {
          "property" : "addressName"
        } ],
        "setImplementations" : [ {
          "class" : "test::Person",
          "id" : "test_Person",
          "mapping" : "test::Map",
          "propertyMappings" : [ {
            "enumMapping" : { },
            "property" : "fullName",
            "type" : "String"
          } ]
        } ]
      },
      "store" : "test::DB1"
    } ],
    "implementation" : {
      "_type" : "java",
      "executionClassFullName" : "_pure.plan.root.Serialize"
    },
    "pure" : {
      "_type" : "func",
      "fControl" : "serialize_T_MANY__RootGraphFetchTree_1__String_1_",
      "function" : "serialize",
      "parameters" : [ {
        "_type" : "collection",
        "multiplicity" : {
          "lowerBound" : 0
        },
        "values" : [ ]
      }, {
        "_type" : "classInstance",
        "type" : "rootGraphFetchTree",
        "value" : {
          "_type" : "rootGraphFetchTree",
          "class" : "test::Person",
          "subTrees" : [ {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "fullName",
            "subTrees" : [ ]
          }, {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "firm",
            "subTrees" : [ {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "name",
              "subTrees" : [ ]
            }, {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "address",
              "subTrees" : [ {
                "_type" : "propertyGraphFetchTree",
                "_type" : "propertyGraphFetchTree",
                "parameters" : [ ],
                "property" : "name",
                "subTrees" : [ ]
              } ]
            } ]
          }, {
            "_type" : "propertyGraphFetchTree",
            "_type" : "propertyGraphFetchTree",
            "parameters" : [ ],
            "property" : "address",
            "subTrees" : [ {
              "_type" : "propertyGraphFetchTree",
              "_type" : "propertyGraphFetchTree",
              "parameters" : [ ],
              "property" : "name",
              "subTrees" : [ ]
            } ]
          } ]
        }
      } ]
    },
    "resultType" : {
      "_type" : "dataType",
      "dataType" : "String"
    }
  },
  "serializer" : {
    "name" : "pure",
    "version" : "vX_X_X"
  },
  "templateFunctions" : [ "<#function renderCollection collection separator prefix suffix defaultValue><#if collection?size == 0><#return defaultValue></#if><#return prefix + collection?join(suffix + separator + prefix) + suffix></#function>", "<#function collectionSize collection> <#return collection?size?c> </#function>", "<#function optionalVarPlaceHolderOperationSelector optionalParameter trueClause falseClause><#if optionalParameter?has_content || optionalParameter?is_string><#return trueClause><#else><#return falseClause></#if></#function>", "<#function varPlaceHolderToString optionalParameter prefix suffix defaultValue><#if optionalParameter?is_enumerable && !optionalParameter?has_content><#return defaultValue><#else><#return prefix + optionalParameter + suffix></#if></#function>", "<#function equalEnumOperationSelector enumVal inDyna equalDyna><#assign enumList = enumVal?split(\",\")><#if enumList?size = 1><#return equalDyna><#else><#return inDyna></#if></#function>" ]
}