// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::json::schema::tests::profile::*;
import meta::json::schema::fromSchema::*;
import meta::json::schema::fromSchema::tests::*;
import meta::json::*;
import meta::json::schema::generation::*;
import meta::json::schema::tests::*;
Profile meta::json::schema::tests::profile::GeneratedProfile
{
   stereotypes:[customStereoType1,customStereoType2];
   tags:[customTag1,customTag2,customTag3];

}

Class <<GeneratedProfile.customStereoType1>>  {meta::pure::profiles::doc.doc='A simple description',GeneratedProfile.customTag1='10',GeneratedProfile.customTag2='first',GeneratedProfile.customTag2='second'}meta::json::schema::tests::ClassWithCustomProfiles
{
   <<GeneratedProfile.customStereoType1>> simpleString : String[0..1];
   <<GeneratedProfile.customStereoType2>> {GeneratedProfile.customTag3='false'} arrayMaxItemOne : String[0..10];
}


function <<meta::json::schema::JSONSchemaTypeExtension.object>> {meta::pure::profiles::doc.doc='Generate an object tag where there typically would not be any'} meta::json::schema::tests::functionForcedToObject(value: meta::pure::metamodel::type::Any[0..1]): Boolean[1]
{
  $value->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if({|[$value->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::meta::instanceOf(meta::json::schema::tests::Cat), $value->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::meta::instanceOf(meta::json::schema::tests::Dog)]->meta::pure::functions::collection::or()}, {|true});
}

Class  meta::json::schema::tests::SimpleClass
{
   p:String[1]; 
   a:SimpleClass2[0..1];
  

}

Class  meta::json::schema::tests::SimpleClass2
{
   p:String[1]; 

}

function  meta::json::schema::tests::functionWithStringType(value: String[0..1]): Boolean[1]
{
  $value->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if(|$value->makeString()->matches('test') ,{|true});
}

Class {meta::json::schema::JSONSchemaGeneration.title='a custom title'} meta::json::schema::tests::ClassWithFunctionReferences
[
  one : $this.one->meta::json::schema::tests::functionWithStringType(),
  optional : $this.optional->meta::json::schema::tests::functionWithStringType(),
  many : $this.many->meta::pure::functions::collection::forAll({value|$value->meta::json::schema::tests::functionWithStringType()})
]

{
  one : String[1];
  optional : String[0..1];
  many : String[*];
}

Class meta::json::schema::tests::ClassWithInLineFunctions
[
  multipleOf_inLine : $this.multipleOf->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if({|($this.multipleOf->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::math::rem(0.1)) == (0)}, {|true}),
  number_inLine : $this.number->meta::pure::functions::collection::in([1, 2]),
  string_inLine : $this.string->meta::pure::functions::collection::in(['a', 'b']),
  stringOptional_inLine : $this.stringOptional->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if({|$this.stringOptional->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::collection::in(['a', 'b'])}, {|true}),
  integer_inLine : $this.integer->meta::pure::functions::collection::in([1, 2]),
  numberOptional_inLine : $this.numberOptional->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if({|$this.numberOptional->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::collection::in([1, 2])}, {|true})
]
{
  multipleOf : Float[0..1];
  number : Float[1];
  string : String[1];
  stringOptional : String[0..1];
  integer : Integer[1];
  numberOptional : Float[0..1];
}

Enum <<meta::json::schema::JSONSchemaTypeExtension.null>> meta::json::schema::tests::NullableEnum
{
   one,
   two

}


Class <<temporal.bitemporal>>  meta::json::schema::tests::BiTemporalPerson
{
   name:String[1]; 
   company: meta::json::schema::tests::BiTemporalFirm[*];
}

Class <<temporal.bitemporal>>  meta::json::schema::tests::BiTemporalFirm
{
   name:String[1]; 

}


function <<test.Test>>  { meta::pure::executionPlan::profiles::serverVersion.start='v1_20_0'}  meta::json::schema::tests::roundTrip::typeInclusionForConstraintFunctions():Boolean[1]
{
     let generatedJSON = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::ClassWithFunctionReferences,meta::json::schema::tests::functionWithStringType_String_$0_1$__Boolean_1_],
                                                         useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true ));

  let jsonschemaclass =       '{' +
'  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
'  "title": "a custom title",' +
'  "type": "object",' +
'  "properties":   {' +
'    "one":     {' +
'      "$ref": "functionWithStringType.json"' +
'    },' +
'    "many":     {' +
'      "type": "array",' +
'      "items":       {' +
'        "$ref": "functionWithStringType.json"' +
'      }' +
'    },' +
'    "optional":     {' +
'      "$ref": "functionWithStringType.json"' +
'    }' +
'  },' +
'  "required": [' +
'"one"' +
'  ]' +
'}'; 
      
     
   let jsonschemafunc=   '{' +
                     '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                     '  "pattern": "test",' +
                     '  "type": "string",' +
                     '  "title": "meta::json::schema::tests::functionWithStringType"' +
                     '}' ;

  assert(jsonEquivalent($jsonschemaclass->parseJSON(),$generatedJSON->filter(c|$c.fileName == 'meta/json/schema/tests/ClassWithFunctionReferences.json').content->toOne()->parseJSON()));
  
  let prefix = 'meta::json::schema::tests';
  let fileMap = [schemaInput('/ClassWithFunctionReferences.json', $jsonschemaclass,$prefix),
                   schemaInput('/functionWithStringType.json', $jsonschemafunc,$prefix)]; 
  let generatedClassFromJSON =  $fileMap->JSONSchemaToPure()->filter(p|$p.name=='ClassWithFunctionReferences')->toOne();

  assert(jsonEquivalent(meta::json::schema::tests::ClassWithFunctionReferences->toSerializer()->parseJSON(),$generatedClassFromJSON->toOne()->toSerializer()->parseJSON()));
      testfromJSONSchema(meta::json::schema::tests::ClassWithFunctionReferences,$generatedClassFromJSON);

}



function <<test.Test>>  { meta::pure::executionPlan::profiles::serverVersion.start='v1_20_0'}  meta::json::schema::tests::roundTrip::testCustomProfile():Boolean[1]
{
   
  let generatedJSONFromClassOpenAPI = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::ClassWithCustomProfiles,meta::json::schema::tests::profile],
                                                         useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true,schemaSpecification=JSONSchemaSpecification.OPEN_API_V3_0_3 ));
  
   
   let jsonSchemaOpenAPI  = ' {\n' +
        '  "x-customStereoType1": true,\n' +
        '  "description": "A simple description",\n' +
        '  "title": "meta::json::schema::tests::ClassWithCustomProfiles",\n' +
        '  "x-customTag2": [\n' +
        '"first",\n' +
        '"second"\n' +
        '  ],\n' +
        '  "type": "object",\n' +
        '  "properties":   {\n' +
        '    "simpleString":     {\n' +
        '      "x-customStereoType1": true,\n' +
        '      "type": "string"\n' +
        '    },\n' +
        '    "arrayMaxItemOne":     {\n' +
        '      "x-customStereoType2": true,\n' +
        '      "maxItems": 10,\n' +
        '      "type": "array",\n' +
        '      "x-customTag3": "false",\n' +
        '      "items":       {\n' +
        '        "type": "string"\n' +
        '      }\n' +
        '    }\n' +
        '  },\n' +
        '  "x-customTag1": 10\n' +
        '}';
          assert(jsonEquivalent($jsonSchemaOpenAPI->parseJSON(),$generatedJSONFromClassOpenAPI.content->toOne()->parseJSON()));

   
   
      
    let prefix = 'meta::json::schema::tests';
    let fileMap = [schemaInput('/ClassWithCustomProfiles.json', $jsonSchemaOpenAPI,$prefix)]; 
    let generatedClassFromJSON =  $fileMap->JSONSchemaToPure(); 
     //should return  a Profile the schemas
   
   let generatedClassOpenAPI  = $generatedClassFromJSON->filter(p|$p.name=='ClassWithCustomProfiles')->toOne();
   let generatedProfileOpenAPI  = $generatedClassFromJSON->filter(p|$p.name=='GeneratedProfile')->toOne();
   testfromJSONSchema(meta::json::schema::tests::ClassWithCustomProfiles,$generatedClassFromJSON);
    testfromJSONSchema(meta::json::schema::tests::profile::GeneratedProfile,$generatedClassFromJSON);
  
      
   let generatedJSONFromClassDraft07 = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::ClassWithCustomProfiles,meta::json::schema::tests::profile],
                                                         useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true ));
   
   let jsonSchemaDraft07  = ' {\n' +
        '  "customStereoType1": true,\n' +
        '  "description": "A simple description",\n' +
        '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
        '  "title": "meta::json::schema::tests::ClassWithCustomProfiles",\n' +
        '  "customTag2": [\n' +
        '"first",\n' +
        '"second"\n' +
        '  ],\n' +
        '  "type": "object",\n' +
        '  "properties":   {\n' +
        '    "simpleString":     {\n' +
        '      "customStereoType1": true,\n' +
        '      "type": "string"\n' +
        '    },\n' +
        '    "arrayMaxItemOne":     {\n' +
        '      "customStereoType2": true,\n' +
        '      "maxItems": 10,\n' +
        '      "type": "array",\n' +
        '      "customTag3": "false",\n' +
        '      "items":       {\n' +
        '        "type": "string"\n' +
        '      }\n' +
        '    }\n' +
        '  },\n' +
        '  "customTag1": 10\n' +
        '}';
   
   assert(jsonEquivalent($jsonSchemaDraft07->parseJSON(),$generatedJSONFromClassDraft07.content->toOne()->parseJSON()));
  let fileMapDraft07 = [schemaInput('/ClassWithCustomProfiles.json', $jsonSchemaDraft07,$prefix)]; 
  let generatedClassFromJSONDraft07 =  $fileMapDraft07->JSONSchemaToPure(); 
  let generatedClassDraft07  = $generatedClassFromJSON->filter(p|$p.name=='ClassWithCustomProfiles')->toOne();
  let generatedProfileDraft07  = $generatedClassFromJSON->filter(p|$p.name=='GeneratedProfile')->toOne();

   testfromJSONSchema(meta::json::schema::tests::ClassWithCustomProfiles,$generatedClassFromJSON);
   testfromJSONSchema(meta::json::schema::tests::profile::GeneratedProfile,$generatedClassFromJSON);

   
}

function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='v1_20_0'}  meta::json::schema::tests::roundTrip::testforceFunctionToObject():Boolean[1]
{
   
     let generatedJSONFromElement = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::functionForcedToObject_Any_$0_1$__Boolean_1_],
                                                          useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true ));  
   let jsonSchema  = '{' +
'  "anyOf": [' +
'    {' +
'      "$ref": "Cat.json"' +
'    },' +
'    {' +
'      "$ref": "Dog.json"' +
'    }' +
'  ],' +
'  "title": "meta::json::schema::tests::functionForcedToObject",' +
'  "type": "object",' +
'  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
'  "description": "Generate an object tag where there typically would not be any"' +
'}';
  
   assert(jsonEquivalent($jsonSchema->parseJSON(),$generatedJSONFromElement.content->toOne()->parseJSON()));
    let prefix = 'meta::json::schema::tests';
    let fileMap = [schemaInput('/functionForcedToObject.json', $jsonSchema,$prefix)]; 
    let generatedElementFromJSON =  $fileMap->JSONSchemaToPure(); 
   testfromJSONSchema(meta::json::schema::tests::functionForcedToObject_Any_$0_1$__Boolean_1_,$generatedElementFromJSON);
}

function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='v1_20_0'}  meta::json::schema::tests::roundTrip::testinLineFunctions():Boolean[1]
{
     let generatedJSONFromElement = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[ meta::json::schema::tests::ClassWithInLineFunctions],
                                                          useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true ));  
   let jsonSchema  = '{' +
                     '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                     '  "title": "meta::json::schema::tests::ClassWithInLineFunctions",' +
                     '  "type": "object",' +
                     '  "properties":   {' +
                     '    "number":     {' +
                     '      "type": "number",' +
                     '      "enum": [' +
                     '1,' +
                     '2' +
                     '      ]' +
                     '    },' +
                     '    "string":     {' +
                     '      "type": "string",' +
                     '      "enum": [' +
                     '"a",' +
                     '"b"' +
                     '      ]' +
                     '    },' +
                     '    "stringOptional":     {' +
                     '      "type": "string",' +
                     '      "enum": [' +
                     '"a",' +
                     '"b"' +
                     '      ]' +
                     '    },' +
                     '    "integer":     {' +
                     '      "type": "integer",' +
                     '      "enum": [' +
                     '1,' +
                     '2' +
                     '      ]' +
                     '    },' +

                     '    "numberOptional":     {' +
                     '      "type": "number",' +
                     '      "enum": [' +
                     '1,' +
                     '2' +
                     '      ]' +
                     '    },' +
                     '    "multipleOf":     {' +
                     '      "type": "number",' +
                     '      "multipleOf": 0.1' +
                     '    }' +

                     '  },' +
                     '  "required": [' +
                     '"number",' +
                     '"string",' +
                     '"integer"' +
                     '  ]' +
                     '}' ;
    


   assert(jsonEquivalent($jsonSchema->parseJSON(),$generatedJSONFromElement.content->toOne()->parseJSON()));
   let prefix = 'meta::json::schema::tests';
   let fileMap = [schemaInput('/ClassWithInLineFunctions.json', $jsonSchema,$prefix)]; 
   let generatedElementFromJSON =  $fileMap->JSONSchemaToPure(); 
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::ClassWithInLineFunctions,$generatedElementFromJSON);

}



function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='v1_20_0'}  meta::json::schema::tests::roundTrip::testComplexPaths():Boolean[1]
{
    let jsonSchema = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::parent::parentClass,
                                                                                          meta::json::schema::tests::parent2::level1::level2::childClass2,
                                                                                          meta::json::schema::tests::parent::parent::levela::parentClass2,
                                                                                          meta::json::schema::tests::parent::level1::childClass,
                                                                                          meta::json::schema::tests::parent::level1::level2::childClass3,
                                                                                          meta::json::schema::tests::parent::level1::levela::childClass4 ],
                                                                           includeAllRelatedTypes = false  ));

    assertFalse( $jsonSchema->isEmpty() );
    assertSize($jsonSchema,6);

    let expectedParentjson=  '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::parentClass","type":"object","properties":{"childClass":{"$ref":"level1\/childClass.json"},"childClass2":{"$ref":"..\/parent2\/level1\/level2\/childClass2.json"}},"required":["childClass","childClass2"]}';

    let actualParentJSON =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/parentClass.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();

    assertEquals($expectedParentjson->meta::json::parseJSON()->toCompactJSONString(),$actualParentJSON);

    let expectedChildJSON = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::level1::childClass","type":"object"}';
   let actualChildJSON =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/level1/childClass.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();
   assertEquals($expectedChildJSON->meta::json::parseJSON()->toCompactJSONString(),$actualChildJSON);

   let expectedParent2 = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::parent::levela::parentClass2","type":"object","properties":{"childClass3":{"$ref":"..\/..\/level1\/level2\/childClass3.json"},"childClass4":{"$ref":"..\/..\/level1\/levela\/childClass4.json"}},"required":["childClass3"]}';
   let actualParent2JSON =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/parent/levela/parentClass2.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();

   assertEquals($expectedParent2->meta::json::parseJSON()->toCompactJSONString(),$actualParent2JSON);

   let expectedchild2 = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent2::level1::level2::childClass2","type":"object","properties":{"parentClass":{"$ref":"..\/..\/..\/parent\/parentClass.json"}},"required":["parentClass"]}';
   let actualChild2 =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent2/level1/level2/childClass2.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();

   let expectedchild3 = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::level1::level2::childClass3","type":"object"}';
   let actualchild3 =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/level1/level2/childClass3.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();

   let expectedchild4 = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::level1::levela::childClass4","type":"object"}';
   let actualchild4 =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/level1/levela/childClass4.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();


    let prefix = 'meta::json::schema::tests';

   let fileMap = [schemaInput('/parent/parentClass.json', $expectedParentjson,$prefix),
                 schemaInput('/parent/level1/childClass.json', $expectedChildJSON,$prefix),
                 schemaInput('/parent/parent/levela/parentClass2.json', $expectedParent2,$prefix),
                 schemaInput('/parent2/level1/level2/childClass2.json', $expectedchild2,$prefix),
                 schemaInput('/parent/level1/level2/childClass3.json', $expectedchild3,$prefix),
                 schemaInput('/parent/level1/levela/childClass4.json', $expectedchild4,$prefix)


   ];
    let generatedElementFromJSON =  $fileMap->JSONSchemaToPure();

       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::parentClass,$generatedElementFromJSON);
       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent2::level1::level2::childClass2,$generatedElementFromJSON);
       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::parent::levela::parentClass2,$generatedElementFromJSON);



}

function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='v1_20_0'}  meta::json::schema::tests::roundTrip::testNullableEnum():Boolean[1]

{
       let jsonSchema = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::NullableEnum]));
       let jsonSchemaOpenAPI = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::NullableEnum],schemaSpecification=JSONSchemaSpecification.OPEN_API_V3_0_3));

       let expectedJSON =  '{' +
                           '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                           '  "title": "meta::json::schema::tests::NullableEnum",' +
                           '  "enum": [' +
                           '"one",' +
                           '"two",' +
                           'null' +
                           '  ],' +
                           '  "type": [' +
                           '"string",' +
                           '"null"' +
                           '  ]' +
                           '}' ;

       let expectedOpenAPIJSON = '{' +
                                 '  "title": "meta::json::schema::tests::NullableEnum",' +
                                 '  "nullable": true,' +
                                 '  "enum": [' +
                                 '"one",' +
                                 '"two",' +
                                 'null' +
                                 '  ],' +
                                 '  "type": "string"' +
                                 '}';

      assert(jsonEquivalent($expectedJSON->parseJSON(),$jsonSchema.content->toOne()->parseJSON()));
      assert(jsonEquivalent($expectedOpenAPIJSON->parseJSON(),$jsonSchemaOpenAPI.content->toOne()->parseJSON()));
      let prefix = 'meta::json::schema::tests';
      let fileMap = [schemaInput('/NullableEnum.json', $expectedJSON,$prefix)];
      let fileMapOpenAPI = [schemaInput('/NullableEnum.json', $expectedOpenAPIJSON,$prefix)];

      let generatedElementFromJSON =  $fileMap->JSONSchemaToPure();
      let generatedElementFromJSONOpenAPI =  $fileMapOpenAPI->JSONSchemaToPure();
       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::NullableEnum,$generatedElementFromJSON);
       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::NullableEnum,$generatedElementFromJSONOpenAPI);

}

function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='v1_20_0'}  meta::json::schema::tests::roundTrip::testSchemaCollection():Boolean[1]
{
     let collectWithNoRelatedTypes = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[ meta::json::schema::tests::SimpleClass,meta::json::schema::tests::ClassWithFunctionReferences],
                                                          useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true,createSchemaCollection=true ));
  
      let collectWithRelatedTypes = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[ meta::json::schema::tests::SimpleClass,meta::json::schema::tests::ClassWithFunctionReferences],
                                                          useConstraints = true ,includeAllRelatedTypes=true,generateConstraintFunctionSchemas=true,createSchemaCollection=true )); 
 
      let collectOpenAPI = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[ meta::json::schema::tests::SimpleClass,meta::json::schema::tests::ClassWithFunctionReferences],
                                                          useConstraints = true ,includeAllRelatedTypes=true,generateConstraintFunctionSchemas=true,createSchemaCollection=true,schemaSpecification=JSONSchemaSpecification.OPEN_API_V3_0_3 )); 
      let collectOpenAPIYAML = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[ meta::json::schema::tests::SimpleClass,meta::json::schema::tests::ClassWithFunctionReferences],
                                                          useConstraints = true ,includeAllRelatedTypes=true,generateConstraintFunctionSchemas=true,createSchemaCollection=true,schemaSpecification=JSONSchemaSpecification.OPEN_API_V3_0_3_YAML )); 
      let expectedOpenAPIYAML = 'components: \n' +
                                 '  schemas: \n' +
                                 '    meta::json::schema::tests::ClassWithFunctionReferences: \n' +
                                 '      title: "a custom title"\n' +
                                 '      type: "object"\n' +
                                 '      properties: \n' +
                                 '        one: \n' +
                                 '          $ref: "#/components/schemas/meta::json::schema::tests::functionWithStringType"\n' +
                                 '        optional: \n' +
                                 '          $ref: "#/components/schemas/meta::json::schema::tests::functionWithStringType"\n' +
                                 '        many: \n' +
                                 '          type: "array"\n' +
                                 '          items: \n' +
                                 '            $ref: "#/components/schemas/meta::json::schema::tests::functionWithStringType"\n' +
                                 '      required: \n' +
                                 '        - "one"\n' +
                                 '    meta::json::schema::tests::SimpleClass: \n' +
                                 '      title: "meta::json::schema::tests::SimpleClass"\n' +
                                 '      type: "object"\n' +
                                 '      properties: \n' +
                                 '        p: \n' +
                                 '          type: "string"\n' +
                                 '        a: \n' +
                                 '          $ref: "#/components/schemas/meta::json::schema::tests::SimpleClass2"\n' +
                                 '      required: \n' +
                                 '        - "p"\n' +
                                 '    meta::json::schema::tests::SimpleClass2: \n' +
                                 '      title: "meta::json::schema::tests::SimpleClass2"\n' +
                                 '      type: "object"\n' +
                                 '      properties: \n' +
                                 '        p: \n' +
                                 '          type: "string"\n' +
                                 '      required: \n' +
                                 '        - "p"\n' +
                                 '    meta::json::schema::tests::functionWithStringType: \n' +
                                 '      pattern: "test"\n' +
                                 '      type: "string"';
   
   
   

    let expectedOPenAPI = '{' +
                        '  "components":   {' +
                        '    "schemas":     {' +
                        '      "meta::json::schema::tests::ClassWithFunctionReferences":       {' +
                        '        "title": "a custom title",' +
                        '        "type": "object",' +
                        '        "properties":         {' +
                        '          "one":           {' +
                        '            "$ref": "#\/components\/schemas\/meta::json::schema::tests::functionWithStringType"' +
                        '          },' +
                        '          "optional":           {' +
                        '            "$ref": "#\/components\/schemas\/meta::json::schema::tests::functionWithStringType"' +
                        '          },' +
                        '          "many":           {' +
                        '            "type": "array",' +
                        '            "items":             {' +
                        '              "$ref": "#\/components\/schemas\/meta::json::schema::tests::functionWithStringType"' +
                        '            }' +
                        '          }' +
                        '        },' +
                        '        "required": [' +
                        '"one"' +
                        '        ]' +
                        '      },' +
                        '      "meta::json::schema::tests::SimpleClass":       {' +
                        '        "title": "meta::json::schema::tests::SimpleClass",' +
                        '        "type": "object",' +
                        '        "properties":         {' +
                        '          "p":           {' +
                        '            "type": "string"' +
                        '          },' +
                        '          "a":           {' +
                        '            "$ref": "#\/components\/schemas\/meta::json::schema::tests::SimpleClass2"' +
                        '          }' +
                        '        },' +
                        '        "required": [' +
                        '"p"' +
                        '        ]' +
                        '      },' +
                        '      "meta::json::schema::tests::SimpleClass2":       {' +
                        '        "title": "meta::json::schema::tests::SimpleClass2",' +
                        '        "type": "object",' +
                        '        "properties":         {' +
                        '          "p":           {' +
                        '            "type": "string"' +
                        '          }' +
                        '        },' +
                        '        "required": [' +
                        '"p"' +
                        '        ]' +
                        '      },' +
                        '      "meta::json::schema::tests::functionWithStringType":       {' +
                        '        "pattern": "test",' +
                        '        "type": "string"' +
                        '      }' +
                        '    }' +
                        '  }' +
                        '}' ;
  
   
  
   let expectedStandardJSONSchema= '{' +
                                       '  "definitions":   {' +
                                       '    "meta::json::schema::tests::ClassWithFunctionReferences":     {' +
                                       '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                                       '      "title": "a custom title",' +
                                       '      "type": "object",' +
                                       '      "properties":       {' +
                                       '        "one":         {' +
                                       '          "$ref": "#\/definitions\/meta::json::schema::tests::functionWithStringType"' +
                                       '        },' +
                                       '        "optional":         {' +
                                       '          "$ref": "#\/definitions\/meta::json::schema::tests::functionWithStringType"' +
                                       '        },' +
                                       '        "many":         {' +
                                       '          "type": "array",' +
                                       '          "items":           {' +
                                       '            "$ref": "#\/definitions\/meta::json::schema::tests::functionWithStringType"' +
                                       '          }' +
                                       '        }' +
                                       '      },' +
                                       '      "required": [' +
                                       '"one"' +
                                       '      ]' +
                                       '    },' +
                                       '    "meta::json::schema::tests::SimpleClass":     {' +
                                       '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                                       '      "title": "meta::json::schema::tests::SimpleClass",' +
                                       '      "type": "object",' +
                                       '      "properties":       {' +
                                       '        "p":         {' +
                                       '          "type": "string"' +
                                       '        },' +
                                       '        "a":         {' +
                                       '          "$ref": "#\/definitions\/meta::json::schema::tests::SimpleClass2"' +
                                       '        }' +
                                       '      },' +
                                       '      "required": [' +
                                       '"p"' +
                                       '      ]' +
                                       '    },' +
                                       '    "meta::json::schema::tests::SimpleClass2":     {' +
                                       '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                                       '      "title": "meta::json::schema::tests::SimpleClass2",' +
                                       '      "type": "object",' +
                                       '      "properties":       {' +
                                       '        "p":         {' +
                                       '          "type": "string"' +
                                       '        }' +
                                       '      },' +
                                       '      "required": [' +
                                       '"p"' +
                                       '      ]' +
                                       '    },' +
                                       '    "meta::json::schema::tests::functionWithStringType":     {' +
                                       '      "pattern": "test",' +
                                       '      "type": "string"' +
                                       '    }' +
                                       '  }' +
                                       '}';
   
   
      let ImportedCollectionNoPath= '{' +
                                       '  "definitions":   {' +
                                       '    "ClassWithFunctionReferences":     {' +
                                       '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                                       '      "title": "a custom title",' +
                                       '      "type": "object",' +
                                       '      "properties":       {' +
                                       '        "one":         {' +
                                       '          "$ref": "#\/definitions\/functionWithStringType"' +
                                       '        },' +
                                       '        "optional":         {' +
                                       '          "$ref": "#\/definitions\/functionWithStringType"' +
                                       '        },' +
                                       '        "many":         {' +
                                       '          "type": "array",' +
                                       '          "items":           {' +
                                       '            "$ref": "#\/definitions\/functionWithStringType"' +
                                       '          }' +
                                       '        }' +
                                       '      },' +
                                       '      "required": [' +
                                       '"one"' +
                                       '      ]' +
                                       '    },' +
                                       '    "SimpleClass":     {' +
                                       '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                                       '      "title": "meta::json::schema::tests::SimpleClass",' +
                                       '      "type": "object",' +
                                       '      "properties":       {' +
                                       '        "p":         {' +
                                       '          "type": "string"' +
                                       '        },' +
                                       '        "a":         {' +
                                       '          "$ref": "#\/definitions\/SimpleClass2"' +
                                       '        }' +
                                       '      },' +
                                       '      "required": [' +
                                       '"p"' +
                                       '      ]' +
                                       '    },' +
                                       '    "SimpleClass2":     {' +
                                       '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                                       '      "title": "meta::json::schema::tests::SimpleClass2",' +
                                       '      "type": "object",' +
                                       '      "properties":       {' +
                                       '        "p":         {' +
                                       '          "type": "string"' +
                                       '        }' +
                                       '      },' +
                                       '      "required": [' +
                                       '"p"' +
                                       '      ]' +
                                       '    },' +
                                       '    "functionWithStringType":     {' +
                                       '      "pattern": "test",' +
                                       '      "type": "string"' +
                                       '    }' +
                                       '  }' +
                                       '}';
      assert($collectWithNoRelatedTypes.fileName=='model.json');
      assert($collectOpenAPIYAML.fileName=='model.yaml');
      assert($collectOpenAPI.fileName=='model.json');

      assert(jsonEquivalent($expectedStandardJSONSchema->parseJSON(),$collectWithNoRelatedTypes.content->toOne()->parseJSON()));
      assert(jsonEquivalent($expectedStandardJSONSchema->parseJSON(),$collectWithRelatedTypes.content->toOne()->parseJSON()));

      assert(jsonEquivalent($expectedOPenAPI->parseJSON(),$collectOpenAPI.content->toOne()->parseJSON()));
      assertEquals($expectedOpenAPIYAML,$collectOpenAPIYAML.content->toOne());
    let mergedPaths = [schemaInput('/schema/tests.json', $ImportedCollectionNoPath,'meta::json')]->JSONSchemaToPure();
    let OpenAPINoPaths = [schemaInput('/tests.json', $ImportedCollectionNoPath,'meta::json::schema')]->JSONSchemaToPure();
    let standardSchema = [schemaInput('/model.json', $expectedStandardJSONSchema,[])]->JSONSchemaToPure();
    let openAPI = [schemaInput('/model.json', $expectedOPenAPI,'should::be::ignored')]->JSONSchemaToPure();

   assert($standardSchema->size()==4);
   assert($openAPI->size()==4);
   assert($OpenAPINoPaths->size()==4);
   assert($mergedPaths->size()==4);

   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::ClassWithFunctionReferences,$standardSchema);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::functionWithStringType_String_$0_1$__Boolean_1_,$standardSchema);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::SimpleClass2,$standardSchema);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::SimpleClass,$standardSchema);


   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::ClassWithFunctionReferences,$openAPI);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::functionWithStringType_String_$0_1$__Boolean_1_,$openAPI);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::SimpleClass2,$openAPI);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::SimpleClass,$openAPI);


   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::ClassWithFunctionReferences,$OpenAPINoPaths);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::functionWithStringType_String_$0_1$__Boolean_1_,$OpenAPINoPaths);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::SimpleClass2,$OpenAPINoPaths);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::SimpleClass,$OpenAPINoPaths);
   
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::ClassWithFunctionReferences,$mergedPaths);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::functionWithStringType_String_$0_1$__Boolean_1_,$mergedPaths);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::SimpleClass2,$mergedPaths);
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::SimpleClass,$mergedPaths);

}




function <<test.Test>>  { meta::pure::executionPlan::profiles::serverVersion.start='v1_20_0'}  meta::json::schema::tests::roundTrip::testDefinitions():Boolean[1]
{
   let generatedJSONSchema = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::parent::parent::levela::parentClass2]));

   let expectedJSON = '{' +
                  '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                  '  "title": "meta::json::schema::tests::parent::parent::levela::parentClass2",' +
                  '  "type": "object",' +
                  '  "properties":   {' +
                  '    "childClass4":     {' +
                  '      "$ref": "#\/definitions\/meta::json::schema::tests::parent::level1::levela::childClass4"' +
                  '    },' +
                  '    "childClass3":     {' +
                  '      "$ref": "#\/definitions\/meta::json::schema::tests::parent::level1::level2::childClass3"' +
                  '    }' +
                  '  },' +
                  '  "required": [' +
                  '"childClass3"' +
                  '  ],' +
                  '  "definitions":   {' +
                  '    "meta::json::schema::tests::parent::level1::level2::childClass3":     {' +
                  '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                  '      "title": "meta::json::schema::tests::parent::level1::level2::childClass3",' +
                  '      "type": "object"' +
                  '    },' +
                  '    "meta::json::schema::tests::parent::level1::levela::childClass4":     {' +
                  '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                  '      "title": "meta::json::schema::tests::parent::level1::levela::childClass4",' +
                  '      "type": "object"' +
                  '    }' +
                  '  }' +
                  '}';
      assert(jsonEquivalent($expectedJSON->parseJSON(),$generatedJSONSchema.content->toOne()->parseJSON()));

      let prefix = 'meta::json::schema::tests';
      let fileMap = [schemaInput('/parent/parent/levela/parentClass2.json', $expectedJSON,$prefix)];
     let generatedElementFromJSON =  $fileMap->JSONSchemaToPure();
      meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::parent::levela::parentClass2,$generatedElementFromJSON);
      meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::level1::levela::childClass4,$generatedElementFromJSON);
      meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::level1::level2::childClass3,$generatedElementFromJSON);

}




function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='v1_20_0'}  meta::json::schema::tests::roundTrip::testMilestoneAnnotation():Boolean[1]
{
   
   let generatedJSONFromElement = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::BiTemporalPerson],
                                                          includeAllRelatedTypes=true ));  

   
   let generatedJSONFromElementWithMilestone = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::BiTemporalPerson],
                                                          includeAllRelatedTypes=false,generateMilestoneProperties=true ));  


   let jsonSchema  =         '{\n' +
                              '  "$schema": "http:\\/\\/json-schema.org\\/draft-07\\/schema#",\n' +
                              '  "title": "meta::json::schema::tests::BiTemporalPerson",\n' +
                              '  "x-legendTemporal": "bitemporal",\n' +
                              '  "type": "object",\n' +
                              '  "properties":   {\n' +
                              '    "name":     {\n' +
                              '      "type": "string"\n' +
                              '    },\n' +
                              '    "company":     {\n' +
                              '      "type": "array",\n' +
                              '      "items":       {\n' +
                              '        "$ref": "#\\/definitions\\/meta::json::schema::tests::BiTemporalFirm"\n' +
                              '      }\n' +
                              '    }\n' +
                              '  },\n' +
                              '  "required": [\n' +
                              '"name"\n' +
                              '  ],\n' +
                              '  "definitions":   {\n' +
                              '    "meta::json::schema::tests::BiTemporalFirm":     {\n' +
                              '      "$schema": "http:\\/\\/json-schema.org\\/draft-07\\/schema#",\n' +
                              '      "title": "meta::json::schema::tests::BiTemporalFirm",\n' +
                              '      "x-legendTemporal": "bitemporal",\n' +
                              '      "type": "object",\n' +
                              '      "properties":       {\n' +
                              '        "name":         {\n' +
                              '          "type": "string"\n' +
                              '        }\n' +
                              '      },\n' +
                              '      "required": [\n' +
                              '"name"\n' +
                              '      ]\n' +
                              '    }\n' +
                              '  }\n' +
                              '}';

let jsonSchemaWithMilestone = '        {\n' +
        '  "$schema": "http:\\/\\/json-schema.org\\/draft-07\\/schema#",\n' +
        '  "title": "meta::json::schema::tests::BiTemporalPerson",\n' +
        '  "x-legendTemporal": "bitemporal",\n' +
        '  "type": "object",\n' +
        '  "properties":   {\n' +
        '    "name":     {\n' +
        '      "type": "string"\n' +
        '    },\n' +
        '    "processingDate":     {\n' +
        '      "type": "string",\n' +
        '      "format": "date-time"\n' +
        '    },\n' +
        '    "businessDate":     {\n' +
        '      "type": "string",\n' +
        '      "format": "date-time"\n' +
        '    },\n' +
        '    "milestoning":     {\n' +
        '      "$ref": "..\\/..\\/..\\/pure\\/milestoning\\/BiTemporalMilestoning.json"\n' +
        '    },\n' +
        '    "companyAllVersions":     {\n' +
        '      "type": "array",\n' +
        '      "items":       {\n' +
        '        "$ref": "BiTemporalFirm.json"\n' +
        '      }\n' +
        '    }\n' +
        '  },\n' +
        '  "required": [\n' +
        '"name",\n' +
        '"processingDate",\n' +
        '"businessDate"\n' +
        '  ]\n' +
        '}\n';


   assert(jsonEquivalent($jsonSchemaWithMilestone->parseJSON(),$generatedJSONFromElementWithMilestone.content->toOne()->parseJSON()));

   assert(jsonEquivalent($jsonSchema->parseJSON(),$generatedJSONFromElement.content->toOne()->parseJSON()));
}
