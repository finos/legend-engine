// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::executionPlan::*;
import meta::pure::extension::*;
import meta::pure::store::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::mapping::*;
import meta::pure::runtime::*;
import meta::pure::metamodel::path::*;
import meta::pure::router::printer::*;
import meta::pure::router::builder::*;
import meta::pure::router::clustering::*;
import meta::pure::router::routing::*;
import meta::pure::router::execution::*;
import meta::pure::router::store::platform::*;

Class meta::pure::router::RoutingQuery<T|m>
{
   fn : FunctionDefinition<{->T[m]}>[1];
}

Class meta::pure::router::RoutingResult
{
   functions:FunctionDefinition<Any>[*];
}

Class meta::pure::router::RoutedVariablePlaceHolder
{
   name : String[1];
}

Class meta::pure::router::Void extends ValueSpecification
{

}

Class meta::pure::router::TDSRoutedValueSpecification extends RoutedValueSpecification
{
   id:String[1];
   runtime:Runtime[1];
   mapping:Mapping[1];
   store:meta::pure::store::Store[1];
   executionContext:ExecutionContext[1];
}

Class meta::pure::router::NoSetRoutedValueSpecification extends RoutedValueSpecification
{
}

Class meta::pure::router::FunctionRoutedValueSpecification extends RoutedValueSpecification
{
   propertyMap : PropertyMap[0..1];
   builtPropertyMap : Map<String, SetImplementation>[0..1];
   originalFunction : FunctionDefinition<Any>[1];
}

Class meta::pure::router::ClassSetImplementationHolder extends RoutedValueSpecification
{
   set : SetImplementation[1];
}

Class meta::pure::router::routing::PropertyMap
{
   v:Pair<String,Any>[*];
}

function meta::pure::router::routeFunction(f:FunctionDefinition<Any>[1], extensions:meta::pure::extension::Extension[*]):RoutingResult[1]
{
   $f->routeFunction(^ExecutionContext(), $extensions, noDebug());
}

function meta::pure::router::routeFunction(f:FunctionDefinition<Any>[1], exeCtx: ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):RoutingResult[1]
{
   let expressions     = $f.expressionSequence->evaluateAndDeactivate();

   assert($expressions->init()->forAll(vs| $vs->isLetFunction()), 'In FunctionDefinition with many expressions, all except last should be let expressions');
   //validate ::execute(..) not present
   let l = {|[]};
   let initStatements = $expressions->init()->fold(
    {vs, a |
                                                                 let varName = $vs->meta::pure::router::extractLetVariableName();

      if($vs->usesFrom(),
        {|
          let f = ^$l(expressionSequence = $vs, openVariables=$a.second->keys());
                                                                              let routed = routeFunction($f, ^Mapping(name = ''), ^meta::pure::runtime::Runtime(), $exeCtx, $a.second, $extensions, $debug);
          let vars = if($varName->isNotEmpty(),
                       | $a.second->put($varName->toOne(), ^List<RoutedVariablePlaceHolder>(values=^RoutedVariablePlaceHolder(name=$varName->toOne()))),
                       | $a.second
                     );
                                                                              let temp = $routed.functions->toOne();
          ^$a(
            first = ^RoutingResult(
              functions       = ^$temp(expressionSequence = $a.first.functions.expressionSequence->concatenate($temp.expressionSequence)->evaluateAndDeactivate()->toOneMany())->cast(@FunctionDefinition<Any>)
            ),
            second = $vars
          );
        },
        {|
          let expression  = $vs->cast(@FunctionExpression).parametersValues->evaluateAndDeactivate()->at(1);
                                                                              let varExprs = $vs->findVariableExpressionsInValueSpecification();
                                                                              let inScopeVars = $a.second->keyValues();

                                                                              let unavailableVars = $varExprs.name->removeAllOptimized($inScopeVars.first);
                                                                              assert($unavailableVars->isEmpty(),'Unable to resolve var(s): '+$unavailableVars->joinStrings());

                                                                              let unResolvedVars = $varExprs->filter(v|let resolved = $a.second->get($v.name); $resolved->isEmpty() || $resolved.values->isEmpty() || $resolved.values->at(0)->instanceOf(RoutedVariablePlaceHolder););
          if($unResolvedVars->isNotEmpty(),
            {|
              let unRoutedFunction = ^$l(expressionSequence = $vs);
                                                                                                                           let vars = $a.second->put($varName->toOne(), ^List<RoutedVariablePlaceHolder>(values=^RoutedVariablePlaceHolder(name=$varName->toOne())));
                                                                                                                           let temp = $unRoutedFunction->toOne();
                                                                                                                           ^$a(first=^RoutingResult(functions=^$temp(expressionSequence = $a.first.functions.expressionSequence->concatenate($temp.expressionSequence)->evaluateAndDeactivate()->toOneMany())->cast(@FunctionDefinition<Any>)), second=$vars);
            },
            {|
              let re = $vs->reactivate($a.second);
                                                                                                                           let vars = $a.second->put($varName->toOne(), ^List<Any>(values=$re));
                                                                                                                           ^$a(first=$a.first, second = $vars);
            }
          );
        }
      );
    },
    pair(^RoutingResult(), $f->openVariableValues())
  );

  let vs      = $expressions->last()->toOne();
  let varName = $vs->meta::pure::router::extractLetVariableName();
  let vars    = if($varName->isNotEmpty(),
                       | $initStatements.second->put($varName->toOne(), ^List<RoutedVariablePlaceHolder>(values=^RoutedVariablePlaceHolder(name=$varName->toOne()))),
                       | $initStatements.second
                                                                                                                         );
   let newF   = ^$l(
                  expressionSequence    = $vs,
                  openVariables         = $vars->keys(),
                  classifierGenericType = ^GenericType(rawType=LambdaFunction, typeArguments=^GenericType(rawType=$f->functionType()))
                                                                     );
   let routed = routeFunction($newF, ^Mapping(name = ''), ^meta::pure::runtime::Runtime(), $exeCtx, $vars, $extensions, $debug);
   let temp   = $routed.functions->toOne();
   ^RoutingResult(
     functions       = ^$temp(expressionSequence = $initStatements.first.functions.expressionSequence->concatenate($temp.expressionSequence)->evaluateAndDeactivate()->toOneMany())->cast(@FunctionDefinition<Any>)
   );
}


function meta::pure::router::routeFunction(f:FunctionDefinition<Any>[1], mapping:Mapping[1], runtime:Runtime[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):RoutingResult[1]
{
   routeFunction($f, $mapping, $runtime, ^ExecutionContext(), $extensions, $debug);
}

function meta::pure::router::routeFunction(f:FunctionDefinition<Any>[1], mapping:Mapping[1], runtime:Runtime[1], exeCtx: ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):RoutingResult[1]
{
   routeFunction($f, $mapping, $runtime, $exeCtx, [], $extensions, $debug)
}

function meta::pure::router::routeFunction(f:FunctionDefinition<Any>[1], mapping:Mapping[1], runtime:Runtime[1], exeCtx: ExecutionContext[1], inScopeVars:Map<String, List<Any>>[0..1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):RoutingResult[1]
{
   let expectedFuncParamSize = 0;
   //assertEquals($expectedFuncParamSize, $f->functionType().parameters->size(), 'Error'+$f->functionType().parameters->size()->toString());

   let fOpenVariables = $f->openVariableValues();
   let openVariables = if($inScopeVars->isNotEmpty(),| assert($fOpenVariables->keys()->intersection($inScopeVars)->isEmpty(),'Routing : unable to determine open variables for FunctionDefinition, suplied inScopeVars and FunctionDefinitionOpenVariables intersect');
                                                       $fOpenVariables->putAll($inScopeVars->toOne()->keyValues());
                                                    ,| $fOpenVariables);
   
   // Mapping allocation
   print(if($debug.debug,|$debug.space+'Processing Mappings:\n',|''));
   let processedCollection = processCollection( ^RoutingState(shouldBeRouted=false, lambdaContext=[], counter=0, depth='', isParentMap=false, propertyMap = ^PropertyMap(), setsByDepth=^Map<String, PermutationSet>(), classMappingsByClass=$mapping->buildClassMappingsByClassMap()),
                                                $f.expressionSequence->evaluateAndDeactivate(),
                                                $mapping,
                                                $runtime,
                                                $exeCtx,
                                                newMap([]->cast(@Pair<VariableExpression, ValueSpecification>), VariableExpression->classPropertyByName('name')->cast(@Property<VariableExpression,String|1>)),
                                                $openVariables,
                                                v:Any[1]|true,
                                                $extensions,
                                                $debug
                                              )->evaluateAndDeactivate();

   if (!$processedCollection->last().sets->isEmpty(),
      |
      // Sets
      print(if($debug.debug,|'\n'+$debug.space+'Sets found:\n', |''));
      print(if($debug.debug,|$processedCollection->last().sets->map(s|$debug.space+'   ['+$s.id->toString()+'|'+$s.sets->map(si|$si.id)->joinStrings(',')+']')->joinStrings('\n')+'\n',|''));
       
      // Permutation
      print(if($debug.debug,|'\n'+$debug.space+'Process Permutations ('+$processedCollection->last().sets.id->size()->toString()+')\n', |''));
      let permutations = $processedCollection->last().sets->permute();
      print(if($debug.debug,|$permutations->map(l|$l.values->map(p|$debug.space + '   ['+$p.id->toString()+'|'+$p.sets->toOne().id->toString()+']')->makeString(', '))->makeString('\n')+'\n', |''));
      
      // Build
      print(if($debug.debug,|'\n'+$debug.space+'Building new queries\n', |''));
      let built = $permutations->map(p|print(if($debug.debug,|'  Query '+$permutations->indexOf($p)->toString()+'\n', |''));
                                               ^List<ValueSpecification>(values = $processedCollection.value->cast(@ValueSpecification)->evaluateAndDeactivate()->map(k|$k->build($p, [], $mapping, $exeCtx, $extensions, $debug))); 
                                    );
      
      print(if($debug.debug,|'\n'+$debug.space+'Built queries:'+$built->size()->toString()+'\n', |''));

      print(if($debug.debug,|$built->map(b|$debug.space+'   - '+$b.values->at(0)->asString())->makeString('\n')+'\n',|''));

      let filteredBuilt = $built->filter(v|!$v.values->at(0)->instanceOf(Void));

      print(if($debug.debug,|'\n'+$debug.space+'Filtered Built queries:'+$filteredBuilt->size()->toString()+'\n', |''));

      let nbuilt = if ($permutations->size() > 1,
         |// Which concatenation to use (dataType/TDS = union all / type = union)?
          let returnType = $filteredBuilt.values->at(0)->match([e:StoreMappingRoutedValueSpecification[1]|$e.value.genericType, v:ValueSpecification[1]|$v.genericType]);
          let concatenate = $returnType.rawType->toOne()->instanceOf(DataType) || $returnType.rawType->toOne()->_subTypeOf(TabularDataSet);
          let concat = buildConcatenate($filteredBuilt.values, $concatenate, $returnType);
          let wrappedConcatToRemove = []->concatenate(^List<ValueSpecification>(values=$concat)->evaluateAndDeactivate()); // usage of concatenate is a trick for 'compiled' to work
          print(if($debug.debug,|$debug.space+'Result: '+$wrappedConcatToRemove.values->at(0)->asString()+'\n',|''));
          $wrappedConcatToRemove;,
         |$filteredBuilt
         );

      ^RoutingResult
      (
         functions = $nbuilt->doCluster($f, $mapping, $runtime, $exeCtx, $extensions, $debug)
      );
      ,
      |^RoutingResult
      (
         functions = ^List<ValueSpecification>(values=$processedCollection.value->cast(@ValueSpecification))->doCluster($f, $mapping, $runtime, $exeCtx, $extensions, $debug)
      );
   );

}

function meta::pure::router::permute(var:PermutationSet[*]):List<PermutationSet>[*]
{
   let l = $var->map(p|^List<PermutationSet>(values=$p.sets->removeDuplicates({a,b|$a.id == $b.id})->map(v|^$p(sets=$v))));
   let seed = $l->head().values->map(o|^List<PermutationSet>(values=$o));
   $l->tail()->fold({v,a|$a->combine($v.values)}, $seed);
}

function meta::pure::router::combine(first:List<PermutationSet>[*], second:PermutationSet[*]):List<PermutationSet>[*]
{
   $first->map(f|$second->map(s|^$f(values+=$s)));
}

function meta::pure::functions::collection::unionLambdas(vs:ValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1]):ValueSpecification[1]
{
   let first = $vs->at(0);
   $first->match
   (
      [
         i:InstanceValue[1]|let size = $i.values->size();
                            ^$i
                            (
                              values = range(0, $size, 1)->map(i|$vs->cast(@InstanceValue)->map(v|$v.values->at($i))->cast(@FunctionRoutedValueSpecification)->unionL($concatenate, $genericType))
                            );,
         e:StoreMappingRoutedValueSpecification[1]|$vs->cast(@StoreMappingRoutedValueSpecification).value->cast(@FunctionRoutedValueSpecification)->unionL($concatenate, $genericType),
         f:FunctionRoutedValueSpecification[1]|$vs->cast(@FunctionRoutedValueSpecification)->unionL($concatenate, $genericType)
      ]
   );
}

function meta::pure::functions::collection::unionL(vs:FunctionRoutedValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1]):ValueSpecification[1]
{
   let fr = $vs->at(0);
   let i = $fr.value->cast(@InstanceValue);
   let l = $i.values->at(0)->cast(@LambdaFunction<Any>);
   let res = $vs.value->cast(@InstanceValue).values->cast(@LambdaFunction<Any>).expressionSequence->map(e|pair($e->asString(), $e))->removeDuplicates({a,b|$a.first == $b.first});
   ^$fr(value=^$i(values=^$l(expressionSequence=doUnion($res.second, $concatenate, $l.expressionSequence->toOne().genericType))));
}

function meta::pure::functions::collection::doUnion(v:ValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1]):ValueSpecification[1]
{
   $v->tail()->fold({a,b|
                          ^SimpleFunctionExpression(func=if($concatenate,|concatenate_T_MANY__T_MANY__T_MANY_,|union_T_MANY__T_MANY__T_MANY_),
                                                    functionName=if($concatenate,|'concatenate',|'union'),
                                                    genericType = $genericType,
                                                    multiplicity = ZeroMany,
                                                    importGroup = system::imports::coreImport,
                                                    resolvedTypeParameters = ^GenericType(rawType=Any),
                                                    parametersValues = [ $b, $a ]->evaluateAndDeactivate()
                                                   )->evaluateAndDeactivate();
                        },$v->head()->toOne())
}

function meta::pure::functions::collection::buildConcatenate(v:ValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1], dispatch:Pair<Function<{FunctionExpression[1]->Boolean[1]}>, Function<{FunctionExpression[*], Boolean[1], GenericType[1]->ValueSpecification[1]}>>[*]):ValueSpecification[1]
{
  if ($v->size() > 1,
      |let funcExprs = $v->map(k|$k->match([f:FunctionExpression[1]|$f, e:StoreMappingRoutedValueSpecification[1]|$e.value->cast(@FunctionExpression)]));
       let funcs = $funcExprs.func->removeDuplicates();
       if ($funcs->size() == 1,| let dispatchProcessing = $dispatch->filter(d|$d.first->eval($funcExprs->at(0)));
                                 if($dispatchProcessing->isNotEmpty(),|$dispatchProcessing->toOne().second->eval($funcExprs, $concatenate, $genericType)
                                                                     ,|$v->doUnion($concatenate, $genericType));
                              ,| $v->doUnion($concatenate, $genericType));,
      |$v->toOne();
     );
}

function meta::pure::functions::collection::buildConcatenate(v:ValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1]):ValueSpecification[1]
{
   let dispatch =
   [
      pair(f:FunctionExpression[1]|$f.func == groupBy_TabularDataSet_1__String_MANY__AggregateValue_MANY__TabularDataSet_1_->cast(@Function<Any>),
          {funcExprs:FunctionExpression[*], concatenate:Boolean[1], genericType:GenericType[1] |
                 let leftSide = $funcExprs->map(f|$f.parametersValues->at(0));
                 let res = $leftSide->buildConcatenate($concatenate, $genericType);
                 let first = $funcExprs->at(0);
                 ^$first
                 (
                   parametersValues = $res->concatenate($first.parametersValues->tail())
                 );
         }
     ),
     pair(f:FunctionExpression[1]|$f.func == project_K_MANY__Function_MANY__String_MANY__TabularDataSet_1_->cast(@Function<Any>),
          {funcExprs:FunctionExpression[*], concatenate:Boolean[1], genericType:GenericType[1] |
                 let leftSide = $funcExprs->map(f|$f.parametersValues->at(0))->cast(@StoreMappingRoutedValueSpecification);
                 if ($leftSide.sets.id->removeDuplicates()->size() == 1,
                     | let first = $funcExprs->at(0);
                       // reprocess Lambdas
                       let right = $funcExprs->map(f|$f.parametersValues->at(1)->evaluateAndDeactivate());
                       let reprocessed = unionLambdas($right, $concatenate, $genericType);
                       // done
                       ^$first
                       (
                         parametersValues = $first.parametersValues->at(0)->concatenate($reprocessed)->concatenate($first.parametersValues->at(2))
                       );,
                     | doUnion($funcExprs, $concatenate, $genericType);
                 );
         }
     ),
     pair(f:FunctionExpression[1]|$f->isSerializeOnGraphFetch(),
          {funcExprs:FunctionExpression[*], concatenate:Boolean[1], genericType:GenericType[1] |
                let concatInputs = $funcExprs->map(v|$v->cast(@FunctionExpression).parametersValues->at(0));
                let graphFetchInputType = $concatInputs->at(0)->byPassRouterInfo()->cast(@FunctionExpression).parametersValues->at(0)->match([e:StoreMappingRoutedValueSpecification[1]|$e.value.genericType, v:ValueSpecification[1]|$v.genericType]);
                let concatenateOverride = $graphFetchInputType.rawType->toOne()->instanceOf(DataType) || $graphFetchInputType.rawType->toOne()->_subTypeOf(TabularDataSet);
                let concat = $concatInputs->doUnion($concatenateOverride, $genericType);
                let serialize = $funcExprs->at(0)->cast(@FunctionExpression);
                ^$serialize(parametersValues=$concat->concatenate($serialize.parametersValues->evaluateAndDeactivate()->tail()));
          })
   ];

   $v->buildConcatenate($concatenate, $genericType, $dispatch);

}