// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::router::metamodel::*;
import meta::pure::router::clustering::*;
import meta::pure::router::externalFormat::routing::*;
import meta::pure::router::routing::*;
import meta::pure::runtime::*;

function meta::pure::router::externalFormat::routing::getExternalFormatRoutingStrategy(binding:meta::external::shared::format::binding::Binding[1]):ExternalFormatRoutingStrategy[1]
{
  ^ExternalFormatRoutingStrategy(binding         = $binding,
                                 processClass    = meta::pure::router::externalFormat::routing::processClass_Class_1__InstanceValue_1__RoutingState_1__ExecutionContext_1__DebugContext_1__RoutingState_1_,
                                 processProperty = meta::pure::router::externalFormat::routing::processProperty_Property_1__FunctionExpression_1__RoutingState_1__ExecutionContext_1__Map_1__Map_1__Extension_MANY__DebugContext_1__RoutingState_1_,
                                 wrapValueSpec   = meta::pure::router::externalFormat::routing::wrapValueSpecification_ValueSpecification_1__RoutingStrategy_1__String_1__ExecutionContext_1__Extension_MANY__DebugContext_1__ExtendedRoutedValueSpecification_1_);
}

function <<access.private>> meta::pure::router::externalFormat::routing::processClass(c:Class<Any>[1], i:InstanceValue[1], state:RoutingState[1], executionContext:ExecutionContext[1], debug:DebugContext[1]):RoutingState[1]
{
   print(if($debug.debug,|$debug.space+'~>C) (ExternalFormatRoutingStrategy) '+$state.value->toOne()->toString()+'\n',|''));
   $state;
}

function <<access.private>> meta::pure::router::externalFormat::routing::processProperty(p:Property<Nil,Any|*>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):RoutingState[1]
{
   fail('Property processing not supported by ExternalFormatRoutingStrategy!!');
   $state;
}

function <<access.private>> meta::pure::router::externalFormat::routing::wrapValueSpecification(value:ValueSpecification[1], routingStrategy:RoutingStrategy[1], id:String[1], executionContext:ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):ExtendedRoutedValueSpecification[1]
{
   fail('Wrapping Value Specification not supported by ExternalFormatRoutingStrategy!!');
   @ExternalFormatRoutedValueSpecification;
}

// ===================================================================================
// Special Functions
// ===================================================================================

function meta::pure::router::externalFormat::routing::specializedFunctionExpressionRouterProcessorForExternalFormat():Pair<Function<{FunctionExpression[1]->Boolean[1]}>, Function<{Function<Any>[1], FunctionExpression[1], RoutingState[1], ExecutionContext[1], Map<VariableExpression, ValueSpecification>[1], Map<String, List<Any>>[1], meta::pure::extension::Extension[*], DebugContext[1]->RoutingState[1]}>>[*]
{
  [
    pair(fe:FunctionExpression[1] | $fe.func->in(meta::external::shared::format::functions::externalizeFunctions()),
        {f:Function<Any>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |
            let processedFirstParam  = processCollection($state, $fe.parametersValues->at(0), $executionContext, $vars, $inScopeVars, {x:Any[1] | true}, $extensions, $debug)->toOne();
            let processedExternalize = ^$fe(parametersValues = $processedFirstParam.value->cast(@ValueSpecification)->concatenate($fe.parametersValues->tail()));
            let binding              = $fe.parametersValues->at(1)->cast(@InstanceValue).values->at(0)->cast(@meta::external::shared::format::binding::Binding);
            let routedExternalize    = ^ExternalFormatRoutedValueSpecification
                                        (
                                          multiplicity    = $f->functionReturnMultiplicity(),
                                          genericType     = $f->functionReturnType(),
                                          executionContext= $executionContext,
                                          id              = $fe->id(),
                                          routingStrategy = getExternalFormatRoutingStrategy($binding),
                                          binding         = $binding,
                                          value           = $processedExternalize
                                        );
            ^$processedFirstParam(value = $routedExternalize);
        }
    ),
    pair(fe:FunctionExpression[1] | $fe.func->in(meta::external::shared::format::functions::internalizeFunctions()),
        {f:Function<Any>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |
            let binding              = $fe.parametersValues->at(1)->cast(@InstanceValue).values->at(0)->cast(@meta::external::shared::format::binding::Binding);
            let processedFirstParam  = processCollection(^$state(routingStrategy = getExternalFormatRoutingStrategy($binding)), $fe.parametersValues->at(0), $executionContext, $vars, $inScopeVars, {x:Any[1] | true}, $extensions, $debug)->toOne();
            let processedExternalize = ^$fe(parametersValues = $processedFirstParam.value->cast(@ValueSpecification)->concatenate($fe.parametersValues->tail()));
            let routedExternalize    = ^ExternalFormatRoutedValueSpecification
                                        (
                                          multiplicity    = $f->functionReturnMultiplicity(),
                                          genericType     = $f->functionReturnType(),
                                          executionContext= $executionContext,
                                          id              = $fe->id(),
                                          routingStrategy = getExternalFormatRoutingStrategy($binding),
                                          binding         = $binding,
                                          value           = $processedExternalize
                                        );
            ^$processedFirstParam(routingStrategy = $state.routingStrategy,
                                  value           = $routedExternalize);
        }
    )
  ]
}

function meta::pure::router::externalFormat::clustering::cluster(v:ValueSpecification[1], openVariables:Map<String, List<Any>>[1], exeCtx:ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):ValueSpecification[*]
{
   $v->match([f:FunctionExpression[1]              | ^$f(parametersValues = $f.parametersValues->evaluateAndDeactivate()->map(v|$v->meta::pure::router::externalFormat::clustering::cluster($openVariables, $exeCtx, $extensions, $debug))),   // TODO: check this to have logic to check if child clusters are compatible and can be used
              i:InstanceValue[1]                   | $i,
               // i:InstanceValue[1]                   | if ($i->isOneFunctionDefinition(),
              //                           | let f = $i.values->at(0)->cast(@FunctionDefinition<Any>)->evaluateAndDeactivate();
              //                             let clusterResponses = $f.expressionSequence->evaluateAndDeactivate()->map(v|print(if($debug.debug,|'\n'+$v->asString()->debug($debug.space+'Processing: '),|''));
              //                                                                                                          $v->cluster($mapping, $openVariables, $exeCtx, $depth+1,^$debug(space = $debug.space+'  '), $analyticsDecision, $extensions););
              //                             let expressions      = $clusterResponses.cluster;
              //                             let unique           = $expressions->filter(p|$p->instanceOf(StoreMappingClusteredValueSpecification))->cast(@StoreMappingClusteredValueSpecification)->removeDuplicatesBy(a | $a.store);
              //                             if($unique->size() == 0,
              //                                | ^ClusterResponse(cluster=^$i(values=^$f(expressionSequence = $expressions->toOneMany())),letFunctions = $clusterResponses.letFunctions, executableSetOperations= $clusterResponses.executableSetOperations),
              //                                | if($unique->size() == 1,
              //                                     | let one = $unique->toOne();
              //                                       print(if($debug.debug, |$i->evaluateAndDeactivate()->asString()->debug($debug.space+'Func: '),|''));
              //                                       let res = ^$one(
              //                                                   genericType  = $i.genericType,
              //                                                   multiplicity = $i.multiplicity,
              //                                                   val = ^$i(values=^$f(expressionSequence = $expressions->evaluateAndDeactivate()->map(p|$p->match([c:StoreMappingClusteredValueSpecification[1]|$c.val;, a:ValueSpecification[1]|$a]))->toOneMany()))
              //                                                 );
              //                                       print(if($debug.debug, |$res->evaluateAndDeactivate()->asString()->debug($debug.space+'~> '),|''));
              //                                       ^ClusterResponse(cluster=$res, letFunctions = $clusterResponses.letFunctions, executableSetOperations= $clusterResponses.executableSetOperations);,
              //                                     | print(if($debug.debug, |$i->evaluateAndDeactivate()->asString()->debug($debug.space+'Func: '), |''));
              //                                       let k = ^PlatformClusteredValueSpecification(
              //                                                   genericType = $i.genericType,
              //                                                   multiplicity = $i.multiplicity,
              //                                                   val = ^$i(values=^$f(expressionSequence = $expressions->toOneMany())),
              //                                                   openVars = $openVariables,
              //                                                   exeCtx = $exeCtx,
              //                                                   executable = true
              //                                               );
              //                                       print(if($debug.debug, |$k->evaluateAndDeactivate()->asString()->debug($debug.space+'~> '),|''));
              //                                       ^ClusterResponse(cluster= $k, letFunctions = $clusterResponses.letFunctions, executableSetOperations= $clusterResponses.executableSetOperations);
              //                                  )
              //                               );,
              //                           | print(if($debug.debug,|$i->asString()->debug($debug.space+'Constant: '),|''));
              //                             let potentialClusterResponses = $i.values->evaluateAndDeactivate()->map(m|if($m->instanceOf(ValueSpecification),
              //                                                                                                          | $m->cast(@ValueSpecification)->cluster($mapping, $openVariables, $exeCtx, $depth+1, ^$debug(space = $debug.space+'  '), $analyticsDecision, $extensions),
              //                                                                                                          | $m->match([
              //                                                                                                               g : meta::pure::graphFetch::routing::RoutedGraphFetchTree[1] | $g->meta::pure::graphFetch::routing::clusterRoutedGraphFetchTree([], $mapping, [], $openVariables, $exeCtx, $extensions, $debug),
              //                                                                                                               a : Any[1] | $a
              //                                                                                                            ])));
              //                             let values       = $potentialClusterResponses->map(r|if($r->instanceOf(ClusterResponse),| $r->cast(@ClusterResponse).cluster,|$r));
              //                             let letFunctions = $potentialClusterResponses->map(r|if($r->instanceOf(ClusterResponse),| $r->cast(@ClusterResponse).letFunctions,|[]));
              //                             let executables  = $potentialClusterResponses->map(r|if($r->instanceOf(ClusterResponse),| $r->cast(@ClusterResponse).executableSetOperations,|[]));

              //                             let unique       = $values->filter(p|$p->instanceOf(StoreMappingClusteredValueSpecification))->cast(@StoreMappingClusteredValueSpecification)->removeDuplicatesBy(a | $a.store->elementToPath());
              //                             let res          = if($unique->size() == 1,
              //                                                   | let one = $unique->toOne();
              //                                                     ^$one(
              //                                                       genericType = $i.genericType,
              //                                                       multiplicity = $i.multiplicity,
              //                                                       val = ^$i(values = $values->evaluateAndDeactivate()->map(p|$p->match([c:StoreMappingClusteredValueSpecification[1]|$c.val;, a:Any[1]|$a])))
              //                                                     );,
              //                                                   | ^$i(values = $values);
              //                                                );
              //                             print(if($debug.debug,|$res->asString()->debug($debug.space+'~> '),|''));
              //                             ^ClusterResponse(cluster=$res, letFunctions = $letFunctions, executableSetOperations=$executables);
              //                     );,
               v:VariableExpression[1]               | $v,
               p:ExternalFormatRoutedValueSpecification[1] | ^meta::pure::router::clustering::ExternalFormatClusteredValueSpecification(
                                                          genericType  = $p.genericType,
                                                          multiplicity = $p.multiplicity,
                                                          openVars = $openVariables,
                                                          exeCtx = $exeCtx,
                                                          binding = $p.binding,
                                                          val = $p.value->meta::pure::router::externalFormat::clustering::cluster($openVariables, $exeCtx, $extensions, $debug)->toOne(),
                                                          executable = true
                                                        ),
               e:ExtendedRoutedValueSpecification[1] | $e->clusterFunctionExpressions($openVariables, $exeCtx, $extensions, $debug),
               c:ClusteredValueSpecification[1]      | $c 
      ]
   );
}