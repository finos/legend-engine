// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::*;
import meta::pure::router::builder::*;
import meta::pure::router::metamodel::*;
import meta::pure::router::operations::*;
import meta::pure::router::printer::*;
import meta::pure::router::routing::*;
import meta::pure::runtime::*;

function meta::pure::router::routing::getRoutingStrategyFromMappingAndRuntime(mapping:Mapping[1], runtime:Runtime[1]):StoreMappingRoutingStrategy[1]
{
  ^StoreMappingRoutingStrategy(mapping = $mapping, 
                               runtime = $runtime, 
                               isParentMap = false, 
                               setsByDepth = ^Map<String, PermutationSet>(), 
                               classMappingsByClass = $mapping->buildClassMappingsByClassMap(),
                               processClass = processClass_Class_1__InstanceValue_1__RoutingState_1__ExecutionContext_1__DebugContext_1__RoutingState_1_,
                               processProperty = routeFunctionExpressionProperty_Property_1__FunctionExpression_1__RoutingState_1__ExecutionContext_1__Map_1__Map_1__Extension_MANY__DebugContext_1__RoutingState_1_,
                               wrapValueSpec = wrapValueSpecification_ValueSpecification_1__RoutingStrategy_1__String_1__ExecutionContext_1__Extension_MANY__DebugContext_1__ExtendedRoutedValueSpecification_1_);
}

function <<access.private>> meta::pure::router::routing::processClass(c:Class<Any>[1], i:InstanceValue[1], s:RoutingState[1], executionContext:ExecutionContext[1], debug:DebugContext[1]):RoutingState[1]
{
   let strategy     = $s.routingStrategy->cast(@StoreMappingRoutingStrategy);
   let mapping      = $strategy.mapping;
   let runtime      = $strategy.runtime;
   
   let state        = ^$s(depth = $s.depth + $c->varToString());
   let classMapping = if($strategy.toChooseSet->isEmpty(), |$mapping.rootClassMappingByClass($c)->potentiallyResolveOperation($mapping), |$strategy.toChooseSet);
   // Possible when the mapping is 'embedded'
   if ($classMapping->isEmpty(),
      | print(if($debug.debug,|$debug.space+'~>C) ('+$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$state.value->toOne()->toString()+'\n',|''));
        $state;,
      | let existingSet = $state->findExistingPemutationSet($debug);
        let existingSetCanBeUsed = $existingSet->permutationSetOnlyHasImplementation($classMapping);
        let newID = if($existingSetCanBeUsed,
                      | $existingSet->toOne().id->cast(@Integer),
                      | $state.counter+1
                    )->toString();
        let newSet = if (!$existingSetCanBeUsed,|^PermutationSet(id = $state.counter+1, sets = $classMapping),|[]);
        let currentRoutingStrategy = $state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne();
        let updatedRoutingStrategy = ^$currentRoutingStrategy(setsByDepth = if (!$existingSetCanBeUsed,
                                                                                    |let setByD = $state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne().setsByDepth;  // TODO: check this remove ->toOne()
                                                                                     $setByD->put(getSetPath($state), $newSet->toOne());,
                                                                                    |$state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne().setsByDepth       // TODO: check this remove ->toOne()
                                                                                ),
                                                                  sets = if (!$existingSetCanBeUsed,|$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->add($newSet->toOne()),|$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets));
        let routed = ^StoreMappingRoutedValueSpecification(genericType = $i.genericType,
                                                           multiplicity = $i.multiplicity,
                                                           id = $newID,
                                                           sets = $classMapping,
                                                           runtime = $runtime,
                                                           mapping = $mapping,
                                                           executionContext = $executionContext,
                                                           value = $i,
                                                           routingStrategy = $updatedRoutingStrategy);
        let res = ^$state(
                       counter = if (!$existingSetCanBeUsed,|$state.counter+1,|$state.counter),
                       routingStrategy = $updatedRoutingStrategy,
                       value = $routed
                  );
        print(if($debug.debug,|$debug.space+'~>C) ('+$res.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$routed->evaluateAndDeactivate()->asString()+'\n',|''));
        $res;
    );
}

function meta::pure::router::routing::routeFunctionExpressionProperty(p:Property<Nil,Any|*>[1], fe:FunctionExpression[1], v:RoutingState[1], executionContext:ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):RoutingState[1]
{
   let mapping = $v.routingStrategy->cast(@StoreMappingRoutingStrategy).mapping;
   let runtime = $v.routingStrategy->cast(@StoreMappingRoutingStrategy).runtime;

   let results = $v->processCollection($fe.parametersValues->evaluateAndDeactivate(), $executionContext, $vars, $inScopeVars, v:Any[1]|true, $extensions, $debug)->evaluateAndDeactivate();
   let newPV   = $results.value->cast(@ValueSpecification)->toOneMany();
   let preLast = $results->last()->toOne();

   let res = if($results.value->size() == 1 && $results.value->toOne()->instanceOf(InstanceValue),
                | let val  = $results.value->toOne()->cast(@InstanceValue).values->map(v | $p->eval($v));
                  let iv   = ^InstanceValue(genericType = $p->functionReturnType(),multiplicity = $p.multiplicity, values = $val);
                  let last = ^$preLast(depth = $preLast.depth + $p.name->toOne());
                  ^$last(value = $iv);,
                | if (!$v.shouldBeRouted,
                      | ^$preLast(value=^NoSetRoutedValueSpecification(genericType = $fe.genericType, multiplicity = $fe.multiplicity, value=^$fe(parametersValues = $results.value->cast(@ValueSpecification)->toOneMany())))->evaluateAndDeactivate();,
                      | let last = ^$preLast(depth = $preLast.depth + $p.name->toOne());

                        print(if($debug.debug,|$debug.space+$fe->asString()+'\n',|''));
                        let targetType = $p.classifierGenericType.typeArguments->at(1).rawType->toOne();
                        if($targetType->instanceOf(DataType),
                           |let sourceClass = $fe.parametersValues->at(0).genericType.rawType->toOne();

                            let subTypes = $sourceClass->cast(@Class<Any>)->getMappedLeafClasses($mapping, $v);
                            let classes = if ($subTypes->isEmpty(), | $sourceClass, | $subTypes);

                            let classMappings = $classes->map( c | $v.routingStrategy->cast(@StoreMappingRoutingStrategy).classMappingsForClass($c->cast(@Class<Any>)));

                            let classMapping = if ($classMappings->isEmpty() && !$subTypes->isEmpty(),
                                                      | //look for direct mapping of base class, as none of the sub types have mappings
                                                        //Ideally (per Pierre) these mappings should not be allowed
                                                          $v.routingStrategy->cast(@StoreMappingRoutingStrategy).classMappingsForClass($sourceClass->cast(@Class<Any>)),
                                                      | $classMappings);

                            let resolvedClassMappings = if($classMapping->isNotEmpty(),
                                                            | $classMapping,
                                                            | $subTypes->map(s|$s->cast(@Class<Any>)->getClassMappings($v))->removeDuplicates());
                            assert($resolvedClassMappings != [], | 'The class \''+$sourceClass.name->toOne()+'\' can\'t be found in the mapping \''+$mapping.name->toOne()+'\'');
                            if ($resolvedClassMappings->isEmpty(),
                                |^$last(value=^$fe(parametersValues = $newPV));,
                                | let r = ^StoreMappingRoutedValueSpecification(
                                              genericType = $fe.genericType,
                                              multiplicity = $fe.multiplicity,
                                              id = $last.counter->toString(),
                                              sets = $resolvedClassMappings,
                                              runtime = $runtime,
                                              mapping = $mapping,
                                              executionContext = $executionContext,
                                              value = ^$fe(parametersValues = $newPV),
                                              routingStrategy = $last.routingStrategy
                                          );
                                  ^$last(value= $r);
                            );,
                          | let propId = $v.lambdaContext->toOne()+$fe->propToString($vars, $inScopeVars);
                            let found = $v.propertyMap.v->filter(p|$p.first == $propId);
                            if (!$found->isEmpty(),
                                | let routed = $found.second->toOne();
                                  ^$last(
                                    value= $routed
                                  );,
                                | let foundSets = $p->findMappingsFromProperty($mapping, $last.value->match([v:StoreMappingRoutedValueSpecification[1]|$v.sets, a:Any[1]|[]->cast(@SetImplementation)]), $v, $extensions);//is this for embedded?
                                  if ($foundSets->isEmpty(),
                                    |^$last(value=^$fe(parametersValues = $newPV)),
                                    | // Can't assert because of embedded
                                      //assert(!$foundSets->isEmpty(), $targetType.name+' :(');
                                      
                                      let existingSet = $last->findExistingPemutationSet($debug);
                                      let existingSetCanBeUsed  = $existingSet->permutationSetOnlyHasImplementation($foundSets);
                                      let newID = if($existingSetCanBeUsed,
                                                  |$existingSet->toOne().id,
                                                  |$last.counter+1
                                                  )->toString();
    
                                      let oldPropertyMap = $last.propertyMap->toOne();
                                      let newSet = if (!$existingSetCanBeUsed,|^PermutationSet(id = $last.counter+1, sets = $foundSets),|[]);

                                      let currentRoutingStrategy = $last.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne();
                                      let updatedRoutingStrategy = ^$currentRoutingStrategy(setsByDepth = if (!$existingSetCanBeUsed,|let setByD = $last.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne().setsByDepth;$setByD->put(getSetPath($last), $newSet->toOne());,|$last.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne().setsByDepth),  // TODO: check this remove ->toOne() 
                                                                                            sets        = if (!$existingSetCanBeUsed,|$last.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->add($newSet->toOne()),|$last.routingStrategy->cast(@StoreMappingRoutingStrategy).sets));

                                      let added = ^StoreMappingRoutedValueSpecification(
                                                        genericType = $fe.genericType,
                                                        multiplicity = $fe.multiplicity,
                                                        id = $newID,
                                                        sets = $foundSets,
                                                        runtime = $runtime,
                                                        mapping = $mapping,
                                                        executionContext = $executionContext,
                                                        value = ^$fe(parametersValues = $newPV),
                                                        routingStrategy = $updatedRoutingStrategy
                                                    );
                                      ^$last(
                                          counter = if (!$existingSetCanBeUsed,|$last.counter+1,|$last.counter),
                                          routingStrategy = $updatedRoutingStrategy, 
                                          propertyMap = ^$oldPropertyMap(v += pair($propId, $added->cast(@Any))),  
                                          value= $added
                                      );
                                  );
                            );
                        );
                   ));
   print(if($debug.debug,|$debug.space+'~>FEP) ('+$res.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$res.value->toOne()->cast(@ValueSpecification)->asString()+'\n',|''));
   $res;
}

function meta::pure::router::routing::wrapValueSpecification(value:ValueSpecification[1], routingStrategy:RoutingStrategy[1], id:String[1], executionContext:ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):ExtendedRoutedValueSpecification[1]
{
   let strategy = $routingStrategy->cast(@StoreMappingRoutingStrategy);

   ^StoreMappingRoutedValueSpecification
   (
      genericType = $value.genericType,
      multiplicity = $value.multiplicity,
      id = $id,
      runtime = $strategy.runtime,
      mapping = $strategy.mapping,
      executionContext = $executionContext,
      value = $value,
      routingStrategy = $strategy
   );
}

function meta::pure::router::routing::enrichStoreMappingRoutedValueSpecification(routedVs: StoreMappingRoutedValueSpecification[1], exeCtx: ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):StoreMappingRoutedValueSpecification[1]
{
   let setsInScope = $routedVs.routingStrategy->cast(@StoreMappingRoutingStrategy).sets;
   let mapping     = $routedVs.mapping;
   let runtime     = $routedVs.runtime;
   
   if(!$setsInScope->isEmpty(),
     | 
      // Sets
      print(if($debug.debug,|'\n'+$debug.space+'Sets found:\n', |''));
      print(if($debug.debug,|$setsInScope->map(s|$debug.space+'   ['+$s.id->toString()+'|'+$s.sets->map(si|$si.id)->joinStrings(',')+']')->joinStrings('\n')+'\n',|''));
       
      // Permutation
      print(if($debug.debug,|'\n'+$debug.space+'Process Permutations ('+$setsInScope.id->size()->toString()+')\n', |''));
      let permutations = $setsInScope->permute();
      print(if($debug.debug,|$permutations->map(l|$l.values->map(p|$debug.space + '   ['+$p.id->toString()+'|'+$p.sets->toOne().id->toString()+']')->makeString(', '))->makeString('\n')+'\n', |''));
      
      // Build
      print(if($debug.debug,|'\n'+$debug.space+'Building new queries\n', |''));
      let built = $permutations->map(p|print(if($debug.debug,|'  Query '+$permutations->indexOf($p)->toString()+'\n', |''));
                                       $routedVs->evaluateAndDeactivate()->build($p, [], $mapping, $exeCtx, $extensions, $debug););
      
      print(if($debug.debug,|'\n'+$debug.space+'Built queries:'+$built->size()->toString()+'\n', |''));

      print(if($debug.debug,|$built->map(b|$debug.space+'   - '+$b->asString())->makeString('\n')+'\n',|''));

      let filteredBuilt = $built->filter(v|!$v->instanceOf(Void));

      print(if($debug.debug,|'\n'+$debug.space+'Filtered Built queries:'+$filteredBuilt->size()->toString()+'\n', |''));

      let nbuilt = if($permutations->size() > 1,
                     | // Which concatenation to use (dataType/TDS = union all / type = union)?
                      let returnType = $filteredBuilt->at(0)->match([e:StoreMappingRoutedValueSpecification[1]|$e.value.genericType, v:ValueSpecification[1]|$v.genericType]);
                      let concatenate = $returnType.rawType->toOne()->instanceOf(DataType) || $returnType.rawType->toOne()->_subTypeOf(TabularDataSet);
                      let concat = buildConcatenate($filteredBuilt, $concatenate, $returnType);
                      print(if($debug.debug,|$debug.space+'Result: '+$concat->asString()+'\n',|''));
                      $concat;,
                     |$filteredBuilt->toOne()
                   );
      $nbuilt->cast(@StoreMappingRoutedValueSpecification);,
     |$routedVs;            // This is needed for expressions (like let x = 1->from($mapping, $runtime)) where there are no sets
   );
}

// ===================================================================================
// Special Functions
// ===================================================================================

function meta::pure::router::routing::specializedFunctionExpressionRouterProcessorForStore(extensions:meta::pure::extension::Extension[*]):Pair<Function<{FunctionExpression[1]->Boolean[1]}>, Function<{Function<Any>[1], FunctionExpression[1], RoutingState[1], ExecutionContext[1], Map<VariableExpression, ValueSpecification>[1], Map<String, List<Any>>[1], meta::pure::extension::Extension[*], DebugContext[1]->RoutingState[1]}>>[*]
{
  [
    pair(fe:FunctionExpression[1] | $fe.func->in([meta::pure::mapping::from_TabularDataSet_1__Mapping_1__Runtime_1__TabularDataSet_1_, meta::pure::mapping::from_TabularDataSet_1__Mapping_1__Runtime_1__ExecutionContext_1__TabularDataSet_1_, meta::pure::mapping::from_T_m__Mapping_1__Runtime_1__T_m_]),
        {f:Function<Any>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |
                let resolvedParameters = $fe.parametersValues->tail()->map(p|$p->evaluateAndDeactivate()->match([v:VariableExpression[1] |let iv = meta::pure::functions::meta::resolve($v, $vars, $inScopeVars)->cast(@InstanceValue).values,
                                                                                                                 f:FunctionExpression[1] |let r = $f->reprocessRuntimeWithVariablePlaceHolder($inScopeVars).value->cast(@ValueSpecification);
                                                                                                                                          $r->reactivate($inScopeVars);,
                                                                                                                 i:InstanceValue[1]      |$i.values]));
                let fromMapping = $resolvedParameters->at(0)->cast(@Mapping);
                let fromRuntime = $resolvedParameters->at(1)->cast(@Runtime);
                let fromExecutionContext = if($resolvedParameters->size() == 3, | $resolvedParameters->at(2)->cast(@ExecutionContext), | $executionContext);

                let currentRoutingStrategy = $state.routingStrategy->cast(@StoreMappingRoutingStrategy);
                let newRoutingStrategy = ^$currentRoutingStrategy(mapping = $fromMapping, runtime = $fromRuntime, classMappingsByClass = $fromMapping->buildClassMappingsByClassMap(), setsByDepth = ^Map<String, PermutationSet>());
                let newState = ^$state(routingStrategy = $newRoutingStrategy);

                let processedFunction = routeFunctionExpressionFunctionDefinition($f, $fe, $newState, $fromExecutionContext, $vars, $inScopeVars, $extensions, $debug);
                let valueSpec         = $processedFunction.value;
                let wrappedValueSpec  = $valueSpec->match([
                                           evs: ExtendedRoutedValueSpecification[1] | $evs,
                                           vs: ValueSpecification[1]                | $processedFunction.routingStrategy.wrapValueSpec($vs, $valueSpec->cast(@ValueSpecification)->toOne()->id(), $executionContext, $extensions, $debug)
                                        ]);
                ^$processedFunction(value = $wrappedValueSpec);
        }
    )
  ]
}

Class meta::pure::router::routing::RuntimeProcessingState
{
   value:Any[1];
   vState:RuntimeProcessingVariableState[*];
}

Class meta::pure::router::routing::RuntimeProcessingVariableState
{
   v:VariableExpression[1];
   shouldReplace : Boolean[1];
   sourceType : Type[0..1];
}

function meta::pure::router::rebuildGenericType(g:GenericType[1], vState:RuntimeProcessingVariableState[*]):GenericType[1]
{
   let l = {t:Type[1]| if($vState.sourceType->contains($t),|RoutedVariablePlaceHolder,|$t)};

   ^$g(rawType=$l->eval($g.rawType), typeArguments=$g.typeArguments->map(a|$a->rebuildGenericType($vState)));
}

function meta::pure::router::replaceTypesWithVariablePlaceHolder(ve:VariableExpression[1], inScopeVars:Map<String, List<Any>>[1]):RuntimeProcessingState[1]
{
   let genericType = $ve.genericType;
   let shouldReplace = $inScopeVars->get($ve.name)->isNotEmpty() && $inScopeVars->get($ve.name).values->at(0)->instanceOf(RoutedVariablePlaceHolder);
   let updatedVe = if($shouldReplace,|^$ve(genericType=^$genericType(rawType=RoutedVariablePlaceHolder)),|$ve);
   ^RuntimeProcessingState(value=$updatedVe, vState=^RuntimeProcessingVariableState(v=$ve, shouldReplace=$shouldReplace, sourceType=$ve.genericType.rawType));
}

function meta::pure::router::replaceTypesWithVariablePlaceHolder(fe:FunctionExpression[1], reprocessedParameters:RuntimeProcessingState[*]):FunctionExpression[1]
{
   let updatedGenericType = $fe.genericType->toOne()->rebuildGenericType($reprocessedParameters.vState);
   let resolvedTypeParameters = range(0, $fe.resolvedTypeParameters->size())->zip($fe.resolvedTypeParameters);
   let updateResolvedTypeParameters = $resolvedTypeParameters->map(rtp| $rtp.second->rebuildGenericType($reprocessedParameters->at($rtp.first).vState));
   ^$fe(genericType=$updatedGenericType, resolvedTypeParameters=$updateResolvedTypeParameters);
}

function <<access.private>> meta::pure::router::routing::reprocessRuntimeWithVariablePlaceHolder(vs:ValueSpecification[1], inScopeVars:Map<String, List<Any>>[1]):RuntimeProcessingState[1]
{
   $vs->match([   fe:FunctionExpression[1] | let params = $fe.parametersValues->evaluateAndDeactivate()->map(v|$v->reprocessRuntimeWithVariablePlaceHolder($inScopeVars));
                                             let updatedFe = ^$fe(parametersValues= $params.value->cast(@ValueSpecification))->replaceTypesWithVariablePlaceHolder($params);
                                             ^RuntimeProcessingState(value=$updatedFe, vState=$params.vState);,
                        i:InstanceValue[1] | let values = $i.values->evaluateAndDeactivate()->map(v|$v->match([ e:ValueSpecification[1]| $e->reprocessRuntimeWithVariablePlaceHolder($inScopeVars),
                                                                                                           f:FunctionDefinition<Any>[1]| let expressions = $f.expressionSequence->map(e|$e->reprocessRuntimeWithVariablePlaceHolder($inScopeVars));
                                                                                                                                         ^RuntimeProcessingState(value= ^$f(expressionSequence = $expressions.value->cast(@ValueSpecification)), vState=$expressions.vState );,
                                                                                                                    k: KeyExpression[1]| let key = $k.key->reprocessRuntimeWithVariablePlaceHolder($inScopeVars)->cast(@RuntimeProcessingState).value->cast(@InstanceValue);
                                                                                                                                         let expression = $k.expression->reprocessRuntimeWithVariablePlaceHolder($inScopeVars);
                                                                                                                                         let nk = ^$k(key=$key, expression= $expression.value->cast(@ValueSpecification));
                                                                                                                                         ^RuntimeProcessingState(value=$nk, vState=$expression.vState );,
                                                                                                             a:Any[1]| ^RuntimeProcessingState(value=$a)]));
                                             ^RuntimeProcessingState(value=^$i(values = $values.value), vState=$values.vState);,
                   v:VariableExpression[1] | $v->replaceTypesWithVariablePlaceHolder($inScopeVars),
                 val:ValueSpecification[1] | ^RuntimeProcessingState(value=$val)
             ]);
}

// ===================================================================================
// Helper Functions
// ===================================================================================

function meta::pure::router::routing::getSetPath(state:RoutingState[1]):String[1]
{
   let setPath = $state.pathPrefix->makeString() + $state.depth
}

function meta::pure::router::routing::findExistingSet(state:RoutingState[1], debug:DebugContext[1]):Integer[0..1]
{
   let setPath = getSetPath($state);
   print(if($debug.debug,|$debug.space+'Looking for:"'+$setPath+'"',|''));
   let permutationSet = $state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne().setsByDepth->get($setPath);
   let res = if($permutationSet->isEmpty(),|[],|$permutationSet->toOne().id->cast(@Integer));
   print(if($debug.debug,|if($res->isEmpty(),|' -> Not Found\n', |' -> Found : '+$permutationSet->toOne().id->toString()+'\n'),|''));
   $res;
}

function meta::pure::router::routing::findExistingPemutationSet(state:RoutingState[1], debug:DebugContext[1]):PermutationSet[0..1]
{
   let setPath = getSetPath($state);
   print(if($debug.debug,|$debug.space+'Looking for:"'+$setPath+'"',|''));
   let permutationSet = $state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne().setsByDepth->get($setPath);
   print(if($debug.debug,|if($permutationSet->isEmpty(),|' -> Not Found\n', |' -> Found : '+$permutationSet->toOne().id->toString()+'\n'),|''));
   $permutationSet;
}

function meta::pure::router::routing::permutationSetOnlyHasImplementation( perm:PermutationSet[0..1],   set:SetImplementation[*]):Boolean[1]
{
   if($perm->isEmpty()||($set->size() > 1)||($set->size() == 0),
     |false,
     | let setImplementationIDs = $perm->toOne().sets.id;
       if($setImplementationIDs->size()>1 || $setImplementationIDs == $set.id,
           |true,
           |false
          );
   )
}

function meta::pure::router::permute(var:PermutationSet[*]):List<PermutationSet>[*]
{
   let l = $var->map(p|^List<PermutationSet>(values=$p.sets->removeDuplicates({a,b|$a.id == $b.id})->map(v|^$p(sets=$v))));
   let seed = $l->head().values->map(o|^List<PermutationSet>(values=$o));
   $l->tail()->fold({v,a|$a->combine($v.values)}, $seed);
}

function meta::pure::router::combine(first:List<PermutationSet>[*], second:PermutationSet[*]):List<PermutationSet>[*]
{
   $first->map(f|$second->map(s|^$f(values+=$s)));
}

function meta::pure::functions::collection::unionLambdas(vs:ValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1]):ValueSpecification[1]
{
   let first = $vs->at(0);
   $first->match
   (
      [
         i:InstanceValue[1]|let size = $i.values->size();
                            ^$i
                            (
                              values = range(0, $size, 1)->map(i|$vs->cast(@InstanceValue)->map(v|$v.values->at($i))->cast(@FunctionRoutedValueSpecification)->unionL($concatenate, $genericType))
                            );,
         e:StoreMappingRoutedValueSpecification[1]|$vs->cast(@StoreMappingRoutedValueSpecification).value->cast(@FunctionRoutedValueSpecification)->unionL($concatenate, $genericType),
         f:FunctionRoutedValueSpecification[1]|$vs->cast(@FunctionRoutedValueSpecification)->unionL($concatenate, $genericType)
      ]
   );
}

function meta::pure::functions::collection::unionL(vs:FunctionRoutedValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1]):ValueSpecification[1]
{
   let fr = $vs->at(0);
   let i = $fr.value->cast(@InstanceValue);
   let l = $i.values->at(0)->cast(@LambdaFunction<Any>);
   let res = $vs.value->cast(@InstanceValue).values->cast(@LambdaFunction<Any>).expressionSequence->map(e|pair($e->asString(), $e))->removeDuplicates({a,b|$a.first == $b.first});
   ^$fr(value=^$i(values=^$l(expressionSequence=doUnion($res.second, $concatenate, $l.expressionSequence->toOne().genericType))));
}

function meta::pure::functions::collection::doUnion(v:ValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1]):ValueSpecification[1]
{
   $v->tail()->fold({a,b|
                          ^SimpleFunctionExpression(func=if($concatenate,|concatenate_T_MANY__T_MANY__T_MANY_,|union_T_MANY__T_MANY__T_MANY_),
                                                    functionName=if($concatenate,|'concatenate',|'union'),
                                                    genericType = $genericType,
                                                    multiplicity = ZeroMany,
                                                    importGroup = system::imports::coreImport,
                                                    resolvedTypeParameters = ^GenericType(rawType=Any),
                                                    parametersValues = [ $b, $a ]->evaluateAndDeactivate()
                                                   )->evaluateAndDeactivate();
                        },$v->head()->toOne())
}

function meta::pure::functions::collection::buildConcatenate(v:ValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1], dispatch:Pair<Function<{FunctionExpression[1]->Boolean[1]}>, Function<{FunctionExpression[*], Boolean[1], GenericType[1]->ValueSpecification[1]}>>[*]):ValueSpecification[1]
{
  if ($v->size() > 1,
      |let funcExprs = $v->map(k|$k->match([f:FunctionExpression[1]|$f, e:StoreMappingRoutedValueSpecification[1]|$e.value->cast(@FunctionExpression)]));
       let funcs = $funcExprs.func->removeDuplicates();
       let funcsWithConcat = if ($funcs->size() == 1,| let dispatchProcessing = $dispatch->filter(d|$d.first->eval($funcExprs->at(0)));
                                                       if($dispatchProcessing->isNotEmpty(),|$dispatchProcessing->toOne().second->eval($funcExprs, $concatenate, $genericType)
                                                                                           ,|$v->doUnion($concatenate, $genericType));
                                                    ,| $v->doUnion($concatenate, $genericType));
       if($v->last()->toOne()->instanceOf(StoreMappingRoutedValueSpecification),
         | let last = $v->last()->toOne()->cast(@StoreMappingRoutedValueSpecification);
           ^$last(value = $funcsWithConcat);,
         | $funcsWithConcat);,
      |$v->toOne();
     );
}

function meta::pure::functions::collection::buildConcatenate(v:ValueSpecification[*], concatenate:Boolean[1], genericType:GenericType[1]):ValueSpecification[1]
{
   let dispatch =
   [
      pair(f:FunctionExpression[1]|$f.func == groupBy_TabularDataSet_1__String_MANY__AggregateValue_MANY__TabularDataSet_1_->cast(@Function<Any>),
          {funcExprs:FunctionExpression[*], concatenate:Boolean[1], genericType:GenericType[1] |
                 let leftSide = $funcExprs->map(f|$f.parametersValues->at(0));
                 let res = $leftSide->buildConcatenate($concatenate, $genericType);
                 let first = $funcExprs->at(0);
                 ^$first
                 (
                   parametersValues = $res->concatenate($first.parametersValues->tail())
                 );
         }
     ),
     pair(f:FunctionExpression[1]|$f.func == project_K_MANY__Function_MANY__String_MANY__TabularDataSet_1_->cast(@Function<Any>),
          {funcExprs:FunctionExpression[*], concatenate:Boolean[1], genericType:GenericType[1] |
                 let leftSide = $funcExprs->map(f|$f.parametersValues->at(0))->cast(@StoreMappingRoutedValueSpecification);
                 if ($leftSide.sets.id->removeDuplicates()->size() == 1,
                     | let first = $funcExprs->at(0);
                       // reprocess Lambdas
                       let right = $funcExprs->map(f|$f.parametersValues->at(1)->evaluateAndDeactivate());
                       let reprocessed = unionLambdas($right, $concatenate, $genericType);
                       // done
                       ^$first
                       (
                         parametersValues = $first.parametersValues->at(0)->concatenate($reprocessed)->concatenate($first.parametersValues->at(2))
                       );,
                     | doUnion($funcExprs, $concatenate, $genericType);
                 );
         }
     ),
     pair(f:FunctionExpression[1]|$f->isSerializeOnGraphFetch(),
          {funcExprs:FunctionExpression[*], concatenate:Boolean[1], genericType:GenericType[1] |
                let concatInputs = $funcExprs->map(v|$v->cast(@FunctionExpression).parametersValues->at(0));
                let graphFetchInputType = $concatInputs->at(0)->byPassRouterInfo()->cast(@FunctionExpression).parametersValues->at(0)->match([e:StoreMappingRoutedValueSpecification[1]|$e.value.genericType, v:ValueSpecification[1]|$v.genericType]);
                let concatenateOverride = $graphFetchInputType.rawType->toOne()->instanceOf(DataType) || $graphFetchInputType.rawType->toOne()->_subTypeOf(TabularDataSet);
                let concat = $concatInputs->doUnion($concatenateOverride, $genericType);
                let serialize = $funcExprs->at(0)->cast(@FunctionExpression);
                ^$serialize(parametersValues=$concat->concatenate($serialize.parametersValues->evaluateAndDeactivate()->tail()));
          })
   ];

   $v->buildConcatenate($concatenate, $genericType, $dispatch);

}


// TODO: check this clean up needed
function meta::pure::router::routing::processProperty(p:AbstractProperty<Any>[1], i:InstanceValue[1], state:RoutingState[1], executionContext:ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):RoutingState[1]
{
   let mapping = $state.routingStrategy->cast(@StoreMappingRoutingStrategy).mapping;
   let runtime = $state.routingStrategy->cast(@StoreMappingRoutingStrategy).runtime;

   let s             = $state.propertyMap.v->filter(p|$p.first == '__propertyOwner').second->evaluateAndDeactivate();
   let permSets      = if($s == 0,|[]->cast(@SetImplementation), |$s->cast(@StoreMappingRoutedValueSpecification).sets);
   let foundMappings = $p->findMappingsFromProperty($mapping, $permSets, $state, $extensions);

   if($foundMappings->isEmpty(),
      | let found = $state.propertyMap.v->filter(p|$p.first == '__propertyOwner').second->evaluateAndDeactivate();
        if($found == 0,
           | ^$state(value=$i),
           | let res = $found->toOne()->cast(@StoreMappingRoutedValueSpecification);
             print(if($debug.debug,|$debug.space+'~>P '+$p.name->toOne()+') ('+$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$res->evaluateAndDeactivate()->asString()+'\n',|''));
             ^$state(value=^$res(value = $i));
        );,
      | let existingSet = $state->findExistingSet($debug);

        let newSet = if ($existingSet->isEmpty(),|^PermutationSet(id = $state.counter+1, sets = $foundMappings),|[]);

        let currentRoutingStrategy = $state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne();
        let updatedRoutingStrategy = ^$currentRoutingStrategy(setsByDepth = if($existingSet->isEmpty(),
                                                                              | let setByD = $state.routingStrategy->cast(@StoreMappingRoutingStrategy).setsByDepth->toOne();       // TODO: check this remove ->toOne()
                                                                                $setByD->put(getSetPath($state), $newSet->toOne());,
                                                                              | $state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne().setsByDepth
                                                                            ),
                                                              sets = if ($existingSet->isEmpty(),|$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->add($newSet->toOne()),|$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets));
        
        let routed = ^StoreMappingRoutedValueSpecification(
                                genericType = $i.genericType,
                                multiplicity = $i.multiplicity,
                                id = if ($existingSet->isEmpty(),|$state.counter+1, |$existingSet->toOne())->toString(),
                                sets = $foundMappings,
                                runtime = $runtime,
                                mapping = $mapping,
                                executionContext = $executionContext,
                                value = $i,
                                routingStrategy = $updatedRoutingStrategy
                    );

        let res= ^$state(
              counter = if ($existingSet->isEmpty(),|$state.counter+1, |$state.counter),
              routingStrategy = $updatedRoutingStrategy,
              value = $routed
          );
        print(if($debug.debug,|$debug.space+'~>P '+$p.name->toOne()+') ('+$res.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$routed->evaluateAndDeactivate()->asString()+'\n',|''));
        $res;
   );
}

function meta::pure::router::routing::getClassMappings(c:Class<Any>[1], r:RoutingState[1]):SetImplementation[*]
{
   let classMappings = $r.routingStrategy->cast(@StoreMappingRoutingStrategy).classMappingsForClass($c)->concatenate($c.generalizations.general.rawType->cast(@Class<Any>)->map(g|$g->getClassMappings($r)));                                              
   assert($classMappings.class->removeDuplicates()->size() <= 1, 'Expected class mapping for only 1 class [Class: ' + $c.name->toOne() + ']');
   $classMappings;
}

function meta::pure::router::routing::propogateSubType(vs:ValueSpecification[1], subTypeId:String[1], subTypeSets:SetImplementation[*], extensions:meta::pure::extension::Extension[*]): ValueSpecification[1]
{
    $vs->evaluateAndDeactivate()->match([e: StoreMappingRoutedValueSpecification[1] | let castClass   = $subTypeSets->at(0).class;
                                                                                      let routedClass = $e.genericType.rawType->toOne();
                                                                                      if($castClass->_subTypeOf($routedClass),| ^$e(sets=$subTypeSets, id=$subTypeId, value=$e.value->evaluateAndDeactivate()->propogateSubType($subTypeId, $subTypeSets, $extensions));,|$e);,
                                         f: SimpleFunctionExpression[1] |if(shouldStop($f.func, $extensions),
                                                                            |$f,
                                                                            |let func = $f.func;
                                                                             let newFunc = if($func->instanceOf(FunctionDefinition),
                                                                                              |let fd=$func->cast(@FunctionDefinition<Any>);
                                                                                               let newEs=$fd.expressionSequence->map(e|$e->propogateSubType($subTypeId,$subTypeSets, $extensions));
                                                                                               ^$fd(expressionSequence=$newEs);,
                                                                                              |$func
                                                                                            );
                                                                             ^$f(func=$newFunc, parametersValues=$f.parametersValues->map(p|$p->propogateSubType($subTypeId,$subTypeSets, $extensions))););,
                                         vs: ValueSpecification[1] | $vs
                                       ])->cast(@ValueSpecification);
}