// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::lineage::scanExecutes::*;
import meta::pure::mapping::*;
import meta::pure::lineage::scanProperties::propertyTree::*;
import meta::pure::metamodel::path::*;
import meta::pure::lineage::scanProperties::*;
import meta::pure::graphFetch::*;


Class meta::pure::lineage::scanProperties::PropertyPathNode
{
   <<equality.Key>> class : Class<Any>[1];
   <<equality.Key>> property : AbstractProperty<Any>[1];
   nestedQualifier : List<PropertyPathNode>[*];
   parameters      : ValueSpecification[*];
   nestedQualifierReturn : List<PropertyPathNode>[0..1];
}

Class meta::pure::lineage::scanProperties::Res
{
   current : List<PropertyPathNode>[1];
   result : List<PropertyPathNode>[*];
}

Class meta::pure::lineage::scanProperties::propertyTree::PropertyPathTree
{
   display : String[1];
   value : Any[1];
   children : PropertyPathTree[*];
   qualifierSubTree : PropertyPathTree[0..1];
}

function <<access.private>> meta::pure::lineage::scanProperties::findAndAddChildrenAtTheEnd(tree: PropertyPathTree[1], path: PropertyPathNode[*], toAdd: PropertyPathTree[*]):PropertyPathTree[1]
{
   if($path->isEmpty(),
      | ^$tree(children += $toAdd),
      | let first = $path->at(0);
        let correctTree = $tree.children->filter(x | $x.value->instanceOf(PropertyPathNode) && ($x.value->cast(@PropertyPathNode).property == $first.property))->toOne();
        let otherTrees = $tree.children->remove($correctTree);
        ^$tree(
           children = $otherTrees->concatenate($correctTree->findAndAddChildrenAtTheEnd($path->tail(), $toAdd))
        );
   )
}

function <<access.private>> meta::pure::lineage::scanProperties::test::dummy():Any[*]
{
   'To ensure integration build does not fail on meta::pure::lineage::scanProperties::test package'
}


function <<doc.deprecated>> {doc.doc = 'Use scanProperties_ValueSpecification_1__List_MANY_ instead'}
meta::pure::lineage::scanProperties::scanProperties(vs:ValueSpecification[1], list:List<PropertyPathNode>[1], processed:Function<Any>[*], vars:Map<String,List<PropertyPathNode>>[0..1]):Res[0..1]
{
   scanProperties($vs, $list, $processed, $vars, noDebug());
}

function <<doc.deprecated>> {doc.doc = 'Use scanProperties_ValueSpecification_1__DebugContext_1__List_MANY_ instead'}
meta::pure::lineage::scanProperties::scanProperties(vs:ValueSpecification[1], list:List<PropertyPathNode>[1], processed:Function<Any>[*], vars:Map<String,List<PropertyPathNode>>[0..1], debug: meta::pure::tools::DebugContext[1]):Res[0..1]
{
   assert($list.values->isEmpty(),                               |'Do not supply base path.  Use scanProperties_ValueSpecification_1__List_MANY_ instead');
   assert($processed->isEmpty(),                                 |'Do not supply processed.  Use scanProperties_ValueSpecification_1__List_MANY_ instead');
   assert($vars->isEmpty() || $vars->toOne()->keys()->isEmpty(), |'Do not supply vars.  Use scanProperties_ValueSpecification_1__List_MANY_ instead');

   $vs->scanProperties($debug);
}

function meta::pure::lineage::scanProperties::scanProperties(vs:ValueSpecification[1]):Res[0..1]
{
   scanProperties($vs, noDebug());
}

function meta::pure::lineage::scanProperties::scanProperties(vs:ValueSpecification[1], debug:DebugContext[1]):Res[0..1]
{
   internal_scanProperties($vs, [], noVars(), $debug);
}

function <<access.private>> meta::pure::lineage::scanProperties::internal_scanProperties(vs:ValueSpecification[1], processed:Function<Any>[*], vars:Map<String,List<PropertyPathNode>>[1], debug: meta::pure::tools::DebugContext[1]):Res[0..1]
{
   let res = $vs->match([
               fe:FunctionExpression[1] | print(if($debug.debug,|$debug.space+'Processing Function Expression\n',|''));
                                          let params = $fe.parametersValues->evaluateAndDeactivate();
                                          $fe.func->match([
                                                            p:Property<Nil,Any|*>[1]|print(if($debug.debug,|$debug.space+'  property:'+$p.name->toOne()+'\n', |''));
                                                                                     let leftSide = $params->at(0)->internal_scanProperties($processed, $vars, ^$debug(space=$debug.space+'  '));
                                                                                     if($params->at(0)->extractType()->instanceOf(Class), 
                                                                                        {|
                                                                                           let srcClass = $params->at(0)->extractType()->cast(@Class<Any>);
                                                                                           let nlist = $p->processProperty($srcClass, $leftSide.current->orElseEmptyPath(), true);
                                                                                           ^Res(
                                                                                              current= $nlist->at(0),
                                                                                              result = $nlist->concatenate($leftSide.result->filter(x | $x.values->isNotEmpty()))
                                                                                           );
                                                                                        },
                                                                                        | $leftSide
                                                                                     );,
                                                            q:QualifiedProperty<Any>[1]|print(if($debug.debug,|$debug.space+'  qualifier:'+$q.name->toOne()+'\n', |''));
                                                                                        let srcClass = $params->at(0)->extractType()->cast(@Class<Any>);
                                                                                        let leftSide = $params->at(0)->map(v|$v->internal_scanProperties($processed->concatenate($q), $vars, ^$debug(space=$debug.space+'    ')));
                                                                                        if(!$processed->contains($q),
                                                                                           {|
                                                                                              let nlist = $q->processQualifier($srcClass, $params->tail(), $leftSide.current->orElseEmptyPath(), $processed, $vars, true, $debug);
                                                                                              ^Res(current= $nlist, result = $nlist);
                                                                                           },
                                                                                           | ^Res(current = emptyPath(), result = [])
                                                                                        );,
                                                            z:Any[1]|print(if($debug.debug,|$debug.space+'  function: \''+$fe.func.name->toOne()+'\'\n',|''));
                                                                         if($fe.func.name->in(['eval_Function_1__T_n__V_m_']),
                                                                            {|
                                                                               print(if($debug.debug,|$debug.space+'  - param 1\n',|''));
                                                                               let collectionPath = $params->at(1)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               $params->at(0)->findFunction()->processFunction($collectionPath, $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                            },
                                                                            |
                                                                         if($fe.func.name == 'sort_T_m__Function_$0_1$__T_m_',
                                                                            {|
                                                                               let collectionPath = $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               let func           = $params->at(1)->findFunction();
                                                                               let funcResult     = $func->processFunction([$collectionPath, $collectionPath], $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                               ^$funcResult(current=$collectionPath.current);
                                                                            },
                                                                            |
                                                                         if($fe.func.name == 'sort_T_m__Function_$0_1$__Function_$0_1$__T_m_',
                                                                            {|
                                                                               let collectionPath = $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               let keyFunc        = $params->at(1)->findFunction();
                                                                               let comparator     = $params->at(2)->findFunction();
                                                                               let keyFuncResult  = $keyFunc->processFunction($collectionPath, $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                               let compResult     = $comparator->processFunction([$keyFuncResult, $keyFuncResult], $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                               ^Res(
                                                                                  current = $collectionPath.current,
                                                                                  result  = $compResult.result->concatenate($keyFuncResult.result)
                                                                               );
                                                                            },
                                                                            |
                                                                         if($fe.func.name == 'removeDuplicates_T_MANY__Function_$0_1$__Function_$0_1$__T_MANY_',
                                                                            {|
                                                                               let collectionPath = $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               let keyFunc        = $params->at(1)->findFunction();
                                                                               let predicate      = $params->at(2)->findFunction();
                                                                               let keyFuncResult  = $keyFunc->processFunction($collectionPath, $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                               let predResult     = $predicate->processFunction($keyFuncResult, $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                               ^Res(
                                                                                  current = $collectionPath.current,
                                                                                  result  = $predResult.result->concatenate($keyFuncResult.result)
                                                                               );
                                                                            },
                                                                            |
                                                                         if($fe.func.name == 'letFunction_String_1__T_m__T_m_',
                                                                            {|
                                                                               print(if($debug.debug,|$debug.space+'  - param 1\n',|''));
                                                                               $params->at(1)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '));
                                                                            },
                                                                            |
                                                                         if($fe.func.name == 'if_Boolean_1__Function_1__Function_1__T_m_',
                                                                            {|
                                                                               print(if($debug.debug,|$debug.space+'  - param 0\n',|''));
                                                                               let testPath = $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               print(if($debug.debug,|$debug.space+'  - param 1\n',|''));
                                                                               let thenPath = $params->at(1)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               print(if($debug.debug,|$debug.space+'  - param 2\n',|''));
                                                                               let elsePath = $params->at(2)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               ^Res(
                                                                                  current = $thenPath.current->concatenate($elsePath.current)->removeEmptyPaths()->first()->orElseEmptyPath(),  // TODO handle when both paths are relevant 
                                                                                  result  = $testPath.result->concatenate($thenPath.result)->concatenate($elsePath.result)
                                                                               );
                                                                            },
                                                                            |
                                                                         if($fe.func.name == 'match_Any_MANY__Function_$1_MANY$__T_m_',
                                                                            {|
                                                                               print(if($debug.debug,|$debug.space+'  - param 0\n',|''));
                                                                               let inputPath   = $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               let funcResults = $params->at(1)->findFunctions()->map(f| $f->processFunction($inputPath, $vars, $processed, ^$debug(space=$debug.space+'    ')));
                                                                               ^Res(
                                                                                  current = $funcResults.current->removeEmptyPaths()->first()->orElseEmptyPath(),  // TODO handle when multiple paths are relevant 
                                                                                  result  = $funcResults.result
                                                                               );
                                                                            },
                                                                            |
                                                                         if($fe.func.name->in(['assert_Boolean_1__Function_1__Boolean_1_',
                                                                                               'exists_T_MANY__Function_1__Boolean_1_', 
                                                                                               'forAll_T_MANY__Function_1__Boolean_1_']),
                                                                            {|
                                                                               // Unary function, result is primitive
                                                                               print(if($debug.debug,|$debug.space+'  - param 0\n',|''));
                                                                               let collectionPath = $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               let funcResult     = $params->at(1)->findFunction()->processFunction($collectionPath, $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                               ^$funcResult(current=emptyPath());
                                                                            },
                                                                            |
                                                                         if($fe.func.name->in(['fold_T_MANY__Function_1__V_m__V_m_', 
                                                                                               'map_T_MANY__Function_1__V_MANY_',
                                                                                               'map_T_m__Function_1__V_m_',
                                                                                               'map_T_$0_1$__Function_1__V_$0_1$_']),
                                                                            {|
                                                                               // Unary function, return is that function's return
                                                                               print(if($debug.debug,|$debug.space+'  - param 0\n',|''));
                                                                               let collectionPath = $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               $params->at(1)->findFunction()->processFunction($collectionPath, $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                            },
                                                                            |
                                                                         if($fe.func.name->in(['filter_T_MANY__Function_1__T_MANY_',
                                                                                               'removeDuplicates_T_MANY__Function_1__T_MANY_',
                                                                                               'removeDuplicatesBy_T_MANY__Function_1__T_MANY_',
                                                                                               'sortBy_T_m__Function_$0_1$__T_m_']),
                                                                            {|
                                                                               // Unary function, return is same as collection in
                                                                               let collectionPath = $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               let func           = $params->at(1)->findFunction();
                                                                               let funcResult     = $func->processFunction($collectionPath, $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                               ^$funcResult(current=$collectionPath.current);
                                                                            },
                                                                            |
                                                                         if($fe.func.name->in(['at_T_MANY__Integer_1__T_1_',
                                                                                               'cast_Any_m__T_1__T_m_',
                                                                                               'distinct_T_MANY__T_MANY_',
                                                                                               'drop_T_MANY__Integer_1__T_MANY_', 
                                                                                               'first_T_MANY__T_$0_1$_', 
                                                                                               'init_T_MANY__T_MANY_', 
                                                                                               'last_T_MANY__T_$0_1$_', 
                                                                                               'limit_T_MANY__Integer_1__T_MANY_', 
                                                                                               'removeDuplicates_T_MANY__T_MANY_', 
                                                                                               'reverse_T_m__T_m_', 
                                                                                               'slice_T_MANY__Integer_1__Integer_1__T_MANY_', 
                                                                                               'subType_Any_m__T_1__T_m_',
                                                                                               'whenSubType_Any_1__T_1__T_$0_1$_',
                                                                                               'whenSubType_Any_$0_1$__T_1__T_$0_1$_',
                                                                                               'whenSubType_Any_MANY__T_1__T_MANY_',
                                                                                               'sort_T_m__T_m_', 
                                                                                               'tail_T_MANY__T_MANY_', 
                                                                                               'take_T_MANY__Integer_1__T_MANY_',
                                                                                               'toOne_T_MANY__T_1_',
                                                                                               'toOneMany_T_MANY__T_$1_MANY$_']),
                                                                            {|
                                                                               // No function, return is same as collection in
                                                                               print(if($debug.debug,|$debug.space+'  - param 0\n',|''));
                                                                               $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                            },
                                                                            |
                                                                         if($fe.func.name->in(['add_T_MANY__T_1__T_$1_MANY$_', 
                                                                                               'concatenate_T_MANY__T_MANY__T_MANY_', 
                                                                                               'union_T_MANY__T_MANY__T_MANY_']),
                                                                            {|
                                                                               // Combine 2 collections
                                                                               print(if($debug.debug,|$debug.space+'  - param 0\n',|''));
                                                                               let col1 = $params->at(0)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               print(if($debug.debug,|$debug.space+'  - param 1\n',|''));
                                                                               let col2 = $params->at(1)->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    '))->orElseEmptyPath();
                                                                               ^Res(
                                                                                  current = $col1.current->concatenate($col2.current)->removeEmptyPaths()->first()->orElseEmptyPath(),  // TODO handle when both paths are relevant 
                                                                                  result  = $col1.result->concatenate($col2.result)
                                                                               );
                                                                            },
                                                                            {|
                                                                               let pp = $params->map(v|$v->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    ')));
                                                                               let func = $fe.func->filter(f| $f->shouldBeProcessed($processed))->first();
                                                                               $func->processFunction($pp, $vars, $processed, ^$debug(space=$debug.space+'    '));
                                                                            }
                                                                         ))))))))))));
                                                          ]);,
               i:InstanceValue[1] | print(if($debug.debug,|$debug.space+'Processing Instance\n',|''));
                                    let instanceRes = $i.values->evaluateAndDeactivate()->map( v |
                                       $v->match([
                                          a: ValueSpecification[1]                                             | $a->internal_scanProperties($processed, $vars, ^$debug(space=$debug.space+'    '));,
                                          k: KeyExpression[1]                                                  | $k.expression->internal_scanProperties($processed, $vars, ^$debug(space=$debug.space+'    '));,
                                          a: meta::pure::functions::collection::AggregateValue<Any,Any,Any>[1] | ^Res(current=emptyPath(), result=$a.mapFn.expressionSequence->map(e | $e->internal_scanProperties($processed, $vars, ^$debug(space=$debug.space+'    '))).result),
                                          a: meta::pure::tds::BasicColumnSpecification<Any>[1]                 | ^Res(current=emptyPath(), result=$a.func->cast(@FunctionDefinition<Any>).expressionSequence->map(e | $e->internal_scanProperties($processed, $vars, ^$debug(space=$debug.space+'    '))).result),
                                          l: LambdaFunction<Any>[1]                                            | $l.expressionSequence->map(e | $e->internal_scanProperties($processed, $vars, ^$debug(space=$debug.space+'    ')));,
                                          l: ConcreteFunctionDefinition<Any>[1]                                | $l.expressionSequence->map(e | $e->internal_scanProperties($processed, $vars, ^$debug(space=$debug.space+'    ')));,
                                          a: String[1]                                                         | ^Res(current=emptyPath()),
                                          p: Path<Nil,Any|*>[1]                                                | ^Res(current=emptyPath(), result=$p->scanPath(emptyPath(), $processed, $vars, $debug)),
                                          r: RootGraphFetchTree<Any>[1]                                        | ^Res(current=emptyPath(), result=$r->scanGraphFetchTree($r->typeFromGraphFetchTree()->cast(@Class<Any>), emptyPath(), $processed, $vars, $debug)),
                                          a: Any[1]                                                            | print(if($debug.debug,|$debug.space+'  Unknown\n',|''));[];
                                    ]));
                                    ^Res(
                                       current = $instanceRes.current->removeEmptyPaths()->first()->orElseEmptyPath(), 
                                       result = $instanceRes.result
                                    );,
               ve:VariableExpression[1] | print(if($debug.debug,|$debug.space+'Processing Variable '+$ve.name+'\n',|''));
                                          let v = $vars->get($ve.name)->orElseEmptyPath();
                                          ^Res(current = $v, result = $v);,
               ervs:StoreMappingRoutedValueSpecification[1] | print(if($debug.debug,|$debug.space+'Bypassing StoreMappingRoutedValueSpecification\n',|''));
                                                          $ervs.value->internal_scanProperties($processed, $vars, ^$debug(space=$debug.space+'    '));,
               frvs:FunctionRoutedValueSpecification[1] | print(if($debug.debug,|$debug.space+'Bypassing FunctionRoutedValueSpecification\n',|''));
                                                          $frvs.value->internal_scanProperties($processed, $vars, ^$debug(space=$debug.space+'    '));
             ]
          )->removeEmptyResults();

   print(if($debug.debug,|$debug.space+'Current:'+$res.current->printPropertyNodeLists($debug.space+'          ')+'\n',|''));
   print(if($debug.debug,|$debug.space+'Results:'+$res.result->printPropertyNodeLists($debug.space+'          ')+'\n',|''));
   $res;
}

function <<access.private>> meta::pure::lineage::scanProperties::shouldBeProcessed(f:Function<Any>[1], processed:Function<Any>[*]):Boolean[1]
{
   let pkgOk = !$f->isWithinPackage(meta) || $f->meta::alloy::isMetaAlloyTestDependency() || $f->isWithinPackage(meta::pure::lineage::scanProperties::test);
   $pkgOk && !$processed->contains($f);
}

function <<access.private>> meta::pure::lineage::scanProperties::extractType(vs:ValueSpecification[1]):Type[1]
{
   $vs->match([
      ervs :StoreMappingRoutedValueSpecification[1] | $ervs.value->extractType(),
      frvs :FunctionRoutedValueSpecification[1] | $frvs.value->extractType(),
      other:ValueSpecification[1]               | $other.genericType.rawType->toOne()
   ]);
}

function <<access.private>> meta::pure::lineage::scanProperties::processFunction(fn:Function<Any>[0..1], paramPaths:Res[*], vars:Map<String,List<PropertyPathNode>>[1], processed:Function<Any>[*], debug:DebugContext[1]):Res[1]
{
   print(if($debug.debug,|$debug.space+'  - func '+if($fn->isEmpty(), |'not found or excuded', |if($fn.name->isEmpty(), |$fn->toOne()->type().name->toOne(), |$fn.name->toOne()))+'\n',|''));

   let fromParams = ^Res(current=emptyPath(), result=$paramPaths.result);

   $fn->match([
      {f0:Function<Any>[0] | $fromParams},
      {f :Function<Any>[1] |
         let newVars     = $f->functionType().parameters.name->zip($paramPaths.current)->newMap();
         let allVars     = $vars->putAll($newVars);
         let expressions = $f->match([l:FunctionDefinition<Any>[1]| $l.expressionSequence, n:NativeFunction<Any>[1]| []]);

         let body = $expressions->processExpressionSequence($allVars, $processed->concatenate($f), $debug);
         ^$body(result=$fromParams.result->concatenate($body.result));
      }
   ]);
}

function <<access.private>> meta::pure::lineage::scanProperties::processExpressionSequence(expressions:ValueSpecification[*], vars:Map<String,List<PropertyPathNode>>[1], processed:Function<Any>[*], debug:DebugContext[1]):Res[1]
{
   print(if($debug.debug,|$debug.space+'  - vars '+$vars->varsToString()+'\n',|''));

   $expressions->fold(
      {e, p |
         let r = $p.first;
         let v = $p.second;

         let ePaths  = $e->internal_scanProperties($processed, $v, ^$debug(space=$debug.space+'    '));
         let newVars = if($e->instanceOf(FunctionExpression) && $e->cast(@FunctionExpression).func == letFunction_String_1__T_m__T_m_,
                          {|
                             let varName  = $e->cast(@FunctionExpression).parametersValues->evaluateAndDeactivate()->at(0)->cast(@InstanceValue).values->at(0)->cast(@String);
                             let varValue = $ePaths.current->orElseEmptyPath();
                             print(if($debug.debug,|$debug.space+'  - +var '+varToString($varName, $varValue)+'\n',|''));
                             $v->put($varName, $varValue);
                          },
                          | $v
                       );
         let newRes  = ^Res(
                          current = if($ePaths->isEmpty(), |emptyPath(), |$ePaths->toOne().current),
                          result  = $r.result->concatenate($ePaths.result)
                       );
         pair($newRes, $newVars);
      },
      pair(^Res(current=emptyPath()), $vars)
   ).first;
}

function <<access.private>> meta::pure::lineage::scanProperties::varsToString(vars:Map<String,List<PropertyPathNode>>[1]):String[1]
{
   $vars->keyValues()->map(kv| varToString($kv.first, $kv.second))->joinStrings('[', ' , ', ']')
}

function <<access.private>> meta::pure::lineage::scanProperties::varToString(name:String[1], value:List<PropertyPathNode>[1]):String[1]
{
   $name+':'+$value->printPropertyNodeLists()->replace('\n', ';');
}

function <<access.private>> meta::pure::lineage::scanProperties::processProperty(p:Property<Nil,Any|*>[1], srcClass:Class<Any>[1], list:List<PropertyPathNode>[1], append:Boolean[1]):List<PropertyPathNode>[1]
{
   let property = ^PropertyPathNode(
                        class = $srcClass,
                        property=$p
                  );
   if($append,|^$list(values = $list.values->concatenate($property)),|^$list(values = $property->concatenate($list.values)));
}

function <<access.private>> meta::pure::lineage::scanProperties::processQualifier(q:QualifiedProperty<Any>[1], srcClass:Class<Any>[1], parameters:ValueSpecification[*], list:List<PropertyPathNode>[1], processed:Function<Any>[*], vars:Map<String,List<PropertyPathNode>>[1], append:Boolean[1], debug:DebugContext[1]):List<PropertyPathNode>[1]
{
   let paramPaths    = $parameters->map(v|$v->internal_scanProperties($processed, $vars,  ^$debug(space=$debug.space+'    ')));
   let qualifierVars = $q->functionType().parameters->tail().name->zip($paramPaths.current)->newMap();
   let qualifierBody = $q.expressionSequence->processExpressionSequence($qualifierVars, $processed->concatenate($q), $debug);
   let property      = ^PropertyPathNode(
                          class                 = $srcClass,
                          property              = $q,
                          nestedQualifier       = $qualifierBody.result,
                          parameters            = $parameters,
                          nestedQualifierReturn = $qualifierBody->last().current
                       );
   if($append,|^$list(values = $list.values->concatenate($property)),|^$list(values = $property->concatenate($list.values)));
}

function <<access.private>> meta::pure::lineage::scanProperties::scanPath(p:Path<Nil,Any|*>[1], list:List<PropertyPathNode>[1], processed:Function<Any>[*], vars:Map<String,List<PropertyPathNode>>[1], debug:DebugContext[1]):List<PropertyPathNode>[*]
{
   $p.path->fold({pe,s|$pe->match([
                                    p:PropertyPathElement[1]|pair($p.property->functionReturnType().rawType->toOne(),
                                                                  $p.property->match(
                                                                                       [
                                                                                          p:Property<Nil,Any|*>[1]| processProperty($p, $s.first->cast(@Class<Any>), $s.second, true),
                                                                                          q:QualifiedProperty<Any>[1]| processQualifier($q, $s.first->cast(@Class<Any>), $p.parameters, $s.second, $processed, $vars, true, $debug)
                                                                                       ]
                                                                               )
                                                            ),
                                    c:CastPathElement[1]| pair($c.type.rawType->toOne(), $s.second)
                                  ]
                                 )
                 }, pair($p.start.rawType->toOne(), $list)
               ).second;
}


function <<access.private>> meta::pure::lineage::scanProperties::scanGraphFetchTree(g:GraphFetchTree[1], type: Class<Any>[1], list:List<PropertyPathNode>[1], processed:Function<Any>[*], vars:Map<String,List<PropertyPathNode>>[1], debug:DebugContext[1]):List<PropertyPathNode>[*]
{
   $g.subTrees->cast(@PropertyGraphFetchTree)->map({st | 
      let res = $st.property->match([
         p:Property<Nil,Any|*>[1]| processProperty($p, $type, $list, true),
         q:QualifiedProperty<Any>[1]| processQualifier($q, $type, $st.parameters, $list, $processed, $vars, true, $debug)
      ]); 
      if($st.subTrees->isNotEmpty(),
         | scanGraphFetchTree($st, $st->typeFromGraphFetchTree()->cast(@Class<Any>), $res, $processed, $vars, $debug),
         | $res
      );
  });
}

function <<access.private>> meta::pure::lineage::scanProperties::findFunction(vs:ValueSpecification[1]):Function<Any>[0..1]
{
   $vs->findFunctions()->first();
}

function <<access.private>> meta::pure::lineage::scanProperties::findFunctions(vs:ValueSpecification[1]):Function<Any>[*]
{
   $vs->match([
      ervs:StoreMappingRoutedValueSpecification[1] | $ervs.value->findFunction(),
      frvs:FunctionRoutedValueSpecification[1] | $frvs.value->findFunction(),
      iv  :InstanceValue[1] | $iv.values->map(v | $v->match([f:Function<Any>[1]|$f, a:Any[*]|[]])),
      a   :Any[*]           | []
   ]);
}

function <<access.private>> meta::pure::lineage::scanProperties::noVars():Map<String,List<PropertyPathNode>>[1]
{
   ^Map<String,List<PropertyPathNode>>();
}

function <<access.private>> meta::pure::lineage::scanProperties::removeEmptyResults(res:Res[0..1]):Res[0..1]
{
   $res->map(r| ^$r(result=$r.result->removeEmptyPaths()));
}

function <<access.private>> meta::pure::lineage::scanProperties::removeEmptyPaths(paths:List<PropertyPathNode>[*]):List<PropertyPathNode>[*]
{
   $paths->filter(l| $l.values->isNotEmpty());
}

function <<access.private>> meta::pure::lineage::scanProperties::orElseEmptyPath(maybeRes:Res[0..1]):Res[1]
{
   $maybeRes->match([
      r0:Res[0] | ^Res(current=emptyPath()),
      r1:Res[1] | $r1
   ]);
}

function <<access.private>> meta::pure::lineage::scanProperties::orElseEmptyPath(maybePath:List<PropertyPathNode>[0..1]):List<PropertyPathNode>[1]
{
   $maybePath->match([
      l0:List<PropertyPathNode>[0] | emptyPath(),
      l1:List<PropertyPathNode>[1] | $l1
   ]);
}

function meta::pure::lineage::scanProperties::emptyPath():List<PropertyPathNode>[1]
{
   ^List<PropertyPathNode>();
}

function meta::pure::lineage::scanProperties::printPropertyNodeLists(properyLists:List<PropertyPathNode>[*]):String[1]
{
   $properyLists->printPropertyNodeLists('');
}

function meta::pure::lineage::scanProperties::printPropertyNodeLists(properyLists:List<PropertyPathNode>[*], space:String[1]):String[1]
{
   $properyLists->map(l|$l.values->map(v|$v.class.name->toOne()+'->'+$v.property.name->toOne())->joinStrings(', '))->sort()->removeDuplicates()->joinStrings('\n'+$space);
}


function <<access.private>> meta::pure::lineage::scanProperties::propertyTree::recurseBuildTree(list:List<PropertyPathNode>[*]):PropertyPathTree[*]
{
   let m = $list->filter(l|!$l.values->isEmpty())->groupBy(l|$l.values->at(0));
   $m->keys()->map(
                  k|^PropertyPathTree(display = $k.property->match([p:Property<Nil,Any|*>[1]|'',q:QualifiedProperty<Any>[1]|'(Q)'])+$k.property.name->toOne(),
                                      value = $k,
                                      children = $m->get($k).values->map(l|^$l(values=$l.values->slice(1, $l.values->size())))->recurseBuildTree(),
                                      qualifierSubTree = $k.nestedQualifier->buildPropertyTree()
                                      )
               );
}

function <<access.private>> meta::pure::lineage::scanProperties::propertyTree::srcClass(property:AbstractProperty<Any>[1]):Type[1]
{
   $property->match([
                     q:QualifiedProperty<Any>[1]|$q->functionType().parameters->evaluateAndDeactivate()->at(0).genericType.rawType->toOne(),
                     p:Property<Nil,Any|*>[1]|$p.classifierGenericType.typeArguments->at(0).rawType->toOne()
                    ]);
}

function meta::pure::lineage::scanProperties::propertyTree::buildPropertyTree(executes:Execute[*]):PropertyPathTree[1]
{
   let properyLists = $executes->map(exec|$exec.funcEntryPoint->scanProperties(emptyPath(), [], []););
   $properyLists.result->buildPropertyTree();
}

function meta::pure::lineage::scanProperties::propertyTree::buildPropertyTree(properyLists:List<PropertyPathNode>[*]):PropertyPathTree[1]
{
   let filteredPropertyLists = $properyLists->filter(f|$f.values->isNotEmpty());

   let grpByClass = $filteredPropertyLists->groupBy(v|$v.values->at(0).class);

   let propertyTree = ^PropertyPathTree(display='root',
                                        value='root',
                                        children = $grpByClass->keys()->map(c|^PropertyPathTree(display=$c.name->toOne(), value=$c, children=$grpByClass->get($c).values->recurseBuildTree()))//filteredPropertyLists->recurse()
                                       );
}



function meta::pure::lineage::scanProperties::propertyTree::printTree(t:PropertyPathTree[1], space:String[1]):String[1]
{
   $space+$t.value->match([c:Class<Any>[1]|'c_'+$c.name->toOne()+'\n',
                            a:String[1]|$a+'\n',
                            p:PropertyPathNode[1]|'p_'+$p.class.name->toOne()+'.'+$p.property.name->toOne()+'\n'+if($p.nestedQualifier->isEmpty(),|'',|$p.nestedQualifier->buildPropertyTree()->printTree($space+'   __ '));
                          ])+
   $t.children->sort({a,b| if($a.value->instanceOf(PropertyPathNode) && $b.value->instanceOf(PropertyPathNode),
                             |let c = $a.value->cast(@PropertyPathNode);
                              let d = $b.value->cast(@PropertyPathNode);
                              let e = $c.class.name->toOne()+'.'+$c.property.name->toOne();
                              let f = $d.class.name->toOne()+'.'+$d.property.name->toOne();
                              $e->compare($f);,
                             |0
                          );
                     })
              ->map(c|$c->printTree($space+' '))->joinStrings('');
}

function meta::pure::lineage::scanProperties::inlineQualifiedPropertyNodes(p: PropertyPathTree[1]):PropertyPathTree[1]
{
   $p->recurse_inlineQualifiedPropertyNodes()->toOne();
}

function <<access.private>> meta::pure::lineage::scanProperties::recurse_inlineQualifiedPropertyNodes(p: PropertyPathTree[1]):PropertyPathTree[*]
{
   let newTrees = if($p.value->instanceOf(PropertyPathNode) && $p.value->cast(@PropertyPathNode).property->instanceOf(QualifiedProperty),
                     {|  
                        if($p.children->isEmpty(),
                           | $p.qualifierSubTree.children.children,
                           {| 
                              let qual = $p.value->cast(@PropertyPathNode).property->cast(@QualifiedProperty<Any>);
                              let qualifierTreeCurrent = $qual.expressionSequence->evaluateAndDeactivate()->toOne()->internal_scanProperties([], noVars(), noDebug()).current;
                              let qualifierTree = $p.qualifierSubTree.children->toOne();
                              findAndAddChildrenAtTheEnd($qualifierTree, $qualifierTreeCurrent.values, $p.children).children;
                           }
                        )->map(nt| $nt->recurse_inlineQualifiedPropertyNodes());
                     },
                     | $p
                  );

   $newTrees->map(t| ^$t(children=$t.children->map(c| $c->recurse_inlineQualifiedPropertyNodes())));
}

function meta::pure::lineage::scanProperties::propertyTree::buildMultiLevelPropertyTrees(vs:ValueSpecification[1], mappings:Mapping[*], extensions:meta::pure::extension::Extension[*]):PropertyPathTree[*]
{
    $vs->buildMultiLevelPropertyTrees($mappings, $extensions, noDebug())
}

function meta::pure::lineage::scanProperties::propertyTree::buildMultiLevelPropertyTrees(vs:ValueSpecification[1], mappings:Mapping[*], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):PropertyPathTree[*]
{
   let res = ^Pair<ValueSpecification, List<PropertyPathTree>>(first=$vs, second=^List<PropertyPathTree>(values=[$vs->scanProperties($debug).result->buildPropertyTree()]));

   $mappings->fold({a, b| let reprocessedQuery = $b.first->cast(@FunctionExpression)->meta::pure::mapping::modelToModel::chain::allReprocess([], $a, $extensions, $debug).res;
                          let newPropertyTree = $reprocessedQuery->scanProperties($debug).result->buildPropertyTree();
                          ^$b(first = $reprocessedQuery,
                              second = ^List<PropertyPathTree>(values=$b.second.values->concatenate($newPropertyTree)));
                       },
                   $res).second.values;
}
