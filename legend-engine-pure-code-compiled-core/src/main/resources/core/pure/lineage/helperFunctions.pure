// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::lineage::analytics::*;

function meta::pure::lineage::analytics::inlineQualifiedProperties(vs: ValueSpecification[1], vars:Map<VariableExpression, ValueSpecification>[1], openVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*]):ValueSpecification[1]
{
   $vs->match([
      fe : FunctionExpression[1] | if(($fe.func->evaluateAndDeactivate()->instanceOf(QualifiedProperty) && !($fe.func->evaluateAndDeactivate()->cast(@QualifiedProperty<Any>).owner == TDSRow)) || ($fe.func->instanceOf(ConcreteFunctionDefinition) && !($fe.func->evaluateAndDeactivate()->instanceOf(NativeFunction) || $fe.func->evaluateAndDeactivate()->meta::pure::router::routing::shouldStop($extensions))),
                                      |
                                        let newParams = $fe.parametersValues->evaluateAndDeactivate()->map(x | $x->inlineQualifiedProperties($vars, $openVars, $extensions));
                                        let newFe  = ^$fe(parametersValues = $newParams);
                                        let qpExpr = $fe.func->evaluateAndDeactivate()->cast(@FunctionDefinition<Any>).expressionSequence->evaluateAndDeactivate()->last()->toOne();
                                        let newVars = $newFe->mapVariables(^Map<VariableExpression, ValueSpecification>(), $openVars);
                                        let feParams = $fe.func->evaluateAndDeactivate()->cast(@FunctionDefinition<Any>)->functionType().parameters->evaluateAndDeactivate();
                                        $qpExpr->inlineQualifiedProperties($newVars->putAll($feParams->size()->range()->map(p | pair($feParams->at($p), $newParams->at($p)))), $openVars, $extensions);,
                                      | ^$fe(parametersValues = $fe.parametersValues->evaluateAndDeactivate()->map(x | $x->inlineQualifiedProperties($vars, $openVars, $extensions)))
                                   ),
      iv : InstanceValue[1] | ^$iv
                              (
                                 values = $iv.values->evaluateAndDeactivate()->map(val | $val->match([
                                    l : LambdaFunction<Any>[1] | ^$l(expressionSequence = $l.expressionSequence->evaluateAndDeactivate()->at(0)->inlineQualifiedProperties($vars->putAll($l->functionType().parameters->evaluateAndDeactivate()->map(x| pair($x, $x))), $openVars, $extensions)),
                                    v : ValueSpecification[1] | $v->inlineQualifiedProperties($vars, $openVars, $extensions),
                                    a : Any[1] | $a
                                 ]))

                              ),
      ve : VariableExpression[1] | let resolved = $ve->resolve($vars, $openVars); if($resolved->isEmpty(), | $ve, | $resolved->toOne());,
      v  : ValueSpecification[1] | $v
   ]);
}