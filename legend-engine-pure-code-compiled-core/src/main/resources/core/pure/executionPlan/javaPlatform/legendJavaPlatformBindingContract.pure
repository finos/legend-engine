// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


import meta::external::language::java::metamodel::*;
import meta::external::language::java::metamodel::project::*;
import meta::external::language::java::transform::*;
import meta::pure::executionPlan::*;
import meta::pure::executionPlan::engine::java::*;
import meta::pure::executionPlan::platformBinding::*;
import meta::pure::executionPlan::platformBinding::legendJava::*;
import meta::pure::extension::*;
import meta::pure::graphFetch::*;
import meta::pure::mapping::*;

Class meta::pure::executionPlan::platformBinding::legendJava::LegendJavaExecutionPlanPlatformBindingConfig extends meta::pure::executionPlan::platformBinding::ExecutionPlanPlatformBindingConfig
{
}

function meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingId(): String[1]
{
   'LegendJava'
}

function meta::pure::executionPlan::platformBinding::legendJava::legendJavaPlatformBindingContract(): ExecutionPlanPlatformBindingContract[1]
{
   ^ExecutionPlanPlatformBindingContract
   (
      id = legendJavaPlatformBindingId(),

      bindPlanToPlatform = meta::pure::executionPlan::engine::java::generatePlatformCode_ExecutionPlan_1__ExecutionPlanPlatformBindingConfig_1__Extension_MANY__DebugContext_1__ExecutionPlan_1_
   )
}

Class meta::pure::executionPlan::platformBinding::legendJava::LegendJavaExecutionPlanPlatformBindingExtension extends ExecutionPlanPlatformBindingExtension
[
   id: $this.id == legendJavaPlatformBindingId()
]
{
   // Convention extensions -----------------------------------------------------------------------------------
   defaultProhibitedFunctions : Function<Any>[*];
   engineDependencyUpdates : Function<{Conventions[1]->Conventions[1]}>[*];
   // ----------------------------------------------------------------------------------- Convention extensions

   // Object reference extensions -----------------------------------------------------------------------------
   getParseObjectReferenceImplClass : Function<{String[1], Any[*], String[1], GenerationContext[1], DebugContext[1]->meta::external::language::java::metamodel::Class[0..1]}>[0..1];
   // ----------------------------------------------------------------------------- Object reference extensions

   // Graph fetch extensions ----------------------------------------------------------------------------------
   walkChildNodesForPrepare : Function<{String[1], GenerationContext[1], Extension[*], DebugContext[1] -> Function<{Nil[1]->GenerationContext[1]}>[*]}>[0..1];
   prepareNode : Function<{String[1], GenerationContext[1], Extension[*], DebugContext[1] -> Function<{Nil[1]->GenerationContext[1]}>[*]}>[0..1];
   generateCode : Function<{String[1], GenerationContext[1], Extension[*], DebugContext[1] -> Function<{Nil[1]->GeneratedCode[1]}>[*]}>[0..1];
   walkAndGenerateChildNodes : Function<{String[1], Mapping[1], GenerationContext[1], Extension[*], Project[0..1], DebugContext[1] -> Function<{Nil[1]->GeneratedNode[1]}>[*]}>[0..1];
   generateCodeForLocalGraphFetchNode : Function<{String[1], GenerationContext[1], Extension[*], DebugContext[1] -> Function<{Nil[1]->Project[1]}>[*]}>[0..1];
   updateImplementationClassWithStoreSpecificFieldsAndMethods : Function<{meta::external::language::java::metamodel::Class[1], GenerationContext[1], Extension[*], DebugContext[1] -> Function<{Nil[1]->Project[1]}>[*]}>[0..1];
   // ---------------------------------------------------------------------------------- Graph fetch extensions

   // Transformer extensions ----------------------------------------------------------------------------------
   sourceVariableNameForSetImplementation : Function<{Nil[1]->String[1]}>[0..1];
   extractTransformFunctionFromPropertyMapping : Function<{Nil[1]->FunctionDefinition<Any>[1]}>[*];
   extractValueTransformerFromPropertyMapping : Function<{Nil[1]->ValueTransformer<Any>[1]}>[*];
   applyTypeFilter : Function<{InstanceSetImplementation[1], Code[1], Code[1..*], GenerationContext[1], DebugContext[1]->Function<{Nil[1]->Code[*]}>[*]}>[0..1];
   addMapOneMethodForMappingAdaptor : Function<{Code[1], Code[1], Conventions[1], DebugContext[1] -> Function<{Nil[1]->Code[1]}>[*]}>[0..1];
   generatePropertyMappingCode : Function<{Conventions[1], DebugContext[1] -> Function<{Nil[1]->Code[1]}>[*]}>[0..1];
   // ---------------------------------------------------------------------------------- Transformer extensions

   // Stream reading extensions (will be removed with strategic external format support) ----------------------
   <<doc.deprecated>> getDataRecordTreeFromConnection : Function<{Nil[1] -> RootGraphFetchTree<Any>[0..1]}>[*];
   <<doc.deprecated>> getDataRecordTypeFromConnection : Function<{Nil[1] -> meta::pure::metamodel::type::Class<Any>[1]}>[*];
   <<doc.deprecated>> streamReaderMethodCodesFromConnection : Function<{String[1],meta::pure::metamodel::type::Class<Any>[1],Conventions[1],Code[1]->Function<{Nil[1] -> Code[1]}>[*]}>[0..1];
   // ---------------------- Stream reading extensions (will be removed with strategic external format support)

   // Execution plan interfaces extensions --------------------------------------------------------------------
   dataRecordClasses : meta::pure::metamodel::type::Class<Any>[*];
   // -------------------------------------------------------------------- Execution plan interfaces extensions
}
