// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::generation::*;
import meta::pure::generation::metamodel::*;
import meta::json::schema::generation::*;


Profile meta::pure::generation::metamodel::Generation
{
   stereotypes : [ Transformation, Configuration];
}

Class meta::pure::generation::metamodel::GenerationTree extends PackageableElement
{
  
}

Class meta::pure::generation::metamodel::GenerationSpecification extends PackageableElement
{

}

Class meta::pure::generation::metamodel::GenerationParameterItem
{
   types:Any[*];
   enums:Any[*];      
}

Class meta::pure::generation::metamodel::GenerationParameter
{
   name:String[1];
   description:String[0..1];
   type:String[1];
   required:Boolean[1];
   items:GenerationParameterItem[0..1];
   defaultValue: Any[0..1];
}

Class meta::pure::generation::metamodel::GenerationConfiguration
{    
   {doc.doc = 'Path to entity'} 
   class:String[0..1];
   
   {doc.doc = 'Path to base package'} 
   package: String[0..1];
   
   {doc.doc = 'List of packageable elements to determine the scope of generation'} 
   scopeElements: PackageableElement[*];
   
   {doc.doc = 'Path used as root for all files generated by config'} 
   generationOutputPath: String[0..1];
   
   allPackageScopeElements()
   {
      $this.scopeElements->filter(p | $p->instanceOf(Package))->map(p | $p->cast(@Package)->getAllPackageElements(true)) ->concatenate($this.scopeElements->filter(p | !$p->instanceOf(Package)));  
   }: PackageableElement[*];
}

Class meta::pure::generation::metamodel::GenerationOutput
{
   content:String[1];
   fileName:String[1];
   format:String[0..1];
   message:GenerationMessage[*];
}

Class meta::pure::generation::metamodel::GenerationMessage
{
   messageType:GenerationMessageType[1];
   message:String[1];
}

Enum  meta::pure::generation::metamodel::GenerationMessageType
{
  WARNING,
  ERROR
}


function meta::pure::generation::addError(existingMessage:GenerationMessage[*],message:String[1]):GenerationMessage[*]
{
  $existingMessage->concatenate(^GenerationMessage(messageType=GenerationMessageType.ERROR, message=$message));
}

function meta::pure::generation::addWarning(existingMessage:GenerationMessage[*],message:String[1]):GenerationMessage[*]
{
  $existingMessage->concatenate(^GenerationMessage(messageType=GenerationMessageType.WARNING, message=$message));
}


function meta::pure::generation::pathToFileName(path:String[0..1],extension:String[1]):String[1]
{
   if($path->isEmpty() ,|'',|$path->toOne()->replace('::','/')+'.'+$extension);
}

function  meta::pure::generation::describeConfiguration(configClass:Class<Any>[1], configCreator:Function<{->Any[1]}>[1],excludedProperties:String[*]):GenerationParameter[*]
{
    describeConfiguration($configClass, $configCreator->eval(), $excludedProperties);
}

function  meta::pure::generation::describeConfiguration(configClass:Class<Any>[1], defaultConfig:Any[1],excludedProperties:String[*]):GenerationParameter[*]
{
  let ignoredProperties = $excludedProperties->concatenate(['class','package']);
  let properties = $configClass->configProperties($ignoredProperties);
  
   
  let propertiesDef = $properties->map(p | let value=$p->evaluate(^List<Any>(values=[$defaultConfig]));
                                          // println($p.name);
                                           let isCollection = $p.multiplicity.upperBound.value->isEmpty();
                                       
                                           let defaultValue=if (!$isCollection,| if ($value->isEmpty(),|[],|$value->toOne()),|^List<Any>(values=$value));
                                          
                                           let rawType = $p.genericType.rawType->toOne();
                                          
                                           let rawTypeAsString = $rawType->match([ e:Enumeration<Any>[1] | 'enum'
                                                                                 , p:Class<Any>[1] | if($p.name=='Profile' || $p.name=='Class',|'String',|$p.name->toOne());
                                                                                 , a:PrimitiveType[1] | $a.name->toOne(); ]);
   
                                           let type= if (!$isCollection ,| $rawTypeAsString ,|'Array' );
                                           
                                           let enums = $rawType->match([ e:Enumeration<Any>[1] | $e->enumValues() ;, a:Any[1] |[] ]);
   
                                           let items = if (!$isCollection,| if($enums->isEmpty()
                                                                              ,|if(!$rawTypeAsString=='Map'
                                                                                  ,|[]
                                                                                  ,| let types = $p.genericType.typeArguments.rawType->map(t |$t ->meta::pure::generation::typeMap());
                                                                                     ^GenerationParameterItem(types=$types.name);)
                                                                              ,|^GenerationParameterItem(types=['string'],enums=$enums));
                                                                         
                                                                         ,| ^GenerationParameterItem(types=[$rawTypeAsString]));
                                       
                                           let required= $p.multiplicity.lowerBound.value > 0;
                                     
                                           let doc = $p->value4Tag('doc', meta::pure::profiles::doc);
   
                                           ^GenerationParameter(name=$p.name->toOne(),
                                                                description=$doc.value->joinStrings(','),
                                                                type=$type,
                                                                defaultValue=$defaultValue,
                                                                required=$required,
                                                                items=$items);
                                         );
}

function <<access.private>> meta::pure::generation::configProperties(configClass:Class<Any>[1], excludedProperties:String[*]):Property<Nil,Any|*>[*]
{
   if($configClass == Any || $configClass == GenerationConfiguration,
      | [],
      {|
         let props  = $configClass.properties->filter(p| !$p.name->in($excludedProperties));
         let supers = $configClass.generalizations->map(g| $g.general.rawType->cast(@Class<Any>)->toOne()->configProperties($excludedProperties));
         $supers->concatenate($props);
      }
   );
}

function <<access.private>> meta::pure::generation::typeMap(type: Type[1]): Type[1]
{
   $type->match([
      packageableElement: PackageableElement[1]| String;,
      t: Type[1]| $t;
    ]);
}