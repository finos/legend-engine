import meta::pure::changetoken::*;

Class <<typemodifiers.abstract>> 
{doc.doc='change tokens describe the changes to a data model from one version to the next. They are generated by a tool, then reviewed and updated by developers, and committed alongside the model changes.'} 
meta::pure::changetoken::ChangeToken 
{
  toString() { $this->toStringClassFields(); }: String[1];
}

Class 
{doc.doc='Version describes a single release to a data model and contains an order-dependent list of change tokens that transform the model from prevVersion to the present version.'}
meta::pure::changetoken::Version 
{
  {doc.doc='string version label, e.g. "ftdm:<sha1>"'}
  version: String[1];

  {doc.doc='reference to the previous version label'}
  prevVersion: String[0..1];

  {doc.doc='list of change tokens that describe the change to the model from prevVersion to Version'}
  changeTokens: ChangeToken[*];

  toString() { $this->toStringClassFields() }: String[1];
}

Class 
{doc.doc='A single linear sequence of versions of how the present model evolved over time'}
meta::pure::changetoken::Versions
[
  linearVersions: $this.versions->size()->range()->map(i|
    if($i==0,
    |$this.versions->at($i).prevVersion->size()==0,
    |$this.versions->at($i).prevVersion == $this.versions->at($i-1).version))
    ->fold({b,res|$b && $res}, true)
]
{
  {doc.doc='all versions in a sorted order from oldest to newest'}
  versions: meta::pure::changetoken::Version[*];

  toString() { $this->toStringClassFields() }: String[1];
}

Class <<typemodifiers.abstract>> 
{doc.doc='the root class for any change tokens affecting a single class'}
meta::pure::changetoken::ClassChangeToken extends ChangeToken 
{
  {doc.doc='affected class name, e.g. "meta::domain::ftdm::MyClass". It is a string because the class may no longer be present in the current model.'}
  class: String[1];
}

Class
{doc.doc='a class was added in this version'}
meta::pure::changetoken::AddedClass extends ClassChangeToken
{
}

Class 
{doc.doc='a class was removed in this version'}
meta::pure::changetoken::RemovedClass extends ClassChangeToken
{
}

Class <<typemodifiers.abstract>> 
{doc.doc='root of a hierarchy of getters for a default value of a newly-added field'}
meta::pure::changetoken::FieldGetter 
{
  toString() { $this->toStringClassFields() }: String[1];
}

Class 
{doc.doc='a constant value, e.g. 100 or "SomeValue"'}
meta::pure::changetoken::ConstValue extends FieldGetter 
{
  value: Any[1];
}

Class <<typemodifiers.abstract>> 
{doc.doc='a way to refer to another field for its value'}
meta::pure::changetoken::FieldReference 
{
  toString() { $this->toStringClassFields() }: String[1];
}

Class 
{doc.doc='refer to another field using a relative path in the serialized form'}
meta::pure::changetoken::RelativeFieldReference extends FieldReference 
{
  {doc.doc='relative path, e.g. "../../some/other/field"'}
  path: String[1];
}

Class 
{doc.doc='a field getter, which copies a value from another field'}
meta::pure::changetoken::CopyValue extends FieldGetter 
{
  {doc.doc='source field for the copied value'}
  source: meta::pure::changetoken::FieldReference[1];
}

Class 
<<typemodifiers.abstract>>
{doc.doc='a field addition or removal to/from a class'}
meta::pure::changetoken::AddRemoveField extends ClassChangeToken 
{
  fieldName: String[1];
  {doc.doc='a field\'s type'}
  fieldType: String[1]; 
  {doc.doc='where the default value for this field comes from'}
  defaultValue: meta::pure::changetoken::FieldGetter[1];
  {doc.doc='whether to fail if casting removes a non-default value'}
  safeCast: Boolean[1];
}

Class 
{doc.doc='a field is added to a class. We use the default for upcast to create and for downcast to delete if equal.'}
meta::pure::changetoken::AddField extends AddRemoveField
{
}

Class 
{doc.doc='a field is removed from a class. We use the default for downcast to create and for upcast to delete if equal.'}
meta::pure::changetoken::RemoveField extends AddRemoveField
{
}

Class 
{doc.doc='rename a field of a class'}
meta::pure::changetoken::RenameField extends ClassChangeToken
{
  oldFieldName: String[1];
  newFieldName: String[1];
}

Class 
{doc.doc='change the type of a field'}
meta::pure::changetoken::ChangeFieldType extends ClassChangeToken 
{
  fieldName: String[1];
  oldFieldType: String[1];
  newFieldType: String[1];
}

/*
** Various toString() helper functions for classes in this module
*/
function meta::pure::changetoken::toStringClassFields(a:Any[1]):String[1]
{
  let properties = $a->type()->generalizations()
    ->map(g|$g->cast(@Class<Any>))->filter(f|$f.package == meta::pure::changetoken)
    ->map(c|$c.properties)->concatenate([]);

  format('%s(%s)', 
  [
    $a->type()->elementToPath(), 
    $properties->map(p|
      $p->elementToPath() + '=' + $p->rawEvalProperty($a)->toStringGeneric()
    )->joinStrings(',')
  ]);
}

function meta::pure::changetoken::toStringGeneric(a:Any[*]):String[1]
{
  $a->match([
    a1:Any[1]|$a1->toStringGeneric(),
    a2:Any[*]|$a2->map(v|$v->toStringGeneric())->joinStrings('[', ',', ']')
  ]);
}

function meta::pure::changetoken::toStringGeneric(a:Any[1]):String[1]
{
  $a->match([
    a1:ChangeToken[1]| $a1.toString(),
    a2:String[1]| '"' + $a2 + '"',
    a3:FieldGetter[1]| $a3->toString(),
    a4:FieldReference[1]| $a4->toString(),
    a5:Version[1]| $a5->toString(),
    a6:Versions[1]| $a6->toString(),
    a7:Number[1]| $a7->toString(),
    a8:Type[1]| $a8->elementToPath(),
    a8:Boolean[1]| $a8->toString()
  ]);
}
