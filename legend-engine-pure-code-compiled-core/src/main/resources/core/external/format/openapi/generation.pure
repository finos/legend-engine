import meta::external::format::openapi::metamodel::*;
import meta::pure::service::*;
import meta::legend::service::metamodel::*;
import meta::external::format::openapi::generation::*;
import meta::pure::functions::meta::*;
import meta::pure::metamodel::path::*;
import meta::pure::service::*;

Class meta::external::format::openapi::generation::FunctionInfo
{
  version: String[0..1];
  title: String[0..1];
  func: Function<Any>[1];
  tags: String[*];
  urlPattern: String[1];
  paramsExample: Map<String, String>[1];
}

function meta::external::format::openapi::generation::serviceToOpenApi(service: Service[1], server: Server[1]):String[1]
{
  ^FunctionInfo
  (
    func = $service.execution->cast(@PureExecution).func,
    tags = 'definition',
    urlPattern = $service.pattern,
    version = '1.0.0',
    title = 'Legend API',
    paramsExample = ^Map<String,String>()
  )->meta::external::format::openapi::generation::funcInfoToOpenApi($server)
  ->asString()->makeString()->replace('\\/','/')
  ->replace('\"ref\"','\"$ref\"')
  ->replace('"_type":"schema"','')
  ->replace('"_type":"reference",','')
  ->replace('"_type":"parameter"','')
  ->replace(',}','}');
}

function <<access.private>> meta::external::format::openapi::generation::funcInfoToOpenApi(funcInfos:FunctionInfo[*], server:Server[1]):JSONResult<OpenApi|1>[1]
{
  let allClasses = $funcInfos->returnTypesFromAllFunctions();
  let result = ^OpenApi(
    openapi='3.0.0',
    info=^Info(title='Legend API', version='1.0.0'),
    servers=[^Server(url=$server.url)],
    paths=newMap($funcInfos->map(fi|let url = $fi.urlPattern;
                                    let paramsExample = $fi.paramsExample;
                                    let ftype = $fi.func->functionType();
                                    let ret = $ftype.returnType;
                                    pair($url,
                                            ^PathItem(
                                                      get=^Operation(
                                                      tags=$fi.tags,
                                                      parameters = $ftype.parameters->evaluateAndDeactivate()->map(p|let val=$paramsExample->get($p.name->toOne());
                                                                                                                      let required = $p.multiplicity->hasLowerBound() && $p.multiplicity->getLowerBound() == 1;
                                                                                                                      let type = $p.genericType.rawType->match([
                                                                                                                      p:PrimitiveType[1] | $p->primitiveType(),
                                                                                                                      e:Enumeration<Enum>[1]| 'string'
                                                                                                                      ]);
                                                                                                                      let enums = $p.genericType.rawType->match([
                                                                                                                          p: PrimitiveType[1] | [],
                                                                                                                          e: Enumeration<Enum>[1] | $e->enumValues().name,
                                                                                                                          c: Class<Any>[1] | []
                                                                                                                      ]);
                                                                                                                      ^Parameter(
                                                                                                                      _type='parameter',
                                                                                                                      name=$p.name->toOne(),
                                                                                                                      in = if($required, | In.path, | In.query),
                                                                                                                      required = $required
                                                                                                                      );
                                                                                                                  ),
                                                      responses = newMap(
                                                                  pair('200', ^Response(
                                                                                description='success',
                                                                                content=$ret->buildResponseSchema([])
                                                                              )
                                                                      )
                                                                  )
                                                      ),
                                                      post=^Operation(
                                                      tags=$fi.tags,
                                                      responses = newMap(
                                                                  pair('200', ^Response(
                                                                                description='success',
                                                                                content=$ret->buildResponseSchema([])
                                                                              )
                                                                      )
                                                                  )
                                                      )
                                                    )
                                          );
                                  )
                  ),  
    components= ^Components(schemas=newMap(
                    $allClasses->map(
                          c|pair(
                            $c.rawType.name->toOne(),
                            ^Schema
                            (
                              _type='schema',
                              type='object',
                              properties=newMap(
                                $c.rawType->cast(@Class<Any>).properties
                                  ->filter(p|$p.name!='elementOverride' && $p.name!='classifierGenericType')
                                  ->map(p|
                                          pair
                                          (
                                            $p.name->toOne(),
                                            $p->functionReturnType()->buildComponent($p.multiplicity)
                                          )
                                      )
                              )
                            )
                          )
                    )
    )));
  
  meta::external::format::openapi::tostring::openApiJSONResult($result);
}


function <<access.private>> meta::external::format::openapi::generation::returnTypesFromAllFunctions(funcInfos:FunctionInfo[*]):GenericType[*]
{
  $funcInfos.func->cast(@Function<Any>)->map(f|$f->cast(@LambdaFunction<Any>).expressionSequence->evaluateAndDeactivate()->toOne()->cast(@SimpleFunctionExpression)->match(
    [
      p:AbstractProperty<Any>[1]| $p.genericType,
      p:Path<Nil,Any|*>[1]| $p.classifierGenericType->toOne().typeArguments->at(1),
      f:NativeFunction<Any>[1] | $f->genericType().typeArguments->at(0).rawType->toOne()->cast(@FunctionType).returnType,
      f:FunctionDefinition<Any>[1]| $f->genericType().typeArguments->at(0).rawType->toOne()->cast(@FunctionType).returnType,
      s:SimpleFunctionExpression[1]| if($s.resolvedTypeParameters->size() > 0,|$s.resolvedTypeParameters->toOne().rawType->toOne().classifierGenericType->toOne().typeArguments->at(0),|^GenericType()),
      a:Any[1]| assert(false, |'functionReturnType not supported yet for the type'+$a->type()->id());^GenericType();
    ]
  ))
  ->map(r|if($r.rawType==JSONResult,|$r.typeArguments,|$r))
  ->filter(c|!$c.rawType->isEmpty() && $c.rawType->toOne()->instanceOf(Class))
  ->map(t|if($t.rawType.specializations->isEmpty(),|$t,|$t.rawType->toOne()->getLeafTypes().classifierGenericType.typeArguments))
  ->removeDuplicates(cmpGenericType_GenericType_1__GenericType_1__Boolean_1_)
  ->map(t|$t->scanClass([]))
  ->removeDuplicates(cmpGenericType_GenericType_1__GenericType_1__Boolean_1_)
  ->sortBy(a|$a.rawType.name->toOne())
  ->concatenate(($funcInfos->returnTypesFromFunctions()))
  ->removeDuplicates(cmpGenericType_GenericType_1__GenericType_1__Boolean_1_);
}


function <<access.private>> meta::external::format::openapi::generation::returnTypesFromFunctions(funcInfos:FunctionInfo[*]):GenericType[*]
{
  $funcInfos.func->cast(@Function<Any>)
  ->map(f|$f->functionReturnType())
  ->map(r|if($r.rawType==JSONResult,|$r.typeArguments,|$r))
  ->filter(c|!$c.rawType->isEmpty() && $c.rawType->toOne()->instanceOf(Class))
  ->map(t|if($t.rawType.specializations->isEmpty(),|$t,|$t.rawType->toOne()->getLeafTypes().classifierGenericType.typeArguments))
  ->removeDuplicates(cmpGenericType_GenericType_1__GenericType_1__Boolean_1_)
  ->map(t|$t->scanClass([]))
  ->removeDuplicates(cmpGenericType_GenericType_1__GenericType_1__Boolean_1_)
  ->sortBy(a|$a.rawType.name->toOne());
}

function <<access.private>> meta::external::format::openapi::generation::buildResponseSchema(type:GenericType[1], m:Multiplicity[0..1]):Map<String,MediaType>[1]
{
  $type->buildComponent($m)->map(res|newMap(pair('application/json', ^MediaType(schema=$res))));
}

function <<access.private>> meta::external::format::openapi::generation::buildComponent(type:GenericType[1], m:Multiplicity[0..1]):SchemaOrReference[1]
{
  $type->map(r|if($r.rawType==JSONResult,|$r.typeArguments,|$r)).rawType
  ->match(
    [
      r: PrimitiveType[1]|^Schema(_type='schema', type=$r->primitiveType()),
      e: Enumeration<Enum>[1]|^Schema(_type='schema', type='string', enum=$e->enumValues().name),
      c: Class<Any>[1]| if(!$m->isEmpty() && $m->toOne()->isToMany(),
                           |^Schema(_type='schema', type='array', items=^Reference(_type='reference', ref=$c.name->toOne())),
                           |^Reference(_type='reference', ref=$c.name->toOne())
      ),
      a: Any[*]| ^Schema(_type='schema', type='object')
    ]
  )
}

function <<access.private>> meta::external::format::openapi::generation::primitiveType(type:PrimitiveType[1]):String[1]
{
  [
    pair(String, 'string'),
    pair(Date, 'dateTime'),
    pair(DateTime, 'dateTime'),
    pair(StrictDate, 'date'),
    pair(Boolean, 'boolean'),
    pair(Integer, 'integer'),
    pair(Float, 'float'),
    pair(Number, 'float')
  ]->filter(t|$t.first==$type).second->toOne();
}


function <<access.private>> meta::external::format::openapi::generation::scanClass(c:GenericType[1], allClasses:GenericType[*]):GenericType[*]
{
  let propertyTypes = $c->properties()->filter(p|$p.owner!=Any)->map(p|$p->functionReturnType()->filter(c|!$c.rawType->isEmpty() && $c.rawType->toOne()->instanceOf(Class)));
  let diff = $propertyTypes->removeAll($allClasses, cmpGenericType_GenericType_1__GenericType_1__Boolean_1_)->removeDuplicates(cmpGenericType_GenericType_1__GenericType_1__Boolean_1_);
  $c->concatenate($diff->map(z|$z->scanClass($allClasses->concatenate($c->concatenate($diff)))));
}

function <<access.private>> meta::external::format::openapi::generation::cmpGenericType(t1: GenericType[1], t2:GenericType[1]):Boolean[1]
{
  $t1.rawType == $t2.rawType &&
  $t1.typeArguments->size() == $t2.typeArguments->size() &&
  $t1.typeArguments->zip($t2.typeArguments)->fold({ta,f|$f && $ta.first.rawType==$ta.second.rawType}, true)
}

function <<access.private>> meta::external::format::openapi::generation::processParamsExample(val: String[0..1]):Map<String,String>[1]
{
  if($val->isEmpty(),
  |^Map<String,String>(),
  |newMap($val->toOne()->split(',')->map(s|$s->trim())->map(v|let res=$v->split('='); pair($res->at(0)->trim(), $res->at(1)->trim());))
  );
}