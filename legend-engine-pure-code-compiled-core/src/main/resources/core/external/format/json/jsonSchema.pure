// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::metamodeJSONSchemaConfigl::path::*;
import meta::external::format::yaml::serialization::*;
import meta::external::format::yaml::*;
import meta::external::format::yaml::metamodel::*;
import meta::pure::generation::*;
import meta::pure::generation::metamodel::*;
import meta::pure::profiles::doc::*;
import meta::pure::profiles::*;
import meta::pure::mapping::*;
import meta::json::schema::*;
import meta::json::schema::constraint::*;
import meta::json::schema::generation::*;
import meta::json::*;


Profile meta::json::schema::JSONSchemaGeneration
{
    stereotypes:[noAdditionalProperties,readOnly,writeOnly];
    tags:[defaultValue,name,example,title];

}
//Stereotypes to support schema generation of types that do not exist in Pure or to force generation of a specific schema type
Profile
meta::json::schema::JSONSchemaTypeExtension
{
    stereotypes:[int64,int32,byte,double,binary,array,null,object];

}
//Profile to support schema generation of commonly used tags not officially part of JSON Specifications
Profile meta::json::schema::JSONSchemaJavaExtension
{
    tags:[javaType,javaInterface];

}

Profile meta::json::schema::JSONSchemaOpenAPIExtension
{
   stereotypes:[discriminatorProperty];
   tags:[discriminatorName];

}

Class meta::json::schema::generation::JSONSchemaConfig extends GenerationConfiguration
{
  {doc.doc='Generate JSON schema constraints from class constraints, unsupported functions will not generate'}useConstraints:Boolean[0..1];  //defaults false
  {doc.doc='Include related types in a definitions element on the schema, ignored if generating openAPI'}  includeAllRelatedTypes:Boolean[0..1];  // defaults true - if true , dependencies generate to definitions elements
  {doc.doc='If true,An additional schema will be generated that can be used as a collection of subTypes' }generateAnyOfSubType:Boolean[0..1];  // defaults false - if true , SuperTypes generate an additional anyOf for all the subTypes.
  {doc.doc='If true, constraint functions generate as schema files, if false constraint function content is in-lined with the parent schema' }generateConstraintFunctionSchemas:Boolean[0..1];  // defaults false - if true , functions generate seperate schemas.
  {doc.doc='The specification which your schema should be compatible with' }schemaSpecification:JSONSchemaSpecification[0..1];
  {doc.doc='Generate a components or definitions collection, if true, only one file will generate with a collection of related elements in scope for execution and there will be no root element in the schema' }createSchemaCollection:Boolean[0..1];
  {doc.doc='Generate milestoned properties on schemas' }generateMilestoneProperties:Boolean[0..1]; //defaults false - If true - the auto-gen milestoned properties will be included on generated schemas


}

Class <<access.protected>> meta::json::schema::JSONSchemaConfigInternal
{
   useConstraints:Boolean[1];  //defaults false
   includeAllRelatedTypes:Boolean[1];  // defaults true - if true , dependencies generate to definitions elements
   useDefinitions:Boolean[1];  //defaults to value of includeAllRelatedTypes - used for second pass
   rootLevel:Boolean[1];//indicates if we are on first pass of generation
   generateAnyOfSubType:Boolean[1];  // defaults false - if true , SupertTypes generate a oneOF for all the subTypes.
   generateConstraintFunctionSchemas:Boolean[1];
   rootElement:Any[0..1]; //root element for correct reletiveReferences
   schemaSpecification:JSONSchemaSpecification[1];
   scopeElements: PackageableElement[*];
   fileType:String[1];
   createSchemaCollection:Boolean[1]; //defaults false, if true all elements generate as a single collection
   generateMilestoneProperties:Boolean[1];  //defaults false - If true - the auto-gen milestoned properties will be included on generated schemas
   anyOfMember:Boolean[1];  //Indicates if we are generating an object inside an anyOf

}


Enum{doc.doc='The versions of schema generation supported by the generator'}
meta::json::schema::generation::JSONSchemaSpecification
{
   OPEN_API_V3_0_3,
   JSON_SCHEMA_DRAFT_07,
   JSON_SCHEMA_2019_09,
   OPEN_API_V3_0_3_YAML,
   OPEN_API_V3_0_3_YAML_PLAIN
}

Class meta::json::schema::generation::JSONSchemaOutput extends GenerationOutput
{
}


function meta::json::schema::generation::toJSONSchema( input:JSONSchemaConfig[1] ) : JSONSchemaOutput[*]
{
    meta::legend::test::mayExecuteLegendTest(
       {clientVersion, serverVersion, serializationKind, host, port|
                   let fStr = 'meta::protocols::pure::'+$clientVersion+'::invocation::generation::json::legendGenerateJson_JSONSchemaConfig_1__String_1__Integer_1__String_1__JSONSchemaOutput_MANY_';
                   let xf = $fStr->pathToElement()->cast(@Function<{JSONSchemaConfig[1], String[1], Integer[1], String[1]->GenerationOutput[*]}>);
                   $xf->evaluate([$input, $host, $port, $serverVersion]->map(v|list($v)))->toOneMany()->cast(@JSONSchemaOutput);},
       |meta::json::schema::generation::internal_toJSONSchema($input)
    )->toOneMany()

}

function <<Generation.Transformation>> meta::json::schema::generation::internal_toJSONSchema(input:JSONSchemaConfig[1] ) : JSONSchemaOutput[*]
{

   let possibleElement = forgivingPathToElement($input.class->toOne());
   assertNotEmpty($possibleElement, | $input.class->toOne() + ' was not found');

   let element = $possibleElement->toOne();
   $element->assertInstanceOf(Type, | 'Element is not a Type:' + $element->toString());
   meta::json::schema::generation::generateJsonSchemaFromPure($input, $element->cast(@Type));
}

function meta::json::schema::generation::generateJsonSchemaFromPureWithScope(config:JSONSchemaConfig[1]):JSONSchemaOutput[*]
{
   $config.scopeElements->filter(e| !$e->instanceOf(Package))->map(e|assert($e->instanceOf(Type) || $e->instanceOf(ConcreteFunctionDefinition )   ||$e->instanceOf(Profile)  || $e->instanceOf(Association ) ,' JsonSchema generation of ' + $e->type().name->toOne()+ ' is not currently supported. Tried to generate json schema for '+ $e->elementToPath()) ;);
   let scopeElements = $config.allPackageScopeElements()->filter(e| $e->instanceOf(Type) ||$e->instanceOf(FunctionDefinition) );
   let internalConfig = $config->externalToInternalConfig();
   if($internalConfig.createSchemaCollection,
         |  $scopeElements->meta::json::schema::schemaCollectionOutput($internalConfig),
         | $scopeElements->map(e|$e->match([ t:Type[1]| $config->meta::json::schema::generation::generateJsonSchemaFromPure($t),
                                             f:FunctionDefinition<Any>[1] | $internalConfig->generateFunctionSchema($f)]
                                           );
                               );
       );
}

function meta::json::schema::generation::generateJsonSchemaFromPure(config:JSONSchemaConfig[1], element: Type[1]) : JSONSchemaOutput[*]
{
   generateJsonSchemaFromPure_internal($config,$element);
}

function <<access.protected>> meta::json::schema::generateJsonSchemaFromPure_internal(config:JSONSchemaConfig[1], element: Type[1]) : JSONSchemaOutput[*]
{
   let internalConfig = $config->externalToInternalConfig();
   let schemaResult = $element->toJSONSchema([],$internalConfig);
   let content = $schemaResult.schema->jsonSchemaString($internalConfig);
   let types = ^JSONSchemaOutput(content=$content,fileName=$element->elementName($internalConfig,true,true,[]), format=$internalConfig.fileType,message=$schemaResult.message);
$types;
}

function <<access.protected>> meta::json::schema::schemaCollectionOutput(elements:PackageableElement[*],config:JSONSchemaConfigInternal[1]) : JSONSchemaOutput[*]
{
   let schemaResult =  $elements->meta::json::schema::schemaCollection($config);
   let types = ^JSONSchemaOutput(content= $schemaResult.schema->jsonSchemaString($config),fileName='model.'+$config.fileType, format=$config.fileType,message=$schemaResult.message);

}


function <<access.protected>> meta::json::schema::generateFunctionSchema(config:JSONSchemaConfigInternal[1], element:FunctionDefinition<Any>[1]) : JSONSchemaOutput[*]
{
   let functionDef =$element->cast(@ConcreteFunctionDefinition<Any>)->toJSONSchemaFromFunctionDefinition($config);

   let objectTag = if($element->hasStereotype('object',JSONSchemaTypeExtension),
                              |newJSONKeyStringValue('type','object'),
                              |[]);

   let schema = if($functionDef.constraint->isNotEmpty(),|$functionDef.constraint->toOne()->cast(@JSONObject),|^JSONObject());

   let elementTags = $element->elementTags($config);

  let header = [$element -> title()]->concatenate($objectTag) ->concatenate($element -> schema($config.schemaSpecification))->concatenate($elementTags);

  let updatedSchema = ^$schema(keyValuePairs+=$header);

  ^JSONSchemaOutput(content= $updatedSchema->jsonSchemaString($config),fileName=$element->elementName($config,true,true,[]), format=$config.fileType, message=$functionDef.generationMessage);

}

function <<access.private>> meta::json::schema::jsonSchemaString(element:JSONElement[1],config:JSONSchemaConfigInternal[1]):String[1]
{
  if($config.schemaSpecification->isYAML(),
     | if($config.schemaSpecification->isPlainYAML(),
            |$element->meta::json::schema::JSONToYaml()->toYAMLString(FlowScalarStyle.PLAIN),
            |$element->meta::json::schema::JSONToYaml()->toYAMLString(FlowScalarStyle.DOUBLE_QUOTE)
          ),
      |$element->meta::json::toPrettyJSONString()
   )

}


function <<access.private>> meta::json::schema::jsonFileName(type:Type[1],config:JSONSchemaConfigInternal[1]):String[1]
{
    $type->elementToPath()->pathToFileName($config.fileType);
}

function <<access.private>> meta::json::schema::generation::defaultConfig():JSONSchemaConfig[1]
{
 ^JSONSchemaConfig(useConstraints=true,
                   includeAllRelatedTypes=true,
                   schemaSpecification = JSONSchemaSpecification.JSON_SCHEMA_DRAFT_07
                   );
}

function <<Generation.Configuration>> meta::json::schema::generation::describeConfiguration():GenerationParameter[*]
{
   meta::pure::generation::describeConfiguration(JSONSchemaConfig,meta::json::schema::generation::defaultConfig__JSONSchemaConfig_1_,[])->filter(p|!$p.name->in(['generateMilestoneProperties']));




}




function <<access.externalizable>> {service.url='/jsonschema/{typeAsString}', service.contentType='application/json'}
meta::json::schema::toJSONSchema( typeAsString:String[1] ) : String[1]
{
   meta::json::schema::generation::toJSONSchema(^JSONSchemaConfig(class=$typeAsString))->at(0).content;
}


function meta::json::schema::generation::toJSONSchema( type:Type[1],config:JSONSchemaConfig[1] ) : JSONObject[1] {

   let internalConfig = $config->meta::json::schema::externalToInternalConfig();
   $type->toJSONSchema( $type, $internalConfig).schema;
}




function <<access.private>> meta::json::schema::defaultInternalConfig() : JSONSchemaConfigInternal[1] {
   ^JSONSchemaConfigInternal(useConstraints =false,
                             includeAllRelatedTypes = true,
                             useDefinitions = true,
                             rootLevel = true,
                             generateAnyOfSubType=false,
                             generateConstraintFunctionSchemas= false,
                             schemaSpecification = JSONSchemaSpecification.JSON_SCHEMA_DRAFT_07,
                             fileType='json',
                             createSchemaCollection = false,
                             generateMilestoneProperties = false,
                             anyOfMember = false
                              )
  }

function <<access.protected>> meta::json::schema::externalToInternalConfig(config:JSONSchemaConfig[0..1]) : JSONSchemaConfigInternal[1] {
  if($config->isEmpty() ,
      | defaultInternalConfig(),
      | let useConstraints = if($config.useConstraints->isEmpty(),|false,|$config.useConstraints->toOne());
        let generateAnyOfSubType = if($config.generateAnyOfSubType->isEmpty(),|false,|$config.generateAnyOfSubType->toOne());
        let generateConstraintFunctionSchemas = if($config.generateConstraintFunctionSchemas->isEmpty(),|false,|$config.generateConstraintFunctionSchemas->toOne());
        let schemaSpecification =   if($config.schemaSpecification->isEmpty(),|JSONSchemaSpecification.JSON_SCHEMA_DRAFT_07,|$config.schemaSpecification->toOne());
        let fileType =   if($config.schemaSpecification->isEmpty(),|'json',|if($config.schemaSpecification->toOne()->meta::json::schema::isYAML() ,|'yaml',|'json'));
        let includeAllRelatedTypes = if($schemaSpecification->isOpenAPI(),|false,|if($config.includeAllRelatedTypes->isEmpty(),|true,| $config.includeAllRelatedTypes->toOne()));  
        let generateMilestoneProperties = if($config.generateMilestoneProperties->isEmpty(),|false,|$config.generateMilestoneProperties->toOne());
        let createSchemaCollection =   if($config.createSchemaCollection->isEmpty(),|false,|$config.createSchemaCollection->toOne());
      ^JSONSchemaConfigInternal(useConstraints =$useConstraints,
                                   includeAllRelatedTypes = $includeAllRelatedTypes,
                                   useDefinitions=$includeAllRelatedTypes,
                                   rootLevel=true,
                                   generateAnyOfSubType=$generateAnyOfSubType,
                                   generateConstraintFunctionSchemas= $generateConstraintFunctionSchemas,
                                   schemaSpecification =$schemaSpecification,
                                   scopeElements = $config.allPackageScopeElements(),
                                   fileType = $fileType ,
                                   createSchemaCollection = $createSchemaCollection,
                                   generateMilestoneProperties = $generateMilestoneProperties,
                                   anyOfMember = false
                                     );
     );

  }

function meta::json::schema::toJSONSchema( type:Type[1] ) : JSONObject[1] {
   $type->toJSONSchema( $type, defaultInternalConfig()).schema;
}


function <<access.private>> meta::json::schema::toJSONRepresentation( values:TaggedValue[0..*],JSONTagName:String[1],type:Type[0..1] ) : JSONKeyValue[0..1]
{

  let jsonValues = $values->map(v| if($type->isNotEmpty(),
                                       |$v.value->parsePureStringtoJSONValue($type->toOne()),
                                       |if($v.value->toOne()->isDigit(),
                                             |if($v.value->contains('.'),
                                                 |^JSONNumber(value=$v.value->toOne()->parseFloat()),
                                                 |^JSONNumber(value=$v.value->toOne()->parseInteger())
                                                 ),
                                                 |^JSONString(value=$v.value->toOne());));
                                 );


let value = if($jsonValues->size()>1,
                |^JSONArray(values=$jsonValues),
                    | $jsonValues );


if($value->isNotEmpty(),|  newJSONKeyValue($JSONTagName,$value->toOne()),|[]);
}



function <<access.protected>> meta::json::schema::toJSONSchema( type:Type[1], root:Type[0..1], config:JSONSchemaConfigInternal[1] ) : JsonSchemaGenerationResult[1]
{
   let javaType = $type->javaTypeReference();
   let javaInterfaces = $type->javaInterfaceReference();

   let schemaType = if($type->instanceOf(Class),|newJSONKeyStringValue( 'type', 'object'),|[]);
   let initialKeys =  $type -> schema($config.schemaSpecification)->concatenate( if($config.anyOfMember,|[],| $type -> title()));

   //let allOf = if($type->instanceOf(Class),|$type->cast(@Class<Any>)->allOfGeneralizations($config),|[]);
   let properties  =   meta::json::schema::schemaProperties($type,$root,$config);

  let schema = newJSONObject(  [ $initialKeys  ]
                                          ->concatenate($type -> elementTags($config))
                                          ->concatenate($javaType)
                                          ->concatenate($javaInterfaces)
                                          -> concatenate($properties.key)
                                          );


^JsonSchemaGenerationResult(schema = $schema, message = $properties.message );
}


function meta::json::schema::schemaProperties(type:Type[1], root:Type[0..1], config:JSONSchemaConfigInternal[1]):JsonSchemaKeyValueMessage[1]
{
   let schemaType = if($type->instanceOf(Class),|newJSONKeyStringValue( 'type', 'object'),|[]);

   let properties  =    if( $type->isEnum(),
                             |   let default = $type->cast(@ElementWithTaggedValues)->value4Tag('defaultValue',JSONSchemaGeneration);
                                 let defaultTag = $default->first()->toJSONRepresentation('default',[]);
                                ^JsonSchemaKeyValueMessage(key=$type->cast(@Enumeration<Any>)->enum()->concatenate($defaultTag)->concatenate( newJSONKeyStringValue( 'type', 'string')->addNullType($type,$config)));,
                             |
                               let class = $type->cast(@Class<Any>);
                               let constraints = if($config.useConstraints ,| $class.constraints->map(c|$c->meta::json::schema::constraint::toJSONSchemaFromConstraint(^$config(rootElement=$class))),|[]);

                               let constraintsNoRef = if($config.useConstraints && $config.generateConstraintFunctionSchemas,| $class.constraints->map(c|$c->meta::json::schema::constraint::jsonSchemaConstraintsWithoutRef($config)),|$constraints);

                               let rootClass = $root->cast(@Class<Any>);
                               let required = $class->required($config);
                               let properties =  if( $config.generateAnyOfSubType && !$config.anyOfMember && !$config.rootLevel,
                                                               |  [],
                                                               |  properties( $class,$rootClass,$constraints,$constraintsNoRef,$config));

                                let anyOf = if( $config.generateAnyOfSubType && !$config.anyOfMember ,
                                                               |$class-> meta::json::schema::specializationsAnyOf($rootClass,$config),
                                                               | []);



                               let res =  if($config.generateAnyOfSubType && $config.anyOfMember,|[],|$class->allOfGeneralizations($config))
                                              ->concatenate( if($config.anyOfMember,|$class->title(),|[]))
                                              ->concatenate( $schemaType)
                                              ->concatenate(if($properties.key.value->cast(@JSONObject).keyValuePairs->isEmpty()  ,|[],|$properties.key) )
                                              ->concatenate($anyOf.key)
                                              ->concatenate(if($type->hasStereotype('noAdditionalProperties',JSONSchemaGeneration),
                                                                  |additionalProperties(false),
                                                                  |[] )
                                                             )->concatenate($class->addDiscriminator($config))->concatenate(  $required);

                               ^JsonSchemaKeyValueMessage(key =if ($config.includeAllRelatedTypes && $config.rootLevel,
                                                                 | $res->concatenate($class->definitions($class,$config)),
                                                                 | $res),
                                                      message=$constraints.generationMessage->concatenate($properties.message));

);
}



function meta::json::schema::createObjectProperty( class:Class<Any>[1] ) : JSONKeyValue[1]
{
   $class->createObjectProperty([],true,[],defaultInternalConfig());
}

function meta::json::schema::createObjectProperty( class:Class<Any>[1], root:Class<Any>[0..1] ) : JSONKeyValue[1]
{
   $class->createObjectProperty($root,true,[],defaultInternalConfig());

}

function meta::json::schema::javaInterfaceReference( type:Type[1] ) : JSONKeyValue[0..1]
{
   if($type->value4Tag('javaInterface',JSONSchemaJavaExtension )->isNotEmpty(),
      |newJSONKeyValue('javaInterfaces',   ^JSONArray(values= $type->value4Tag('javaInterface',JSONSchemaJavaExtension ).value->map(v | ^JSONString(value=$v->toOne())))),
      |[]  );


}

function meta::json::schema::javaTypeReference( type:Type[1] ) : JSONKeyValue[0..1]
{
   if($type->value4Tag('javaType',JSONSchemaJavaExtension )->isNotEmpty(),|newJSONKeyStringValue('javaType',$type->value4Tag('javaType',JSONSchemaJavaExtension ).value->toOne()),|[]  );
}

function meta::json::schema::additionalProperties( hasAdditionalProperties:Boolean[1] ) : JSONKeyValue[1]
{
   newJSONKeyValue('additionalProperties', ^JSONBoolean( value = $hasAdditionalProperties ) );
}

function meta::json::schema::unevaluatedProperties( ) : JSONKeyValue[1]
{
   newJSONKeyValue('unevaluatedProperties', ^JSONBoolean( value = false ) );
}


function meta::json::schema::enum( type:Enumeration<Any>[1] ) : JSONKeyValue[1]
{
    let nullValue = if($type->hasStereotype('null',JSONSchemaTypeExtension),|^JSONNull(),|[]);

    let enumValues = $type->enumValues()->map(s|  let enumTagValue = $s->cast(@ElementWithTaggedValues)->value4Tag('name',JSONSchemaGeneration);
                                                     let value = if($enumTagValue->isNotEmpty(),
                                                                      |assert($enumTagValue->size()==1,'can only have 1 enumTagValue per enumValue');
                                                                       $enumTagValue.value->toOne();,
                                                                      |$s->cast(@Enum).name
                                                                        );

                                                     ^JSONString(value=$value);
                                                )->concatenate($nullValue);


       newJSONKeyValue('enum', ^JSONArray(values=$enumValues));
}


function meta::json::schema::newJSONKeyStringValueAsObject( key:String[1], value:String[1] ) : JSONObject[1]
{
   newJSONObject( [ newJSONKeyStringValue( $key, $value) ] );
}

function meta::json::schema::newJSONKeyStringValue( key:String[1], value:String[1] ) : JSONKeyValue[1]
{
   newJSONKeyValue( $key, ^JSONString( value = $value ));
}

function meta::json::schema::newJsonRef( element:PackageableElement[1] ) : JSONKeyValue[1]
{
   newJsonRef( $element, [],true,[],defaultInternalConfig()) ;
}

function <<access.protected>> meta::json::schema::newJsonRef( element:FunctionDefinition<Any>[1], root:Any[0..1],useDefinitions:Boolean[1],propertyOwner:Any[0..1],config:JSONSchemaConfigInternal[1] ) : JSONKeyValue[1]
{
    $element->cast(@PackageableElement)->newJsonRef($root, $useDefinitions, $propertyOwner, $config);
}

function <<access.protected>> meta::json::schema::newJsonRef( element:Type[1], root:Any[0..1],useDefinitions:Boolean[1],propertyOwner:Any[0..1],config:JSONSchemaConfigInternal[1] ) : JSONKeyValue[1]
{
    $element->cast(@PackageableElement)->newJsonRef($root, $useDefinitions, $propertyOwner, $config);
}

function <<access.protected>> meta::json::schema::newJsonRef( element:PackageableElement[1], root:Any[0..1],useDefinitions:Boolean[1],propertyOwner:Any[0..1],config:JSONSchemaConfigInternal[1] ) : JSONKeyValue[1]
{
   newJSONKeyStringValue( '$ref', calculateJSONRef($element,$root,$useDefinitions,$propertyOwner,$config) ) ;
}

function <<access.protected>> meta::json::schema::isRef(pairs:JSONKeyValue[*] ) : Boolean[1]
{
    $pairs->filter(k|$k.key.value=='$ref').value->isNotEmpty();
}



function <<access.private>> meta::json::schema::calculateJSONRef( element:PackageableElement[1], root:Any[0..1],useDefinitions:Boolean[1],referenceParent:Any[0..1], config:JSONSchemaConfigInternal[1] ) : String[1]
{
   if(  ( !$root->isEmpty() ) && $element == $root,
                      | '#',
                      | if($useDefinitions || $referenceParent->isEmpty() || $config.createSchemaCollection,
                             | $config->JSONRefPrefix() + $element->elementName($config,true,false,[]),
                             |    let parentPath = $referenceParent->toOne()->cast(@PackageableElement)->elementPath().name->tail()->init();
                                  let elementPath = $element->elementPath().name->tail()->init();
                            let parentWithIndex=  $parentPath->fold({p,a:Integer[1..*]| let next= $a->last()->toOne()+1;
                                                                    $a->concatenate($next);},0)->zip($parentPath  );
                            let elementWithIndex=  $elementPath->fold({p,a:Integer[1..*]| let next= $a->last()->toOne()+1;
                                                                    $a->concatenate($next);},0)->zip($elementPath  );

                               let parentParts = $parentWithIndex->map( parentPart |  let parentIndex = $parentPart.first;
                                                                                    if($elementPath->size()>$parentIndex,
                                                                                        |  let elementPart = $elementPath->at($parentIndex);
                                                                                          if($elementPath->take($parentIndex+1)==$parentPath->take($parentIndex+1),
                                                                                                 |[];,
                                                                                                 |'..');,
                                                                                        |'..');

                                                                       );




                                  let elemntParts = $elementWithIndex->map( elementPart |let elementIndex = $elementPart.first;
                                                                                    if($parentPath->size()>$elementIndex,
                                                                                           |let parentPart = $parentPath->at($elementIndex);
                                                                                             if($elementPath->take($elementIndex+1)==$parentPath->take($elementIndex+1),
                                                                                                 |[],
                                                                                                 |$elementPart.second);,
                                                                                           |$elementPart.second);
                                                                    );
                                   let allParts =  $parentParts->concatenate($elemntParts);
                                   let result = if($allParts->isNotEmpty(),
                                                   | $allParts->joinStrings('/')+'/',
                                                   |'')+$element->elementName($config,false,true,[]);

                          );
                  );
}


function <<access.private>> meta::json::schema::JSONRefPrefix(config:JSONSchemaConfigInternal[1] ):String[1]
{
     if($config->isOpenAPI(),
        |'#/components/schemas/' ,
        |'#/'+ $config->definitionsKey() +'/');


}

function <<access.private>> meta::json::schema::elementName( element:FunctionDefinition<Any>[1],config:JSONSchemaConfigInternal[1],includePackage:Boolean[1],convertToPath:Boolean[1],newName:String[0..1] ) : String[1]
{
    $element->cast(@PackageableElement)->meta::json::schema::elementName($config, $includePackage, $convertToPath, $newName);
}

function <<access.private>> meta::json::schema::elementName( element:Type[1],config:JSONSchemaConfigInternal[1],includePackage:Boolean[1],convertToPath:Boolean[1],newName:String[0..1] ) : String[1]
{
    $element->cast(@PackageableElement)->meta::json::schema::elementName($config, $includePackage, $convertToPath, $newName);
}

function <<access.private>> meta::json::schema::elementName( element:PackageableElement[1],config:JSONSchemaConfigInternal[1],includePackage:Boolean[1],convertToPath:Boolean[1],newName:String[0..1] ) : String[1]
{
  let package = if($includePackage,|$element.package->toOne()-> elementToPath()+'::',|'');
  let path = if($element->instanceOf(FunctionDefinition),
                    | let funcName = $element->cast(@FunctionDefinition<Any>).functionName->toOne()->split('::')->last()->toOne();
                      $package + $funcName;,
                    | let name = if($newName->isNotEmpty(),|$newName->toOne(),|$element.name->toOne());
                      $package + $name;
               );

   if($convertToPath,|$path->pathToFileName($config.fileType),|$path);
}


function meta::json::schema::title( element:FunctionDefinition<Any>[1] ) : JSONKeyValue[1]
{
    $element->cast(@PackageableElement)->title();
}

function meta::json::schema::title( element:Type[1] ) : JSONKeyValue[1]
{
    $element->cast(@PackageableElement)->title();
}

function meta::json::schema::title( element:PackageableElement[1] ) : JSONKeyValue[1]
{
   let titleTag = $element->value4Tag('title',JSONSchemaGeneration);

   newJSONKeyStringValue( 'title',
                         if($titleTag->isNotEmpty(),
                             |$titleTag->first()->toOne().value,
                             |$element->titleValue();
                          ));

}

function <<access.protected>> meta::json::schema::titleValue(element:Any[1] ) : String[1]
{
    if($element->instanceOf(PackageableElement),
        |if($element->instanceOf(PackageableFunction),
            |$element->cast(@PackageableFunction<Any>).package->toOne()-> elementToPath()+ '::' + $element->cast(@PackageableFunction<Any>).functionName->toOne()->split('::')->last()->toOne();,
            |$element->cast(@PackageableElement)->elementToPath();
         ),
        |''
    );
}


function meta::json::schema::description( element:AnnotatedElement[1] ) : JSONKeyValue[0..1]
{
   if( meta::pure::functions::doc::hasDoc( $element ),
      | newJSONKeyStringValue( 'description',
                                meta::pure::functions::doc::getDocs( $element )->at(0) ),
      | [] );
}
function <<access.private>> meta::json::schema::schema( element:FunctionDefinition<Any>[1],schema:JSONSchemaSpecification[1])  : JSONKeyValue[0..1]
 {
     $element->cast(@PackageableElement)->meta::json::schema::schema($schema);
 }

function <<access.private>> meta::json::schema::schema( element:Type[1],schema:JSONSchemaSpecification[1])  : JSONKeyValue[0..1]
{
    $element->cast(@PackageableElement)->meta::json::schema::schema($schema);
}

function <<access.private>> meta::json::schema::schema( element:PackageableElement[1],schema:JSONSchemaSpecification[1])  : JSONKeyValue[0..1]
{
  if($schema==JSONSchemaSpecification.JSON_SCHEMA_DRAFT_07,
     |   newJSONKeyStringValue( '$schema', 'http://json-schema.org/draft-07/schema#' );,
     |if($schema==JSONSchemaSpecification.JSON_SCHEMA_2019_09,
         |newJSONKeyStringValue( '$schema', 'http://json-schema.org/draft/2019-09/schema' ),
        |[])

   );

}

function <<access.private>> meta::json::schema::supportsUnevaluatedProperties( schema:JSONSchemaSpecification[1])  : Boolean[1]
{
   $schema == JSONSchemaSpecification.JSON_SCHEMA_2019_09;

}

function meta::json::schema::schema( element:PackageableElement[1] ) : JSONKeyValue[1]
{
   newJSONKeyStringValue( '$schema', 'http://json-schema.org/draft-07/schema#' );
}

function meta::json::schema::convertPrimitiveType( type:PrimitiveType[1] ) : String[1]
{
   let name = $type.name;

      if ($name == 'String',     | 'string',
    | if ($name == 'Date',       | 'string',
    | if ($name == 'DateTime',   | 'string',
    | if ($name == 'StrictDate', | 'string',
    | if ($name == 'Integer',    | 'integer',
    | if ($name == 'Float',      | 'number',
    | if ($name == 'Boolean',    | 'boolean',
    | if ($name == 'Number',     | 'number',
    | if ($name == 'Decimal',    | 'number',
    | if ($name == 'Binary',    |  'string',

    | 'object') ) ) ) ) ) ))));
}

function meta::json::schema::convertPrimitiveTypeToFormat( type:PrimitiveType[1] ) : String[0..1]
{

   let name = $type.name;

     if ($name == 'Date',       | 'date',
    | if ($name == 'DateTime',   | 'date-time',
    | if ($name == 'StrictDate', | 'date',
    | []) ) );
}
function <<access.protected>> meta::json::schema::refObjectForType( type:Type[1],config:JSONSchemaConfigInternal[1] ) : JSONObject[1]
{
   if(!$type->instanceOf(PrimitiveType),
       |  newJSONObject($type->cast(@PackageableElement)-> meta::json::schema::newJsonRef($config.rootElement,$config.useDefinitions,$config.rootElement,$config ));,
       |   let format =  $type->cast(@PrimitiveType)->meta::json::schema::convertPrimitiveTypeToFormat();
           let formatKV =if($format->isNotEmpty(),| newJSONKeyValue( 'format', ^JSONString( value= $format->toOne()  )   ),|[]);
          ^JSONObject(keyValuePairs=newJSONKeyValue( 'type', ^JSONString( value= $type->cast(@PrimitiveType)->meta::json::schema::convertPrimitiveType()) )->concatenate($formatKV));
      );

}
function meta::json::schema::allOfGeneralizations( class:Class<Any>[1],config:JSONSchemaConfigInternal[1] ) : JSONKeyValue[0..1]
{
    $class->generalizations('allOf',$config);
}

function meta::json::schema::allOfGeneralizations( class:Class<Any>[1] ) : JSONKeyValue[0..1]
{
    $class->generalizations('allOf',defaultInternalConfig());
}

function meta::json::schema::extendsGeneralizations( class:Class<Any>[1] ) : JSONKeyValue[0..1]
{
    $class->generalizations('extends',defaultInternalConfig());
}

function meta::json::schema::isClass( rawType:PackageableElement[*] ) : Boolean[1]
{
   let type = $rawType->toOne();
   $type->match([
      p:PrimitiveType[1]    | false,
      e:Enumeration<Any>[1] | false,
      c:Class<Any>[1]       | !$c->isAnyClass()
   ]);
}

function meta::json::schema::isEnum( rawType:Type[*] ) : Boolean[1]
{
    $rawType->cast(@PackageableElement)->isEnum();
}

function meta::json::schema::isEnum( rawType:PackageableElement[*] ) : Boolean[1]
{
   let type = $rawType->toOne();
   $type->match([
      p:PrimitiveType[1]    | false,
      e:Enumeration<Any>[1] | true,
      c:Class<Any>[1]       | false
   ]);
}

function meta::json::schema::allNonPrimitivePropertiesOfClass( class:Class<Any>[1] ) : PackageableElement[*]
{
meta::json::schema::allNonPrimitivePropertiesOfClass($class,[],defaultInternalConfig());


}
function <<access.private>> meta::json::schema::allNonPrimitivePropertiesOfClass( class:Class<Any>[1],visited:PackageableElement[*],config:JSONSchemaConfigInternal[1] ) : PackageableElement[*]
{


   let generalizationsProperties = $class.generalizations->map(g |
      if($g.general.rawType->isEmpty() ||$class->in($visited)  || $class->instanceOf((MappingClass)),
       | [],
       | let extended = $g.general.rawType->cast(@Class<Any>)->toOne();
         if(!$extended->isAnyClass(),
            |$extended -> allNonPrimitivePropertiesOfClass($visited->add($class),$config),
            | []
           );
      );
   );
   let myPropertyPackagableElements =
      $class->inscopeProperties($config)->map( property |
         let type = $property.genericType.rawType->toOne();
         let packagableElement = $type->match([ p:PrimitiveType[1]    | [],
                                                e:Enumeration<Any>[1] | $type->cast(@PackageableElement),
                                                c:Class<Any>[*]       | if($c->isAnyClass(),|[],|$type->cast(@PackageableElement))
                                              ]);
         $packagableElement;
   );

   meta::pure::functions::collection::removeDuplicates(
      $myPropertyPackagableElements->concatenate($generalizationsProperties)
   );
}

function meta::json::schema::allGeneralizations( class:Class<Any>[1] ) : Class<Any>[*]
{
   if( $class->isAnyClass(),
      | [],
      |
         let myGeneralizationClasses =
               $class.generalizations->map( g |

                  let rawType = $g.general.rawType;

                  if( $rawType->isEmpty() || $rawType->isAnyClass(),
                     | [],
                     | $rawType->cast( @Class<Any> )->toOne()
                  );
               );
         let superGeneralizations = $myGeneralizationClasses->map( c | $c->allGeneralizations() );

         meta::pure::functions::collection::removeDuplicates(
            $myGeneralizationClasses->concatenate($superGeneralizations)
         );
   );
}

function meta::json::schema::allReferencedElements( class:Class<Any>[1] ) : PackageableElement[*]
{
   $class->allReferencedElements([],defaultInternalConfig(),true)
         ->filter( element |   $element != $class )
}

function   <<access.private>> meta::json::schema::allReferencedElements( class:Class<Any>[1],config:JSONSchemaConfigInternal[1] ) : PackageableElement[*]
{
   $class->allReferencedElements([],$config,true)
         ->filter( element |   $element != $class )
}

function <<access.private>> meta::json::schema::allReferencedElements( element:PackageableElement[1],bag:PackageableElement[*],config:JSONSchemaConfigInternal[1],includeSubTypes:Boolean[1] )  : PackageableElement[*]
{

   $element->match([class:Class<Any>[1]|
                     if(meta::pure::functions::collection::contains($bag,$class) || $class->instanceOf(MappingClass),
                        | [],
                        |
                           let generalizations                  = $class->allGeneralizations();
                           let specializations                  = if($includeSubTypes,|$class.specializations->map( spec | $spec.specific)->filter( oclass | !$oclass->instanceOf(MappingClass) )->cast(@Class<Any>),|[]);
                           let specializationPropertyElements   = $specializations->map( oclass | $oclass->allReferencedElements( $bag->concatenate($class)->concatenate( $generalizations),$config,$includeSubTypes ) );
                           let constraints = if($config.useConstraints,|$class.constraints->map(c |$c.functionDefinition.expressionSequence->evaluateAndDeactivate()->at(0)->meta::json::schema::allFunctionElements([],$config))->removeDuplicates(),|[]);
                           let allReferencedElements =
                            meta::pure::functions::collection::removeDuplicates(
                               $generalizations->concatenate($specializations)
                                            ->concatenate($specializationPropertyElements)
                            );


                            let allNonPrimitivePropertiesOfClass = $class->allNonPrimitivePropertiesOfClass($bag,$config);

                            let myPropertyElements =  $allNonPrimitivePropertiesOfClass->map( p |
                                                                      if( !$p->isClass(),
                                                                          | [],
                                                                          |   $p->cast(@Class<Any>)->meta::pure::functions::meta::getLeafTypes()->cast(@Class<Any>)
                                                                      );
                                                      )
                                                      -> concatenate( $allNonPrimitivePropertiesOfClass );

                           let result = $myPropertyElements->map( p | if($p->isClass(),
                                                                | $p->cast(@Class<Any>)->allReferencedElements( $bag->concatenate($class)->concatenate($allReferencedElements),$config,$includeSubTypes),
                                                                | $p
                                                             )
                                                   )
                                              ->concatenate($allReferencedElements)
                                              ->concatenate($bag)
                                              ->concatenate($class);

                          meta::pure::functions::collection::removeDuplicates( $result )->concatenate($constraints)->cast(@PackageableElement);
                     );,
                a:Any[1]|$a->allFunctionElements([],$config)->cast(@PackageableElement)

                     ]);
}



function <<access.private>> meta::json::schema::allFunctionElements(any:Any[1], seen:Any[*],config:JSONSchemaConfigInternal[0..1]):Function<Any>[*]
{
   $any->match([
      {
        sfe:SimpleFunctionExpression[1] |

         if($sfe.func->in($seen) || $sfe.func->instanceOf(Property),
            | [],
            |  let newElements = if($sfe.func->isWithinPackage(meta) &&!$sfe.func->meta::alloy::isMetaAlloyTestDependencyForGeneration(),|[];,|$sfe.func);
               $newElements->concatenate($sfe.parametersValues->evaluateAndDeactivate()->map(p| $p->allFunctionElements($seen->concatenate($newElements),$config);));
         );
      },
      lam:LambdaFunction<Any>[1]      | $lam.expressionSequence->evaluateAndDeactivate()->map(vs| $vs->allFunctionElements($seen,$config)),
      val:InstanceValue[1]            | $val.values->map(v| $v->allFunctionElements($seen,$config)),
      a  :Any[1]                      | [];
   ]);
}



function <<access.private>> meta::json::schema::createObjectProperty( class:Class<Any>[1], root:Class<Any>[0..1],useDefinitions:Boolean[1],property:Property<Nil,Any|*>[0..1] ,config:JSONSchemaConfigInternal[1] ) : JSONKeyValue[1]
{
    let specializations = $class->allSpecializations()->filter(c|!$c->isAbstract()&& !$c->instanceOf(MappingClass))->sortBy(v|$v->elementToPath());
    let propertyOwner = if($property->isNotEmpty(),|$property->toOne()->ownerClass()->toOne(),|[]);

   let objProperty =
      if( $specializations->isEmpty(),
        | if($property->isNotEmpty() &&  $property->toOne()->hasStereotype('object',JSONSchemaTypeExtension)   ,
               |newJSONKeyStringValue('type','object'),
               | $class->newJsonRef( $root,$useDefinitions,$propertyOwner,$config )
            ),
        | if( size( $specializations ) == 1,
              | $specializations->toOne()->newJsonRef($root,$useDefinitions,$propertyOwner,$config),
              |  if(  $config.generateAnyOfSubType,
                         | $class->newJsonRef($root,$useDefinitions,$propertyOwner,$config),
                         | let specialisedObjectRefs = $specializations->map(
                                    specialisedClass |
                                    newJSONObject( $specialisedClass->newJsonRef($root,$useDefinitions,$propertyOwner,$config) ) );


                 newJSONKeyValue('oneOf', ^JSONArray( values = $specialisedObjectRefs ) );
             )
           );
      );
     
}


function <<access.private>> meta::json::schema::generalizations( class:Class<Any>[1], keyName:String[1],config:JSONSchemaConfigInternal[1] ) : JSONKeyValue[0..1]
{
     let generalizations = $class.generalizations->map(g |
      if($g.general.rawType->isEmpty(),
       | [],
       | let extended = $g.general.rawType->cast(@Class<Any>)->toOne();
         if (!$extended->isAnyClass(),
         |  newJSONObject( $extended-> newJsonRef([],$config.useDefinitions,$class,$config) ),
         | []
       );
      );
   );

   if( $generalizations->isEmpty(),
       | [],
       | newJSONKeyValue( $keyName, ^JSONArray( values = $generalizations ) )
   );
}

function <<access.private>> meta::json::schema::shouldCreateArrayProperty( property:Property<Nil,Any|*>[1] ) : Boolean[1]
{
   ( !$property.multiplicity->meta::pure::functions::multiplicity::isZeroOne()
   && !$property.multiplicity->meta::pure::functions::meta::isToOne()  || $property->hasStereotype('array',JSONSchemaTypeExtension) );
}

function <<access.private>> meta::json::schema::createProperty( property : Property<Nil,Any|*>[1], root:Class<Any>[0..1],constraintHasType:Boolean[1] ,constraint:JSONObject[*], constraintHasRef:Boolean[1], config:JSONSchemaConfigInternal[1]) : JSONKeyValue[1]
{
   let format = $property->propertyFormatValue();
    assert($property.genericType.rawType!=Any || $constraintHasType ||  $property->hasStereotype('object',JSONSchemaTypeExtension) , 'Unable to generate schema for propery '+$property.name->toOne() + ' on class '+  $property.owner->elementToPath() +'. Found pure type Any: Change the data type or specify an instanceOf constraint. If using constraints, ensure useConstraints is enabled in the config' );

   let titleTag = $property->value4Tag('title',JSONSchemaGeneration);
   let titleKV = if($titleTag->isNotEmpty(),|newJSONKeyStringValue('title',$titleTag->first()->toOne().value),|[]);



   let type =if($constraintHasRef,|[] ,|$property->propertyType($root,$constraintHasType, $config));
   let elementTags = $property->elementTags($config);
   let default = $property->value4Tag('defaultValue',JSONSchemaGeneration);
   let defaulttag =if($default->isNotEmpty(),
                          | let value = $default.value->toOne()->parsePureStringtoJSONValue($property.genericType.rawType->toOne());
                               newJSONKeyValue('default',$value);,
                            |[]);

   let list = $type->concatenate($titleKV)->concatenate($defaulttag)->concatenate($elementTags)->concatenate($format)->concatenate($constraint.keyValuePairs);
   let propertyObject = newJSONObject($list);


   newJSONKeyValue( $property.name->toOne(), $propertyObject );
}


function  meta::json::schema::parsePureStringtoJSONValue(value:String[1],type:Type[1]):JSONElement[1]
{
   if($type==String,
        | ^JSONString(value=$value),
        |if($type==Integer,
            |^JSONNumber(value=$value->parseInteger()),
            |  if($type->in(Number.specializations.specific->concatenate(Number)),
                 | ^JSONNumber(value=$value->parseFloat());,
                 | if($type==Boolean,
                    |^JSONBoolean(value=$value->parseBoolean()),
                    |   ^JSONString(value=$value->toOne())));));

}

function meta::json::schema::propertyFormatValue( property:Property<Nil,Any|*>[1]):JSONKeyValue[0..1]
{
  let type = $property.genericType.rawType->toOne();
  if($type == StrictDate,
       | newJSONKeyStringValue('format', 'date'),
       |  if( $type == DateTime || $type == Date,
         |  newJSONKeyStringValue('format', 'date-time'),
         |  if($property.stereotypes->filter(s |$s.profile==JSONSchemaTypeExtension && $s.value->in(['int64','int32','byte','double','binary']))->isNotEmpty() ,
               |  let st =  $property.stereotypes->filter(s |$s.profile==JSONSchemaTypeExtension)->at(0);
                     newJSONKeyStringValue('format',$st.value);,
                | []
               );
            )



      );
}

function <<access.protected>> meta::json::schema::addNullType( existingType:JSONKeyValue[1],element:Type[1],config: JSONSchemaConfigInternal[1]):JSONKeyValue[1]
{
    $existingType->addNullType($element->cast(@AnnotatedElement), $config);
}

function <<access.protected>> meta::json::schema::addNullType( existingType:JSONKeyValue[1],element:AnnotatedElement[1],config: JSONSchemaConfigInternal[1]):JSONKeyValue[1]
{

   if(!$config->isOpenAPI() && $element->cast(@ElementWithStereotypes)->hasStereotype('null',JSONSchemaTypeExtension),
     |   ^$existingType(value=^JSONArray(values=[$existingType.value,^JSONString(value='null')])),
     |$existingType);
}

function <<access.protected>> meta::json::schema::elementTags( element:FunctionDefinition<Any>[1],config: JSONSchemaConfigInternal[1]):JSONKeyValue[*]
{
    $element->cast(@AnnotatedElement)->elementTags($config);
}

function <<access.protected>> meta::json::schema::elementTags( element:Type[1],config: JSONSchemaConfigInternal[1]):JSONKeyValue[*]
{
    $element->cast(@AnnotatedElement)->elementTags($config);
}

function <<access.protected>> meta::json::schema::elementTags( element:AnnotatedElement[1],config: JSONSchemaConfigInternal[1]):JSONKeyValue[*]
{

  let type = if($element->instanceOf(Property),|$element->cast(@Property<Nil,Any|*>).genericType.rawType->toOne(),|[]);

  let hasReadOnly = $element->cast(@ElementWithStereotypes)->hasStereotype('readOnly',JSONSchemaGeneration);
  let hasWriteOnly = $element->cast(@ElementWithStereotypes)->hasStereotype('writeOnly',JSONSchemaGeneration);
  let examples  =  $element->value4Tag('example',JSONSchemaGeneration)->toJSONRepresentation('example',$type) ;
  let nullable = if( $element->cast(@ElementWithStereotypes)->hasStereotype('null',JSONSchemaTypeExtension) && $config.schemaSpecification == JSONSchemaSpecification.OPEN_API_V3_0_3, |newJSONKeyValue('nullable',^JSONBoolean(value=true)),|[]);

  let readWrite = if($hasReadOnly,
                   | newJSONKeyValue('readOnly', ^JSONBoolean(value=true)) ,
                   |  if( $hasWriteOnly,
                   | newJSONKeyValue('writeOnly', ^JSONBoolean(value=true)),
                       | []);
                 );
  let doc =    $element->cast(@AnnotatedElement)->description();

  let milestoning = $element->addMilestoningTag();


let customTags = if( $config.scopeElements->filter(e|$e->instanceOf(Profile))->isNotEmpty(),
                        |  let allProfiles = $config.scopeElements->filter(e|$e->instanceOf(Profile));
                          assert($allProfiles->size()==1,'Found multiple in scope Profiles, only one profile can be in scope for custom tag generation: '+ $allProfiles->map(e|$e->elementToPath())->joinStrings(', '));
                          let profile = $allProfiles->toOne()->cast(@Profile);
                          let tags =  $profile.p_tags->map(t | $element->value4Tag($t.value,$t.profile)->toJSONRepresentation($t.value->extendedKeyName($config),[])       )   ;
                          let st =  $profile.p_stereotypes->map(s |if( $element->hasStereotype($s.value,$s.profile),| newJSONKeyValue($s.value->extendedKeyName($config), ^JSONBoolean(value=true)),|[]) );
                         $tags->concatenate($st);,
                        |[]);



   $readWrite->concatenate($doc)->concatenate($examples)->concatenate($nullable)->concatenate($customTags)->concatenate($milestoning);

}

function <<access.private>> meta::json::schema::extendedKeyName(key:String[1],config:JSONSchemaConfigInternal[1]) : String[1]
{
  if($config->isOpenAPI(), //for open api, replace x_ with x-
      |if($key->startsWith('x_'),
          |$key->replace('x_','x-'),
           | 'x-'+$key),
      |$key);
}

function meta::json::schema::addMilestoningTag(type:AnnotatedElement[1]):JSONKeyValue[0..1]
{
 let temporalKey = 'x-legendTemporal';

  if($type->hasStereotype('businesstemporal', temporal),
        |newJSONKeyValue($temporalKey, ^JSONString(value='businesstemporal'))  ,
        |if($type->hasStereotype('bitemporal', temporal),
            |newJSONKeyValue($temporalKey, ^JSONString(value='bitemporal'))  ,
            |if($type->hasStereotype('processingtemporal', temporal),
                  |newJSONKeyValue($temporalKey, ^JSONString(value='processingtemporal')),
                  |[]
                );
              );   
  );

}

function <<access.private>> meta::json::schema::propertyType( property:Property<Nil,Any|*>[1],root:Class<Any>[0..1] ,constraintHasType:Boolean[1],config:JSONSchemaConfigInternal[1]) : JSONKeyValue[0..1]
{
   if($constraintHasType,
        |[] ,
        |meta::json::schema::propertyTypeValue( $property,$root, false, $config);
      );
}

function meta::json::schema::propertyTypeValue( property:Property<Nil,Any|*>[1],root:Class<Any>[0..1] ) : JSONKeyValue[1]
{
    meta::json::schema::propertyTypeValue( $property,$root, false, defaultInternalConfig() );
}

function <<access.private>> meta::json::schema::propertyTypeValue( property:Property<Nil,Any|*>[1],root:Class<Any>[0..1], constraintHasType:Boolean[1] ,config:JSONSchemaConfigInternal[1] ) : JSONKeyValue[1]
{
   let type = $property.genericType.rawType->toOne();
   let propertyOwner = $property->ownerClass();
   $type->match([
      p:PrimitiveType[1]    | newJSONKeyStringValue( 'type', $p->cast(@PrimitiveType)->convertPrimitiveType( ) ),
      e:Enumeration<Any>[1] | newJsonRef( $e,[], $config.includeAllRelatedTypes,$propertyOwner,$config),
      c:Class<Any>[1]       | createObjectProperty( $c,$root,$config.includeAllRelatedTypes ,$property,$config)
   ]);
}


function meta::json::schema::properties( class:Class<Any>[1] ) : JSONKeyValue[1]
{
   $class->properties([],[],[],defaultInternalConfig()).key->toOne();
}

function meta::json::schema::properties( class:Class<Any>[1], root:Class<Any>[0..1]) : JSONKeyValue[1]
{
   $class->properties([],[],[],defaultInternalConfig()).key->toOne();

}
function <<access.private>> meta::json::schema::properties( class:Class<Any>[1], root:Class<Any>[0..1],constraint:SchemaConstraint[*],constraintNoRef:SchemaConstraint[*], config:JSONSchemaConfigInternal[1]) : JsonSchemaKeyValueMessage[1]
{
    let properties = $class->inscopeProperties($config);
    let values = $properties->map( p | let propertyConstraint = $constraint->filter(c| $c.property.name==$p.name).constraint;
                                       let propertyConstraintNoRef = $constraintNoRef->filter(c| $c.property.name==$p.name).constraint;
                                       let constraintHasRef = if($propertyConstraint->isNotEmpty(),|  $propertyConstraint->map(c|$c->meta::json::schema::constraint::constraintHasRef())->toOneMany()->or() &&  $config.generateConstraintFunctionSchemas,|false);
                                       let constraintHasType =if($propertyConstraintNoRef->isNotEmpty(),
                                                                       |$propertyConstraintNoRef->map(c|$c->constraintHasType())->toOneMany()->or() ,
                                                                       | false);
                                      ^JsonSchemaKeyValueMessage(key= if($p->shouldCreateArrayProperty(),
                                                                         | $p->createArrayProperty($root,$constraintHasType, $propertyConstraint,$constraintHasRef,$config),
                                                                         | $p->createProperty($root,$constraintHasType, $propertyConstraint,$constraintHasRef,$config)
                                                                      ),
                                                              message = if($constraintNoRef->filter(c| $c.property.name==$p.name).generationMessage->isNotEmpty(),
                                                                                       |[]->addError('Property ' +$class->elementToPath()+'.'+ $p.name->toOne() + ' references an unsupported schema and likely did not generate correctly' ),
                                                                                       |[])
                                                                    ););
 let key = newJSONKeyValue( 'properties', newJSONObject( $values.key ) );
^JsonSchemaKeyValueMessage(key= $key, message = $values.message);

}

function <<access.private>> meta::json::schema::inscopeProperties( class:Class<Any>[1], config:JSONSchemaConfigInternal[1]) : Property<Nil,Any|*>[*]
{
   let classProps = if($config.anyOfMember,
                      |$class->meta::pure::functions::meta::hierarchicalProperties(),
                      |$class.properties);

   if($config.generateMilestoneProperties,
      | $classProps->concatenate($class.propertiesFromAssociations)->filter(p|$p.owner->in($config.scopeElements)),
      |  $classProps->concatenate($class.propertiesFromAssociations->concatenate($class.originalMilestonedProperties)->filter(p|$p.owner->in($config.scopeElements)))->filter(p|!$p->meta::pure::milestoning::hasGeneratedMilestoningPropertyStereotype());
      );

}

function meta::json::schema::required( class:Class<Any>[1] ) : JSONKeyValue[0..1]
{
   required($class,defaultInternalConfig());

}


function <<access.private>> meta::json::schema::required( class:Class<Any>[1],config:JSONSchemaConfigInternal[1] ) : JSONKeyValue[0..1]
{
  let values = $class->inscopeProperties($config)->map( p |
        if( $p->isRequired(),
           | ^JSONString( value = $p.name->toOne() ),
           | []
        )
  );

  if( $values == [],
     | [],
     | newJSONKeyValue( 'required', ^JSONArray( values=$values ) ) );
}

function meta::json::schema::definitions( class:Class<Any>[1] ) : JSONKeyValue[0..1]
{
   $class->definitions([],defaultInternalConfig());
}
function meta::json::schema::definitions( class:Class<Any>[1], root:Class<Any>[0..1] ) : JSONKeyValue[0..1]
{
      definitions($class,$root,defaultInternalConfig());
}




function <<access.private>> meta::json::schema::specializationsAnyOf( class:Class<Any>[1],  root:Class<Any>[0..1], config:JSONSchemaConfigInternal[1] ) : JsonSchemaKeyValueMessage[0..1]
{
     let  newConfig = ^$config(anyOfMember=true, rootLevel=false);
     let unevalulated = if($config.schemaSpecification->supportsUnevaluatedProperties(),| unevaluatedProperties(),|[]);

     let specializations = $class->findAllSpecializations()->concatenate($class)->map(s |
         if (!$s->isAnyClass(),
         |   let schema = newJSONObject( $s->meta::json::schema::schemaProperties($root,$newConfig).key->concatenate($unevalulated));,
         | []
       );

   );

  let r =  if( $specializations->isEmpty(),
       | [],
       |    ^JsonSchemaKeyValueMessage(key =newJSONKeyValue( 'anyOf', ^JSONArray( values = $specializations )))


   );
}

function  <<access.private>> meta::json::schema::definitions( class:Class<Any>[1], root:Class<Any>[0..1], config:JSONSchemaConfigInternal[1] ) : JSONKeyValue[0..1]
{
   let updatedConfig = ^$config(rootLevel=false);
   let values = $class->allReferencedElements($config)->sortBy(e|$e->elementToPath())->map( p | newJSONKeyValue( $p->elementToPath(), $p->match([t:Type[1]|$t->toJSONSchema($root,$updatedConfig).schema,
                                                                                                                                           f:ConcreteFunctionDefinition<Any>[1] | $f->toJSONSchemaFromFunctionDefinition($updatedConfig).constraint->toOne()]))) ;
  let definitionsKey =meta::json::schema::definitionsKey($config);

  if( $values->isEmpty(),
     | [],
     | newJSONKeyValue( $definitionsKey , newJSONObject( $values ) )
  );
}

function  <<access.private>> meta::json::schema::definitionsKey( config:JSONSchemaConfigInternal[1] ) : String[1]
{
   if($config.schemaSpecification==JSONSchemaSpecification.JSON_SCHEMA_2019_09,|'$defs',|'definitions' );
}

function <<access.private>> meta::json::schema::createArrayProperty( property:Property<Nil,Any|*>[1],root:Class<Any>[0..1],constraintHasType:Boolean[1], constraint:JSONObject[*],constraintHasRef:Boolean[1],config: JSONSchemaConfigInternal[1] ) : JSONKeyValue[1]
{
   let format = $property->propertyFormatValue();
   let propertyTypeValue = if($constraintHasRef,|[],|$property-> propertyType($root,$constraintHasType,$config));
   let isUnqiue = $constraint.keyValuePairs->filter(c| $c.key.value=='uniqueItems');

   let elementTags = $property->elementTags($config);
   let list = newJSONKeyStringValue('type', 'array')->concatenate($isUnqiue)->concatenate($elementTags);

   let finalList = $list->concatenate(newJSONKeyValue('items', newJSONObject( $propertyTypeValue->concatenate($format)->concatenate($constraint.keyValuePairs->filter(p|$p.key.value!='uniqueItems')) ) ))
           ->concatenate(arrayMinMaxItemKeyValue( $property ) );

   newJSONKeyValue( $property.name->toOne(), newJSONObject( $finalList));
}


function meta::json::schema::arrayMinMaxItemKeyValue( property:Property<Nil,Any|*>[1] ) : JSONKeyValue[*]
{
   if( $property.multiplicity->hasLowerBound(),
       | if( $property.multiplicity->hasUpperBound(),
             |  [ newJSONKeyValue('minItems', ^JSONNumber(value=$property.multiplicity->getLowerBound())),
                  newJSONKeyValue('maxItems', ^JSONNumber(value=$property.multiplicity->getUpperBound())) ] ,
             |  [ newJSONKeyValue('minItems', ^JSONNumber(value=$property.multiplicity->getLowerBound())) ] ),
       | if( $property.multiplicity->hasUpperBound(),
             |  [ newJSONKeyValue('maxItems', ^JSONNumber(value=$property.multiplicity->getUpperBound())) ],
             |  [] ) );
}

function <<access.private>> meta::json::schema::isRequired( property:Property<Nil,Any|*>[1] ) : Boolean[1]
{
   $property.multiplicity->getLowerBound()>0;
}
function <<access.private>>  meta::json::schema::isOpenAPI(config:JSONSchemaConfigInternal[1]):Boolean[1]
{
    $config.schemaSpecification ->meta::json::schema::isOpenAPI();
}

function <<access.private>>  meta::json::schema::isOpenAPI(spec:JSONSchemaSpecification[0..1]):Boolean[1]
{
    if($spec->isNotEmpty(),
       |$spec->toOne()  == JSONSchemaSpecification.OPEN_API_V3_0_3 ||$spec->toOne()==JSONSchemaSpecification.OPEN_API_V3_0_3_YAML ||$spec->toOne() == JSONSchemaSpecification.OPEN_API_V3_0_3_YAML_PLAIN;
      ,|false);
}

function <<access.private>>  meta::json::schema::isYAML(spec:JSONSchemaSpecification[1]):Boolean[1]
{
    $spec == JSONSchemaSpecification.OPEN_API_V3_0_3_YAML ||     $spec == JSONSchemaSpecification.OPEN_API_V3_0_3_YAML_PLAIN;
}

function <<access.private>>  meta::json::schema::isPlainYAML(spec:JSONSchemaSpecification[1]):Boolean[1]
{
      $spec == JSONSchemaSpecification.OPEN_API_V3_0_3_YAML_PLAIN;
}

function <<access.private>>  meta::json::schema::addDiscriminator(pureElement:Class<Any>[1],config:JSONSchemaConfigInternal[1]):JSONKeyValue[0..1]
{
   //class has a property with discriminator stereotype
  if($config->isOpenAPI(),
     |let dProperty = $pureElement.properties->filter(p|$p->hasStereotype('discriminatorProperty',JSONSchemaOpenAPIExtension));
      if($dProperty->isEmpty(),
         |[],
         | assert($dProperty->size()==1,'You can only specify one discriminator property per class, found '+ $dProperty.name->joinStrings(',') + ' on class ' +$pureElement->elementToPath() );
            let dKeyValue = newJSONKeyStringValue  ('propertyName',$dProperty.name->toOne());
          let mappingTags = $pureElement->findAllSpecializations()->map(s |let tag = $s->cast(@Class<Any>)->toOne()->value4Tag('discriminatorName',JSONSchemaOpenAPIExtension);
                                                                              if($tag->isNotEmpty(),
                                                                                    |$tag->map(t| newJSONKeyStringValue($t.value->toOne(),   meta::json::schema::calculateJSONRef( $s->cast(@Class<Any>)->toOne(), $pureElement,$config.useDefinitions,$pureElement, $config )   )),
                                                                                    |[]);
                                                      );
          let mappingKV=   if($mappingTags->isNotEmpty(),
                                 |newJSONKeyValue('mapping', newJSONObject($mappingTags)  ),
                                 |[]);
           let  dObject= newJSONObject($dKeyValue->concatenate($mappingKV)->cast(@JSONKeyValue));

           newJSONKeyValue('discriminator',  $dObject );

      );,

   |[])
}


function meta::json::schema::discriminateOneOf(sourceInstance:Any[1],propertyValue:Any[1],classSelection:Type[*],mapping:DiscriminatorMapping[*] ):Boolean[1]
{
   let PropertyValue = if($propertyValue->instanceOf(Enum),|$propertyValue->cast(@Enum).name,|$propertyValue->toString());

   oneOf($classSelection->map(t| $t.name==$propertyValue ))  || $propertyValue->in($mapping.value);
}

function  meta::json::schema::JSONToYaml(json:meta::json::JSONElement[1]):meta::external::format::yaml::metamodel::YAMLElement[1]
{
    $json->match([
                  b:JSONBoolean[1] |^YAMLBoolean(value=$b.value),
                  s:JSONString[1] |^YAMLString(value=$s.value),
                  n:JSONNumber[1] | ^YAMLNumber(value=$n.value),
                  n:JSONNull[1] | ^YAMLNull(),
                  a:JSONArray[1] | ^YAMLArray(values=$a.values->map(v | $v->JSONToYaml()  )),
                  o:JSONObject[1] | ^YAMLObject(keyValuePairs=$o.keyValuePairs->map(kv | ^YAMLKeyValue(key= $kv.key->JSONToYaml()->cast(@YAMLString),value = $kv.value->JSONToYaml())))
                 ])


}


function meta::json::schema::mapSchema(value:String[1],class:Type[1]):DiscriminatorMapping[1]
{
    ^DiscriminatorMapping(value=$value,class=$class);

}

function <<access.private>> meta::json::schema::schemaCollection(elements:PackageableElement[*],config:JSONSchemaConfigInternal[1]):JsonSchemaGenerationResult[1]
{
    let updatedConfig =  ^$config(useDefinitions=false,includeAllRelatedTypes=false);
    let updatedElements = $elements->map(e|$e->allReferencedElements([],$updatedConfig,false));


   let generatedSchemas = $updatedElements->distinct()->sortBy(e|$e->elementToPath())->map( p | let keyName=$p->elementName($updatedConfig,true,false,[]);
                                                                                                let generated =  $p->toOne()->match([ t:Type[1]|   let schema= $t->toJSONSchema([],$updatedConfig);
                                                                                                                                                    ^JsonSchemaKeyValueMessage(key=newJSONKeyValue($keyName,$schema.schema),message=$schema.message);  ,
                                                                                                                                      f:FunctionDefinition<Any>[1] |
                                                                                                                                                    let schema = $f->toJSONSchemaFromFunctionDefinition($updatedConfig);
                                                                                                                                                    let resolvedSchema = if($schema.constraint->isNotEmpty(),|$schema.constraint->toOne(),|^JSONObject());
                                                                                                                                                    ^JsonSchemaKeyValueMessage(key=newJSONKeyValue($keyName,$resolvedSchema),message=$schema.generationMessage);


                                                                                                                              ])->cast(@JsonSchemaKeyValueMessage)->toOne();  );

    let collection =  if($config->isOpenAPI(),
                        | newJSONKeyValue('components',newJSONObject(newJSONKeyValue('schemas',newJSONObject($generatedSchemas.key)))),
                        | newJSONKeyValue($config->definitionsKey(),newJSONObject($generatedSchemas.key)));

   ^JsonSchemaGenerationResult(schema = newJSONObject($collection), message =$generatedSchemas.message);
}





Class meta::json::schema::DiscriminatorMapping
{
   value:String[1];
   class:Type[1];
}

Class meta::json::schema::JsonSchemaGenerationResult
{
 schema:JSONObject[1];
 message:GenerationMessage[*];
}

Class <<access.private>> meta::json::schema::JsonSchemaKeyValueMessage
{
 key:JSONKeyValue[*];
 message:GenerationMessage[*];
}
