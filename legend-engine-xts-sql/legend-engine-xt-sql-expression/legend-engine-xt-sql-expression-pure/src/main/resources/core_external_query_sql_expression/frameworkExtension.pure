import meta::external::query::sql::expression::*;
import meta::pure::router::store::routing::*;
import meta::core::runtime::*;
import meta::pure::runtime::*;
import meta::external::query::sql::metamodel::*;
import meta::pure::store::*;
import meta::pure::router::routing::*;
import meta::pure::extension::*;

function meta::external::query::sql::expression::sqlExpressionFeatureExtension() : Extension[1]
{
   let shared = ^Extension(
      type = 'sqlExpressionExtension',
      availableFeatures  = ^FeatureExtension
                           (
                              id = 'sqlReprocessToFunction',
                              instanceProcessors = {i:InstanceValue[1], state:RoutingState[1], executionContext:ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |
                                                      pair(
                                                          | $i.values->size() == 1 && $i.values->at(0)->instanceOf(SQLExpression),
                                                          | processCollection($state, extractFunctionFromSQLExpression($i.values->at(0)->cast(@SQLExpression<Any>)), $executionContext, $vars, $inScopeVars, v:Any[1]|true, $extensions, $debug);
                                                        )
                                                   }
                          ),
      grammarSerializerExtensions = ^meta::pure::metamodel::serialization::grammar::GrammarExtension(
                                            extraInstanceValueHandlers = [
                                                            x:SQLExpression<Any>[1]| '#SQL{'+$x.sqlString+'}#'
                                                        ]
                                    )

   )
}

function meta::external::query::sql::expression::extractFunctionFromSQLExpression(s:SQLExpression<Any>[1]):FunctionExpression[1]
{
  let func = $s.pureFunction;
  ^FunctionExpression(func = meta::pure::functions::lang::eval_Function_1__V_m_,
                      importGroup = ^ImportGroup(),
                      genericType = $func->functionReturnType(),
                      multiplicity = ZeroMany,
                      parametersValues = ^InstanceValue
                                          (
                                            genericType = ^GenericType(rawType=LambdaFunction, typeArguments=^GenericType(rawType=$func->functionType())),
                                            multiplicity = PureOne,
                                            values = $func
                                          )
  )->evaluateAndDeactivate();
}
