import meta::pure::metamodel::variant::*;
import meta::external::query::sql::transformation::utils::*;
import meta::external::query::sql::transformation::compile::utils::*;
import meta::pure::functions::relation::variant::*;
import meta::external::query::sql::metamodel::*;
import meta::external::query::sql::transformation::queryToPure::*;



//TODO we likely want to mix this with normal function processors below.
function meta::external::query::sql::transformation::queryToPure::tableFunctionProcessors():FunctionProcessor[*]
{
  [
    array('unnest', Relation, {args, fc, expCtx, ctx |
      assertRelation($ctx.relation, 'unnest');
      assert($ctx.name->isNotEmpty(), | 'context name must be populated for unnest');

      $fc.arguments->match([
        a:ArrayLiteral[1] | assert($a.values->forAll(v | !$v->instanceOf(ArrayLiteral))),
        e:meta::external::query::sql::metamodel::Expression[1] | 'unnest only currently supports simple array literals'
      ]);

      sfe(flatten_T_MANY__ColSpec_1__Relation_1_, [$args->at(0), iv(^meta::pure::metamodel::relation::ColSpec<Any>(name = $ctx.name->toOne()))]);
    }),

    misc('var', Relation, {args, fc, expCtx, ctx |
      assertRelation($ctx.relation, 'var');

      let relation = getVariableReference($args, $ctx);

      assert($relation.genericType.rawType->toOne()->subTypeOf(meta::pure::metamodel::relation::Relation), | 'var table expression must be a relation');

      $relation->evaluateAndDeactivate();
    })
  ]
}

function meta::external::query::sql::transformation::queryToPure::functionProcessors():FunctionProcessor[*]
{
  [
      //AGGREGATE FUNCTIONS
      aggregate('count', count_Any_MANY__Integer_1_),
      aggregate('bool_and', and_Boolean_MANY__Boolean_1_),
      aggregate('bool_or', or_Boolean_MANY__Boolean_1_),
      aggregate('every', and_Boolean_MANY__Boolean_1_),
      aggregate('min', [], {args, fc, expCtx, ctx |
        let type = getAggregationArgumentType($args)->preciseToPrimitive();

        [
          pair(Number, |sfe(min_Number_MANY__Number_$0_1$_, $args)),
          pair(Float, |sfe(min_Float_MANY__Float_$0_1$_, $args)),
          pair(Integer, |sfe(min_Integer_MANY__Integer_$0_1$_, $args)),
          pair(Decimal, |sfe(min_Number_MANY__Number_$0_1$_, $args)),
          pair(Date, |sfe(min_Date_MANY__Date_$0_1$_, $args)),
          pair(StrictDate, |sfe(min_StrictDate_MANY__StrictDate_$0_1$_, $args)),
          pair(DateTime, |sfe(min_DateTime_MANY__DateTime_$0_1$_, $args))
        ]->getValue($type, | sfe(min_X_MANY__X_$0_1$_, ^GenericType(rawType = $type), ^GenericType(rawType = $type), $args))->eval();
      }),
      aggregate('max', [], {args, fc, expCtx, ctx |
        let type = getAggregationArgumentType($args)->preciseToPrimitive();
        [
          pair(Number, |sfe(max_Number_MANY__Number_$0_1$_, $args)),
          pair(Float, |sfe(max_Float_MANY__Float_$0_1$_, $args)),
          pair(Integer, |sfe(max_Integer_MANY__Integer_$0_1$_, $args)),
          pair(Decimal, |sfe(max_Number_MANY__Number_$0_1$_, $args)),
          pair(Date, |sfe(max_Date_MANY__Date_$0_1$_, $args)),
          pair(StrictDate, |sfe(max_StrictDate_MANY__StrictDate_$0_1$_, $args)),
          pair(DateTime, |sfe(max_DateTime_MANY__DateTime_$0_1$_, $args))
        ]->getValue($type, | sfe(max_X_MANY__X_$0_1$_, ^GenericType(rawType = $type), ^GenericType(rawType = $type), $args))->eval();
      }),
      aggregate('string_agg', String, {args, fc, expCtx, ctx |
        let func = [
          pair(1, joinStrings_String_MANY__String_1_),
          pair(2, joinStrings_String_MANY__String_1__String_1_)
        ]->getValue($args->size());

        sfe($func, $args);
      }),

      aggregate('avg', Float, {args, fc, expCtx, ctx |
        let type = getAggregationArgumentType($args)->preciseToPrimitive();

        let func = [
          pair(Integer, average_Integer_MANY__Float_1_),
          pair(Float, average_Float_MANY__Float_1_)
        ]->getValue($type, average_Number_MANY__Float_1_);

        sfe($func, $args);
      }),
      aggregate('percentile_cont', Number, {args, fc, expCtx, ctx |
        processPercentile('percentile_cont', $args, true, $fc, $expCtx)
      }, percentilePreProcessor_Expression_1__FunctionCall_1__AggregateFunctionPreProcessorWrapper_1_),
      aggregate('percentile_disc', Number, {args, fc, expCtx, ctx |
        processPercentile('percentile_disc', $args, false, $fc, $expCtx)
      }, percentilePreProcessor_Expression_1__FunctionCall_1__AggregateFunctionPreProcessorWrapper_1_),
      aggregate('stddev_pop', stdDevPopulation_Number_MANY__Number_1_),
      aggregate('stddev_samp', stdDevSample_Number_MANY__Number_1_),
      aggregate('stddev', stdDevSample_Number_MANY__Number_1_),
      aggregate('sum', Number, {args, fc, expCtx, ctx |
        let type = getAggregationArgumentType($args)->preciseToPrimitive();

        let func = [
          pair(Integer, sum_Integer_MANY__Integer_1_),
          pair(Float, sum_Float_MANY__Float_1_)
        ]->getValue($type, sum_Number_MANY__Number_1_);

        sfe($func, $args);
      }),

      aggregate('variance', varianceSample_Number_MANY__Number_1_),
      aggregate('var_samp', varianceSample_Number_MANY__Number_1_),
      aggregate('var_pop', variancePopulation_Number_MANY__Number_1_),

      //MATH
      math('abs', Number, {args, fc, expCtx, ctx |
        assert($args->size() == 1, 'incorrect number of args for abs');
        let type = $args->at(0).genericType.rawType->toOne()->preciseToPrimitive();

        let func = [
          pair(Integer, abs_Integer_1__Integer_1_),
          pair(Float, abs_Float_1__Float_1_),
          pair(Decimal, abs_Decimal_1__Decimal_1_)
        ]->getValue($type, abs_Number_1__Number_1_);

        nullOrSfe($func, $args);
      }),
      math('acos', acos_Number_1__Float_1_),
      math('asin', asin_Number_1__Float_1_),
      math('atan', atan_Number_1__Float_1_),
      math('atan2', atan2_Number_1__Number_1__Float_1_),
      math('cbrt', cbrt_Number_1__Float_1_),
      math('ceil', ceiling_Number_1__Integer_1_),
      math('ceiling', ceiling_Number_1__Integer_1_),
      math('cos', cos_Number_1__Float_1_),
      math('cosh', cosh_Number_1__Float_1_),
      math('cot', cot_Number_1__Float_1_),
      math('degrees', toDegrees_Number_1__Float_1_),
      math('div', divide_Number_1__Number_1__Float_1_),
      math('exp', exp_Number_1__Float_1_),
      math('floor', floor_Number_1__Integer_1_),
      math('ln', log_Number_1__Float_1_),
      math('log', log10_Number_1__Float_1_),
      math('mod', rem_Number_1__Number_1__Number_1_),
      math('pi', pi__Float_1_),
      math('power', pow_Number_1__Number_1__Number_1_),
      math('radians', toRadians_Number_1__Float_1_),
      math('round', Number, {args, fc, expCtx, ctx |
        assert(($args->size() == 1) || ($args->size() == 2), 'incorrect number of args for round');

        let func = if ($args->size() == 1 || ($args->at(0).genericType.rawType == Integer
                                              && $args->at(1)->match([i:InstanceValue[1] | $i.values == 0, v:ValueSpecification[1] | false])),
          |
            round_Number_1__Integer_1_,
          | if ($args->at(0).genericType.rawType == Float,
              | round_Float_1__Integer_1__Float_1_,
              | round_Decimal_1__Integer_1__Decimal_1_)
        );

        nullOrSfe($func, $args);
      }),
      math('sign', sign_Number_1__Integer_1_),
      math('sin', sin_Number_1__Float_1_),
      math('sinh', sinh_Number_1__Float_1_),
      math('sqrt', sqrt_Number_1__Float_1_),
      math('tan', tan_Number_1__Float_1_),
      math('tanh', tanh_Number_1__Float_1_),
      math('trunc', Integer, {args, fc, expCtx, ctx |
        //TODO replace with pure trunc function when implemented;
        assert($args->size() == 1, | 'trunc with defined decimal places is not currently supported');

        let condition = nullOrSfe(greaterThan_Number_1__Number_1__Boolean_1_, [$args->at(0), iv(0)])->evaluateAndDeactivate();
        let truth = nullOrSfe(floor_Number_1__Integer_1_, $args->at(0))->evaluateAndDeactivate();
        let else = nullOrSfe(ceiling_Number_1__Integer_1_, $args->at(0))->evaluateAndDeactivate();

        createIfStatement($condition, $truth, $else);
      }),

      //STRING
      string('ascii', ascii_String_1__Integer_1_),
      string('btrim', String, {args, fc, expCtx, ctx | processTrim(trim_String_1__String_1_, $args)}),
      string('char_length', length_String_1__Integer_1_),
      string('chr', char_Integer_1__String_1_),
      string('concat', String, {args, fc, expCtx, ctx |
        sfe(plus_String_MANY__String_1_, iv($args))
      }),
      string('decode', String, {args, fc, expCtx, ctx |
        assert($args->size() == 2, | 'incorrect number of args to decode');

        let type = $args->at(1)->reactivate()->cast(@String)->toOne();

        let func = [
          pair('base64', decodeBase64_String_1__String_1_)
        ]->getValue($type->toLower());

        nullOrSfe($func, $args->at(0));
      }),
      string('encode', String, {args, fc, expCtx, ctx |
        assert($args->size() == 2, | 'incorrect number of args to encode');

        let type = $args->at(1)->reactivate()->cast(@String)->toOne();

        let func = [
          pair('base64', encodeBase64_String_1__String_1_)
        ]->getValue($type->toLower());

        nullOrSfe($func, $args->at(0));
      }),
      string('initcap', toUpperFirstCharacter_String_1__String_1_),
      string('length', length_String_1__Integer_1_),
      string('lower', toLower_String_1__String_1_),
      string('lpad', String, {args, fc, expCtx, ctx | processPad($args, true)}),
      string('ltrim', String, {args, fc, expCtx, ctx | processTrim(ltrim_String_1__String_1_, $args)}),
      string('left', left_String_1__Integer_1__String_1_),
      string('md5', String, {args, fc, expCtx, ctx | processHash($args, meta::pure::functions::hash::HashType.MD5)}),
      string('regexp_like', Boolean, {args, fc, expCtx, ctx |
        assert($args->size() == 2 || $args->size() == 3, 'incorrect number of args to regexp_like');

        let caseInsensitive = $args->size() == 3 && $args->at(2)->reactivate()->match([
          s:String[1] | $s == 'i',
          a:Any[*] | false
        ]);

        createRegexMatch($args->at(0), $args->at(1), $caseInsensitive, false);
      }),
      string('repeat', repeatString_String_$0_1$__Integer_1__String_$0_1$_),
      string('replace', replace_String_1__String_1__String_1__String_1_),
      string('reverse', reverseString_String_1__String_1_),
      string('right', right_String_1__Integer_1__String_1_),
      string('rpad', String, {args, fc, expCtx, ctx | processPad($args, false)}),
      string('rtrim', String, {args, fc, expCtx, ctx | processTrim(rtrim_String_1__String_1_, $args)}),
      string('sha256', String, {args, fc, expCtx, ctx | processHash($args, meta::pure::functions::hash::HashType.SHA256)}),
      string('split_part', String, {args, fc, expCtx, ctx |
        assertEquals(3, $args->size(), 'split_part must specify three arguments');

        let position = $args->at(2)->match([
          i:InstanceValue[1] | $i.values->match([
            i:Integer[1] | iv($i - 1),
            a:Any[*] | fail('invalid split part position'); iv(1);
          ]),
          v:ValueSpecification[1] | sfe(minus_Integer_MANY__Integer_1_, iv([$args->at(2), iv(1)]))
        ]);

        let arguments = [$args->at(0), $args->at(1), $position];

        sfe(splitPart_String_$0_1$__String_1__Integer_1__String_$0_1$_, $arguments);
      }),
      string('starts_with', startsWith_String_1__String_1__Boolean_1_),
      string('strpos', indexOf_String_1__String_1__Integer_1_),
      string('substr', String, {args, fc, expCtx, ctx | processSubstring($args)}),
      string('substring', String, {args, fc, expCtx, ctx | processSubstring($args)}),
      string('upper', toUpper_String_1__String_1_),
      //DATE
      date('date', Date, {args, fc, expCtx, ctx |
        let date = possiblyProcessParseDate($args->at(0));

        nullOrSfe(datePart_Date_1__Date_1_, $date);
      }),
      date('date_part', Integer, {args, fc, expCtx, ctx |
        assertEquals(2, $args->size(), 'incorrect number of args for date_part');
        let part = $args->at(0)->reactivate()->toOne()->cast(@String);

        let func = [
          pair('year', year_Date_1__Integer_1_),
          pair('quarter', quarterNumber_Date_1__Integer_1_),
          pair('month', monthNumber_Date_1__Integer_1_),
          pair('week', weekOfYear_Date_1__Integer_1_),
          pair('dow', dayOfWeekNumber_Date_1__Integer_1_),
          pair('doy', dayOfYear_Date_1__Integer_1_),
          pair('day', dayOfMonth_Date_1__Integer_1_),
          pair('hour', hour_Date_1__Integer_1_),
          pair('minute', minute_Date_1__Integer_1_),
          pair('second', second_Date_1__Integer_1_),
          pair('epoch', toEpochValue_Date_1__Integer_1_)
        ]->getValue($part->toLower());

        nullOrSfe($func, $args->at(1));
      }),
      date('date_trunc', Date, {args, fc, expCtx, ctx |
        assertEquals(2, $args->size(), 'incorrect number of args for date_trunc');
        let part = $args->at(0);

        let value = $part->reactivate()->toOne()->cast(@String);

        let func = [
          pair('year', firstDayOfYear_Date_1__Date_1_),
          pair('quarter', firstDayOfQuarter_Date_1__StrictDate_1_),
          pair('month', firstDayOfMonth_Date_1__Date_1_),
          pair('week', firstDayOfWeek_Date_1__Date_1_),
          pair('day', firstHourOfDay_Date_1__DateTime_1_),
          pair('hour', firstMinuteOfHour_Date_1__DateTime_1_),
          pair('minute', firstSecondOfMinute_Date_1__DateTime_1_),
          pair('second', firstMillisecondOfSecond_Date_1__DateTime_1_)
        ]->getValue($value->toLower());

        nullOrSfe($func, $args->at(1));
      }),
      date('localtimestamp', Date, {args, fc, expCtx, ctx |
        assertEquals(0, $args->size(), 'only zero arg localtimestamp supported');

        sfe(now__DateTime_1_, []);
      }),
      date('make_date', Date, {args, fc, expCtx, ctx |
        assertEquals(3, $args->size(), 'incorrect number of args for make_date');

        let year = $args->at(0)->reactivate()->toOne()->cast(@Integer);
        let month = $args->at(1)->reactivate()->toOne()->cast(@Integer);
        let day = $args->at(2)->reactivate()->toOne()->cast(@Integer);

        let date = date($year, $month, $day);

        iv($date);
      }),

      date('make_timestamp', Date, {args, fc, expCtx, ctx |
        assertEquals(6, $args->size(), 'incorrect number of args for make_timestamp');

        let year = $args->at(0)->reactivate()->toOne()->cast(@Integer);
        let month = $args->at(1)->reactivate()->toOne()->cast(@Integer);
        let day = $args->at(2)->reactivate()->toOne()->cast(@Integer);
        let hours = $args->at(3)->reactivate()->toOne()->cast(@Integer);
        let minutes = $args->at(4)->reactivate()->toOne()->cast(@Integer);
        let seconds = $args->at(5)->reactivate()->toOne()->cast(@Number);

        let date = date($year, $month, $day, $hours, $minutes, $seconds);

        iv($date);
      }),

      //COLLECTION
      conditional('coalesce', [], {args, fc, expCtx, ctx |
        let filteredArgs = getNonNullArguments($args);
        let type = $filteredArgs.genericType->first().rawType;

        sfe(meta::pure::tds::extensions::firstNotNull_T_MANY__T_$0_1$_, ^GenericType(rawType = $type), ^GenericType(rawType = $type), $filteredArgs->iv());
      }),

      conditional('greatest', [], {args, fc, expCtx, ctx |
        let filteredArgs = getNonNullArguments($args);
        let type = $filteredArgs.genericType->first().rawType;

        let func = if ($filteredArgs->isEmpty(), | greatest_X_MANY__X_$0_1$_, | greatest_X_$1_MANY$__X_1_);

        sfe($func, ^GenericType(rawType = $type), ^GenericType(rawType = $type), $filteredArgs->iv());
      }),

      conditional('least', [], {args, fc, expCtx, ctx |
        let filteredArgs = getNonNullArguments($args);
        let type = $filteredArgs.genericType->first().rawType;

        let func = if ($filteredArgs->isEmpty(), | least_X_MANY__X_$0_1$_, | least_X_$1_MANY$__X_1_);

        sfe($func, ^GenericType(rawType = $type), ^GenericType(rawType = $type), $filteredArgs->iv());
      }),

      array('distinct', Any, {args, fc, expCtx, ctx |
        let type = getAggregationArgumentType($args);
        let genericType = ^GenericType(rawType = $type);
        sfe(distinct_T_MANY__T_MANY_, $genericType, $genericType, $args);
      }),

      array('array_position', Integer, {args, fc, expCtx, ctx |
        assertRelation($expCtx.relation, 'array_position');
        assertEquals(2, $args->size(), 'only two arg array_position supported');

        sfe(indexOf_T_MANY__T_1__Integer_1_, $args);
      }),
      array('array_length', Integer, {args, fc, expCtx, ctx |
        $args->at(1)->match([
          i:InstanceValue[1] | assert($i.values == 1, 'only array_length with arg 1 supported')
        ]);

        sfe(size_Any_MANY__Integer_1_, $args->at(0));
      }),

      //FORMAT
      format('to_char', String, {args, fc, expCtx, ctx |
        assertEquals(2, $args->size(), 'incorrect number of args for to_char');

        let arg = $args->at(0);
        let type = $arg.genericType.rawType;
        let format = $args->at(1)->reactivate()->toOne()->cast(@String);

        assert($type->isNotEmpty() && $type->toOne()->normalizeType() == Date, 'to_char currently only supported for date inputs');

        toChar($format, [], $arg->evaluateAndDeactivate());
      }),

      //JSON
      json('json_extract_path', Variant, {args, fc, expCtx, ctx | processJSONExtractPath($args)}),
      json('json_extract_path_text', Variant, {args, fc, expCtx, ctx |
        processVariantCast(^Cast(expression = $fc, type = ^ColumnType(name = 'TEXT')), processJSONExtractPath($args));
      }),

      //WINDOW
      window('last_value', [], {args, fc, expCtx, ctx |
        assertRelation($expCtx.relation, 'last_value');

        let last = sfe(meta::pure::functions::relation::last_Relation_1___Window_1__T_1__T_$0_1$_, [var('p', PureOne, []), var('w', PureOne, []), var('r', PureOne, [])]);

        getWindowPropertyArg($args, $last, 'last_value');
      }),
      window('first_value', [], {args, fc, expCtx, ctx |
        assertRelation($expCtx.relation, 'first_value');

        let first = sfe(meta::pure::functions::relation::first_Relation_1___Window_1__T_1__T_$0_1$_, [var('p', PureOne, []), var('w', PureOne, []), var('r', PureOne, [])]);

        getWindowPropertyArg($args, $first, 'first_value');
      }),
      window('lag', [], {args, fc, expCtx, ctx |
        assertRelation($expCtx.relation, 'lag');

        let lag = $args->match([
          v:ValueSpecification[2] | sfe(meta::pure::functions::relation::lag_Relation_1__T_1__Integer_1__T_$0_1$_, [var('p', PureOne, []), var('r', PureOne, []), $v->at(1)]),
          v:ValueSpecification[1] | sfe(meta::pure::functions::relation::lag_Relation_1__T_1__T_$0_1$_, [var('p', PureOne, []), var('r', PureOne, [])]),
          v:ValueSpecification[*] | fail('incorrect number of args for lag'); iv(1);
        ]);

        getWindowPropertyArg($args->first(), $lag, 'lag');
      }),

      window('lead', [], {args, fc, expCtx, ctx |
        assertRelation($expCtx.relation, 'lead');

        let lead = $args->match([
          v:ValueSpecification[2] | sfe(meta::pure::functions::relation::lead_Relation_1__T_1__Integer_1__T_$0_1$_, [var('p', PureOne, []), var('r', PureOne, []), $v->at(1)]),
          v:ValueSpecification[1] | sfe(meta::pure::functions::relation::lead_Relation_1__T_1__T_$0_1$_, [var('p', PureOne, []), var('r', PureOne, [])]),
          v:ValueSpecification[*] | fail('incorrect number of args for lead'); iv(1);
        ]);

        getWindowPropertyArg($args->first(), $lead, 'lead');
      }),

      window('nth_value', [], {args, fc, expCtx, ctx |
        assertRelation($expCtx.relation, 'lead');
        assertEquals(2, $args->size(), 'incorrect number of args for nth');

        let nth = sfe(meta::pure::functions::relation::nth_Relation_1___Window_1__T_1__Integer_1__T_$0_1$_, [var('p', PureOne, []), var('w', PureOne, []), var('r', PureOne, []), $args->at(1)]);

        getWindowPropertyArg($args->first(), $nth, 'lead');
      }),

      window('row_number', [], {args, fc, expCtx, ctx |
        if ($expCtx.relation,
          |
            sfe(rowNumber_Relation_1__T_1__Integer_1_, [var('p', PureOne, []), var('r', PureOne, [])]),
          |
            let values = $expCtx.defaultVar->toOne()->concatenate($args);
            sfe(meta::pure::functions::math::olap::rowNumber_Any_MANY__Map_1_, ^GenericType(rawType = Map, typeArguments = [^GenericType(rawType = Any), ^GenericType(rawType = Integer)]), [^GenericType(rawType = Any), ^GenericType(rawType = Integer)], $values);
        )
      }),
      window('dense_rank', [], {args, fc, expCtx, ctx |
        if ($expCtx.relation,
          |
            sfe(denseRank_Relation_1___Window_1__T_1__Integer_1_, [var('p', PureOne, []), var('w', PureOne, []), var('r', PureOne, [])]),
          |
            let values = $expCtx.defaultVar->toOne()->concatenate($args);
            sfe(meta::pure::functions::math::olap::denseRank_Any_MANY__Map_1_, ^GenericType(rawType = Map, typeArguments = [^GenericType(rawType = Any), ^GenericType(rawType = Integer)]), [^GenericType(rawType = Any), ^GenericType(rawType = Integer)], $values);
        )
      }),
      window('rank', [], {args, fc, expCtx, ctx |
        if ($expCtx.relation,
          |
            sfe(rank_Relation_1___Window_1__T_1__Integer_1_, [var('p', PureOne, []), var('w', PureOne, []), var('r', PureOne, [])]),
          |
            let values = $expCtx.defaultVar->toOne()->concatenate($args);
            sfe(meta::pure::functions::math::olap::rank_Any_MANY__Map_1_, ^GenericType(rawType = Map, typeArguments = [^GenericType(rawType = Any), ^GenericType(rawType = Integer)]), [^GenericType(rawType = Any), ^GenericType(rawType = Integer)], $values);
        )
      }),

      window('percent_rank', [], {args, fc, expCtx, ctx |
        assertRelation($expCtx.relation, 'percent_rank');
        assertEquals(0, $args->size(), 'incorrect number of args for percent_rank');

        sfe(meta::pure::functions::relation::percentRank_Relation_1___Window_1__T_1__Float_1_, [var('p', PureOne, []), var('w', PureOne, []), var('r', PureOne, [])]);
      }),

      window('ntile', [], {args, fc, expCtx, ctx |
        assertRelation($expCtx.relation, 'ntile');
        assertEquals(1, $args->size(), 'incorrect number of args for ntile');

        sfe(meta::pure::functions::relation::ntile_Relation_1__T_1__Integer_1__Integer_1_, [var('p', PureOne, []), var('r', PureOne, []), $args->at(0)]);
      }),

      window('cume_dist', [], {args, fc, expCtx, ctx |
        assertRelation($expCtx.relation, 'cume_dist');
        assertEquals(0, $args->size(), 'incorrect number of args for cume_dist');

        sfe(meta::pure::functions::relation::cumulativeDistribution_Relation_1___Window_1__T_1__Float_1_, [var('p', PureOne, []), var('w', PureOne, []), var('r', PureOne, [])]);
      }),

      misc('var', Any, {args, fc, expCtx, ctx |
        getVariableReference($args, $ctx);
      })
  ]
}



function meta::external::query::sql::transformation::queryToPure::functionProcessor(name:QualifiedName[1]):FunctionProcessor[1]
{
  assertEquals(1, $name.parts->size(), | 'function name has more than 1 part ' + $name->extractNameFromQualifiedName([]));
  functionProcessor($name.parts->at(0));
}

function meta::external::query::sql::transformation::queryToPure::allProcessors():FunctionProcessor[*]
{
  functionProcessors()->concatenate(tableFunctionProcessors())
}

function meta::external::query::sql::transformation::queryToPure::functionProcessor(name:String[1]):FunctionProcessor[1]
{
  functionProcessor($name, functionProcessors());
}

function meta::external::query::sql::transformation::queryToPure::tableFunctionProcessor(name:String[1]):FunctionProcessor[1]
{
  functionProcessor($name, tableFunctionProcessors());
}

function meta::external::query::sql::transformation::queryToPure::functionProcessor(name:String[1], processors:FunctionProcessor[*]):FunctionProcessor[1]
{
  let coreProcessor = $processors->filter(p | $p.name == $name->toLower());

  let processor = if ($coreProcessor->isEmpty(),
  | meta::external::query::sql::getSQLExtensions().udf($name),
  | $coreProcessor);

  assertEquals(1, $processor->size(), | 'no handler found for function ' + $name);

  $processor->toOne();
}

function meta::external::query::sql::transformation::queryToPure::aggregateProcessor(name:QualifiedName[1]):AggregateFunctionProcessor[1]
{
  assertEquals(1, $name.parts->size(), | 'function name has more than 1 part ' + $name->extractNameFromQualifiedName([]));
  aggregateProcessor($name.parts->at(0));
}

function meta::external::query::sql::transformation::queryToPure::aggregateProcessor(name:String[1]):AggregateFunctionProcessor[1]
{
  let processor = functionProcessor($name);
  assert($processor->instanceOf(AggregateFunctionProcessor), | 'processor for ' + $name + ' is not aggregate processor');
  $processor->cast(@AggregateFunctionProcessor);
}

function meta::external::query::sql::transformation::queryToPure::misc(name:String[1], func:Function<Any>[1]):FunctionProcessor[1]
{
  processor($name, $func->functionReturnType().rawType, simpleFunctionTransform($func), ProcessorFunctionType.MISC);
}

function meta::external::query::sql::transformation::queryToPure::misc(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]):FunctionProcessor[1]
{
  processor($name, $returnType, $transform, ProcessorFunctionType.ARRAY)
}


function meta::external::query::sql::transformation::queryToPure::format(name:String[1], func:Function<Any>[1]):FunctionProcessor[1]
{
  processor($name, $func->functionReturnType().rawType, simpleFunctionTransform($func), ProcessorFunctionType.FORMAT);
}

function meta::external::query::sql::transformation::queryToPure::format(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]):FunctionProcessor[1]
{
  processor($name, $returnType, $transform, ProcessorFunctionType.ARRAY)
}


function meta::external::query::sql::transformation::queryToPure::conditional(name:String[1], func:Function<Any>[1]):FunctionProcessor[1]
{
  processor($name, $func->functionReturnType().rawType, simpleFunctionTransform($func), ProcessorFunctionType.CONDITIONAL);
}

function meta::external::query::sql::transformation::queryToPure::conditional(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]):FunctionProcessor[1]
{
  processor($name, $returnType, $transform, ProcessorFunctionType.CONDITIONAL)
}

function meta::external::query::sql::transformation::queryToPure::array(name:String[1], func:Function<Any>[1]):FunctionProcessor[1]
{
  processor($name, $func->functionReturnType().rawType, simpleFunctionTransform($func), ProcessorFunctionType.ARRAY);
}

function meta::external::query::sql::transformation::queryToPure::array(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]):FunctionProcessor[1]
{
  processor($name, $returnType, $transform, ProcessorFunctionType.ARRAY)
}

function meta::external::query::sql::transformation::queryToPure::json(name:String[1], func:Function<Any>[1]):FunctionProcessor[1]
{
  processor($name, $func->functionReturnType().rawType, simpleFunctionTransform($func), ProcessorFunctionType.JSON);
}

function meta::external::query::sql::transformation::queryToPure::json(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]):FunctionProcessor[1]
{
  processor($name, $returnType, $transform, ProcessorFunctionType.JSON)
}

function meta::external::query::sql::transformation::queryToPure::date(name:String[1], func:Function<Any>[1]):FunctionProcessor[1]
{
  processor($name, $func->functionReturnType().rawType, simpleFunctionTransform($func), ProcessorFunctionType.DATE);
}

function meta::external::query::sql::transformation::queryToPure::date(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]):FunctionProcessor[1]
{
  processor($name, $returnType, $transform, ProcessorFunctionType.DATE)
}

function meta::external::query::sql::transformation::queryToPure::math(name:String[1], func:Function<Any>[1]):FunctionProcessor[1]
{
  processor($name, $func->functionReturnType().rawType, simpleFunctionTransform($func), ProcessorFunctionType.MATH);
}

function meta::external::query::sql::transformation::queryToPure::math(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]):FunctionProcessor[1]
{
  processor($name, $returnType, $transform, ProcessorFunctionType.MATH)
}

function meta::external::query::sql::transformation::queryToPure::string(name:String[1], func:Function<Any>[1]):FunctionProcessor[1]
{
  processor($name, $func->functionReturnType().rawType, simpleFunctionTransform($func), ProcessorFunctionType.STRING);
}

function meta::external::query::sql::transformation::queryToPure::string(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]):FunctionProcessor[1]
{
  processor($name, $returnType, $transform, ProcessorFunctionType.STRING)
}

function meta::external::query::sql::transformation::queryToPure::processor(name:String[1], func:Function<Any>[1], type:ProcessorFunctionType[1]):FunctionProcessor[1]
{
  processor($name, $func->functionReturnType().rawType, simpleFunctionTransform($func), $type);
}

function meta::external::query::sql::transformation::queryToPure::processor(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1], type:ProcessorFunctionType[1]):FunctionProcessor[1]
{
  ^FunctionProcessor(name = $name, returnType = $returnType, transform = $transform, type = $type);
}

function meta::external::query::sql::transformation::queryToPure::aggregate(name:String[1], func:Function<Any>[1]):AggregateFunctionProcessor[1]
{
  aggregate($name, $func->functionReturnType().rawType, simpleFunctionTransform($func));
}

function meta::external::query::sql::transformation::queryToPure::aggregate(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1] ->ValueSpecification[1]}>[1]):AggregateFunctionProcessor[1]
{
  aggregate($name, $returnType, $transform, defaultAggregatePreProcessor_Expression_1__FunctionCall_1__AggregateFunctionPreProcessorWrapper_1_);
}

function meta::external::query::sql::transformation::queryToPure::aggregate(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1], preProcessor:Function<{meta::external::query::sql::metamodel::Expression[1], meta::external::query::sql::metamodel::FunctionCall[1] -> AggregateFunctionPreProcessorWrapper[1]}>[1]):AggregateFunctionProcessor[1]
{
  ^AggregateFunctionProcessor(name = $name, returnType = $returnType, transform = $transform, preProcessor = $preProcessor, type = ProcessorFunctionType.AGGREGATE);
}

function meta::external::query::sql::transformation::queryToPure::window(name:String[1], returnType:Type[0..1], transform:Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]):WindowFunctionProcessor[1]
{
  ^WindowFunctionProcessor(name = $name, returnType = $returnType, transform = $transform, type = ProcessorFunctionType.WINDOW);
}

Class meta::external::query::sql::transformation::queryToPure::AggregateFunctionPreProcessorWrapper
{
  map:meta::external::query::sql::metamodel::Expression[0..1];
  aggregate:meta::external::query::sql::metamodel::Expression[1];
}

function meta::external::query::sql::transformation::queryToPure::percentilePreProcessor(column:meta::external::query::sql::metamodel::Expression[1], aggregate:FunctionCall[1]):AggregateFunctionPreProcessorWrapper[1]
{
  assert($aggregate.group->isNotEmpty(), 'percentile must be within group');
  assert($aggregate.orderBy->isEmpty(), 'aggregate order by not supported');

  ^AggregateFunctionPreProcessorWrapper(
    map = $aggregate.group.orderBy.sortKey->toOne(),
    aggregate = $column
  );
}

function meta::external::query::sql::transformation::queryToPure::defaultAggregatePreProcessor(column:meta::external::query::sql::metamodel::Expression[1], aggregate:FunctionCall[1]):AggregateFunctionPreProcessorWrapper[1]
{
  assert($aggregate.group->isEmpty(), 'aggregate within group not supported');
  assert($aggregate.orderBy->isEmpty(), 'aggregate order by not supported');

  ^AggregateFunctionPreProcessorWrapper(
    map = $aggregate.arguments->first(),
    aggregate = $column->replaceAggregateArguments()
  );
}

function meta::external::query::sql::transformation::queryToPure::simpleFunctionTransform(func:Function<Any>[1]):Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1]->ValueSpecification[1]}>[1]
{
  {args:ValueSpecification[*], f:FunctionCall[1], e:SqlTransformExpressionContext[1], c:SqlTransformContext[1] | nullOrSfe($func, $args)}
}

function meta::external::query::sql::transformation::queryToPure::replaceAggregateArguments(column:meta::external::query::sql::metamodel::Expression[1]):meta::external::query::sql::metamodel::Expression[1]
{
  $column->walk([
      f:FunctionCall[1] |
        let processor = $f.name->functionProcessor();
        let var = ^QualifiedNameReference(name=^QualifiedName());
        if ($processor.isAggregate,
          | ^$f(arguments = $f.arguments->match([
              a:meta::external::query::sql::metamodel::Expression[0..1] | $var,
              a:meta::external::query::sql::metamodel::Expression[1..*] | $var->concatenate($a->tail()),
              a:meta::external::query::sql::metamodel::Expression[*] | fail('aggregation type currently not supported'); [];
          ])),
          | $f);
    ])->toOne()
}



Class meta::external::query::sql::transformation::queryToPure::AggregateFunctionProcessor extends FunctionProcessor
[
  $this.type == ProcessorFunctionType.AGGREGATE
]
{
  preProcessor: Function<{meta::external::query::sql::metamodel::Expression[1], meta::external::query::sql::metamodel::FunctionCall[1] -> AggregateFunctionPreProcessorWrapper[1]}>[1];
  preProcess(column:meta::external::query::sql::metamodel::Expression[1], aggregate:meta::external::query::sql::metamodel::FunctionCall[1]){
    $this.preProcessor->eval($column, $aggregate)
  }:AggregateFunctionPreProcessorWrapper[1];
}

Class meta::external::query::sql::transformation::queryToPure::WindowFunctionProcessor extends FunctionProcessor[
  $this.type == ProcessorFunctionType.WINDOW
]
{
}

Class meta::external::query::sql::transformation::queryToPure::FunctionProcessor
{
  name: String[1];
  transform: Function<{ValueSpecification[*], FunctionCall[1], SqlTransformExpressionContext[1], SqlTransformContext[1] ->ValueSpecification[1]}>[1];
  returnType: Type[0..1];
  isAggregate(){
    $this->instanceOf(AggregateFunctionProcessor);
  }:Boolean[1];
  isWindow(){
    $this->instanceOf(WindowFunctionProcessor)
  }:Boolean[1];
  type:ProcessorFunctionType[1];
}

Enum meta::external::query::sql::transformation::queryToPure::ProcessorFunctionType
{
  STRING, MATH, DATE, JSON, ARRAY, FORMAT, MISC, AGGREGATE, WINDOW, BIT, CONDITIONAL
}