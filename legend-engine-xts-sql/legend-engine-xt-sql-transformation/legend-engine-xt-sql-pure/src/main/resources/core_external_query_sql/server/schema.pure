// Copyright 2025 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::metamodel::relation::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::external::query::sql::transformation::compile::utils::*;
import meta::external::query::sql::*;
import meta::pure::metamodel::relation::*;
import meta::relational::metamodel::*;
import meta::external::query::sql::server::schema::*;

Class meta::external::query::sql::server::schema::AddressableRelation
{
  tableFunctionName: String[1];
  packageableElement : String[1];
  pathWithinElement : String[*];
  relationType : meta::protocols::pure::vX_X_X::metamodel::m3::relation::RelationType[1];
}

Class meta::external::query::sql::server::schema::AddressableRelationCollection
{
  addressableRelations : meta::external::query::sql::server::schema::AddressableRelation[*];
}

function meta::external::query::sql::server::schema::transform(p:PackageableElement[*]):AddressableRelationCollection[1]
{
  ^AddressableRelationCollection
  (
      addressableRelations = $p->removeDuplicates()->map(a|$a->transformOne())
  )
}

function meta::external::query::sql::server::schema::serialize(p:PackageableElement[1]):String[1]
{
  let config = meta::external::query::sql::transformation::queryToPure::dynamicGrammarConfiguration();
  $p
  ->scanDependencies([], meta::pure::extension::runtime::getExtensions().moduleExtensions->filter(x|$x->instanceOf(PureToSQLSourceModule))->cast(@PureToSQLSourceModule).extraScanDependenciesType)
  ->removeDuplicates({a,b|$a->elementToPath() == $b->elementToPath()})
  ->map(x|$x->printPackageableElements($config))->joinStrings('\n');
}

function meta::external::query::sql::server::schema::transformOne(p:PackageableElement[1]):AddressableRelation[*]
{
  $p->match(
    meta::pure::extension::runtime::getExtensions().moduleExtensions->filter(x|$x->instanceOf(PureToSQLSourceModule))->cast(@PureToSQLSourceModule).extraSchemaTransformers->concatenate(
      [
          d:Database[1]| let dbPath = $d->elementToPath();
                         let dbStr = $d->serialize();

                        let accessors = $d.schemas.tables->map(t | 
                          let path = getTablePath($t);
                          '#>{'+$dbPath + '.' + $path->joinStrings('.')+'}#;';
                        );

                        if ($accessors->isNotEmpty(),
                          |
                            let code = $dbStr+'\n###Pure\nfunction test::container():Any[*]{\n' + $accessors->joinStrings('\n') + '\n}';

                            let compiled = meta::legend::compile($code);

                            let expressions = $compiled->filter(x|$x.name == 'container__Any_MANY_')->toOne()->cast(@FunctionDefinition<Any>).expressionSequence->evaluateAndDeactivate();

                            $expressions->map(e |
                              let table = $e->cast(@InstanceValue).values->toOne()->cast(@meta::pure::store::RelationStoreAccessor<Any>).sourceElement->cast(@Table);

                              ^AddressableRelation
                              (
                                  tableFunctionName = 'tb',
                                  packageableElement = $dbPath,
                                  pathWithinElement = getTablePath($table),
                                  relationType = $e.genericType.typeArguments.rawType->toOne()->cast(@RelationType<Any>)->transformRelationType()
                              );
                            );,
                          | []);,
          a:Any[1]|[]
      ]
    )->toOneMany()    
  )
}

function <<access.private>> meta::external::query::sql::server::schema::getTablePath(t:Table[1]):String[1]
{
  if ($t.schema.name == 'default', | '', | $t.schema.name + '.') + $t.name
}