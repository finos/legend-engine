import meta::pure::metamodel::relation::*;
import meta::pure::dataQuality::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::lineage::scanProperties::*;
import meta::external::dataquality::*;
import meta::pure::graphFetch::*;
import meta::pure::functions::collection::*;
import meta::pure::functions::meta::*;
import meta::pure::graphFetch::execution::*;
import meta::core::runtime::*;
import meta::pure::executionPlan::*;
import meta::pure::mapping::*;
import meta::pure::functions::boolean::*;
import meta::pure::metamodel::constraint::*;
import meta::pure::lineage::scanProperties::propertyTree::*;
import meta::pure::precisePrimitives::*;


Class meta::external::dataquality::MilestoningContext
{
  rootBusinessTemporal: Boolean[1];
  rootProcessingTemporal: Boolean[1];
  nonRootBusinessTemporal: Boolean[1];
  nonRootProcessingTemporal: Boolean[1];

  businessTemporal(){
      $this.rootBusinessTemporal || $this.nonRootBusinessTemporal
  }:Boolean[1];

  processingTemporal(){
      $this.rootProcessingTemporal || $this.nonRootProcessingTemporal
  }:Boolean[1];
}

function meta::external::dataquality::generateDataQualityQuery(dataquality:meta::external::dataquality::DataQuality<Any>[1], limit: Integer[0..1]): LambdaFunction<Any>[1]
{
  generateDataQualityQuery($dataquality, $limit, true);
}


function meta::external::dataquality::getMilestoningContext(tree:RootGraphFetchTree<Any>[1]): MilestoningContext[1]
{
  let properties = getAllProperties($tree);
  let propertyTypes = $properties.genericType.rawType;

  ^MilestoningContext(
      rootBusinessTemporal = $tree.class->meta::pure::milestoning::isBusinessTemporal(),
      rootProcessingTemporal = $tree.class->meta::pure::milestoning::isProcessingTemporal(),
      nonRootBusinessTemporal = $propertyTypes->exists(t | $t->meta::pure::milestoning::isBusinessTemporal()),
      nonRootProcessingTemporal = $propertyTypes->exists(t | $t->meta::pure::milestoning::isProcessingTemporal())
  );
}

function meta::external::dataquality::addMilestoningParameters(tree:GraphFetchTree[1]):GraphFetchTree[1]
{
  $tree->match([
    p:PropertyGraphFetchTree[1] |
      let parameters = if ($p.parameters->isEmpty(),
        | let isBusinessTemporal = $p.property.genericType.rawType->toOne()->meta::pure::milestoning::isBusinessTemporal();
          let isProcessingTemporal = $p.property.genericType.rawType->toOne()->meta::pure::milestoning::isProcessingTemporal();
          getTemporalParameters($isProcessingTemporal, $isBusinessTemporal);,
        | $p.parameters
      );

      ^$p(
          subTrees = $p.subTrees->map(t | addMilestoningParameters($t)),
          parameters = $parameters,
          subTypeTrees = $p.subTypeTrees->map(t | addMilestoningParameters($t))->cast(@SubTypeGraphFetchTree)
      );,
    g:GraphFetchTree[1] |
      ^$g(
          subTrees = $g.subTrees->map(t | addMilestoningParameters($t)),
          subTypeTrees = $g.subTypeTrees->map(t | addMilestoningParameters($t))->cast(@SubTypeGraphFetchTree)
      )
  ])
}

function meta::external::dataquality::generateDataQualityQuery(dataquality:meta::external::dataquality::DataQuality<Any>[1], limit: Integer[0..1], useFrom:Boolean[1]): LambdaFunction<Any>[1]
{
   $dataquality.validationTree->validateTreeForNestedConstraints(true);

   let milestonedTree = $dataquality.validationTree->addMilestoningParameters();

   // 1. enrich tree with selected constraint properties
   let enrichedTree = $milestonedTree->ensureFunctionRequirementsForDataQuality($dataquality.validationTree.constraints, $dataquality.validationTree.class, [], true)->cast(@RootGraphFetchTree<Any>);

   let milestoningContext = getMilestoningContext($enrichedTree);

   // 2. build query
   let getAll = $dataquality.validationTree.class->createGetAll($milestoningContext.rootProcessingTemporal, $milestoningContext.rootBusinessTemporal);

   let getExpr = if ($dataquality.filter->isNotEmpty(),
                            | $dataquality.validationTree.class->generateFilterQuery($getAll, $dataquality.filter->toOne());,
                            | $getAll);
   let dqRootConstraints = $dataquality.validationTree.constraints;
   let constraintQueryExpr = $dataquality.validationTree.class->meta::external::dataquality::generateConstraintsNegatedORQuery($getExpr, ^List<Constraint>(values=$dqRootConstraints));
   let limitQueryExpr = if ($limit->isNotEmpty(),
                             | $constraintQueryExpr->buildLimitFilterExpression($limit->toOne(), ^GenericType(rawType=$dataquality.validationTree.class)),
                             | $constraintQueryExpr);
   let graphFetchChecked = ^SimpleFunctionExpression(func=graphFetchChecked_T_MANY__RootGraphFetchTree_1__Checked_MANY_  ,
                                                    parametersValues=[$limitQueryExpr, ^InstanceValue(values=$enrichedTree, genericType=^GenericType(rawType=RootGraphFetchTree), multiplicity=PureOne)],
                                                    functionName=graphFetchChecked_T_MANY__RootGraphFetchTree_1__Checked_MANY_.name,
                                                    genericType=^GenericType(rawType=Checked, typeArguments=^GenericType(rawType=$dataquality.validationTree.class)),
                                                    multiplicity = ZeroMany,
                                                    importGroup=system::imports::coreImport);
  // 2.1
  let serialized = ^SimpleFunctionExpression(func=serialize_Checked_MANY__RootGraphFetchTree_1__String_1_,
                                             functionName=serialize_Checked_MANY__RootGraphFetchTree_1__String_1_.name,
                                             importGroup=system::imports::coreImport,
                                             genericType=^GenericType(rawType=String),
                                             multiplicity=ZeroMany,
                                             parametersValues=[$graphFetchChecked, ^InstanceValue(values=$enrichedTree, genericType=^GenericType(rawType=RootGraphFetchTree), multiplicity=PureOne)])->evaluateAndDeactivate();

  // 2.2 extract mapping and runtime here
  let mappingAndRuntime = $dataquality.context->getMappingAndRuntime();
  let deactivatedMapping = ^InstanceValue(values=$mappingAndRuntime.first->evaluateAndDeactivate(), genericType=^GenericType(rawType=Mapping), multiplicity=PureOne) ;
  let deactivatedRuntime = ^InstanceValue(values=$mappingAndRuntime.second->evaluateAndDeactivate(), genericType=^GenericType(rawType=NonExecutableValueSpecification), multiplicity=PureOne);

  let from = if ($useFrom, | ^SimpleFunctionExpression(func=from_T_m__Mapping_1__Runtime_1__T_m_,
                                       functionName=from_T_m__Mapping_1__Runtime_1__T_m_.name,
                                       importGroup=system::imports::coreImport,
                                       genericType=^GenericType(rawType=String),
                                       multiplicity=ZeroMany,
                                       parametersValues=[$serialized, $deactivatedMapping, $deactivatedRuntime])->evaluateAndDeactivate(), | $serialized);

  // 3. build lambda
  createLambda($from, $milestoningContext.processingTemporal, $milestoningContext.businessTemporal);
}

function meta::external::dataquality::validateTreeForNestedConstraints(node:GraphFetchTree[1], isRoot:Boolean[1]): Boolean[1]
{
  if ($isRoot->isFalse() && $node->cast(@DataQualityPropertyGraphFetchTree).constraints->isNotEmpty(),
      | fail('Nested constraints are not currently supported!'),
      | ''
      );
  $node.subTrees->fold({subtree, isValid | $isValid && $subtree->validateTreeForNestedConstraints(false)}, true);
}

function meta::external::dataquality::ensureFunctionRequirementsForDataQuality(node:GraphFetchTree[1], constraints:Constraint[*], class:Class<Any>[1], processed:Class<Any>[*], ensureConstraintsForSubTrees:Boolean[1]): GraphFetchTree[1]
{
   let constraintResult          = pathsForConstraintFunctions($class, $constraints.functionDefinition->concatenate($constraints.messageFunction));
   let qualifiedPropertyPaths    = $constraintResult->filter(path| $path.values->exists(x| $x.property->instanceOf(QualifiedProperty)));  //QualifiedProperty/derived property - methods within a class - first try with inline properties, milestoning properties - used in loans usecase
   let inlinedPropertyTree       = $constraintResult->meta::pure::lineage::scanProperties::propertyTree::buildPropertyTree()->meta::pure::lineage::scanProperties::inlineQualifiedPropertyNodes();
   let inlinedGraphTree          = $inlinedPropertyTree->propertyTreeToGraphFetchTree($class);
   let inlinedPropertyGraphTrees = $inlinedGraphTree.subTrees->cast(@PropertyGraphFetchTree);
   let withFoundProperties       = $node->addSubTrees($inlinedPropertyGraphTrees);
   let updatedForClass           = $qualifiedPropertyPaths->fold({path, gt| $gt->meta::external::dataquality::recordQualifiedProperties($path)}, $withFoundProperties);
   let updatedProcessed          = $processed->add($class);

   if($ensureConstraintsForSubTrees,
      {|
         let newSubTrees = $updatedForClass.subTrees->map({st|
            let returns = if($st->cast(@PropertyGraphFetchTree).subType->isEmpty(),
                            | $st->cast(@PropertyGraphFetchTree).property->functionReturnType().rawType->toOne(),
                            | $st->cast(@PropertyGraphFetchTree).subType->toOne()
                            );
            if($returns->instanceOf(Class) && !$updatedProcessed->contains($returns),
               | $st->ensureFunctionRequirementsForDataQuality($constraints, $returns->cast(@Class<Any>), $updatedProcessed, $ensureConstraintsForSubTrees),
               | $st
            );
         });

         ^$updatedForClass(subTrees=$newSubTrees);
      },
      | $updatedForClass
   );
}

function <<access.private>> meta::external::dataquality::createGetAll<T>(c: Class<T>[1]):FunctionExpression[1]
{
  let getAllExpression = ^SimpleFunctionExpression
   (
      func = getAll_Class_1__T_MANY_,
      functionName = getAll_Class_1__T_MANY_.name,
      importGroup = system::imports::coreImport,
      genericType = ^GenericType(rawType = $c),
      multiplicity = ZeroMany,
      parametersValues = ^InstanceValue( genericType = ^GenericType(rawType = Class, typeArguments = ^GenericType(rawType = $c)),
                                         multiplicity = PureOne,
                                         values = $c
                                       ))->evaluateAndDeactivate();
   let classifierGenericType = ^GenericType(rawType = LambdaFunction, typeArguments = ^GenericType(rawType = ^FunctionType(returnMultiplicity = ZeroMany, returnType = ^GenericType(rawType = $c))));
   let lambda = {|[]};
   ^$lambda(classifierGenericType=$classifierGenericType, expressionSequence = $getAllExpression).expressionSequence->at(0)->cast(@FunctionExpression);
}

function <<access.private>> meta::external::dataquality::getAllProperties(tree:GraphFetchTree[1]):AbstractProperty<Any>[*]
{
  let properties = $tree->match([
    p:PropertyGraphFetchTree[1] | $p.property,
    g:GraphFetchTree[1] | []
  ]);

  $tree.subTrees->concatenate($tree.subTypeTrees)
    ->map(t | $t->getAllProperties())
    ->concatenate($properties);
}

function meta::external::dataquality::createLambda(body:ValueSpecification[1], processingTemporal:Boolean[1], businessTemporal:Boolean[1]):LambdaFunction<Any>[1]
{
  let parameters = getTemporalParameters($processingTemporal, $businessTemporal);
  let functionType = ^FunctionType(returnMultiplicity = $body.multiplicity, returnType = $body.genericType, parameters = $parameters);

  let lambda = newLambdaFunction($functionType);
  ^$lambda(expressionSequence = $body);
}

function <<access.private>> meta::external::dataquality::createGetAll<T>(c: Class<T>[1], processingTemporal:Boolean[1], businessTemporal:Boolean[1]):FunctionExpression[1]
{
  let func = [
    pair($processingTemporal && $businessTemporal, getAll_Class_1__Date_1__Date_1__T_MANY_),
    pair($processingTemporal || $businessTemporal, getAll_Class_1__Date_1__T_MANY_),
    pair(true, getAll_Class_1__T_MANY_)
  ]->filter(t | $t.first == true)->at(0).second;

  let parameters = getTemporalParameters($processingTemporal, $businessTemporal);

  ^SimpleFunctionExpression
   (
      func = $func,
      functionName = $func.name,
      importGroup = system::imports::coreImport,
      genericType = ^GenericType(rawType = $c),
      multiplicity = ZeroMany,
      parametersValues = ^InstanceValue( genericType = ^GenericType(rawType = Class, typeArguments = ^GenericType(rawType = $c)),
                                          multiplicity = PureOne,
                                          values = $c
                                       )->concatenate($parameters)
    )->evaluateAndDeactivate();
}

function <<access.private>> meta::external::dataquality::getTemporalParameters(processingTemporal:Boolean[1], businessTemporal:Boolean[1]):VariableExpression[*]
{

  [
    pair($processingTemporal, ^VariableExpression(name='processingDate', genericType=^GenericType(rawType=Date), multiplicity=PureOne)->evaluateAndDeactivate()),
    pair($businessTemporal, ^VariableExpression(name='businessDate', genericType=^GenericType(rawType=Date), multiplicity=PureOne)->evaluateAndDeactivate())
  ]->filter(f | $f.first).second->evaluateAndDeactivate();
}

function meta::external::dataquality::generateFilterQuery<T>(c:Class<T>[1], f: FunctionExpression[1], filter:LambdaFunction<{T[1]->Boolean[1]}>[1]):FunctionExpression[1] {
  let dummyLambda = {|'ok'};
   ^SimpleFunctionExpression
   (
      func = filter_T_MANY__Function_1__T_MANY_,
      multiplicity = ZeroMany,
      genericType  = ^GenericType(rawType = $c),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [  $f,
         ^InstanceValue (
            genericType = ^GenericType(rawType=LambdaFunction, typeArguments=^GenericType(rawType=^FunctionType(parameters=^VariableExpression(name='x', genericType=^GenericType(rawType = $c), multiplicity=PureOne), returnMultiplicity=PureOne, returnType=^GenericType(rawType=Boolean)))),
            multiplicity = PureOne,
            values = lambda(functionType('x', $c, PureOne, Boolean, ZeroMany), $filter.expressionSequence->evaluateAndDeactivate()->replaceVariableWithVariable('this', 'x'))
         )
     ]
   )->evaluateAndDeactivate();
}


function meta::external::dataquality::lambda(functionType:FunctionType[1], expressionSequence:ValueSpecification[*]):LambdaFunction<Any>[1]
{
  let lambda = meta::pure::functions::meta::newLambdaFunction($functionType);
  ^$lambda(expressionSequence = $expressionSequence->toOneMany());
}

function meta::external::dataquality::functionType(name:String[1], type:Type[1], multiplicity:Multiplicity[1], returnType:Type[1], returnMultiplicity:Multiplicity[1]):FunctionType[1]
{
  functionType($name, ^GenericType(rawType = $type), $multiplicity, ^GenericType(rawType = $returnType), $returnMultiplicity);
}

function meta::external::dataquality::functionType(name:String[1], type:GenericType[1], multiplicity:Multiplicity[1], returnType:GenericType[1], returnMultiplicity:Multiplicity[1]):FunctionType[1]
{
  ^FunctionType(parameters = ^VariableExpression(genericType = $type, name = $name, multiplicity = $multiplicity), returnMultiplicity = $returnMultiplicity, returnType = $returnType);
}

function meta::external::dataquality::functionType(parameters:VariableExpression[*], returnType:GenericType[1], returnMultiplicity:Multiplicity[1]):FunctionType[1]
{
  ^FunctionType(parameters = $parameters, returnMultiplicity = $returnMultiplicity, returnType = $returnType);
}


function meta::external::dataquality::generateConstraintsNegatedORQuery<T>(c:Class<T>[1], f: FunctionExpression[1], constraints: List<Constraint>[1]):FunctionExpression[1] {
  if ($constraints.values->isEmpty(),
       | $f ,
       | if ($constraints.values->size() == 1,
             | $c->generateConstraintNegatedQuery($f, $constraints.values->at(0)) ,
             | $c->generateORNegatedQuery($f, $constraints)
            );
     );
}


function meta::external::dataquality::generateORNegatedQuery<T>(c:Class<T>[1], f: FunctionExpression[1], constraints: List<Constraint>[1]):FunctionExpression[1]
{
   let c1 = $constraints.values->at(0);
   let c2 = $constraints.values->at(1);
   let c1_negatedExprSequence = $c1.functionDefinition.expressionSequence->evaluateAndDeactivate()->toOne()->negatedFunctionExpression();
   let c2_negatedExprSequence = $c2.functionDefinition.expressionSequence->evaluateAndDeactivate()->toOne()->negatedFunctionExpression();
   let c1_c2_or_expr = $c1_negatedExprSequence->orFunctionExpression($c2_negatedExprSequence);

   let final_expr = $constraints.values->drop(2)->fold({c3, curr_or_exp |
          let c3_negatedExprSequence = $c3.functionDefinition.expressionSequence->evaluateAndDeactivate()->toOne()->negatedFunctionExpression();
          $c3_negatedExprSequence->orFunctionExpression($curr_or_exp);}, $c1_c2_or_expr);

   ^SimpleFunctionExpression
   (
      func = filter_T_MANY__Function_1__T_MANY_,
      multiplicity = ZeroMany,
      genericType  = ^GenericType(rawType = $c),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [  $f,
         ^InstanceValue (
            genericType = $c1.functionDefinition.classifierGenericType->toOne(),
            multiplicity = PureOne,
            values = lambda(functionType('x', $c, PureOne, Boolean, ZeroMany), $final_expr->evaluateAndDeactivate()->replaceVariableWithVariable('this', 'x'))
         )
     ]
   )->evaluateAndDeactivate();

}

function meta::external::dataquality::replaceVariableWithVariable(v:ValueSpecification[1..*], from:String[1], to:String[1]):ValueSpecification[1..*]
{
  $v->map(a | $a->replaceVariableWithVariable($from, $to))
}

function meta::external::dataquality::replaceVariableWithVariable(v:ValueSpecification[1], from:String[1], to:String[1]):ValueSpecification[1]
{
  $v->match([
    v:VariableExpression[1] | if ($v.name == $from, | ^$v(name = $to), | $v),
    s:SimpleFunctionExpression[1] | ^$s(parametersValues = $s.parametersValues->map(p | replaceVariableWithVariable($p, $from, $to))),
    i:InstanceValue[1] | ^$i(values = $i.values->map(v | $v->replaceVariableWithVariable($from, $to)))
  ])
}

function meta::external::dataquality::replaceVariableWithVariable(l:FunctionDefinition<Any>[1], from:String[1], to:String[1]):FunctionDefinition<Any>[1]
{
  ^$l(expressionSequence = $l.expressionSequence->replaceVariableWithVariable($from, $to))
}

function meta::external::dataquality::replaceVariableWithVariable(a:Any[1], from:String[1], to:String[1]):Any[1]
{
  $a->match([
    v:ValueSpecification[1] | $v->replaceVariableWithVariable($from, $to),
    l:LambdaFunction<Any>[1] | $l->replaceVariableWithVariable($from, $to),
    a:Any[1] | $a
  ])
}


function meta::external::dataquality::generateConstraintNegatedQuery<T>(c:Class<T>[1], f: FunctionExpression[1], constraint: Constraint[1]):FunctionExpression[1]
{
   let constraintExprSequence = $constraint.functionDefinition.expressionSequence->evaluateAndDeactivate()->toOne();
   let negatedExprSequence = $constraintExprSequence->negatedFunctionExpression();

   ^SimpleFunctionExpression
   (
      func = filter_T_MANY__Function_1__T_MANY_,
      multiplicity = ZeroMany,
      genericType  = ^GenericType(rawType = $c),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [  $f,
         ^InstanceValue (
            genericType = $constraint.functionDefinition.classifierGenericType->toOne(),
            multiplicity = PureOne,
            values = lambda(functionType('x', $c, PureOne, Boolean, ZeroMany), $negatedExprSequence->evaluateAndDeactivate()->replaceVariableWithVariable('this', 'x'))
         )
     ]
   )->evaluateAndDeactivate();
}

function <<access.private>> {doc.doc = 'Genrates a "!$f" query'}
meta::external::dataquality::negatedFunctionExpression(f: ValueSpecification[1]):ValueSpecification[1]
{
   if($f->instanceOf(SimpleFunctionExpression) && $f->cast(@SimpleFunctionExpression).func->evaluateAndDeactivate() == not_Boolean_1__Boolean_1_,
      | $f->cast(@SimpleFunctionExpression).parametersValues->evaluateAndDeactivate()->at(0),
      | ^SimpleFunctionExpression
         (
            func = not_Boolean_1__Boolean_1_, //native function meta::pure::functions::boolean::not(bool:Boolean[1]):Boolean[1];
            multiplicity = PureOne,
            genericType  = ^GenericType(rawType = Boolean),
            importGroup  = system::imports::coreImport,
            parametersValues = $f
         )->evaluateAndDeactivate()
   )
}

function {doc.doc = 'Generates a OR query'}
meta::external::dataquality::orFunctionExpression(f1: ValueSpecification[1], f2: ValueSpecification[1]):ValueSpecification[1]
{
^SimpleFunctionExpression
         (
            func = meta::pure::functions::boolean::or_Boolean_1__Boolean_1__Boolean_1_ ,   // meta::pure::functions::boolean::or  **use OR**
            multiplicity = PureOne,
            genericType  = ^GenericType(rawType = Boolean), // check types
            importGroup  = system::imports::coreImport,
            parametersValues = [$f1, $f2]
         )->evaluateAndDeactivate();
}

function {doc.doc = 'Generates a AND query'}
meta::external::dataquality::andFunctionExpression(f1: ValueSpecification[1], f2: ValueSpecification[1]):ValueSpecification[1]
{
^SimpleFunctionExpression
         (
            func = meta::pure::functions::boolean::and_Boolean_1__Boolean_1__Boolean_1_ ,
            multiplicity = PureOne,
            genericType  = ^GenericType(rawType = Boolean),
            importGroup  = system::imports::coreImport,
            parametersValues = [$f1, $f2]
         )->evaluateAndDeactivate();
}

function meta::external::dataquality::getMappingAndRuntime(context: DataQualityExecutionContext[1]):Pair<Mapping, Runtime>[1] {
  if($context->instanceOf(MappingAndRuntimeDataQualityExecutionContext),
      | let mappingAndRuntimeContext = $context->cast(@MappingAndRuntimeDataQualityExecutionContext);
        ^Pair<Mapping, Runtime>(first=$mappingAndRuntimeContext.mapping, second=$mappingAndRuntimeContext.runtime);,
      | let dataSpaceDataQualityExecutionContext = $context->cast(@DataSpaceDataQualityExecutionContext);
        let dataSpaceExecutionContext = $dataSpaceDataQualityExecutionContext.dataSpace.executionContexts->filter(execContext| $execContext.name == $dataSpaceDataQualityExecutionContext.contextName)->toOne();
        ^Pair<Mapping, Runtime>(first=$dataSpaceExecutionContext.mapping, second=$dataSpaceExecutionContext.defaultRuntime.runtimeValue);
    );
}

function  meta::external::dataquality::recordQualifiedProperties(tree:GraphFetchTree[1], path:List<PropertyPathNode>[1]): GraphFetchTree[1]
{
   if($path.values->isEmpty(),
      | $tree,
      {|
         let head         = $path.values->at(0);
         let tail         = if($head.property->instanceOf(QualifiedProperty),
                               | list($head.nestedQualifierReturn.values->tail()->concatenate($path.values->tail())),
                               | list($path.values->tail())
                            );
         let nextProperty = if($head.property->instanceOf(QualifiedProperty),
                               | $head.nestedQualifierReturn.values->first().property,
                               | $head.property
                            );
         let withQp       = if($head.property->instanceOf(QualifiedProperty),
                               {|
                                  let qp = $head.property->cast(@QualifiedProperty<Any>);
                                  $tree->match([
                                     ergft: ExtendedRootGraphFetchTree<Any>[1] | ^$ergft(requiredQualifiedProperties=$ergft.requiredQualifiedProperties->concatenate($qp)->removeDuplicates()),
                                     epgft: ExtendedPropertyGraphFetchTree[1]  | ^$epgft(requiredQualifiedProperties=$epgft.requiredQualifiedProperties->concatenate($qp)->removeDuplicates()),
                                     rgft : RootGraphFetchTree<Any>[1]         | ^ExtendedRootGraphFetchTree<Any>(requiredQualifiedProperties=$qp, class=$rgft.class, subTrees=$rgft.subTrees),
                                     pgft : PropertyGraphFetchTree[1]          | ^ExtendedPropertyGraphFetchTree(requiredQualifiedProperties=$qp, property=$pgft.property, subTrees=$pgft.subTrees)
                                  ]);
                               },
                               | $tree;
                            );

         ^$withQp(subTrees=$tree.subTrees->cast(@PropertyGraphFetchTree)->map(st|if($st.property == $nextProperty, |$st->meta::external::dataquality::recordQualifiedProperties($tail), |$st)));
      }
   );
}

function meta::external::dataquality::getEnrichedTreeForStructuralValidations(validationTree:meta::external::dataquality::DataQualityRootGraphFetchTree<Any>[1]): RootGraphFetchTree<Any>[1]
{
  // 1. enrich tree with selected constraint properties
   $validationTree->ensureFunctionRequirementsForDataQuality($validationTree.constraints, $validationTree.class, [], true)->cast(@RootGraphFetchTree<Any>);
}

function meta::external::dataquality::generateDQMetaDataForDQValidation(dataquality:meta::external::dataquality::DataQuality<Any>[1]): DataQualityRule[*]
{
   let enrichedTree = ensureFunctionRequirementsForDataQuality($dataquality.validationTree, $dataquality.validationTree.constraints, $dataquality.validationTree.class, [], true)->cast(@RootGraphFetchTree<Any>);
   $dataquality.validationTree->nodeToDqRule(true, '')->concatenate($enrichedTree->nodeToDqRule(false, ''));
}

function meta::external::dataquality::nodeToDqRule(node:GraphFetchTree[1], processOnlyConstraints:Boolean[1], path:String[*]):DataQualityRule[*]
{
   let dqRules = $node->match([
      dr: DataQualityRootGraphFetchTree<Any>[1]        | $dr->rootNodeToDqRule($processOnlyConstraints),
      dp: DataQualityPropertyGraphFetchTree[1]         | $dp->propertyNodeToDqRule($processOnlyConstraints, $path),
      r : RootGraphFetchTree<Any>[1]                   | $r->rootNodeToDqRule($processOnlyConstraints),
      p : PropertyGraphFetchTree[1]                    | $p->propertyNodeToDqRule($processOnlyConstraints, $path)
   ]);

   $dqRules->concatenate($node.subTrees->map(st|$st->nodeToDqRule($processOnlyConstraints, if ($dqRules->isEmpty(), | [], | $dqRules->at(0).propertyPath))));
}

function <<access.private>> meta::external::dataquality::rootNodeToDqRule(node:RootGraphFetchTree<Any>[1], processOnlyConstraints: Boolean[1]):DataQualityRule[*]
{
  if ( $processOnlyConstraints,
       | $node->cast(@DataQualityRootGraphFetchTree<Any>).constraints->map(c|$c->constraintToDqRule($node.class.name->toOne())),
       | ^DataQualityRule(constraintName=$node.class.name->toOne(), constraintGrammar='Class', constraintType='Alloy_Class_Validation', propertyPath=$node.class.name->toOne())
     );
}

function <<access.private>> meta::external::dataquality::propertyNodeToDqRule(node:PropertyGraphFetchTree[1], processOnlyConstraints: Boolean[1], path:String[*]):DataQualityRule[*]
{
    if ( $processOnlyConstraints,
         | $node->cast(@DataQualityPropertyGraphFetchTree).constraints->map(c|$c->constraintToDqRule($path->concatenate($node.property.name->toOne())->joinStrings('::'))),
         | ^DataQualityRule(constraintName=$node.property.name->toOne(), constraintGrammar=$node.property.multiplicity->printMultiplicity(), constraintType='Alloy_Structural_Validation', propertyPath=$path->concatenate($node.property.name->toOne())->joinStrings('::'))
      );
}

function <<access.private>> meta::external::dataquality::constraintToDqRule(constraint:Constraint[1], path:String[1]):DataQualityRule[1]
{
  ^DataQualityRule(constraintName=$constraint.name->toOne(), constraintGrammar=$constraint.functionDefinition->replaceVariableWithVariable('this', 'x')->meta::pure::metamodel::serialization::grammar::printFunctionDefinitionExpressions(^meta::pure::metamodel::serialization::grammar::GContext(space=''))->toOne(), constraintType='Alloy_Constraint_Validation', propertyPath=$path);
}


function meta::external::dataquality::generateDataqualityRelationValidationLambda(dqRelationValidation: meta::external::dataquality::DataQualityRelationValidation[1], validationName: String[1], defectsLimit:Integer[0..1]): LambdaFunction<Any>[1]
{
  $dqRelationValidation->meta::external::dataquality::generateDataqualityRelationValidationLambda($validationName, $defectsLimit, true)
}

function meta::external::dataquality::generateDataqualityRelationValidationLambda(dqRelationValidation: meta::external::dataquality::DataQualityRelationValidation[1], validationNames: String[*], defectsLimit:Integer[0..1], enrichDQColumns:Boolean[1]): LambdaFunction<Any>[1]
{
  generateDataqualityRelationValidationLambda($dqRelationValidation, $validationNames, $defectsLimit, $enrichDQColumns, false, false);
}

function meta::external::dataquality::generateDataqualityRelationValidationLambda(dqRelationValidation: meta::external::dataquality::DataQualityRelationValidation[1], validationNames: String[*], defectsLimit:Integer[0..1], enrichDQColumns:Boolean[1], castDQColumnsToPrimitive:Boolean[1], removeFrom:Boolean[1]): LambdaFunction<Any>[1]
{
  let lambda = if ($removeFrom, | $dqRelationValidation.query->popTerminalFunctionExpression(), | $dqRelationValidation.query);
  //if validation name provided only generate query for that validation else generate query for all validations
  let selectedValidations = if ($validationNames->isEmpty(),
    | $dqRelationValidation.validations,
    | $dqRelationValidation.validations->filter(val| $validationNames->contains($val.name))
  );
  if ($selectedValidations->isEmpty(),
    | fail('Expect at least one validation to exist on data quality validation');
      $lambda;,
    | let validationSubQueries = $selectedValidations->map(val | $dqRelationValidation->generateDataqualityRelationValidationLambda($val, $defectsLimit, $enrichDQColumns, $castDQColumnsToPrimitive, $removeFrom));
      let validationsUnion = $validationSubQueries->tail()->fold({val1, val2 | buildUnionExpression($val1->evaluateAndDeactivate(), $val2->evaluateAndDeactivate())}, $validationSubQueries->head()->toOne()->evaluateAndDeactivate());
      ^$lambda(expressionSequence=$validationsUnion);
  );
}

function meta::external::dataquality::generateDataqualityRelationValidationLambda(dqRelationValidation: meta::external::dataquality::DataQualityRelationValidation[1], selectedValidation: RelationValidation[1], defectsLimit:Integer[0..1], enrichDQColumns:Boolean[1], castDQColumnsToPrimitive:Boolean[1], removeFrom:Boolean[1]): FunctionExpression[1]
{
  if($selectedValidation.type->isNotEmpty() && $selectedValidation.type == 'ROW_LEVEL',
     | $dqRelationValidation->generateDataqualityRelationValidationLambda_RowLevel($selectedValidation, $defectsLimit, $enrichDQColumns, $castDQColumnsToPrimitive, $removeFrom), // for backward compatibility
     | $dqRelationValidation->generateDataqualityRelationValidationLambda_Aggregate($selectedValidation, $defectsLimit, $enrichDQColumns, $castDQColumnsToPrimitive, $removeFrom));
}


// row level validation for backward compatibility
function meta::external::dataquality::generateDataqualityRelationValidationLambda_RowLevel(dqRelationValidation: meta::external::dataquality::DataQualityRelationValidation[1], selectedValidation: RelationValidation[1], defectsLimit:Integer[0..1], enrichDQColumns:Boolean[1], castDQColumnsToPrimitive:Boolean[1], removeFrom:Boolean[1]): FunctionExpression[1]
{
  let lambda = if ($removeFrom, | $dqRelationValidation.query->popTerminalFunctionExpression(), | $dqRelationValidation.query);
  let inputRelType = $lambda->evaluateAndDeactivate()->functionReturnType().typeArguments.rawType->cast(@meta::pure::metamodel::relation::RelationType<Any>)->toOne();
  let withValidationFilterExpression = $lambda.expressionSequence->toOne()->evaluateAndDeactivate()->buildRelationFilterExpressionForRowLevelVal($selectedValidation, $inputRelType);

  // assertion - enrich DQ columns
  let withDQColumnsAndNewRelationType = if($enrichDQColumns, | $withValidationFilterExpression->enrichDQColumns($inputRelType, $selectedValidation, $castDQColumnsToPrimitive), | ^Pair<FunctionExpression, meta::pure::metamodel::relation::RelationType<Any>>(first=$withValidationFilterExpression, second=$inputRelType););

  if($defectsLimit->isEmpty(),
    | $withDQColumnsAndNewRelationType.first,
    | $withDQColumnsAndNewRelationType.first->buildLimitFilterExpression($defectsLimit->toOne(), ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$withDQColumnsAndNewRelationType.second)))
  );
}

function meta::external::dataquality::generateDataqualityRelationValidationLambda_Aggregate(dqRelationValidation: meta::external::dataquality::DataQualityRelationValidation[1], selectedValidation: RelationValidation[1], resultLimit:Integer[0..1], enrichDQcolumns:Boolean[0..1], castDQColumnsToPrimitive:Boolean[1], removeFrom:Boolean[1]): FunctionExpression[1]
{
  // assertion transformation
  let poppedAssertion = $selectedValidation->popAssertionForProjection()->evaluateAndDeactivate();

  // assertion - columns transformation
  let inputRelType = $poppedAssertion.genericType.typeArguments.rawType->toOne()->cast(@meta::pure::metamodel::relation::RelationType<Any>);

  // assertion - enrich DQ columns by default
  let withDQColumnsAndNewRelationType = if($enrichDQcolumns->isEmpty() || $enrichDQcolumns->toOne(), | $poppedAssertion->enrichDQColumns($inputRelType, $selectedValidation, $castDQColumnsToPrimitive), | ^Pair<ValueSpecification, meta::pure::metamodel::relation::RelationType<Any>>(first=$poppedAssertion, second=$inputRelType););

  // main dataset query transformation
  let lambda = if ($removeFrom, | $dqRelationValidation.query->popTerminalFunctionExpression(), | $dqRelationValidation.query);
  let queryWithLimitExpression = if($resultLimit->isEmpty(),
                                     | $lambda.expressionSequence->toOne()->evaluateAndDeactivate(),
                                     | $lambda.expressionSequence->toOne()->evaluateAndDeactivate()->buildRelationLimitFilterExpression($resultLimit->toOne(), $dqRelationValidation.query->genericType())
                                  );

  // compose above transformed query and assertion
  $withDQColumnsAndNewRelationType.first->buildEvalExpression($queryWithLimitExpression->cast(@ValueSpecification), $selectedValidation, getRelationType($selectedValidation), $withDQColumnsAndNewRelationType.second);
}

function meta::external::dataquality::buildUnionExpression(param1: FunctionExpression[1], param2: FunctionExpression[1]): FunctionExpression[1]
{
  let inputRelType1 = $param1.genericType.typeArguments.rawType->toOne()->cast(@meta::pure::metamodel::relation::RelationType<Any>);
  let inputRelType2 = $param2.genericType.typeArguments.rawType->toOne()->cast(@meta::pure::metamodel::relation::RelationType<Any>);
  let colsToAdd = $inputRelType2.columns->filter(col | !$inputRelType1.columns.name->contains($col.name->toOne()));
  let allCols = $inputRelType1.columns->concatenate($colsToAdd);
  let newRelTypeWithAllCols = ^meta::pure::metamodel::relation::RelationType<Nil>(columns = $allCols);

  let concatFunction = ^SimpleFunctionExpression
  (
      func = concatenate_Relation_1__Relation_1__Relation_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$newRelTypeWithAllCols)),
      importGroup  = system::imports::coreImport,
      parametersValues = [
        $param1,
        $param2
      ]
  )->evaluateAndDeactivate();
}


function meta::external::dataquality::enrichDQColumns(f:ValueSpecification[1], inputRelType:meta::pure::metamodel::relation::RelationType<Any>[1], selectedValidation: RelationValidation[1], castDQColumnsToPrimitive:Boolean[1]): Pair<FunctionExpression, meta::pure::metamodel::relation::RelationType<Any>>[1]
{
  if ($castDQColumnsToPrimitive, | enrichDQColumnsPrecise($f, $inputRelType, $selectedValidation), | enrichDQColumns($f, $inputRelType, $selectedValidation));
}

function meta::external::dataquality::enrichDQColumns(f:ValueSpecification[1], inputRelType:meta::pure::metamodel::relation::RelationType<Any>[1], selectedValidation: RelationValidation[1]): Pair<FunctionExpression, meta::pure::metamodel::relation::RelationType<Any>>[1]
{
  let relParamName = 'row';

  let newRelTypeWithLogicalDefectId = $inputRelType->addColumns(~[DQ_LOGICAL_DEFECT_ID: String[1]])->evaluateAndDeactivate();
  let withLogicalId = $f->buildExtendExpression('DQ_LOGICAL_DEFECT_ID', buildHashFunctionExpression($inputRelType, $inputRelType.columns.name, $relParamName), $relParamName, $inputRelType, $newRelTypeWithLogicalDefectId, String);

  let newRelTypeWithDefectId = $newRelTypeWithLogicalDefectId->addColumns(~[DQ_DEFECT_ID: String[1]])->evaluateAndDeactivate();
  let withDefectId = $withLogicalId->buildExtendExpression('DQ_DEFECT_ID', buildGenerateGuidExpression(), $relParamName, $newRelTypeWithLogicalDefectId, $newRelTypeWithDefectId, String);

  let newRelTypeWithRuleId = $newRelTypeWithDefectId->addColumns(~[DQ_RULE_NAME: String[1]])->evaluateAndDeactivate();
  let withRuleId = $withDefectId->buildExtendExpression('DQ_RULE_NAME', ^InstanceValue(values=$selectedValidation.name, genericType=^GenericType(rawType=String), multiplicity=PureOne), $relParamName, $newRelTypeWithDefectId, $newRelTypeWithRuleId, String);

  ^Pair<FunctionExpression, meta::pure::metamodel::relation::RelationType<Any>>(first=$withRuleId, second=$newRelTypeWithRuleId);
}

//TODO move this inferrence into correct place,
function meta::external::dataquality::enrichDQColumnsPrecise(f:ValueSpecification[1], inputRelType:meta::pure::metamodel::relation::RelationType<Any>[1], selectedValidation: RelationValidation[1]): Pair<FunctionExpression, meta::pure::metamodel::relation::RelationType<Any>>[1]
{
  let relParamName = 'row';

  let newRelTypeWithLogicalDefectId = $inputRelType->addColumns(~[DQ_LOGICAL_DEFECT_ID: Varchar(32)[1]])->evaluateAndDeactivate();
  let withLogicalId = $f->buildExtendExpression('DQ_LOGICAL_DEFECT_ID', buildVarcharCast(buildHashFunctionExpression($inputRelType, $inputRelType.columns.name, $relParamName), 32), $relParamName, $inputRelType, $newRelTypeWithLogicalDefectId, String);

  let newRelTypeWithDefectId = $newRelTypeWithLogicalDefectId->addColumns(~[DQ_DEFECT_ID: Varchar(36)[1]])->evaluateAndDeactivate();
  let withDefectId = $withLogicalId->buildExtendExpression('DQ_DEFECT_ID', buildVarcharCast(buildGenerateGuidExpression(), 36), $relParamName, $newRelTypeWithLogicalDefectId, $newRelTypeWithDefectId, String);

  let newRelTypeWithRuleId = $newRelTypeWithDefectId->addColumns(~[DQ_RULE_NAME: Varchar(200)[1]])->evaluateAndDeactivate();
  let withRuleId = $withDefectId->buildExtendExpression('DQ_RULE_NAME', buildVarcharCast(^InstanceValue(values=$selectedValidation.name, genericType=^GenericType(rawType=String), multiplicity=PureOne), 255), $relParamName, $newRelTypeWithDefectId, $newRelTypeWithRuleId, String);

  ^Pair<FunctionExpression, meta::pure::metamodel::relation::RelationType<Any>>(first=$withRuleId, second=$newRelTypeWithRuleId);
}

function meta::external::dataquality::getRelationType(selectedValidation: RelationValidation[1]):meta::pure::metamodel::relation::RelationType<Any>[1]
{
  let assertionFunction = getAssertionFunction($selectedValidation);
  //we know that this will be one of the allowed assertion terminal functions so the first parameter will be the relation
  $assertionFunction.parametersValues->at(0).genericType.typeArguments.rawType->toOne()->cast(@meta::pure::metamodel::relation::RelationType<Any>);
}

function meta::external::dataquality::popAssertionForProjection(selectedValidation: RelationValidation[1]):ValueSpecification[1]
{
  let assertionFunction = getAssertionFunction($selectedValidation);
  //function will either be assertRelationEmpty or assertRelationNotEmpty - this is enforced in the compiler
  if($assertionFunction.func == assertRelationEmpty_Relation_1__ColSpecArray_1__Boolean_1_,
  | buildSelectExpression($assertionFunction.parametersValues->evaluateAndDeactivate()->at(0), $assertionFunction.parametersValues->at(1)->cast(@InstanceValue)),
  | buildOneRowIfEmptyExpression($assertionFunction.parametersValues->evaluateAndDeactivate()->at(0)));
}

function meta::external::dataquality::popTerminalFunctionExpression(query: LambdaFunction<Any>[1]):LambdaFunction<Any>[1]
{
  ^$query(expressionSequence = $query.expressionSequence->evaluateAndDeactivate()->toOne()->cast(@SimpleFunctionExpression).parametersValues->evaluateAndDeactivate()->at(0)->evaluateAndDeactivate())
}

function meta::external::dataquality::getAssertionFunction(selectedValidation: RelationValidation[1]):SimpleFunctionExpression[1]
{
  //we know that this will be a simple function expression since the assertion needs to end with one of the allowed assertion terminal functions
  $selectedValidation.assertion.expressionSequence->evaluateAndDeactivate()->toOne()->cast(@SimpleFunctionExpression);
}

function meta::external::dataquality::buildSelectExpression(inputRel: ValueSpecification[1], selectedCols: InstanceValue[1]):FunctionExpression[1]
{
  let currentRelType = $inputRel.genericType.typeArguments.rawType->toOne()->cast(@meta::pure::metamodel::relation::RelationType<Any>);
  let projectedColumnNames = $selectedCols.values->match([
    csa:meta::pure::metamodel::relation::ColSpecArray<Any>[1] | $csa.names,
    cs:meta::pure::metamodel::relation::ColSpec<Any>[1] | [$cs.name]
  ]);
  let newRelType = ^meta::pure::metamodel::relation::RelationType<Nil>(columns = $currentRelType.columns->filter(col | $projectedColumnNames->contains($col.name->toOne())));
  let selectFunction = ^SimpleFunctionExpression
  (
      func = select_Relation_1__ColSpecArray_1__Relation_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$newRelType)),
      importGroup  = system::imports::coreImport,
      parametersValues = [
        $inputRel,
        $selectedCols
      ]
  )->evaluateAndDeactivate();
}

//we need to create an expression that will produce 1 row with the count if the relation is empty otherwise return no rows.
function meta::external::dataquality::buildOneRowIfEmptyExpression(inputRel: ValueSpecification[1]):FunctionExpression[1]
{
  //get COUNT of relation
  let inputRelType = $inputRel.genericType.typeArguments.rawType->toOne()->cast(@meta::pure::metamodel::relation::RelationType<Any>);
  let newRelTypeWithCount = $inputRelType->addColumns(~[COUNT: Integer[1]])->evaluateAndDeactivate();
  let newRelTypeWithOnlyCount = ^meta::pure::metamodel::relation::RelationType<Nil>(columns = $newRelTypeWithCount.columns->filter(col | 'COUNT' == ($col.name->toOne())));
  let withCount = buildGetRowCountExpression($inputRel, $inputRelType, $newRelTypeWithOnlyCount);

  //filter where COUNT == 0
  buildFilterOnEmptyCountExpression($withCount, $newRelTypeWithOnlyCount);
}

function meta::external::dataquality::buildGetRowCountExpression(rel: ValueSpecification[1], relType: meta::pure::metamodel::relation::RelationType<Any>[1], newRelType: meta::pure::metamodel::relation::RelationType<Any>[1]):FunctionExpression[1]
{
  ^SimpleFunctionExpression
  (
      func = aggregate_Relation_1__AggColSpec_1__Relation_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=$newRelType),
      importGroup  = system::imports::coreImport,
      parametersValues = [
        $rel,
        buildAggColSpecCountExpression($rel, $relType, $newRelType)
      ]
  )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildAggColSpecCountExpression(rel: ValueSpecification[1], relType: meta::pure::metamodel::relation::RelationType<Any>[1], newRelType: meta::pure::metamodel::relation::RelationType<Any>[1]):FunctionExpression[1]
{
  let param1 = buildAggColSpecCountFirstParam($relType);
  let param2 = buildAggColSpecCountSecondParam();
  ^SimpleFunctionExpression
  (
      func = aggColSpec_Function_1__Function_1__String_1__T_1__AggColSpec_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType = AggColSpec, typeArguments = [$param1.genericType, $param2.genericType, ^GenericType(rawType=$newRelType)]),
      importGroup  = system::imports::coreImport,
      parametersValues = [
        $param1,
        $param2,
        ^InstanceValue(genericType = ^GenericType(rawType = String), multiplicity = PureOne, values = 'COUNT')->evaluateAndDeactivate(),
        ^InstanceValue(genericType = ^GenericType(rawType = $newRelType), multiplicity = PureOne)->evaluateAndDeactivate()
      ]
  )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildAggColSpecCountFirstParam(relType: meta::pure::metamodel::relation::RelationType<Any>[1]):InstanceValue[1]
{
  let expression = ^VariableExpression(name = 'x', genericType = ^GenericType(rawType = $relType), multiplicity = PureOne);
  ^InstanceValue(
      genericType = ^GenericType(rawType = LambdaFunction, typeArguments = ^GenericType(rawType = ^FunctionType(parameters = $expression, returnMultiplicity = PureOne, returnType = ^GenericType(rawType = Integer)))),
      multiplicity = PureOne,
      values = meta::external::dataquality::lambda(^FunctionType(returnMultiplicity = PureOne, returnType = ^GenericType(rawType = Integer), parameters = $expression), ^InstanceValue(genericType = ^GenericType(rawType = Integer), multiplicity = PureOne, values = 1))
  )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildAggColSpecCountSecondParam():InstanceValue[1]
{
  let countExpression = ^SimpleFunctionExpression
  (
      func = count_Any_MANY__Integer_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType = Integer),
      importGroup  = system::imports::coreImport,
      parametersValues = [
        ^VariableExpression(name = 'y', genericType = ^GenericType(rawType = Integer), multiplicity = ZeroMany)
      ]
  )->evaluateAndDeactivate();
  let expression = ^VariableExpression(name = 'y', genericType = ^GenericType(rawType = Integer), multiplicity = ZeroMany);
  ^InstanceValue(
      genericType = ^GenericType(rawType = LambdaFunction, typeArguments = ^GenericType(rawType = ^FunctionType(parameters = $expression, returnMultiplicity = PureOne, returnType = ^GenericType(rawType = Integer)))),
      multiplicity = PureOne,
      values = meta::external::dataquality::lambda(^FunctionType(returnMultiplicity = PureOne, returnType = ^GenericType(rawType = Integer), parameters = $expression), $countExpression)
  )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildFilterOnEmptyCountExpression(rel: ValueSpecification[1], relType: meta::pure::metamodel::relation::RelationType<Any>[1]):FunctionExpression[1]
{
  ^SimpleFunctionExpression
   (
      func = filter_Relation_1__Function_1__Relation_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$relType)),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [  $rel,
         ^InstanceValue (genericType = ^GenericType(rawType=LambdaFunction, typeArguments=^GenericType(rawType=^FunctionType(parameters=^VariableExpression(name='row', genericType=^GenericType(rawType=$relType), multiplicity=PureOne), returnMultiplicity=PureOne, returnType=^GenericType(rawType=Boolean)))),
            multiplicity = PureOne,
            values = meta::external::dataquality::lambda(^FunctionType(returnMultiplicity= PureOne, returnType = ^GenericType(rawType = Boolean), parameters = ^VariableExpression(name='row', genericType=^GenericType(rawType=$relType), multiplicity=PureOne)), buildEqualToZeroExpression($relType))
         )->evaluateAndDeactivate()
      ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildEqualToZeroExpression(relType: meta::pure::metamodel::relation::RelationType<Any>[1]):FunctionExpression[1]
{
  ^SimpleFunctionExpression
  (
      func = equal_Any_MANY__Any_MANY__Boolean_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=Boolean),
      importGroup  = system::imports::coreImport,
      parametersValues = [
        ^SimpleFunctionExpression
        (
            func = $relType.columns->filter(x|$x.name == 'COUNT')->toOne(),
            multiplicity = ZeroOne,
            genericType  = ^GenericType(rawType=Integer),
            importGroup  = system::imports::coreImport,
            parametersValues =
            [
              ^VariableExpression(name='row', genericType=^GenericType(rawType=$relType), multiplicity=PureOne)->evaluateAndDeactivate()
            ],
            propertyName = ^InstanceValue(genericType = ^GenericType(rawType=Any), multiplicity = ZeroOne, values = ['COUNT'])
        )->evaluateAndDeactivate(),
        ^InstanceValue(values=0, genericType=^GenericType(rawType=Integer), multiplicity=PureOne)
      ]
  )->evaluateAndDeactivate();
}


function meta::external::dataquality::buildEvalExpression(f: ValueSpecification[1], query: ValueSpecification[1], selectedValidation: RelationValidation[1], relType:meta::pure::metamodel::relation::RelationType<Any>[1], newRelType: meta::pure::metamodel::relation::RelationType<Any>[1]):FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = eval_Function_1__T_n__V_m_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$newRelType)),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [ ^InstanceValue (
            genericType = ^GenericType(rawType=LambdaFunction, typeArguments=^GenericType(rawType=^FunctionType(parameters=^VariableExpression(name='rel', genericType=^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$relType)), multiplicity=PureOne), returnMultiplicity=PureOne, returnType=^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$newRelType))))),
            multiplicity = PureOne,
            values = meta::external::dataquality::lambda(^FunctionType(returnMultiplicity = PureOne, returnType = ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$newRelType)), parameters = [^VariableExpression(multiplicity=PureOne,genericType=^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$relType)),name='rel')]),
                                                          $f->evaluateAndDeactivate()->toOne())
         ),
         $query
     ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildExtendExpression(rel: ValueSpecification[1], newColumnName: String[1], newColumnFunction: ValueSpecification[1], relParamName: String[1], relType: meta::pure::metamodel::relation::RelationType<Any>[1], newRelType: meta::pure::metamodel::relation::RelationType<Any>[1], newColType: Type[1]):FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = extend_Relation_1__FuncColSpec_1__Relation_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$newRelType)),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [  $rel,
         ^SimpleFunctionExpression
          (
                func = funcColSpec_Function_1__String_1__T_1__FuncColSpec_1_,
                multiplicity = PureOne,
                genericType  = ^GenericType(rawType=$newRelType),
                importGroup  = system::imports::coreImport,
                parametersValues =
                [  ^InstanceValue (
                        genericType = ^GenericType(rawType=LambdaFunction, typeArguments=^GenericType(rawType=^FunctionType(returnMultiplicity=PureOne, returnType=^GenericType(rawType=$newColType), parameters=^VariableExpression(name=$relParamName, genericType=^GenericType(rawType=$relType), multiplicity=PureOne)))),
                        multiplicity = PureOne,
                        values = meta::external::dataquality::lambda(^FunctionType(returnMultiplicity=PureOne, returnType=^GenericType(rawType=$newColType), parameters=^VariableExpression(name=$relParamName, genericType=^GenericType(rawType=$relType), multiplicity=PureOne)), $newColumnFunction)),
                   ^InstanceValue(values=$newColumnName, genericType=^GenericType(rawType=String), multiplicity=PureOne),
                   ^InstanceValue(values=$newRelType, genericType=^GenericType(rawType=$newRelType), multiplicity=PureOne)->evaluateAndDeactivate()
                ]
          )->evaluateAndDeactivate()
      ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildRelationFilterExpressionForRowLevelVal(queryExpression: ValueSpecification[1], selectedValidation: RelationValidation[1], relationType:Type[1]):FunctionExpression[1]
{

  let assertion = $selectedValidation.assertion;

   ^SimpleFunctionExpression
   (
      func = filter_Relation_1__Function_1__Relation_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=Relation, typeArguments = ^GenericType(rawType=$relationType)),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [  $queryExpression,
         ^InstanceValue (
            genericType = ^GenericType(rawType=LambdaFunction, typeArguments=^GenericType(rawType=^FunctionType(parameters=^VariableExpression(name='validationFilter', genericType=^GenericType(rawType=$relationType), multiplicity=PureOne), returnMultiplicity=PureOne, returnType=^GenericType(rawType=Boolean)))),
            multiplicity = PureOne,
            values = meta::external::dataquality::lambda(^FunctionType(returnMultiplicity = PureOne, returnType = ^GenericType(rawType = Boolean), parameters = [^VariableExpression(multiplicity=PureOne,genericType=^GenericType(rawType=$relationType),name=$assertion->meta::pure::metamodel::serialization::grammar::printLambdaParameters(false))]),
                                                          $assertion.expressionSequence->evaluateAndDeactivate()->toOne()->negatedFunctionExpression())
         )
     ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildLimitFilterExpression(f: ValueSpecification[1], limit: Integer[1], returnType:GenericType[1]):FunctionExpression[1]
{
  ^SimpleFunctionExpression(func=take_T_MANY__Integer_1__T_MANY_,
                            parametersValues=[$f, ^InstanceValue(values=$limit->toOne(), genericType=^GenericType(rawType=Integer), multiplicity=PureOne)],
                            functionName=take_T_MANY__Integer_1__T_MANY_.name,
                            genericType=$returnType,
                            multiplicity = ZeroMany,
                            importGroup=system::imports::coreImport)->evaluateAndDeactivate();
}

function meta::external::dataquality::buildRelationLimitFilterExpression(f: ValueSpecification[1], limit: Integer[1], returnType:GenericType[1]):FunctionExpression[1]
{
  ^SimpleFunctionExpression(func=limit_Relation_1__Integer_1__Relation_1_,
                            parametersValues=[$f, ^InstanceValue(values=$limit->toOne(), genericType=^GenericType(rawType=Integer), multiplicity=PureOne)],
                            functionName=limit_Relation_1__Integer_1__Relation_1_.name,
                            genericType=$returnType,
                            multiplicity = ZeroMany,
                            importGroup=system::imports::coreImport)->evaluateAndDeactivate();
}

function meta::external::dataquality::isFromFunctionPresent(func: FunctionDefinition<Any>[1]):Boolean[1]
{
  let getExprList = $func->findExpressionsForFunctionInFunctionDefinition(
    meta::external::dataquality::fromFunctions()
    );
  !$getExprList->isEmpty();
}

function meta::external::dataquality::isEndingWithFromFunction(func: FunctionDefinition<Any>[1]):Boolean[1]
{
  let queryEndExpression = $func.expressionSequence->evaluateAndDeactivate()->last()->cast(@SimpleFunctionExpression);
  $queryEndExpression.func->in(fromFunctions());
}

function <<access.protected>> meta::external::dataquality::fromFunctions():Function<Any>[*]
{
  [
    meta::pure::mapping::from_FunctionDefinition_1__Mapping_1__PackageableRuntime_1__T_m_,
    meta::pure::mapping::from_FunctionDefinition_1__Mapping_1__Runtime_1__T_m_,
    meta::pure::mapping::from_FunctionDefinition_1__PackageableRuntime_1__T_m_,
    meta::pure::mapping::from_FunctionDefinition_1__Runtime_1__T_m_,
    meta::pure::mapping::from_T_m__DataSpaceExecutionContext_1__T_m_,
    meta::pure::mapping::from_T_m__DataSpace_1__T_m_,
    meta::pure::mapping::from_T_m__Mapping_1__PackageableRuntime_1__T_m_,
    meta::pure::mapping::from_T_m__Mapping_1__Runtime_1__T_m_,
    meta::pure::mapping::from_T_m__PackageableRuntime_1__T_m_,
    meta::pure::mapping::from_T_m__Runtime_1__T_m_,
    meta::pure::mapping::from_TabularDataSet_1__Mapping_1__PackageableRuntime_1__ExecutionContext_1__TabularDataSet_1_,
    meta::pure::mapping::from_TabularDataSet_1__Mapping_1__PackageableRuntime_1__TabularDataSet_1_,
    meta::pure::mapping::from_TabularDataSet_1__Mapping_1__Runtime_1__ExecutionContext_1__TabularDataSet_1_,
    meta::pure::mapping::from_TabularDataSet_1__Mapping_1__Runtime_1__TabularDataSet_1_
    ]
}


function meta::external::dataquality::generateMainQueryCountLambda(dqRelationValidation: meta::external::dataquality::DataQualityRelationValidation[1]): LambdaFunction<Any>[1]
{
  $dqRelationValidation->meta::external::dataquality::generateMainQueryCountLambda(true);
}

function meta::external::dataquality::generateMainQueryCountLambda(dqRelationValidation: meta::external::dataquality::DataQualityRelationValidation[1], useFrom:Boolean[1]): LambdaFunction<Any>[1]
{
  let lambda = $dqRelationValidation.query;
  let relationType = $dqRelationValidation.query->evaluateAndDeactivate()->functionReturnType().typeArguments.rawType->toOne();

  let withSizeExpression = $dqRelationValidation.query.expressionSequence->toOne()->evaluateAndDeactivate()->buildSizeExpression();
  ^$lambda(expressionSequence=$withSizeExpression);
}

function meta::external::dataquality::buildSizeExpression(queryExpression: ValueSpecification[1]):FunctionExpression[1]
{
  ^SimpleFunctionExpression
  (
     func = size_Relation_1__Integer_1_,
     multiplicity = PureOne,
     genericType  = ^GenericType(rawType=Integer),
     importGroup  = system::imports::coreImport,
     parametersValues =
      [
        $queryExpression
      ]
  )->evaluateAndDeactivate();
}

//TODO- This should be replaced with native/helper function on Relational when available (similar to extendWithDigestOnColumns on TDS)
function meta::external::dataquality::buildHashFunctionExpression(relType: meta::pure::metamodel::relation::RelationType<Any>[1], columns: String[*], relParamName: String[1]):FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = meta::pure::functions::hash::hash_String_1__HashType_1__String_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=String),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [
        meta::external::dataquality::buildGetRowStringFunctionExpression($relType, $columns, $relParamName),
        meta::external::dataquality::buildHashTypeFunctionExpression()
     ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildVarcharCast(expression:ValueSpecification[1], size:Integer[1]):ValueSpecification[1]
{
  // $expression;
  buildCast($expression, varcharGenericType($size));
}

function meta::external::dataquality::buildCast(expression:ValueSpecification[1], genericType:GenericType[1]):FunctionExpression[1]
{
  ^SimpleFunctionExpression(
    func = cast_Any_m__T_1__T_m_,
    genericType = $genericType,
    importGroup = system::imports::coreImport,
    multiplicity = $expression->evaluateAndDeactivate().multiplicity,
    parametersValues = [$expression, ^InstanceValue(genericType = $genericType, multiplicity = PureOne)]
  );
}

function meta::external::dataquality::varcharGenericType(size:Integer[1]):GenericType[1]
{
  ^GenericType(rawType = Varchar, typeVariableValues = ^InstanceValue(values = $size, genericType = ^GenericType(rawType = Integer), multiplicity = PureOne));
}

function meta::external::dataquality::buildGetRowStringFunctionExpression(relType: meta::pure::metamodel::relation::RelationType<Any>[1], columns: String[*], relParamName: String[1]):FunctionExpression[1]
{
  if($columns->size() == 1,
  | meta::external::dataquality::buildGetStringValueOrEmptyIfNullFunctionExpression($relType, $columns->at(0), $relParamName),
  | meta::external::dataquality::buildConcatenateFunctionExpression($relType, $columns, $relParamName)
  )
}

function meta::external::dataquality::buildConcatenateFunctionExpression(relType: meta::pure::metamodel::relation::RelationType<Any>[1], columns: String[*], relParamName: String[1]):FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = plus_String_MANY__String_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=String),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [
        ^InstanceValue (
          genericType = ^GenericType(rawType=String),
          multiplicity = OneMany,
          values = [$columns->map(col | meta::external::dataquality::buildGetStringValueOrEmptyIfNullFunctionExpression($relType, $col, $relParamName))]
        )
     ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildGetStringValueOrEmptyIfNullFunctionExpression(relType: meta::pure::metamodel::relation::RelationType<Any>[1], column: String[1], relParamName: String[1]):FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = if_Boolean_1__Function_1__Function_1__T_m_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=String),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [
        meta::external::dataquality::buildIsEmptyFunctionExpression($relType, $column, $relParamName),
        meta::external::dataquality::buildEmptyInstanceValue(),
        meta::external::dataquality::buildToOneInstanceValue($relType, $column, $relParamName)
     ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildIsEmptyFunctionExpression(relType: meta::pure::metamodel::relation::RelationType<Any>[1], column: String[1], relParamName: String[1]):FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = isEmpty_Any_$0_1$__Boolean_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=Boolean),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [
        ^InstanceValue (
          genericType = ^GenericType(rawType=Any),
          multiplicity = ZeroOne,
          values = [meta::external::dataquality::buildGetValueAtColumnFunctionExpression($relType, $column, $relParamName)]
        )
     ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildGetValueAtColumnFunctionExpression(relType: meta::pure::metamodel::relation::RelationType<Any>[1], column: String[1], relParamName: String[1]):FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = $relType.columns->filter(x|$x.name == $column)->toOne(),
      multiplicity = ZeroOne,
      genericType  = ^GenericType(rawType=Any),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [
        ^VariableExpression(name=$relParamName, genericType=^GenericType(rawType=$relType), multiplicity=PureOne)->evaluateAndDeactivate()
      ],
      propertyName = ^InstanceValue(genericType = ^GenericType(rawType=Any), multiplicity = ZeroOne, values = [$column])
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildEmptyInstanceValue():InstanceValue[1]
{
   ^InstanceValue
   (
      genericType = ^GenericType(rawType = LambdaFunction, typeArguments = ^GenericType(rawType = ^FunctionType(returnMultiplicity = PureOne, returnType = ^GenericType(rawType=String)))),
      multiplicity = PureOne,
      values = meta::external::dataquality::lambda(
        ^FunctionType(returnMultiplicity=PureOne, returnType=^GenericType(rawType=String)),
                      ^InstanceValue (genericType = ^GenericType(rawType=String), multiplicity = PureOne, values = [''])
      )
   )
}

function meta::external::dataquality::buildToOneInstanceValue(relType: meta::pure::metamodel::relation::RelationType<Any>[1], column: String[1], relParamName: String[1]):InstanceValue[1]
{
  ^InstanceValue
  (
    genericType = ^GenericType(rawType = LambdaFunction, typeArguments = ^GenericType(rawType = ^FunctionType(returnMultiplicity = PureOne, returnType = ^GenericType(rawType=String)))),
    multiplicity = PureOne,
    values = meta::external::dataquality::lambda(
      ^FunctionType(returnMultiplicity=PureOne, returnType=^GenericType(rawType=String)),
                    meta::external::dataquality::buildToStringToOneFunctionExpression($relType, $column, $relParamName)
    )
  )
}

function meta::external::dataquality::buildToStringToOneFunctionExpression(relType: meta::pure::metamodel::relation::RelationType<Any>[1], column: String[1], relParamName: String[1]):FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = toString_Any_1__String_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=String),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [
        ^SimpleFunctionExpression
           (
              func = toOne_T_MANY__T_1_,
              multiplicity = PureOne,
              genericType  = ^GenericType(rawType=String),
              importGroup  = system::imports::coreImport,
              parametersValues =
              [
                ^InstanceValue (genericType = ^GenericType(rawType=Any), multiplicity = ZeroOne, values = [meta::external::dataquality::buildGetValueAtColumnFunctionExpression($relType, $column, $relParamName)])
              ]
           )->evaluateAndDeactivate()
      ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildHashTypeFunctionExpression():FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = extractEnumValue_Enumeration_1__String_1__T_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=meta::pure::functions::hash::HashType),
      importGroup  = system::imports::coreImport,
      parametersValues =
      [
        ^InstanceValue (
            genericType = ^GenericType(rawType=Enumeration),
            multiplicity = PureOne,
            values = [meta::pure::functions::hash::HashType]
         ),
         ^InstanceValue (
            genericType = ^GenericType(rawType=String),
            multiplicity = PureOne,
            values = ['MD5']
         )
     ]
   )->evaluateAndDeactivate();
}

function meta::external::dataquality::buildGenerateGuidExpression():FunctionExpression[1]
{
   ^SimpleFunctionExpression
   (
      func = meta::pure::functions::string::generation::generateGuid__String_1_,
      multiplicity = PureOne,
      genericType  = ^GenericType(rawType=String),
      importGroup  = system::imports::coreImport,
      parametersValues = []
   )->evaluateAndDeactivate();
}
