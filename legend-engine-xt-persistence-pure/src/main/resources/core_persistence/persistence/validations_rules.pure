// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::shared::format::*;
import meta::legend::service::metamodel::*;

import meta::pure::executionPlan::*;
import meta::pure::extension::*;

import meta::pure::persistence::metamodel::*;
import meta::pure::persistence::metamodel::persister::*;
import meta::pure::persistence::metamodel::persister::targetshape::*;
import meta::pure::persistence::validation::*;

import meta::relational::extension::*;

function meta::pure::persistence::validation::commonRules(): ValidationRuleSet<PersistenceContext>[1]
{
  ^ValidationRuleSet<PersistenceContext>(
    name = 'Common',
    rules = [
      c: PersistenceContext[1] | validateTarget($c.persistence.persister->subType(@BatchPersister).targetShape),
      c: PersistenceContext[1] | validateServiceAndTarget($c.persistence.service, $c.persistence.persister->subType(@BatchPersister).targetShape)
    ]
  );
}

/**********
 * target validations
 **********/

function meta::pure::persistence::validation::validateTarget(target: TargetShape[1]): ValidationResult[1]
{
  $target->match([
    f: FlatTarget[1] | if ($f.targetName->isEmpty(), | failure('Flat target name must not be empty'), | success()),
    mf: MultiFlatTarget[1] | if ($mf.parts->exists(p | $p.targetName->isEmpty()), | failure('Multi flat part target names must not be empty'), | success())
  ]);
}

/**********
 * service + target validations
 **********/

function meta::pure::persistence::validation::validateServiceAndTarget(service: Service[1], target: TargetShape[1]): ValidationResult[1]
{
  $service.execution->match([
    se: PureSingleExecution[1] | $target->match([
      f: FlatTarget[1] | validateSingleExecutionServiceAndFlatTarget($service, $se, $f),
      mf: MultiFlatTarget[1] | validateSingleExecutionServiceAndMultiFlatTarget($service, $se, $mf),
      any: Any[1] | failure('Unknown target shape')
    ]),
    me: PureMultiExecution[1] | $target->match([
      f: FlatTarget[1] | validateMultiExecutionServiceAndFlatTarget($service, $me, $f),
      mf: MultiFlatTarget[1] | validateMultiExecutionServiceAndMultiFlatTarget($service, $me, $mf),
      any: Any[1] | failure('Unknown target shape')
    ]),
    any: Any[1] | failure('Unknown service execution')
  ]);
}

function meta::pure::persistence::validation::validateSingleExecutionServiceAndFlatTarget(service: Service[1], execution: PureSingleExecution[1], target: FlatTarget[1]): ValidationResult[1]
{
  let classification = $execution->classify();
  if ($classification == ExecutionClassification.GRAPH_FETCH_SERIALIZE || $classification == ExecutionClassification.TDS,
    | success(),
    | failure('Flat target requires a service that returns a TDS'));
}

function meta::pure::persistence::validation::validateSingleExecutionServiceAndMultiFlatTarget(service: Service[1], execution: PureSingleExecution[1], target: MultiFlatTarget[1]): ValidationResult[1]
{
  let classification = $execution->classify();
  if ($classification == ExecutionClassification.GRAPH_FETCH_SERIALIZE,
    | success(),
    | failure('Multi flat target requires a service that ends with "graphFetch()->serialize()'));
}

function meta::pure::persistence::validation::validateMultiExecutionServiceAndFlatTarget(service: Service[1], execution: PureMultiExecution[1], target: FlatTarget[1]): ValidationResult[1]
{
  //TODO: ledav -- implement flat validations
  success();
}

function meta::pure::persistence::validation::validateMultiExecutionServiceAndMultiFlatTarget(service: Service[1], execution: PureMultiExecution[1], target: MultiFlatTarget[1]): ValidationResult[1]
{
  //TODO: ledav -- implement multi flat validations
  success();
}

/**********
 * execution validations
 **********/

Enum meta::pure::persistence::validation::ExecutionClassification
{
  GRAPH_FETCH_SERIALIZE,
  TDS,
  OTHER
}

function meta::pure::persistence::validation::classify(execution: PureSingleExecution[1]): ExecutionClassification[1]
{
  let serviceEndsWithGraphFetchSerialize = $execution.func.expressionSequence->evaluateAndDeactivate()->last()->match([
    fe: FunctionExpression[1] | if ($fe.func == meta::pure::graphFetch::execution::serialize_T_MANY__RootGraphFetchTree_1__String_1_, | true, | false),
    any: Any[1] | false
  ]);

  if (!$serviceEndsWithGraphFetchSerialize,
    | ExecutionClassification.GRAPH_FETCH_SERIALIZE,
    | let plan = executionPlan($execution.func, $execution.mapping, $execution.runtime, extensions());
      $plan.rootExecutionNode.resultType->match([
        tds: TDSResultType[1] | ExecutionClassification.TDS,
        any: Any[1] | ExecutionClassification.OTHER
      ]);
  );
}

/**********
 * utility functions
 **********/

function meta::pure::persistence::validation::extensions(): Extension[*]
{
  defaultExtensions()->add(externalFormatExtension())->concatenate(relationalExtensions());
}
