// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::test::pct::*;
import meta::pure::metamodel::relation::*;

native function <<PCT.function>> {doc.doc = 'Pivots a relation by rotating data from rows into columns. Takes multiple pivot columns and a single aggregate specification. All unique combinations of values from the pivot columns become new columns in the result. Each combination is aggregated according to the aggregate specification. All remaining columns (not pivoted or aggregated) become grouping columns.'}
  meta::pure::functions::relation::pivot<T,Z,K,V,R>(r:Relation<T>[1], cols:ColSpecArray<Z⊆T>[1], agg:AggColSpec<{T[1]->K[0..1]},{K[*]->V[0..1]}, R>[1]):Relation<Any>[1];

native function <<PCT.function>> {doc.doc = 'Pivots a relation by rotating data from rows into columns. Takes a single pivot column and a single aggregate specification. All unique values from the pivot column become new columns in the result. Each value is aggregated according to the aggregate specification. All remaining columns (not pivoted or aggregated) become grouping columns.'}
  meta::pure::functions::relation::pivot<T,Z,K,V,R>(r:Relation<T>[1], cols:ColSpec<Z⊆T>[1], agg:AggColSpec<{T[1]->K[0..1]},{K[*]->V[0..1]}, R>[1]):Relation<Any>[1];

native function <<PCT.function>> {doc.doc = 'Pivots a relation by rotating data from rows into columns. Takes a single pivot column with explicitly specified values and a single aggregate specification. Only the specified pivot values become new columns in the result. Each value is aggregated according to the aggregate specification. This static pivot allows control over which columns appear in the output and their order. All remaining columns (not pivoted or aggregated) become grouping columns.'}
  meta::pure::functions::relation::pivot<T,Z,K,V,R>(r:Relation<T>[1], cols:ColSpec<Z⊆T>[1], values:Any[1..*], agg:AggColSpec<{T[1]->K[0..1]},{K[*]->V[0..1]}, R>[1]):Relation<Any>[1];

native function <<PCT.function>> {doc.doc = 'Pivots a relation by rotating data from rows into columns. Takes multiple pivot columns and multiple aggregate specifications. All unique combinations of values from the pivot columns become new column groups in the result. For each combination, multiple aggregated columns are created (one per aggregate specification). All remaining columns (not pivoted or aggregated) become grouping columns.'}
  meta::pure::functions::relation::pivot<T,Z,K,V,R>(r:Relation<T>[1], cols:ColSpecArray<Z⊆T>[1], agg:AggColSpecArray<{T[1]->K[0..1]},{K[*]->V[0..1]}, R>[1]):Relation<Any>[1];

native function <<PCT.function>> {doc.doc = 'Pivots a relation by rotating data from rows into columns. Takes a single pivot column and multiple aggregate specifications. All unique values from the pivot column become new column groups in the result. For each value, multiple aggregated columns are created (one per aggregate specification). All remaining columns (not pivoted or aggregated) become grouping columns.'}
  meta::pure::functions::relation::pivot<T,Z,K,V,R>(r:Relation<T>[1], cols:ColSpec<Z⊆T>[1], agg:AggColSpecArray<{T[1]->K[0..1]},{K[*]->V[0..1]}, R>[1]):Relation<Any>[1];

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_SingleSingle<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #->pivot(~[year], ~[newCol : x | $x.treePlanted : y | $y->plus()])
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2000__|__newCol\',\'2011__|__newCol\',\'2012__|__newCol\'\n' +
                  '   LDN,UK,null,3000,null\n' +
                  '   NYC,USA,15000,5000,15200\n' +
                  '   SAN,USA,2000,2600,null\n' +
                  '#', $res->cast(@Relation<(city:String,country:String,'2000__|__newCol':Integer,'2011__|__newCol':Integer,'2012__|__newCol':Integer)>)->sort([ascending(~city)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_SingleSingle_MultipleExpressions<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {|
                 let t = #TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #;
                 
                 $t->pivot(~[year], ~[newCol : x | $x.treePlanted : y | $y->plus()]);
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2000__|__newCol\',\'2011__|__newCol\',\'2012__|__newCol\'\n' +
                  '   LDN,UK,null,3000,null\n' +
                  '   NYC,USA,15000,5000,15200\n' +
                  '   SAN,USA,2000,2600,null\n' +
                  '#', $res->cast(@Relation<(city:String,country:String,'2000__|__newCol':Integer,'2011__|__newCol':Integer,'2012__|__newCol':Integer)>)->sort([ascending(~city)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_MultipleSingle<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #->pivot(~[country, city], ~sum : x | $x.treePlanted : y | $y->plus())
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   year,\'UK__|__LDN__|__sum\',\'USA__|__NYC__|__sum\',\'USA__|__SAN__|__sum\'\n' +
                  '   2000,null,15000,2000\n' +
                  '   2011,3000,5000,2600\n' +
                  '   2012,null,15200,null\n' +
                  '#', $res->cast(@Relation<(year:Integer,'UK__|__LDN__|__sum':Integer,'USA__|__NYC__|__sum':Integer,'USA__|__SAN__|__sum':Integer)>)->sort([ascending(~year)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_MultipleSingle_MultipleExpressions<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {|
                 let t = #TDS
                    city, country, year:Integer[1], treePlanted:Integer[1]
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #;
                 
                 $t->pivot(~[country, city], ~sum : x | $x.treePlanted : y | $y->plus());
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   year,\'UK__|__LDN__|__sum\',\'USA__|__NYC__|__sum\',\'USA__|__SAN__|__sum\'\n' +
                  '   2000,null,15000,2000\n' +
                  '   2011,3000,5000,2600\n' +
                  '   2012,null,15200,null\n' +
                  '#', $res->cast(@Relation<(year:Number,'UK__|__LDN__|__sum':Number,'USA__|__NYC__|__sum':Number,'USA__|__SAN__|__sum':Number)>)->sort([ascending(~year)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_SingleMultiple<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #->pivot(~[year], ~[sum : x | $x.treePlanted : y | $y->plus(), count : x | 1 : y | $y->plus()])
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2000__|__sum\',\'2000__|__count\',\'2011__|__sum\',\'2011__|__count\',\'2012__|__sum\',\'2012__|__count\'\n' +
                  '   LDN,UK,null,null,3000,1,null,null\n' +
                  '   NYC,USA,15000,2,5000,1,15200,2\n' +
                  '   SAN,USA,2000,1,2600,2,null,null\n' +
                  '#', $res->cast(@Relation<(city:String,country:String,'2000__|__sum':Integer,'2000__|__count':Integer,'2011__|__sum':Integer,'2011__|__count':Integer,'2012__|__sum':Integer,'2012__|__count':Integer)>)
                           ->select(~[city, country, '2000__|__sum', '2000__|__count', '2011__|__sum', '2011__|__count', '2012__|__sum', '2012__|__count'])
                           ->sort([ascending(~city)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_SingleMultiple_MultipleExpressions<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {|
                 let t = #TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #;
                 
                 $t->pivot(~[year], ~[sum : x | $x.treePlanted : y | $y->plus(), count : x | 1 : y | $y->plus()]);
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2000__|__sum\',\'2000__|__count\',\'2011__|__sum\',\'2011__|__count\',\'2012__|__sum\',\'2012__|__count\'\n' +
                  '   LDN,UK,null,null,3000,1,null,null\n' +
                  '   NYC,USA,15000,2,5000,1,15200,2\n' +
                  '   SAN,USA,2000,1,2600,2,null,null\n' +
                  '#', $res->cast(@Relation<(city:String,country:String,'2000__|__sum':Integer,'2000__|__count':Integer,'2011__|__sum':Integer,'2011__|__count':Integer,'2012__|__sum':Integer,'2012__|__count':Integer)>)
                           ->select(~[city, country, '2000__|__sum', '2000__|__count', '2011__|__sum', '2011__|__count', '2012__|__sum', '2012__|__count'])
                           ->sort([ascending(~city)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_SingleMultiple_Dynamic_Aggregation<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted, coefficient
                    NYC, USA, 2011, 5000, 1
                    NYC, USA, 2000, 5000, 2
                    SAN, USA, 2000, 2000, 1
                    SAN, USA, 2011, 100, 2
                    LDN, UK, 2011, 3000, 2
                    SAN, USA, 2011, 2500, 1
                    NYC, USA, 2000, 10000, 2
                    NYC, USA, 2012, 7600, 1
                    NYC, USA, 2012, 7600, 2
                 #->pivot(~[year], ~[sum : x | $x.treePlanted->toOne() * $x.coefficient->toOne() : y | $y->plus(), count : x | 1 : y | $y->plus()])
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2000__|__sum\',\'2000__|__count\',\'2011__|__sum\',\'2011__|__count\',\'2012__|__sum\',\'2012__|__count\'\n' +
                  '   LDN,UK,null,null,6000,1,null,null\n' +
                  '   NYC,USA,30000,2,5000,1,22800,2\n' +
                  '   SAN,USA,2000,1,2700,2,null,null\n' +
                  '#', $res->cast(@Relation<(city:String,country:String,'2000__|__sum':Integer,'2000__|__count':Integer,'2011__|__sum':Integer,'2011__|__count':Integer,'2012__|__sum':Integer,'2012__|__count':Integer)>)
                           ->select(~[city, country, '2000__|__sum', '2000__|__count', '2011__|__sum', '2011__|__count', '2012__|__sum', '2012__|__count'])
                           ->sort([ascending(~city)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_MultipleMultiple<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #->pivot(~[country, city], ~[sum : x | $x.treePlanted : y | $y->plus(), count : x | 1 : y | $y->plus()])
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   year,\'UK__|__LDN__|__sum\',\'UK__|__LDN__|__count\',\'USA__|__NYC__|__sum\',\'USA__|__NYC__|__count\',\'USA__|__SAN__|__sum\',\'USA__|__SAN__|__count\'\n' +
                  '   2000,null,null,15000,2,2000,1\n' +
                  '   2011,3000,1,5000,1,2600,2\n' +
                  '   2012,null,null,15200,2,null,null\n' +
                  '#', $res->cast(@Relation<(year:Integer,'UK__|__LDN__|__sum':Integer,'UK__|__LDN__|__count':Integer,'USA__|__NYC__|__sum':Integer,'USA__|__NYC__|__count':Integer,'USA__|__SAN__|__sum':Integer,'USA__|__SAN__|__count':Integer)>)
                           ->select(~[year, 'UK__|__LDN__|__sum', 'UK__|__LDN__|__count', 'USA__|__NYC__|__sum', 'USA__|__NYC__|__count', 'USA__|__SAN__|__sum', 'USA__|__SAN__|__count'])
                           ->sort([ascending(~year)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_MultipleMultiple_MultipleExpressions<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {|
                 let t = #TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #;
                 
                 $t->pivot(~[country, city], ~[sum : x | $x.treePlanted : y | $y->plus(), count : x | 1 : y | $y->plus()]);
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   year,\'UK__|__LDN__|__sum\',\'UK__|__LDN__|__count\',\'USA__|__NYC__|__sum\',\'USA__|__NYC__|__count\',\'USA__|__SAN__|__sum\',\'USA__|__SAN__|__count\'\n' +
                  '   2000,null,null,15000,2,2000,1\n' +
                  '   2011,3000,1,5000,1,2600,2\n' +
                  '   2012,null,null,15200,2,null,null\n' +
                  '#', $res->cast(@Relation<(year:Integer,'UK__|__LDN__|__sum':Integer,'UK__|__LDN__|__count':Integer,'USA__|__NYC__|__sum':Integer,'USA__|__NYC__|__count':Integer,'USA__|__SAN__|__sum':Integer,'USA__|__SAN__|__count':Integer)>)
                           ->select(~[year, 'UK__|__LDN__|__sum', 'UK__|__LDN__|__count', 'USA__|__NYC__|__sum', 'USA__|__NYC__|__count', 'USA__|__SAN__|__sum', 'USA__|__SAN__|__count'])
                           ->sort([ascending(~year)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testPivot_MultipleMultiple_Dynamic_Aggregation<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted, coefficient
                    NYC, USA, 2011, 5000, 1
                    NYC, USA, 2000, 5000, 2
                    SAN, USA, 2000, 2000, 1
                    SAN, USA, 2011, 100, 2
                    LDN, UK, 2011, 3000, 2
                    SAN, USA, 2011, 2500, 1
                    NYC, USA, 2000, 10000, 2
                    NYC, USA, 2012, 7600, 1
                    NYC, USA, 2012, 7600, 2
                 #->pivot(~[country, city], ~[sum : x | $x.treePlanted->toOne() * $x.coefficient->toOne() : y | $y->plus(), count : x | 1 : y | $y->plus()])
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   year,\'UK__|__LDN__|__sum\',\'UK__|__LDN__|__count\',\'USA__|__NYC__|__sum\',\'USA__|__NYC__|__count\',\'USA__|__SAN__|__sum\',\'USA__|__SAN__|__count\'\n' +
                  '   2000,null,null,30000,2,2000,1\n' +
                  '   2011,6000,1,5000,1,2700,2\n' +
                  '   2012,null,null,22800,2,null,null\n' +
                  '#', $res->cast(@Relation<(year:Integer,'UK__|__LDN__|__sum':Integer,'UK__|__LDN__|__count':Integer,'USA__|__NYC__|__sum':Integer,'USA__|__NYC__|__count':Integer,'USA__|__SAN__|__sum':Integer,'USA__|__SAN__|__count':Integer)>)
                           ->select(~[year, 'UK__|__LDN__|__sum', 'UK__|__LDN__|__count', 'USA__|__NYC__|__sum', 'USA__|__NYC__|__count', 'USA__|__SAN__|__sum', 'USA__|__SAN__|__count'])
                           ->sort([ascending(~year)])->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testStaticPivot_SingleSingle<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000.0
                    NYC, USA, 2000, 5000.0
                    SAN, USA, 2000, 2000.0
                    SAN, USA, 2011, 100.0
                    LDN, UK, 2011, 3000.0
                    SAN, USA, 2011, 2500.0
                    NYC, USA, 2000, 10000.0
                    NYC, USA, 2012, 7600.0
                    NYC, USA, 2012, 7600.0
                 #->pivot(~year, [2000, 2011], ~newCol : x | $x.treePlanted : y | $y->plus())
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2000__|__newCol\',\'2011__|__newCol\'\n' +
                  '   LDN,UK,null,3000.0\n' +
                  '   NYC,USA,15000.0,5000.0\n' +
                  '   SAN,USA,2000.0,2600.0\n' +
                  '#', $res->cast(@Relation<(city:String,country:String,'2000__|__newCol':Number,'2011__|__newCol':Number)>)->sort([ascending(~city)])->toString()); // New pivoted columns should be cast to Integer
}

function <<PCT.test>> meta::pure::functions::relation::tests::pivot::testStaticPivot_SingleSingle_StringPivotValue<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    week, day, numWorkers, itemsProduced
                    Week1, SUNDAY, 2, 4.0
                    Week1, MONDAY, 11, 15.0
                    Week1, TUESDAY, 10, 12.0
                    Week1, WEDNESDAY, 11, 7.0
                    Week1, THURSDAY, 10, 12.0
                    Week1, FRIDAY, 11, 10.0
                    Week1, SATURDAY, 5, 7.0
                    Week2, SUNDAY, 4, 5.0
                    Week2, MONDAY, 8, 10.0
                    Week2, TUESDAY, 8, 11.0
                    Week2, WEDNESDAY, 7, 9.0
                    Week2, THURSDAY, 11, 8.0
                    Week2, FRIDAY, 11, 12.0
                    Week2, SATURDAY, 6, 8.0
                 #->pivot(~day, ['MONDAY', 'TUESDAY'], ~newCol : x | $x.itemsProduced : y | $y->plus())
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   week,numWorkers,\'MONDAY__|__newCol\',\'TUESDAY__|__newCol\'\n' +
                  '   Week2,8,10.0,11.0\n' +
                  '   Week1,10,null,12.0\n' +
                  '   Week1,11,15.0,null\n' +
                  '#', $res->cast(@Relation<(week:String,numWorkers:Number,'MONDAY__|__newCol':Number,'TUESDAY__|__newCol':Number)>)->sort([ascending(~numWorkers)])->toString());
}
