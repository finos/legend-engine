// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::metamodel::relation::*;
import meta::pure::test::pct::*;

function <<PCT.function, PCT.platformOnly>> meta::pure::functions::relation::assertTdsEquivalent(one:Relation<Any>[1], two:Relation<Any>[1], delta:Number[1]):Boolean[1]
{
   let oneCol = $one->meta::pure::functions::relation::columns();
   let twoCol = $two->meta::pure::functions::relation::columns();
   $oneCol->size() == $twoCol->size() && $oneCol.name == $twoCol.name && $one->size() == $two->size() &&
   if($oneCol->zip($twoCol)->fold({cols, acc|
          let oneVals = $one->map(x|$cols.first->eval($x));
          let twoVals = $two->map(x|$cols.second->eval($x));
          $acc && if ($cols.first.classifierGenericType.typeArguments->at(1).rawType->toOne()->subTypeOf(Number) && $cols.second.classifierGenericType.typeArguments->at(1).rawType->toOne()->subTypeOf(Number),
            |$oneVals->zip($twoVals)->fold({a,b| $b && ($a.first->isEmpty() && $a.second->isEmpty()) || ((!$a.first->isEmpty() && !$a.second->isEmpty()) && (abs($a.first->toOne()->cast(@Number) - $a.second->toOne()->cast(@Number)) <= abs($delta)))}, true),
            |$oneVals == $twoVals
          );
        },
        true
      ),
      | true,
      | fail($one->toString(true)+'\n is not equivalent to:\n'+$two->toString(true))
   );
}

function <<test.Test>> meta::pure::functions::relation::tests::tdsEquivalent::testDifferentNumTypes():Boolean[1]
{
  assertTdsEquivalent(
      #TDS
        val:Number[1]
        1
      #,
      #TDS
        val:Integer[1]
        1
      #,
      0.001
  )
}

function <<test.Test>> meta::pure::functions::relation::tests::tdsEquivalent::testMultiCols():Boolean[1]
{
  assertTdsEquivalent(
      #TDS
        val:Number[1], name:String[1]
        1, ok
        2.0, bla
        #,
      #TDS
        val:Integer[1], name:String[1]
        1, ok
        2, bla
      #,
      0.001
  )
}