// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::functions::variant::navigation::*;
import meta::pure::test::pct::*;
import meta::pure::metamodel::relation::*;
import meta::pure::functions::relation::*;
import meta::pure::functions::relation::tests::composition::*;

Class meta::pure::functions::relation::tests::composition::FirmTypeForCompositionTests
{
  legalName : String[1];
  employees : PersonTypeForCompositionTests[*];
}

Class meta::pure::functions::relation::tests::composition::PersonTypeForCompositionTests
{
  firstName : String[1];
  lastName  : String[1];
}

function <<PCT.test>> meta::pure::functions::relation::tests::composition::testExtendFilter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str
                  1, a
                  3, ewe
                  4, qw
                  5, wwe
                  6, weq
                #->extend(~newCol:x|$x.str->toOne() + $x.val->toOne()->toString())
                 ->filter(x|$x.newCol == 'qw4');
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   val,str,newCol\n'+
                  '   4,qw,qw4\n'+
                  '#', $res->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::composition::testFilterPostProject<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {|
                     [
                        ^FirmTypeForCompositionTests
                        (
                            legalName = 'Firm X',
                            employees = [
                                ^PersonTypeForCompositionTests(firstName = 'Peter', lastName = 'Smith'),
                                ^PersonTypeForCompositionTests(firstName = 'John', lastName = 'Johnson'),
                                ^PersonTypeForCompositionTests(firstName = 'John', lastName = 'Hill'),
                                ^PersonTypeForCompositionTests(firstName = 'Anthony', lastName = 'Allen')
                            ]
                        ),
                        ^FirmTypeForCompositionTests
                        (
                            legalName = 'Firm A',
                            employees = [
                                ^PersonTypeForCompositionTests(firstName = 'Fabrice', lastName = 'Roberts')
                            ]
                        )
                     ]
                     ->project(~[
                        legalName : x | $x.legalName,
                        firstName : x | $x.employees.firstName
                     ])
                     ->filter(x | $x.legalName == 'Firm X');
                  };

        let res =  $f->eval($expr);

        assertEquals( '#TDS\n' +
                      '   legalName,firstName\n' +
                      '   Firm X,Anthony\n' +
                      '   Firm X,John\n' +
                      '   Firm X,John\n' +
                      '   Firm X,Peter\n' +
                      '#', $res->sort(~firstName->ascending())->toString());
}


function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Distinct_GroupBy<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  3, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->distinct(~[val, str])->groupBy(~str, ~newCol:x|$x.val:x|$x->plus());
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol\n'+
                  '   a,5\n'+
                  '   qw,9\n'+
                  '   weq,2\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::composition::test_Distinct_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  3, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->distinct(~[val, str])->filter(x|$x.val > 2)
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   val,str\n'+
                  '   3,a\n'+
                  '   4,qw\n'+
                  '   5,qw\n'+
                  '#', $res->sort(~val->ascending())->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_GroupBy_GroupBy<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  3, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->groupBy(~[str, str2], ~newCol:x|$x.val:x|$x->plus())->groupBy(~[str], ~newCol2:x|$x.newCol:x|$x->plus())
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol2\n'+
                  '   a,5\n'+
                  '   qw,9\n'+
                  '   weq,2\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_GroupBy_Distinct<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  3, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->groupBy(~[str, str2], ~newCol:x|$x.val:x|$x->plus())->distinct(~[str])
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str\n'+
                  '   a\n'+
                  '   qw\n'+
                  '   weq\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::composition::test_Pivot_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #->pivot(~[year], ~['newCol' : x | $x.treePlanted : y | $y->plus()])
                 ->cast(@Relation<(city:String,country:String,'\'2000__|__newCol\'':Integer,'\'2011__|__newCol\'':Integer,'\'2012__|__newCol\'':Integer)>)
                 ->filter(x|$x.city=='NYC')
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2000__|__newCol\',\'2011__|__newCol\',\'2012__|__newCol\'\n' +
                  '   NYC,USA,15000,5000,15200\n' +
                  '#', $res->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Extend_Filter_Select_ComplexGroupBy_Pivot<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #
                  ->extend(~yr:x|$x.year->toOne() - 2000)
                  ->filter(x|$x.yr > 10)
                  ->select(~[city,country,year,treePlanted])
                  ->groupBy(~[city,country], ~[year:x|$x.year:x|$x->plus(), treePlanted:x|$x.treePlanted:x|$x->plus()])
                  ->pivot(~[year], ~['newCol' : x|$x.treePlanted:x|$x->plus()])
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2011__|__newCol\',\'4022__|__newCol\',\'6035__|__newCol\'\n' +
                  '   LDN,UK,3000,null,null\n' +
                  '   NYC,USA,null,null,20200\n' +
                  '   SAN,USA,null,2600,null\n' +
                  '#', $res->cast(@Relation<(city:String,country:String,'\'2011__|__newCol\'':Integer,'\'4022__|__newCol\'':Integer,'\'6035__|__newCol\'':Integer)>)->sort(ascending(~city))->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Extend_Filter_Select_GroupBy_Pivot_Extend_Sort_Limit<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #
                  ->extend(~yr:x|$x.year->toOne() - 2000)
                  ->filter(x|$x.yr > 10)
                  ->select(~[city,country,year,treePlanted])
                  ->groupBy(~[year,city,country], ~treePlanted:x|$x.treePlanted:x|$x->plus())
                  ->pivot(~[year], ~['newCol' : x | $x.treePlanted : y | $y->plus()])
                  ->cast(@Relation<(city:String,country:String,'\'2011__|__newCol\'':Integer,'\'2012__|__newCol\'':Integer)>)
                  ->extend(~newCol:x|$x.city->toOne() + '_0')
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2011__|__newCol\',\'2012__|__newCol\',newCol\n' +
                  '   LDN,UK,3000,null,LDN_0\n' +
                  '   NYC,USA,5000,15200,NYC_0\n' +
                  '   SAN,USA,2600,null,SAN_0\n' +
                  '#', $res->sort(ascending(~city))->limit(3)->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Extend_Filter_Select_Pivot_GroupBy_Extend_Sort<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #
                  ->extend(~yr:x|$x.year->toOne() - 2000)
                  ->filter(x|$x.yr > 10)
                  ->select(~[city,country,year,treePlanted])
                  ->pivot(~[year], ~['newCol':x|$x.treePlanted:x|$x->plus()])
                  ->cast(@Relation<(city:String,country:String,'\'2011__|__newCol\'':Integer,'\'2012__|__newCol\'':Integer)>)
                  ->groupBy(~[country], ~['\'2011__|__newCol\'':x|$x.'\'2011__|__newCol\'':x|$x->plus(),'\'2012__|__newCol\'':x|$x.'\'2012__|__newCol\'':x|$x->plus()])
                  ->extend(~newCol:x|$x.country->toOne() + '_0')
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   country,\'2011__|__newCol\',\'2012__|__newCol\',newCol\n' +
                  '   UK,3000,0,UK_0\n' +
                  '   USA,7600,15200,USA_0\n' +
                  '#', $res
                    ->sort(ascending(~country))
                    ->toString());
}

// ------------------------------------- TO FIX -------------------------------------

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_GroupBy_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str
                  2, a
                  3, a
                  4, qw
                  5, qw
                  2, weq
                #->groupBy(~str, ~newCol:x|$x.val:x|$x->plus())
                 ->filter(x|$x.newCol > 4);
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol\n'+
                  '   a,5\n'+
                  '   qw,9\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_GroupBy_Distinct_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  2, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->groupBy(~[str, str2], ~newCol:x|$x.val:x|$x->plus())->distinct(~[str, newCol])->filter(x|$x.newCol > 2)
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol\n'+
                  '   a,4\n'+
                  '   qw,4\n'+
                  '   qw,5\n'+
                  '#', $res->sort([~str->ascending(), ~newCol->ascending()])->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Distinct_GroupBy_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  2, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->distinct()->groupBy(~[str], ~newCol:x|$x.val:x|$x->plus())->filter(x|$x.newCol > 2)
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol\n'+
                  '   qw,9\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.olap>> meta::pure::functions::relation::tests::composition::testWindowFunctionsAfterProject<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {|
        [
            ^PersonTypeForCompositionTests(firstName = 'Peter', lastName = 'Smith'),
            ^PersonTypeForCompositionTests(firstName = 'Peter', lastName = 'Johnson'),
            ^PersonTypeForCompositionTests(firstName = 'Peter', lastName = 'Hill'),
            ^PersonTypeForCompositionTests(firstName = 'Anthony', lastName = 'Allen'),
            ^PersonTypeForCompositionTests(firstName = 'Anthony', lastName = 'Roberts')
        ]->project(~[
            first : x | $x.firstName,
            last  : x | $x.lastName
        ])
        ->extend(over(~first, ~last->ascending()), ~[leadLast:{p,w,r|$p->lead($r).last}, lagLast:{p,w,r|$p->lag($r).last}])
        ->sort([ascending(~first), ascending(~last)]);
    };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   first,last,leadLast,lagLast\n'+
                  '   Anthony,Allen,Roberts,null\n'+
                  '   Anthony,Roberts,null,Allen\n'+
                  '   Peter,Hill,Johnson,null\n'+
                  '   Peter,Johnson,Smith,Hill\n'+
                  '   Peter,Smith,null,Johnson\n'+
                  '#', $res->toString());
}

function
  <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>>
  {
    doc.doc='Tests map and casting the values of the column before applying the aggregate function. Cast is treated as a noop in this case.'
  }
meta::pure::functions::relation::tests::composition::testGroupByCastBeforeAgg<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]{
  let expr = {
              | #TDS
                id, grp
                1, 2
                2, 1
                3, 3
                4, 4
                5, 2
                6, 1
                7, 3
                8, 1
                9, 5
                10, 0
              #->groupBy(~grp, ~newCol:x|$x.id:x|$x->cast(@Integer)->plus())
              };

  let res = $f->eval($expr);

  assertEquals( '#TDS\n'+
                '   grp,newCol\n'+
                '   0,10\n'+
                '   1,16\n'+
                '   2,6\n'+
                '   3,10\n'+
                '   4,4\n'+
                '   5,9\n'+
                '#', $res->sort(~grp->ascending())->toString());
}

function
  <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>>
  {
    doc.doc='Tests map and casting result of the aggregate function. Cast is treated as a noop in this case.'
  }
meta::pure::functions::relation::tests::composition::testGroupByCastAfterAgg<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]{
  let expr = {
              | #TDS
                id, grp
                1, 2
                2, 1
                3, 3
                4, 4
                5, 2
                6, 1
                7, 3
                8, 1
                9, 5
                10, 0
              #->groupBy(~grp, ~newCol:x|$x.id:x|$x->plus()->cast(@Integer))
              };

  let res = $f->eval($expr);

  assertEquals( '#TDS\n'+
                '   grp,newCol\n'+
                '   0,10\n'+
                '   1,16\n'+
                '   2,6\n'+
                '   3,10\n'+
                '   4,4\n'+
                '   5,9\n'+
                '#', $res->sort(~grp->ascending())->toString());
}

function
  <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.olap>>
  {
    doc.doc='Tests olap with a partition window and casting result of the aggregate function. Cast is treated as a noop in this case.'
  }
meta::pure::functions::relation::tests::composition::testOLAPCastAggWithPartitionWindow<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                | #TDS
                  id, grp, name
                  1, 2, A
                  2, 1, B
                  3, 3, C
                  4, 4, D
                  5, 2, E
                  6, 1, F
                  7, 3, G
                  8, 1, H
                  9, 5, I
                  10, 0, J
                #->extend(over(~grp), ~newCol:{p,w,r|$r.id}:y|$y->plus()->cast(@Integer))
               };


    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   id,grp,name,newCol\n'+
                  '   10,0,J,10\n'+
                  '   2,1,B,16\n'+
                  '   6,1,F,16\n'+
                  '   8,1,H,16\n'+
                  '   1,2,A,6\n'+
                  '   5,2,E,6\n'+
                  '   3,3,C,10\n'+
                  '   7,3,G,10\n'+
                  '   4,4,D,4\n'+
                  '   9,5,I,9\n'+
                  '#', $res->sort([~grp->ascending(), ~id->ascending()])->toString());
}

function
  <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.olap>>
  {
    doc.doc='Tests olap with a partition window and casting the values of the column before applying the aggregate function. Cast is treated as a noop in this case.'
  }
meta::pure::functions::relation::tests::composition::testOLAPAggCastWithPartitionWindow<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                | #TDS
                  id, grp, name
                  1, 2, A
                  2, 1, B
                  3, 3, C
                  4, 4, D
                  5, 2, E
                  6, 1, F
                  7, 3, G
                  8, 1, H
                  9, 5, I
                  10, 0, J
                #->extend(over(~grp), ~newCol:{p,w,r|$r.id}:y|$y->cast(@Integer)->plus())
               };


    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   id,grp,name,newCol\n'+
                  '   10,0,J,10\n'+
                  '   2,1,B,16\n'+
                  '   6,1,F,16\n'+
                  '   8,1,H,16\n'+
                  '   1,2,A,6\n'+
                  '   5,2,E,6\n'+
                  '   3,3,C,10\n'+
                  '   7,3,G,10\n'+
                  '   4,4,D,4\n'+
                  '   9,5,I,9\n'+
                  '#', $res->sort([~grp->ascending(), ~id->ascending()])->toString());
}

function
  <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.olap>>
  {
    doc.doc='Tests olap with a partition window and casting the values of the extract function before applying the aggregate function. Cast is treated as a noop in this case.'
  }
meta::pure::functions::relation::tests::composition::testOLAPCastExtractAggWithPartitionWindow<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                | #TDS
                  id, grp, name
                  1, 2, A
                  2, 1, B
                  3, 3, C
                  4, 4, D
                  5, 2, E
                  6, 1, F
                  7, 3, G
                  8, 1, H
                  9, 5, I
                  10, 0, J
                #->extend(over(~grp), ~newCol:{p,w,r|$r.id->cast(@Integer)}:y|$y->plus())
               };


    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   id,grp,name,newCol\n'+
                  '   10,0,J,10\n'+
                  '   2,1,B,16\n'+
                  '   6,1,F,16\n'+
                  '   8,1,H,16\n'+
                  '   1,2,A,6\n'+
                  '   5,2,E,6\n'+
                  '   3,3,C,10\n'+
                  '   7,3,G,10\n'+
                  '   4,4,D,4\n'+
                  '   9,5,I,9\n'+
                  '#', $res->sort([~grp->ascending(), ~id->ascending()])->toString());
}

function
  <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.olap>>
  {
    doc.doc='Tests olap with a partition window, casting the values of the extract function before applying the aggregate function, and casting result of the aggregate function. Cast is treated as a noop in this case.'
  }
meta::pure::functions::relation::tests::composition::testOLAPCastExtractCastAggWithPartitionWindow<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                | #TDS
                  id, grp, name
                  1, 2, A
                  2, 1, B
                  3, 3, C
                  4, 4, D
                  5, 2, E
                  6, 1, F
                  7, 3, G
                  8, 1, H
                  9, 5, I
                  10, 0, J
                #->extend(over(~grp), ~newCol:{p,w,r|$r.id->cast(@Integer)}:y|$y->plus()->cast(@Integer))
               };


    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   id,grp,name,newCol\n'+
                  '   10,0,J,10\n'+
                  '   2,1,B,16\n'+
                  '   6,1,F,16\n'+
                  '   8,1,H,16\n'+
                  '   1,2,A,6\n'+
                  '   5,2,E,6\n'+
                  '   3,3,C,10\n'+
                  '   7,3,G,10\n'+
                  '   4,4,D,4\n'+
                  '   9,5,I,9\n'+
                  '#', $res->sort([~grp->ascending(), ~id->ascending()])->toString());
}