// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::functions::variant::navigation::*;
import meta::pure::test::pct::*;
import meta::pure::metamodel::relation::*;
import meta::pure::functions::relation::*;
import meta::pure::functions::relation::tests::composition::*;

Class meta::pure::functions::relation::tests::composition::FirmTypeForCompositionTests
{
  legalName : String[1];
  employees : PersonTypeForCompositionTests[*];
}

Class meta::pure::functions::relation::tests::composition::PersonTypeForCompositionTests
{
  firstName : String[1];
  lastName  : String[1];
}

function <<PCT.test>> meta::pure::functions::relation::tests::composition::testExtendFilter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str
                  1, a
                  3, ewe
                  4, qw
                  5, wwe
                  6, weq
                #->extend(~newCol:x|$x.str->toOne() + $x.val->toOne()->toString())
                 ->filter(x|$x.newCol == 'qw4');
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   val,str,newCol\n'+
                  '   4,qw,qw4\n'+
                  '#', $res->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::composition::testFilterPostProject<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {|
                     [
                        ^FirmTypeForCompositionTests
                        (
                            legalName = 'Firm X',
                            employees = [
                                ^PersonTypeForCompositionTests(firstName = 'Peter', lastName = 'Smith'),
                                ^PersonTypeForCompositionTests(firstName = 'John', lastName = 'Johnson'),
                                ^PersonTypeForCompositionTests(firstName = 'John', lastName = 'Hill'),
                                ^PersonTypeForCompositionTests(firstName = 'Anthony', lastName = 'Allen')
                            ]
                        ),
                        ^FirmTypeForCompositionTests
                        (
                            legalName = 'Firm A',
                            employees = [
                                ^PersonTypeForCompositionTests(firstName = 'Fabrice', lastName = 'Roberts')
                            ]
                        )
                     ]
                     ->project(~[
                        legalName : x | $x.legalName,
                        firstName : x | $x.employees.firstName
                     ])
                     ->filter(x | $x.legalName == 'Firm X');
                  };

        let res =  $f->eval($expr);

        assertEquals( '#TDS\n' +
                      '   legalName,firstName\n' +
                      '   Firm X,Anthony\n' +
                      '   Firm X,John\n' +
                      '   Firm X,John\n' +
                      '   Firm X,Peter\n' +
                      '#', $res->sort(~firstName->ascending())->toString());
}


function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Distinct_GroupBy<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  3, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->distinct(~[val, str])->groupBy(~str, ~newCol:x|$x.val:x|$x->plus());
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol\n'+
                  '   a,5\n'+
                  '   qw,9\n'+
                  '   weq,2\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::composition::test_Distinct_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  3, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->distinct(~[val, str])->filter(x|$x.val > 2)
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   val,str\n'+
                  '   3,a\n'+
                  '   4,qw\n'+
                  '   5,qw\n'+
                  '#', $res->sort(~val->ascending())->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_GroupBy_GroupBy<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  3, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->groupBy(~[str, str2], ~newCol:x|$x.val:x|$x->plus())->groupBy(~[str], ~newCol2:x|$x.newCol:x|$x->plus())
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol2\n'+
                  '   a,5\n'+
                  '   qw,9\n'+
                  '   weq,2\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_GroupBy_Distinct<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  3, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->groupBy(~[str, str2], ~newCol:x|$x.val:x|$x->plus())->distinct(~[str])
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str\n'+
                  '   a\n'+
                  '   qw\n'+
                  '   weq\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test>> meta::pure::functions::relation::tests::composition::test_Pivot_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #->pivot(~[year], ~['newCol' : x | $x.treePlanted : y | $y->plus()])
                 ->cast(@Relation<(city:String,country:String,'\'2000__|__newCol\'':Integer,'\'2011__|__newCol\'':Integer,'\'2012__|__newCol\'':Integer)>)
                 ->filter(x|$x.city=='NYC')
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2000__|__newCol\',\'2011__|__newCol\',\'2012__|__newCol\'\n' +
                  '   NYC,USA,15000,5000,15200\n' +
                  '#', $res->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Extend_Filter_Select_ComplexGroupBy_Pivot<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #
                  ->extend(~yr:x|$x.year->toOne() - 2000)
                  ->filter(x|$x.yr > 10)
                  ->select(~[city,country,year,treePlanted])
                  ->groupBy(~[city,country], ~[year:x|$x.year:x|$x->plus(), treePlanted:x|$x.treePlanted:x|$x->plus()])
                  ->pivot(~[year], ~['newCol' : x|$x.treePlanted:x|$x->plus()])
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2011__|__newCol\',\'4022__|__newCol\',\'6035__|__newCol\'\n' +
                  '   LDN,UK,3000,null,null\n' +
                  '   NYC,USA,null,null,20200\n' +
                  '   SAN,USA,null,2600,null\n' +
                  '#', $res->cast(@Relation<(city:String,country:String,'\'2011__|__newCol\'':Integer,'\'4022__|__newCol\'':Integer,'\'6035__|__newCol\'':Integer)>)->sort(ascending(~city))->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Extend_Filter_Select_GroupBy_Pivot_Extend_Sort_Limit<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #
                  ->extend(~yr:x|$x.year->toOne() - 2000)
                  ->filter(x|$x.yr > 10)
                  ->select(~[city,country,year,treePlanted])
                  ->groupBy(~[year,city,country], ~treePlanted:x|$x.treePlanted:x|$x->plus())
                  ->pivot(~[year], ~['newCol' : x | $x.treePlanted : y | $y->plus()])
                  ->cast(@Relation<(city:String,country:String,'\'2011__|__newCol\'':Integer,'\'2012__|__newCol\'':Integer)>)
                  ->extend(~newCol:x|$x.city->toOne() + '_0')
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   city,country,\'2011__|__newCol\',\'2012__|__newCol\',newCol\n' +
                  '   LDN,UK,3000,null,LDN_0\n' +
                  '   NYC,USA,5000,15200,NYC_0\n' +
                  '   SAN,USA,2600,null,SAN_0\n' +
                  '#', $res->sort(ascending(~city))->limit(3)->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Extend_Filter_Select_Pivot_GroupBy_Extend_Sort<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
                |#TDS
                    city, country, year, treePlanted
                    NYC, USA, 2011, 5000
                    NYC, USA, 2000, 5000
                    SAN, USA, 2000, 2000
                    SAN, USA, 2011, 100
                    LDN, UK, 2011, 3000
                    SAN, USA, 2011, 2500
                    NYC, USA, 2000, 10000
                    NYC, USA, 2012, 7600
                    NYC, USA, 2012, 7600
                 #
                  ->extend(~yr:x|$x.year->toOne() - 2000)
                  ->filter(x|$x.yr > 10)
                  ->select(~[city,country,year,treePlanted])
                  ->pivot(~[year], ~['newCol':x|$x.treePlanted:x|$x->plus()])
                  ->cast(@Relation<(city:String,country:String,'\'2011__|__newCol\'':Integer,'\'2012__|__newCol\'':Integer)>)
                  ->groupBy(~[country], ~['\'2011__|__newCol\'':x|$x.'\'2011__|__newCol\'':x|$x->plus(),'\'2012__|__newCol\'':x|$x.'\'2012__|__newCol\'':x|$x->plus()])
                  ->extend(~newCol:x|$x.country->toOne() + '_0')
               };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   country,\'2011__|__newCol\',\'2012__|__newCol\',newCol\n' +
                  '   UK,3000,0,UK_0\n' +
                  '   USA,7600,15200,USA_0\n' +
                  '#', $res
                    ->sort(ascending(~country))
                    ->toString());
}

// ------------------------------------- TO FIX -------------------------------------

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_GroupBy_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str
                  2, a
                  3, a
                  4, qw
                  5, qw
                  2, weq
                #->groupBy(~str, ~newCol:x|$x.val:x|$x->plus())
                 ->filter(x|$x.newCol > 4);
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol\n'+
                  '   a,5\n'+
                  '   qw,9\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_GroupBy_Distinct_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  2, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->groupBy(~[str, str2], ~newCol:x|$x.val:x|$x->plus())->distinct(~[str, newCol])->filter(x|$x.newCol > 2)
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol\n'+
                  '   a,4\n'+
                  '   qw,4\n'+
                  '   qw,5\n'+
                  '#', $res->sort([~str->ascending(), ~newCol->ascending()])->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::test_Distinct_GroupBy_Filter<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {
               | #TDS
                  val, str, str2
                  2, a, b
                  2, a, b
                  4, qw, b
                  5, qw, c
                  2, weq, c
                #->distinct()->groupBy(~[str], ~newCol:x|$x.val:x|$x->plus())->filter(x|$x.newCol > 2)
              };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   str,newCol\n'+
                  '   qw,9\n'+
                  '#', $res->sort(~str->ascending())->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.olap>> meta::pure::functions::relation::tests::composition::testWindowFunctionsAfterProject<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let expr = {|
        [
            ^PersonTypeForCompositionTests(firstName = 'Peter', lastName = 'Smith'),
            ^PersonTypeForCompositionTests(firstName = 'Peter', lastName = 'Johnson'),
            ^PersonTypeForCompositionTests(firstName = 'Peter', lastName = 'Hill'),
            ^PersonTypeForCompositionTests(firstName = 'Anthony', lastName = 'Allen'),
            ^PersonTypeForCompositionTests(firstName = 'Anthony', lastName = 'Roberts')
        ]->project(~[
            first : x | $x.firstName,
            last  : x | $x.lastName
        ])
        ->extend(over(~first, ~last->ascending()), ~[leadLast:{p,w,r|$p->lead($r).last}, lagLast:{p,w,r|$p->lag($r).last}])
        ->sort([ascending(~first), ascending(~last)]);
    };

    let res =  $f->eval($expr);

    assertEquals( '#TDS\n'+
                  '   first,last,leadLast,lagLast\n'+
                  '   Anthony,Allen,Roberts,null\n'+
                  '   Anthony,Roberts,null,Allen\n'+
                  '   Peter,Hill,Johnson,null\n'+
                  '   Peter,Johnson,Smith,Hill\n'+
                  '   Peter,Smith,null,Johnson\n'+
                  '#', $res->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTCoreQualifier.variant>> meta::pure::functions::relation::tests::composition::testVariantColumn_roundTrip<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
    let tds = #TDS
      id, payload:meta::pure::metamodel::variant::Variant
      1, "[1,2,3]"
      2, "[4,5,6]"
      3, "[7,8,9]"
      4, "[10,11,12]"
      5, "[13,14,15]"
    #;

    let expr = {|$tds};

    let res =  $f->eval($expr);

    assertEquals( $expr->eval()->toString(), $res->sort(~id->ascending())->toString());
}

// TODO interpreted does not like the sort on ~id in the assert
//function <<PCT.test, PCTRelationQualifier.relation, PCTCoreQualifier.variant>> meta::pure::functions::relation::tests::composition::testVariantColumn_indexExtraction<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
//{
//    let tds = #TDS
//      id, payload:meta::pure::metamodel::variant::Variant
//      1, "[1,2,3]"
//      2, "[4,5,6]"
//      3, "[7,8,9]"
//      4, "[10,11,12]"
//      5, "[13,14,15]"
//    #;
//
//    let expr = {|$tds->extend(~atCol:x | $x.payload->get(0))};
//
//    let res =  $f->eval($expr);
//
//    assertEquals( $expr->eval()->toString(), $res->sort(~id->ascending())->toString());
//}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::testGroupByCastBeforeAgg<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
  let expr = {
              | #TDS
                id, grp
                1, 2
                2, 1
                3, 3
                4, 4
                5, 2
                6, 1
                7, 3
                8, 1
                9, 5
                10, 0
              #->groupBy(~grp, ~newCol:x|$x.id:x|$x->cast(@Integer)->plus())
              };

  let res = $f->eval($expr);

  assertEquals( '#TDS\n'+
                '   grp,newCol\n'+
                '   0,10\n'+
                '   1,16\n'+
                '   2,6\n'+
                '   3,10\n'+
                '   4,4\n'+
                '   5,9\n'+
                '#', $res->sort(~grp->ascending())->toString());
}

function <<PCT.test, PCTRelationQualifier.relation, PCTRelationQualifier.aggregation>> meta::pure::functions::relation::tests::composition::testGroupByCastAfterAgg<T|m>(f:Function<{Function<{->T[m]}>[1]->T[m]}>[1]):Boolean[1]
{
  let expr = {
              | #TDS
                id, grp
                1, 2
                2, 1
                3, 3
                4, 4
                5, 2
                6, 1
                7, 3
                8, 1
                9, 5
                10, 0
              #->groupBy(~grp, ~newCol:x|$x.id:x|$x->plus()->cast(@Integer))
              };

  let res = $f->eval($expr);

  assertEquals( '#TDS\n'+
                '   grp,newCol\n'+
                '   0,10\n'+
                '   1,16\n'+
                '   2,6\n'+
                '   3,10\n'+
                '   4,4\n'+
                '   5,9\n'+
                '#', $res->sort(~grp->ascending())->toString());
}