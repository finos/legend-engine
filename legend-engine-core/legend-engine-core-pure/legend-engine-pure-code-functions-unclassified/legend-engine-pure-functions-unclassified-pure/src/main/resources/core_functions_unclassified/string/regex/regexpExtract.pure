// Copyright 2025 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::test::pct::*;

function <<PCT.function>> {doc.doc = 'Returns the substring that matches a regular expression within a string. If extractAll is true, then it returns an array that contains all substrings that match a regular expression within a string. Group number specifies which group to extract. Groups are specified by using parentheses in the regular expression. The group number defaults to 0. By default, it does case-sensitive matching and single-line mode, and POSIX wildcard character . does not match \n newline characters. The platform supports the full POSIX ERE (Extended Regular Expression) syntax.'}
  meta::pure::functions::string::regexpExtract(string:String[1], regexp:String[1], extractAll:Boolean[1]):String[*]
{
  $string->regexpExtract($regexp, $extractAll, 0, [RegexpParameter.CASE_SENSITIVE]);
}

function <<PCT.function>> {doc.doc = 'Returns the substring that matches a regular expression within a string. If extractAll is true, then it returns an array that contains all substrings that match a regular expression within a string. Group number specifies which group to extract. Groups are specified by using parentheses in the regular expression. The group number defaults to 0. By default, it does case-sensitive matching and single-line mode, and POSIX wildcard character . does not match \n newline characters. The platform supports the full POSIX ERE (Extended Regular Expression) syntax.'}
  meta::pure::functions::string::regexpExtract(string:String[1], regexp:String[1], extractAll:Boolean[1], groupNumber:Integer[1]):String[*]
{
  $string->regexpExtract($regexp, $extractAll, $groupNumber, [RegexpParameter.CASE_SENSITIVE]);
}

function <<PCT.function>> {doc.doc = 'Returns the substring that matches a regular expression within a string. If extractAll is true, then it returns an array that contains all substrings that match a regular expression within a string. Group number specifies which group to extract. Groups are specified by using parentheses in the regular expression. The group number defaults to 0. By default, it does case-sensitive matching and single-line mode, and POSIX wildcard character . does not match \n newline characters. The platform supports the full POSIX ERE (Extended Regular Expression) syntax.'}
  meta::pure::functions::string::regexpExtract(string:String[1], regexp:String[1], extractAll:Boolean[1], regexpParameters:RegexpParameter[1..*]):String[*]
{
  $string->regexpExtract($regexp, $extractAll, 0, $regexpParameters);
}

native function <<PCT.function>> {doc.doc = 'Returns the substring that matches a regular expression within a string. If extractAll is true, then it returns an array that contains all substrings that match a regular expression within a string. Group number specifies which group to extract. Groups are specified by using parentheses in the regular expression. The group number defaults to 0. By default, it does case-sensitive matching and single-line mode, and POSIX wildcard character . does not match \n newline characters. The platform supports the full POSIX ERE (Extended Regular Expression) syntax.'}
  meta::pure::functions::string::regexpExtract(string:String[1], regexp:String[1], extractAll:Boolean[1], groupNumber:Integer[1], regexpParameters:RegexpParameter[1..*]):String[*];

function <<PCT.test>> meta::pure::functions::string::tests::regexpExtract::testRegexpExtract<Z|y>(f:Function<{Function<{->Z[y]}>[1]->Z[y]}>[1]):Boolean[1]
{
  assertEquals('ab', $f->eval(|'abc'->regexpExtract('([a-z])(b)', false, 0)));
  assertEquals('a', $f->eval(|'abc'->regexpExtract('([a-z])(b)', false, 1)));
  assertEquals('b', $f->eval(|'abc'->regexpExtract('([a-z])(b)', false, 2)));
}

function <<PCT.test>> meta::pure::functions::string::tests::regexpExtract::testRegexpExtractAll<Z|y>(f:Function<{Function<{->Z[y]}>[1]->Z[y]}>[1]):Boolean[1]
{
  assertEquals(['ab', 'cb', 'cb'], $f->eval(|'abcccbbacb'->regexpExtract('([a-z])(b)', true, 0)));
  assertEquals(['a', 'c', 'c'], $f->eval(|'abcccbbacb'->regexpExtract('([a-z])(b)', true, 1)));
}
