import meta::legend::compiler::match::*;

function meta::legend::compiler::match::generate(f:Function<Any>[*]):String[1]
{
   let generation = $f->sortBy(f|$f->elementToPath())
                      ->map(ff|$ff->generateCheck());

   '// ------------------------------------------------------------------------------------------------\n'+
   '// Please do not update the following code manually! Please check with the team when introducing\n'+
   '// new matchers as this might be complicated by modularization\n'+
   '// THIS CODE IS GENERATED BY A FUNCTION IN PURE - CONTACT THE CORE TEAM FOR MORE DETAILS\n'+
   '//-------------------------------------------------------------------------------------------------\n\n'+
   'private static Map<String, MutableSet<String>> buildTaxoMap()\n'+
   '{\n'+
   '     Map<String, MutableSet<String>> map = Maps.mutable.empty();\n'+
         $generation.taxo->removeDuplicates({a,b|$a.type == $b.type && $a.covariant == $b.covariant})
                   ->map(x|if($x.covariant,
                                            |'     map.put("' + varName($x) + '", Sets.mutable.with('+$x.type->concatenate($x.type->_findAllSpecializations())->map(x|'"'+$x.name->toOne()+'"')->joinStrings(',')+'))',
                                            |'     map.put("' + varName($x) + '", Sets.mutable.with('+$x.type->_getAllTypeGeneralisations()->map(x|'"'+$x.name->toOne()+'"')->joinStrings(',')+'))'
                                       )
                                    )->joinStrings(';\n')+';\n' +

   '     return map;\n'+
   '}\n'+
   'private MutableMap<String, Dispatch> buildDispatch()\n'+
   '{\n'+
   '     CompileContext context = this.pureModel.getContext();'+
   '\n'+
   '     MutableMap<String, Dispatch> map = Maps.mutable.empty();\n'+
   '     registerUnknown(map);\n'+
         $generation.checkString->map(x|'     '+$x)->joinStrings(';\n') + ';\n' +
   '     ListIterate.flatCollect(context.getCompilerExtensions().getExtraFunctionHandlerDispatchBuilderInfoCollectors(), collector -> collector.valueOf(this)).forEach(info -> map.put(info.functionName, info.dispatch));\n'+
   '     return map;\n'+
   '}\n\n'+
   '// ------------------------------------------------------------------------------------------------\n'+
   '// Please do not update the following code manually! Please check with the team when introducing\n'+
   '// new matchers as this might be complicated by modularization\n'+
   '// THIS CODE IS GENERATED BY A FUNCTION IN PURE - CONTACT THE CORE TEAM FOR MORE DETAILS\n'+
   '//-------------------------------------------------------------------------------------------------\n';
}

function <<access.private>> meta::legend::compiler::match::varName(t:TypeTaxo[1]):String[1]
{
  if ($t.covariant,|'cov_',|'contra_') +
  if($t.type->instanceOf(PackageableElement),
    |if($t.type->cast(@PackageableElement).package->isEmpty(),|'',|$t.type->cast(@PackageableElement).package.name->toOne()+'_'),
    |''
  ) +
  $t.type.name->toOne();
}

function <<access.private>> meta::legend::compiler::match::generateCheck(f:Function<Any>[1]):CheckResult[1]
{
   let fCheck = $f->functionType()->generateOneCheck('ps', true);
   ^CheckResult
   (
      checkString='map.put("'+$f->elementToPath()+'", (List<ValueSpecification> ps) -> '+$fCheck.checkString+')',
      taxo = $fCheck.taxo
   );
}

function <<access.private>> meta::legend::compiler::match::generateOneCheck(ftype : FunctionType[1], param:String[1], firstCall:Boolean[1]):CheckResult[1]
{
   let parameters = $ftype.parameters->evaluateAndDeactivate();

   let val = ^CheckResult(checkString = if($parameters->isEmpty(),|$param+'.isEmpty()', |$param+'.size() == '+$parameters->size()->toString()));

   let res = $val->concatenate(
      $parameters->map(
         p| let typeCheck = $p.genericType->checkType($parameters->indexOf($p), $param, $firstCall);
            let str = $p.multiplicity->checkMultiplicity($parameters->indexOf($p), $param)->concatenate($typeCheck.checkString);
            if ($str->isEmpty(),
              |[],
              |^CheckResult
               (
                  checkString = $str->joinStrings(' && '), // first time parameter check is covariant subsequent ones are not.
                  taxo = $typeCheck.taxo
               )
            );
      )
   );
   ^CheckResult
   (
      checkString = $res.checkString->joinStrings(' && '),
      taxo = $res.taxo
   );
}

function <<access.private>> meta::legend::compiler::match::checkMultiplicity(m:Multiplicity[1], offset:Integer[1], param:String[1]):String[0..1]
{
   checkMultiplicity($m, $param+'.get('+$offset->toString()+')._multiplicity()');
}

function <<access.private>> meta::legend::compiler::match::checkMultiplicity(m:Multiplicity[1], str:String[1]):String[0..1]
{
   if ($m.lowerBound.value == 1 && $m.upperBound.value == 1,
       |'isOne('+$str+')',
       |if ($m.lowerBound.value == 0 && $m.upperBound.value == 1,
            | 'matchZeroOne('+$str+')',
            | if ($m.lowerBound.value == 1,
                  |'matchOneMany('+$str+')',
                  |[]
              )
        )
    );
}


Class meta::legend::compiler::match::CheckResult
{
  checkString : String[1];
  taxo : TypeTaxo[*];
}

Class meta::legend::compiler::match::TypeTaxo
{
  type : Type[1];
  covariant : Boolean[1];
}

function <<access.private>> meta::legend::compiler::match::checkType(m:GenericType[1], offset:Integer[1], param:String[1], b:Boolean[1]):CheckResult[0..1]
{
   checkType($m, $param+'.get('+$offset->toString()+')._genericType()', $b);
}

function <<access.private>> meta::legend::compiler::match::checkType(m:GenericType[1], str:String[1], covariant:Boolean[1]):CheckResult[0..1]
{
   [
      pair(|$m.rawType->isEmpty() || $m.rawType == Enumeration || $m.rawType == Enum, |[]),
      pair(|$covariant && $m.rawType == Any, |[]),
      pair(|!$covariant && $m.rawType == Nil, |[]),
      pair(|$m.rawType == meta::pure::metamodel::function::Function, |let fType = $m.typeArguments->at(0).rawType->cast(@FunctionType)->toOne();
                                                                      let fReturnType = checkType($fType.returnType, 'ft._returnType()', true);
                                                                      let checkParams = $fType->generateOneCheck('nps', false);
                                                                      ^CheckResult
                                                                      (
                                                                        checkString = '('+printCheckType($str, 'Nil') + ' || check(funcType('+$str+'), (FunctionType ft) ->'+ checkMultiplicity($fType.returnMultiplicity,'ft._returnMultiplicity()')
                                                                                          ->concatenate($fReturnType.checkString)
                                                                                          ->concatenate('check(ft._parameters().toList(), (List<? extends VariableExpression> nps) -> ' + $checkParams.checkString)
                                                                                          ->joinStrings(' && ') + ')))',
                                                                        taxo = $fReturnType.taxo->concatenate($checkParams.taxo)
                                                                      );
          ),
      pair(|$covariant && $m.rawType->isNotEmpty(), |let type = $m.rawType->toOne();
                                                     let typeTaxo = ^TypeTaxo(type=$type, covariant=true);
                                                     ^CheckResult
                                                     (
                                                        checkString = printCheckTypeSet($str, 'taxoMap.get("'+varName($typeTaxo)+'")'),
                                                        taxo = $typeTaxo
                                                     );
          ),
      pair(|!$covariant && $m.rawType->isNotEmpty(), |let type = $m.rawType->toOne();
                                                      let typeTaxo = ^TypeTaxo(type=$type, covariant=false);
                                                      ^CheckResult
                                                      (
                                                         checkString = printCheckTypeSet($str , 'taxoMap.get("'+varName($typeTaxo)+'")'),
                                                         taxo = $typeTaxo
                                                      );
          )
   ]->filter(a|$a.first->eval())->first().second->toOne()->eval();
}


function <<access.private>> meta::legend::compiler::match::printCheckType(s:String[1], s2:String[1]):String[1]
{
   '"'+$s2+'".equals('+$s+'._rawType()._name())'
}

function <<access.private>> meta::legend::compiler::match::printCheckTypeSet(s:String[1], s2:String[1]):String[1]
{
   $s2+'.contains('+$s+'._rawType()._name())'
}

function <<access.private>> meta::legend::compiler::match::_getAllTypeGeneralisations(c : Type[1]) : Type[*]
{
      getAllTypeGeneralisations($c)->filter(x|!$x->elementToPath()->contains('::test'));
}

function <<access.private>> meta::legend::compiler::match::_findAllSpecializations(c : Type[1]) : Type[*]
{
      _findAllSpecializationsR($c)->filter(x|!$x->elementToPath()->contains('::test'))->add(Nil);
}

function <<access.private>> meta::legend::compiler::match::_findAllSpecializationsR(c : Type[1]) : Type[*]
{
      let scs = $c.specializations.specific;
      $scs->concatenate($scs->map(s |$s->_findAllSpecializationsR()))->removeDuplicates();
}
