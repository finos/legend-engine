// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Press F9 to execute the 'go' function...
// Press F10 to run the full test suite

import meta::json::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::valueSpecification::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::toPureGrammar::*;
import meta::pure::extension::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::mapping::*;
import meta::pure::mapping::modelToModel::test::simple::*;
import meta::pure::mapping::modelToModel::test::shared::dest::*;
import meta::pure::mapping::modelToModel::test::shared::src::*;
import meta::pure::router::preeval::*;
import meta::pure::router::preeval::tests::*;
import meta::core::runtime::*;
Class meta::pure::router::preeval::tests::Person
{
  firstName : String[1];
  lastName : String[1];
  otherNames : String[*];

  name(){$this.firstName+' '+$this.lastName}:String[1];
  nameWithTitle(title:String[1]){$title+' '+$this.firstName+' '+$this.lastName}:String[1];
  nameWithPrefixAndSuffix(prefix:String[0..1], suffixes:String[*])
  {
    if($prefix->isEmpty(),
        | if($suffixes->isEmpty(),
            | $this.firstName + ' ' + $this.lastName,
            | $this.firstName + ' ' + $this.lastName + ', ' + $suffixes->joinStrings(', ')),
        | if($suffixes->isEmpty(),
            | $prefix->toOne() + ' ' + $this.firstName + ' ' + $this.lastName,
            | $prefix->toOne() + ' ' + $this.firstName + ' ' + $this.lastName + ', ' + $suffixes->joinStrings(', ')))
  }:String[1];

  fullName(lastNameFirst:Boolean[1])
  {
      if($lastNameFirst, | $this.lastName + ', ' + $this.firstName, | $this.firstName + ' ' + $this.lastName)
  }:String[1];
  extraInformation : String[0..1];
  manager : meta::pure::router::preeval::tests::Person[0..1];
  age : Integer[0..1];
  constant() { 'constant' } : String[1];
  nickName : String[0..1];
  activeEmployment: Boolean[0..1];
}

Class meta::pure::router::preeval::tests::FinancialInstrument
{
  id : Integer[1];
  price : Decimal[1];
}

Class <<typemodifiers.abstract>> meta::pure::router::preeval::tests::BaseAccount
{
  id: Integer[1];
  accountId(){
    $this.id
  }:Integer[1];
}

Class <<temporal.processingtemporal>> meta::pure::router::preeval::tests::Position
{
  account:BaseAccount[1];
  id: Integer[1];
  quantity: Float[1];
}

Class <<temporal.businesstemporal>> meta::pure::router::preeval::tests::BaseOrganizationalEntity
{
  name: String[1];
  id: Integer[1];
}

Class <<temporal.businesstemporal>> meta::pure::router::preeval::tests::OrganizationalEntity extends BaseOrganizationalEntity
{
  isActive: Boolean[1];
  parent: OrganizationalEntity[1];
  parentAtDate(date:Date[1])
  {
    $this.parent($date);
  }:OrganizationalEntity[1];
  ceo: meta::pure::router::preeval::tests::Person[1];

  latestPositions()
  {
    $this.positions(now());
  }:Position[*];
}

Association meta::pure::router::preeval::tests::PositionClient
{
  positions:Position[*];
  client:OrganizationalEntity[1];
}

Class <<access.private>> meta::pure::router::preeval::tests::ClassA
{
  myPropertyB : meta::pure::router::preeval::tests::ClassB[*];
}

Class <<access.private>> meta::pure::router::preeval::tests::ClassB
{
  myLeafProperty : String[1];
}


function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting1():Boolean[1]
{
  let input = {| let x = 'hello' + ' world'; $x + (' ' + (5->toString()));};

  let expected = {| 'hello world 5';};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting2():Boolean[1]
{
  let input = {| let x = today()->adjust(1, DurationUnit.DAYS); let y = %2017-01-01->adjust(1, DurationUnit.DAYS); };

  let expected = {| let x = today()->adjust(1, DurationUnit.DAYS); %2017-01-02; };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting2b():Boolean[1]
{
  let input = {|
      let a = mostRecentDayOfWeek(DayOfWeek.Monday);
      let b = previousDayOfWeek(DayOfWeek.Monday)->adjust(2, DurationUnit.DAYS);

      true;
    };

  let expected = {|
      let a = today()->mostRecentDayOfWeek(DayOfWeek.Monday);
      let b = today()->previousDayOfWeek(DayOfWeek.Monday)->adjust(2, DurationUnit.DAYS);

      true;
    };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting3():Boolean[1]
{
  let input = {| let y = 1; $y + (6 + 10);};

  let expected = {| 17;};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting4():Boolean[1]
{
  let value = 'hello world';

  let input = {| let y = $value->substring(0, 5); };

  let expected = {| 'hello'};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting5():Boolean[1]
{
  let input = {| currentUserId() + '_user' ;};

  let expected = $input;

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting6():Boolean[1]
{
  let value = 10;

  let input = {| range(5)->map(x|$x+$value); };

  let expected = {| [10, 11, 12,13,14]};

  assertRoundTrip($input, $expected);
}


function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting7():Boolean[1]
{
  let input = {| %2018-01-02->toString()->myExpandableFunc(5) ;};

  let expected = {| '2018-01-02|2018-01-02|2018-01-02|2018-01-02|2018-01-02'};

  assertRoundTrip($input, $expected);
}

function <<test.ToFix>> meta::pure::router::preeval::tests::testPrerouting8():Boolean[1]
{
  let input = {| today()->toString()->myNonExpandableMultiExpressionFunc(5) ;};

  let expected = $input;

  assertRoundTrip($input, $expected);
}

function <<test.Test>>  meta::pure::router::preeval::tests::testPrerouting9():Boolean[1]
{
  let input = {| {x:String[1]| $x + 'hello'} ;};

  let expected = $input;

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting10():Boolean[1]
{
  let input = {| range(3)->map(x|$x->toString());};

  let expected = {| ['0','1','2']};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting11():Boolean[1]
{
  let input = {| range(3)->map(x| $x->map(index|$index->toString()));};

  let expected = {| ['0','1','2']};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting12():Boolean[1]
{
  let input = {| range(3)->map(x| $x->toString()->map(index|$index));};

  let expected = {| ['0','1','2']};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting13():Boolean[1]
{
  let input = {| range(4)->map(x| [1,2,3,4,5]->take($x)->map(index|$index));};

  let expected = {| [1,1,2,1,2,3]};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting14():Boolean[1]
{
  let input = {| range(3)->map(x| [1,2,3,4,5]->take($x + 1)->map(index|$index));};

  let expected = {| [1,1,2,1,2,3]};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting15():Boolean[1]
{
  // ->cast(@Integer) added to help with compile mode java generation, this should not be needed but java compiler fails on java generated code
  let input = {| range(3)->map(x| range(5)->map(k|$k+1)->cast(@Integer)->take($x + 1)->map(index|$index->cast(@Integer)));};

  let expected = {| [1,1,2,1,2,3]};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting16():Boolean[1]
{
  let input = {| range(3)->map(x|$x+1)->map(index|'i' + $index->toString()) ;};

  let expected = {|['i1', 'i2', 'i3'] };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting17():Boolean[1]
{
  let c = 3;

  let input = {| range($c)->map(x|$x+1)->map(index|'i' + $index->toString()) ;};

  let expected = {|['i1', 'i2', 'i3'] };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting18():Boolean[1]
{
  let c = 3;

  let input = {| range($c)->map(x|$x+1)->map(index|('i' + $c->makeString()) + $index->toString()) ;};

  let expected = {|['i31', 'i32', 'i33'] };

  assertRoundTrip($input, $expected);
}


function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting19():Boolean[1]
{
  let input = {|['a']->fold({p,x|$x->concatenate(range(2)->map(index|$p)->joinStrings('|'))}, [])};

  let expected = {|['a|a']};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting20():Boolean[1]
{
  let input = {|['hello']->map(a|$a->f1())};

  let expected = {|'hello'};

  assertRoundTrip($input, $expected);
}

function <<access.private>> meta::pure::router::preeval::tests::f1(zzz : String[1]):String[1]
{
  $zzz->map(k|$zzz->substring(0,5));
}

function <<test.Test>>  {test.excludePlatform = 'Java compiled'} meta::pure::router::preeval::tests::testPrerouting20a():Boolean[1]
{
  let input = {|'hello'->map(x|$x->myFirst1())};

  let expected = {|'hello'};

  assertRoundTrip($input, $expected);
}

function meta::pure::router::preeval::tests::myFirst1<T>(theFirstSet:T[*]):T[0..1]
{
  myFirst2($theFirstSet);
}

function meta::pure::router::preeval::tests::myFirst2<T>(theSecondSet:T[*]):T[0..1]
{
  $theSecondSet->first();
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting21():Boolean[1]
{
  let input = {|['a']->fold({p,x|$x->concatenate(myExpandableFunc2($p, 3))}, [])};

  let expected = {|'a|a|a' };

  assertRoundTrip($input, $expected);
}

function <<access.private>> meta::pure::router::preeval::tests::myExpandableFunc2(val : String[1], count : Integer[1]):String[*]
{
  range(0, $count, 1)->map(index|$val)->joinStrings('|');
// $val->myFakeJoin('|');
}


function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_mapOnInstanceValuesExpanded():Boolean[1]
{
  let c = 3;

  let input = {| range(1, $c+1, 1)->map(index|$index->toString() + currentUserId()->toString()) ;};

  let expected = {|[
      ('1' + meta::core::runtime::currentUserId()->toString()),
      ('2' + meta::core::runtime::currentUserId()->toString()),
      ('3' + meta::core::runtime::currentUserId()->toString())
      ] };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_foldOnInstanceValuesExpanded():Boolean[1]
{
  let c = 2;

  let input = {|
    range(1, $c+1, 1)->fold({index, r|
        $r + ($index->toString() + currentUserId() + ';');
      }, 'Values: ')
    };

  let expected = {|
    'Values: ' + '1' + meta::core::runtime::currentUserId() + ';' + '2' + meta::core::runtime::currentUserId() + ';'
  };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_foldOnInstanceValuesExpanded2():Boolean[1]
{
  let c = 2;

  let input = {|
    range(1, $c+1, 1)->fold({index, r|
        $r->concatenate(($index->toString() + currentUserId()));
      }, [])
    };

  let expected = {|
    [('1' + currentUserId()), ('2' + currentUserId())]
    ///[('1' + meta::core::runtime::currentUserId())]	        ->concatenate('2' + meta::core::runtime::currentUserId())
  };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_concatenateInstanceValuesExpanded_Basic():Boolean[1]
{
  let c = 2;

  let input = {|
    ['hello']->concatenate(currentUserId());
  };

  let expected = {|
    ['hello', currentUserId()];
  };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_concatenateInstanceValuesExpanded_Complex():Boolean[1]
{
  let x = 2;

  let input = {|
    let a = []->concatenate(currentUserId());
    let b = []->concatenate(['hello', currentUserId()]);
    let c = []->concatenate(['hello', currentUserId(), (currentUserId() + $x->toString())]);

    let d = currentUserId()->concatenate([]);
    let e = ['hello', currentUserId()]->concatenate([]);
    let f = ['hello', currentUserId(), (currentUserId() + $x->toString())]->concatenate([]);

    let g = currentUserId()->concatenate(currentUserId());
    let h = ['hello', currentUserId()]->concatenate(['hello', currentUserId()]);
    let i = ['hello', currentUserId(), (currentUserId() + $x->toString())]->concatenate(['hello', currentUserId(), (currentUserId() + $x->toString())]);

    let j = myCollectionFunc($x->toString())->concatenate(currentUserId());

    let k = {a:Integer[1], b:Integer[1]|$a->concatenate($b)};
    let l = {a:Integer[*], b:Integer[1]|$a->concatenate($b)};
    let m = {a:Integer[1], b:Integer[*]|$a->concatenate($b)};
    let n = {a:Integer[*], b:Integer[*]|$a->concatenate($b)};

    true;
    };

  let expected = {|
    let a = currentUserId();
    let b = ['hello', currentUserId()];
    let c = ['hello',meta::core::runtime::currentUserId(),(meta::core::runtime::currentUserId() + '2')];

    let d = currentUserId();
    let e = ['hello', currentUserId()];
    let f = ['hello',meta::core::runtime::currentUserId(),(meta::core::runtime::currentUserId() + '2')];

    let g = [meta::core::runtime::currentUserId(),meta::core::runtime::currentUserId()];
    let h = ['hello',meta::core::runtime::currentUserId(),'hello',meta::core::runtime::currentUserId()];
    let i = ['hello',meta::core::runtime::currentUserId(),(meta::core::runtime::currentUserId() + '2'),'hello',meta::core::runtime::currentUserId(),(meta::core::runtime::currentUserId() + '2')];

    let j= ['2', currentUserId()];

    let k = {a:Integer[1], b:Integer[1]|[$a,$b]};
    let l = {a:Integer[*], b:Integer[1]|$a->concatenate($b)};
    let m = {a:Integer[1], b:Integer[*]|$a->concatenate($b)};
    let n = {a:Integer[*], b:Integer[*]|$a->concatenate($b)};

    true;
    };

  assertRoundTrip($input, $expected);
}

function meta::pure::router::preeval::tests::myCollectionFunc<T|m>(values:T[m]):T[m]
{
  $values;
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting23a():Boolean[1]
{
  let input = {| if(false, | []->toOne(), | 'hello ' + 'world') ;};

  let expected = {| 'hello world' };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting23b():Boolean[1]
{
  let input = {| if(true, | 'hello ' + 'world', | []->toOne() ) ;};

  let expected = {| 'hello world' };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting24a():Boolean[1]
{
  let x = [];

  let input = {|
      $x->isEmpty() || ($x->at(0) == 'hello');
    };

  let expected = {| true };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting24b():Boolean[1]
{
  let x = [];

  let input = {|
    $x->isNotEmpty() && ($x->at(0) == 'hello');
  };

  let expected = {| false };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting24c():Boolean[1]
{
  let x = [];

  let input = {|
      (today() > %2018-01-01) && (1 == 1);
    };

  let expected = {| today() > %2018-01-01 };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting24d():Boolean[1]
{
  let x = [];

  let input = {|
      (today() > %2018-01-01) || (1 == 1);
    };

  let expected = {| true };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting24e():Boolean[1]
{
  let x = [];

  let input = {|
      (1 == 1) && (today() > %2018-01-01);
    };

  let expected = {| today() > %2018-01-01 };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting24f():Boolean[1]
{
  let x = [];

  let input = {|
      (1 == 1) || (today() > %2018-01-01);
    };

  let expected = {| true };

  assertRoundTrip($input, $expected);
}


function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting25a():Boolean[1]
{
  let input = {|meta::pure::router::preeval::tests::Person.all()
    ->project([
        col({p:meta::pure::router::preeval::tests::Person[1]|$p.firstName}, 'firstName'),
        col({p:meta::pure::router::preeval::tests::Person[1]|$p.lastName}, 'lastName'),
        col({p:meta::pure::router::preeval::tests::Person[1]|$p.age}, 'age'),
        col({p:meta::pure::router::preeval::tests::Person[1]|today()}, 'today')
      ])
    ->extend(^BasicColumnSpecification<meta::pure::tds::TDSRow>(name = 'ageString', func = {row:TDSRow[1]|$row.getInteger('age')->toString()}))}	 ;

  let expected = {| meta::pure::router::preeval::tests::Person.all()
    ->project([
        ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'firstName', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.firstName}),
        ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'lastName', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.lastName}),
        ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age}),
        ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'today', func = {p:meta::pure::router::preeval::tests::Person[1]|today()})
        ])
    ->extend(^BasicColumnSpecification<meta::pure::tds::TDSRow>(name = 'ageString', func = {row:TDSRow[1]|$row.getInteger('age')	->toString()}))};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting25b():Boolean[1]
{
  let input = {|meta::pure::router::preeval::tests::Person.all()
	  ->project([
       col({p:meta::pure::router::preeval::tests::Person[1]|$p.firstName + ('hello' + '_world')}, 'firstName'),
       col({p:meta::pure::router::preeval::tests::Person[1]|'world' + ' blue'}, 'const'),
       col({p:meta::pure::router::preeval::tests::Person[1]|$p.age}, 'age')
    ])
   ->extend(['e']->map(x|col({row:TDSRow[1]|$row.getInteger('ag' + $x)	->toString()}, 'ageString')))};

  let expected = {| meta::pure::router::preeval::tests::Person.all()
	  ->project([
       ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'firstName', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.firstName + 'hello_world'}),
       ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'const', func = {p:meta::pure::router::preeval::tests::Person[1]|'world blue'}),
       ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age})])
  	->extend(^BasicColumnSpecification<meta::pure::tds::TDSRow>(name = 'ageString', func = {row:TDSRow[1]|$row.getInteger('age')->toString()}))};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting25c():Boolean[1]
{
  let blue = 'blue';

  let cols = [
              col({p:meta::pure::router::preeval::tests::Person[1]|$p.firstName + ('hello' + '_world')}, 'firstName'),
              col({p:meta::pure::router::preeval::tests::Person[1]|'world' + ' ' + $blue}, 'const'),
              col({p:meta::pure::router::preeval::tests::Person[1]|$p.age}, 'age')
             ];

  let input = {|meta::pure::router::preeval::tests::Person.all()
	    ->project($cols)
      ->extend(['e']->map(x|col({row:TDSRow[1]|$row.getInteger('ag' + $x)	->toString()}, 'ageString')))
    };

  let expected = {| meta::pure::router::preeval::tests::Person.all()
    ->project([
        ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'firstName', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.firstName + 'hello_world'}),
        ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'const', func = {p:meta::pure::router::preeval::tests::Person[1]|'world blue'}),
        ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age})])
    ->extend(^BasicColumnSpecification<meta::pure::tds::TDSRow>(name = 'ageString', func = {row:TDSRow[1]|$row.getInteger('age')->toString()}))};

  assertRoundTrip($input, $expected);
}



function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting26():Boolean[1]
{
  let input = {|
      pair('hello', today());
    };

  let expected = {| ^Pair<String,StrictDate>(first='hello', second = today()) };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting27a():Boolean[1]
{
  let input = {|
      [1,2,3]->map(v| ^Pair<String,Integer>(first = 'hello', second = $v));
    };

  let expected = {| [^Pair<String,Integer>(first = 'hello', second = 1),^Pair<String,Integer>(first = 'hello', second = 2),^Pair<String,Integer>(first = 'hello', second = 3)] };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting27b():Boolean[1]
{
  let input = {|
                [1,2,3]->map(v| pair('hello', $v));
              };

  let expected = {| [^Pair<String,Integer>(first = 'hello', second = 1),^Pair<String,Integer>(first = 'hello', second = 2),^Pair<String,Integer>(first = 'hello', second = 3)] };

  assertRoundTrip($input, $expected);
}


// function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting27c():Boolean[1]
// {
//     let input = {|
//        [today(),today(),today()]->map(v| pair('hello', $v));
//       };

//     let expected = {| [today(),today(),today()]->map(v|^Pair<String,StrictDate>(first = 'hello', second = $v)) };

//     assertRoundTrip($input, $expected);
// }

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting28():Boolean[1]
{
  let input = {|
      [1,2,3]->map(v| $v->map(x|pair('hello' + '*' + $x->makeString(), $v)));
    };

  let expected = {| [^Pair<String,Integer>(first = 'hello*1', second = 1),^Pair<String,Integer>(first = 'hello*2', second = 2),^Pair<String,Integer>(first = 'hello*3', second = 3)] };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting29a():Boolean[1]
{
  let input = {r:String[1]| ['a', 'b', 'c']->map(v| $r + ('_' + $v))};

  let expected = {r:String[1]|[ ($r + '_a'),($r + '_b'),($r + '_c')]};

  assertRoundTrip($input, $expected);
}

function <<access.private>> meta::pure::router::preeval::tests::myPair<U,V>(firstVal : String[1], secondVal : StrictDate[1]):Pair<String,StrictDate>[1]
{
  ^Pair<String,StrictDate>(first = $firstVal, second=$secondVal);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting29b():Boolean[1]
{
  let input = {| range(3)->map(index|today()) ;};

  let expected = {|[today(),today(),today()] };

  assertRoundTrip($input, $expected);
}

function <<test.ToFix>> meta::pure::router::preeval::tests::testPrerouting29c():Boolean[1]
{
  let input = {| myNonFullyExpandableDateFunc('a', 5) ;};

  let expected = {|[
        ('a' + (today()->toString())),
        ('a' + (today()->toString())),
        ('a' + (today()->toString())),
        ('a' + (today()->toString())),
        ('a' + (today()->toString()))
      ]->joinStrings('|');
    };

  assertRoundTrip($input, $expected);
}

function <<access.private>> meta::pure::router::preeval::tests::myExpandableFunc(val : String[1], count : Integer[1]):String[1]
{
  range($count)->map(index|$val)->joinStrings('|');
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting30():Boolean[1]
{
  let input = {|
    range(3)->map(index|[$index, today()]);
    };

  let expected = {|
    [0,today(), 1,today(), 2,today()]
    };

  assertRoundTrip($input, $expected);
}

function <<test.ToFix>> meta::pure::router::preeval::tests::testPrerouting31a():Boolean[1]
{
  let input = {|
            range(2)->map(a|^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age_' + $a->makeString(), func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age->toOne() + ($a * 10)}))
    };

  let expected = {|[^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age_0', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age->toOne() + 0}),^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age_1', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age->toOne() + 10})] };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting31b():Boolean[1]
{
  let input = {| meta::pure::router::preeval::tests::Person.all()
                ->project(
                      range(2)->map(a|
                      [col({p:meta::pure::router::preeval::tests::Person[1]|$p.age->toOne() + ($a * 10)}, 'age_' + makeString($a*10)),col({p:meta::pure::router::preeval::tests::Person[1]|$p.age->toOne() + (($a*10) + 1)}, 'age_' + makeString(($a*10) + 1))]
                      )
                    )
              };

  let expected = {|meta::pure::router::preeval::tests::Person.all()
                ->project([
                    ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age_0', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age->toOne() + 0}),
                    ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age_1', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age->toOne() + 1}),
                    ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age_10', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age->toOne() + 10}),
                    ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age_11', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age->toOne() + 11})
                    ])
                };

  assertRoundTrip($input, $expected);
}

function <<test.ToFix>> meta::pure::router::preeval::tests::testPrerouting32a():Boolean[1]
{
  let input = {| ['e']->map(x|col({row:TDSRow[1]|$row.getInteger('ag' + $x)->toString()}, 'ageString'));};

  let expected = {|^BasicColumnSpecification<meta::pure::tds::TDSRow>(name = 'ageString', func = {row:TDSRow[1]|$row.getInteger('age')->toString()}) };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting32b():Boolean[1]
{
  let input = {| let x = 'e'; col({row:TDSRow[1]|$row.getInteger('ag' + $x)->toString()}, 'ageString');};

  let expected = {|^BasicColumnSpecification<meta::pure::tds::TDSRow>(name = 'ageString', func = {row:TDSRow[1]|$row.getInteger('age')->toString()}); };

  assertRoundTrip($input, $expected);
}



function <<access.private>> meta::pure::router::preeval::tests::myFakeJoin(vals : String[*], char : String[1]):String[1]
{
  let x = 'hello';
  $vals->drop(1)->fold({x,n| $x + $char + $n}, $vals->at(0));
  //$vals->at(0);
}

function <<access.private>> meta::pure::router::preeval::tests::myComplexExpandableFunc(vals : String[*]):String[1]
{
  $vals->map(x|$x->myExpandableFunc(1))->joinStrings('hello');
}



function meta::pure::router::preeval::tests::myNonExpandableMultiExpressionFunc(val : String[1], count : Integer[1]):String[1]
{
  let x = range($count);
  $x->map(index|$val)->joinStrings('|');
}

function <<access.private>> meta::pure::router::preeval::tests::myNonFullyExpandableDateFunc(val : String[1], count : Integer[1]):String[1]
{
  range($count)->map(index|$val + today()->toString())->joinStrings('|');
}



function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting33():Boolean[1]
{
  let input = {|
      meta::pure::router::preeval::tests::Person.all()
      ->project([
            col({p:meta::pure::router::preeval::tests::Person[1]|$p.firstName}, 'firstName'),
            col({p:meta::pure::router::preeval::tests::Person[1]|$p.lastName}, 'lastName'),
            col({p:meta::pure::router::preeval::tests::Person[1]|$p.age}, 'age'),
            col({p:meta::pure::router::preeval::tests::Person[1]|today()}, 'today')
        ])
        ->filterToStringColumns()
    };

  let expected = {|
        meta::pure::router::preeval::tests::Person.all()
          ->project([
              ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'firstName', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.firstName}),
              ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'lastName', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.lastName}),
              ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age}),
              ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'today', func = {p:meta::pure::router::preeval::tests::Person[1]|today()})
            ])
            ->restrict(['firstName','lastName'])
        };

  assertRoundTrip($input, $expected);
}

function <<access.private>> meta::pure::router::preeval::tests::filterToStringColumns(input : TabularDataSet[1]):TabularDataSet[1]
{
  $input->restrict($input.columns->filter(c|$c.type == String).name);
}

function <<access.private>> meta::pure::router::preeval::tests::extendColumns(input : TabularDataSet[1], cols : String[*]):TabularDataSet[1]
{
  $input->extend($input.columns->filter(c|$c.name->in($cols))->sortBy(c|$cols->indexOf($c.name))->map(c|
    if($c.type == String,
        | col({row:TDSRow[1]|$row.getString($c.name)}, $c.name + '_ext'),
        | if($c.type == Integer,
          | col({row:TDSRow[1]|$row.getInteger($c.name)}, $c.name + '_ext'),
          | col({row:TDSRow[1]|$row.getDate($c.name)}, $c.name + '_ext')
          )
        )
    ));
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting34():Boolean[1]
{
  let input = {|
        let businessDate = now();
        let processingDate = today()->adjust(-1, DurationUnit.DAYS);

        meta::pure::router::preeval::tests::Position.all($processingDate)
          ->project([
              x | $x.quantity,
              x | $x.client($businessDate).name],
              ['Quantity',
              'Client/Name']
          )
          ->extendColumns('Quantity');
    };

  let expected = {|
        let businessDate = now();
        let processingDate = today()->adjust(-1, DurationUnit.DAYS);

        meta::pure::router::preeval::tests::Position
          ->getAll($processingDate)
          ->project([{x|$x.quantity},{x|$x.client($businessDate).name}], ['Quantity','Client/Name'])
          ->extend(^BasicColumnSpecification<meta::pure::tds::TDSRow>(name = 'Quantity_ext', func = {row:TDSRow[1]|$row.getDate('Quantity')}));
    };

    assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting35():Boolean[1]
{
  let input = {|
        let x = 'world';

        {|('hello' + ' ') + $x}->eval();
    };

  let expected = {|
        'hello world';
    };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_parameterAssignedToVariable():Boolean[1]
{
  let input = {item:Pair<String,String>[1]|
      let other = $item;
      $other.first->isNotEmpty();
    };

  let expected = {item:Pair<String,String>[1]|
      $item.first->isNotEmpty();
    };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting36():Boolean[1]
{
  let input = {a:meta::pure::router::preeval::tests::ClassA[1]|
      $a.myPropertyB.myLeafProperty->map(x|now())->map(d|$d->adjust(-1, DurationUnit.DAYS))
    };

  assertRoundTrip($input, $input);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting37():Boolean[1]
{
  let input = {x:Integer[*]|
        $x->otherFunc2(y|$y+1)
    };

  let expected = {x:Integer[*]|
      $x->map({y|$y + 1})
    };

  assertRoundTrip($input, $expected);
}

function <<access.private>> meta::pure::router::preeval::tests::otherFunc2(x : Integer[*], l : FunctionDefinition<{Integer[1]->Integer[1]}>[1]):Integer[*]
{
  $x->map($l);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting38():Boolean[1]
{
  let input = {|
        let x = myPair('hello', 'world');
        let y = myPair(1, $x.first + ' ' + $x.second);
    };

  let expected = {|
      ^Pair<Integer,String>(first = 1, second = 'hello world');
    };

  assertRoundTrip($input, $expected);
}

function <<access.private>> meta::pure::router::preeval::tests::myPair<X,Y>(v1 : X[1], v2 : Y[1]) : Pair<X,Y>[1]
{
   pair($v1, $v2);
}

function <<access.private>> meta::pure::router::preeval::tests::myPair2<U,V>(v1 : U[1], v2 : V[1]) : Pair<U,V>[1]
{
   pair($v1, $v2);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting39():Boolean[1]
{
  let input = {|
        let x = 123;
        $x->cast(@Integer);
    };

  let expected = {|
    123
    };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting40a():Boolean[1]
{
  let input = {|
        let x = 123;
        $x->toOne()->myToOne();
    };

  let expected = {|
        123;
    };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting40b():Boolean[1]
{
  let input = {|
        let x = today();
        $x->toOne()->myToOne();
    };

  let expected = {|
        let x = today();
        $x;
    };

  assertRoundTrip($input, $expected);
}


function <<access.private>> meta::pure::router::preeval::tests::myToOne<T>(x : T[1]) : T[1]
{
  $x->toOne();
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_PropertyValue():Boolean[1]
{
  let prop = meta::pure::router::preeval::tests::Person.properties->at(0);
  let name = $prop.name;

  let input = {| $prop.name;};

  let expected = {| $name};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_OptionalLimit1():Boolean[1]
{
  let limit = 5;

  let input = {|
      meta::pure::router::preeval::tests::Person.all()
        ->project([
          col({p:meta::pure::router::preeval::tests::Person[1]|$p.firstName}, 'firstName')
        ])
        ->meta::pure::router::preeval::tests::optionalLimit($limit)
      };

  let expected = {|
      meta::pure::router::preeval::tests::Person.all()
       ->project([
          ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'firstName', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.firstName})
       ])
       ->limit(5);
      };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_OptionalLimit2():Boolean[1]
{
  let limit = [];

  let input = {|
  meta::pure::router::preeval::tests::Person.all()
      ->project([
        col({p:meta::pure::router::preeval::tests::Person[1]|$p.firstName}, 'firstName')
      ])
      ->meta::pure::router::preeval::tests::optionalLimit($limit)
    };

  let expected = {|
    meta::pure::router::preeval::tests::Person.all()
      ->project([
        ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'firstName', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.firstName})
      ]);
    };

  assertRoundTrip($input, $expected);
}

function meta::pure::router::preeval::tests::optionalLimit(t: TabularDataSet[1], limit:Integer[0..1]) : TabularDataSet[1]
{
  if($limit->isEmpty() || ($limit->toOne()<=0), | $t, | $t->limit($limit));
}


function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_mappedTdsAgg():Boolean[1]
{
  let v = [pair('name', '6')];

  let input = {|meta::pure::router::preeval::tests::Person.all()
                ->project([
                  col({p:meta::pure::router::preeval::tests::Person[1]|$p.age}, 'age')
                ])
                ->groupBy([], $v->map(pv|agg('sumAgg_' + $pv.first->toString(), {row:TDSRow[1]|if($row.getInteger('age')->toString() == $pv.second, | 1, | 0)}, y|$y->sum())))
              };

  let expected = {| meta::pure::router::preeval::tests::Person.all()
                    ->project(^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age}))
                    ->groupBy([], agg('sumAgg_name', {row:TDSRow[1]|if($row.getInteger('age')->toString() == '6', |1, |0)}, {y|$y->sum()}))
                  };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_mappedModelAgg():Boolean[1]
{
  let v = [pair('name', '6')];

  let input = {|meta::pure::router::preeval::tests::Person.all()
                  ->groupBy([],
                    $v->map(pv|agg({p:meta::pure::router::preeval::tests::Person[1]|if($p.age->toOne()->toString() == $pv.second, | 1, | 0)}, y|$y->sum())),
                    $v->map(pv|'sumAgg_' + $pv.first)
                  )
              };

  let expected = {|meta::pure::router::preeval::tests::Person.all()
	                  ->groupBy([], agg({p:meta::pure::router::preeval::tests::Person[1]|if($p.age->toOne()->toString() == '6', |1, |0)}, {y|$y->sum()}), 'sumAgg_name')
  };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_constantInAgg():Boolean[1]
{
  let lambda = {|
    let businessDate = %2023-01-01;
    let x = 'a';
    meta::pure::router::preeval::tests::Position.all($businessDate)->groupBy(
      [],
      agg(x|$x.client($businessDate).name + 'b', y|$y->count()),
      'ID Count'
    );
  };

  //we re-write the lambda to inline an AggregateValue with businessDate variable
  let aggregateValue = ^meta::pure::functions::collection::AggregateValue<meta::pure::router::preeval::tests::Position, String, Integer>(mapFn={x:meta::pure::router::preeval::tests::Position[1] | $x.client(%2023-01-01).name + $x->toString()},aggregateFn={y:String[*] | $y->count()});

  let expressionSequence = $lambda.expressionSequence->evaluateAndDeactivate();
  let groupBy = $expressionSequence->at(2)->cast(@SimpleFunctionExpression);

  let mapFn = $aggregateValue.mapFn;
  let mapFnExpressionSequnce = $mapFn.expressionSequence->evaluateAndDeactivate()->cast(@SimpleFunctionExpression)->toOne();

  let plus = $mapFnExpressionSequnce.parametersValues->at(0)->cast(@InstanceValue);
  let plusParams = $plus.values;
  let plusLeft = $plusParams->at(0)->cast(@SimpleFunctionExpression);
  let client = $plusLeft.parametersValues->at(0)->cast(@SimpleFunctionExpression);
  let newClient = ^$client(parametersValues = [$client.parametersValues->at(0), ^VariableExpression(name='businessDate',genericType=^GenericType(rawType = StrictDate),multiplicity=PureOne)]);

  let newPlusLeft = ^$plusLeft(parametersValues = $newClient);
  let newPlus = ^$plus(values = [$newPlusLeft,$plus.values->at(1)]);

  let newAggregateValue = ^$aggregateValue(mapFn = ^$mapFn(expressionSequence = ^$mapFnExpressionSequnce(parametersValues = [$newPlus])));
  let newAggregateValueInstance = ^InstanceValue(genericType=^GenericType(rawType = meta::pure::functions::collection::AggregateValue),multiplicity=PureOne, values = $newAggregateValue);
  let newGroupBy = ^$groupBy(parametersValues = [$groupBy.parametersValues->at(0), $groupBy.parametersValues->at(1), $newAggregateValueInstance, $groupBy.parametersValues->at(3)]);
  let newLambda = ^$lambda(expressionSequence = [$expressionSequence->at(0), $expressionSequence->at(1), $newGroupBy]);


  let expected = {|
    meta::pure::router::preeval::tests::Position.all(%2023-01-01)->groupBy([], ^meta::pure::functions::collection::AggregateValue<meta::pure::router::preeval::tests::Position, String, Integer>(mapFn={x:meta::pure::router::preeval::tests::Position[1] | $x.client(%2023-01-01).name + $x->toString()},aggregateFn={y:String[*]|$y->count()}), ['ID Count'])
  };

    assertRoundTrip($newLambda, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testDecimalType():Boolean[1]
{
  let input = {|meta::pure::router::preeval::tests::FinancialInstrument.all()
                  ->project([
                              col(f:meta::pure::router::preeval::tests::FinancialInstrument[1]|$f.price, 'price'),
                              col(f:meta::pure::router::preeval::tests::FinancialInstrument[1]|parseDecimal('3.14D'), 'decimal_constant_col')
                  ])
              };

  let expected = {|meta::pure::router::preeval::tests::FinancialInstrument.all()
                  ->project([
                      ^BasicColumnSpecification<meta::pure::router::preeval::tests::FinancialInstrument>(name = 'price', func={f:meta::pure::router::preeval::tests::FinancialInstrument[1]| $f.price }),
                      ^BasicColumnSpecification<meta::pure::router::preeval::tests::FinancialInstrument>(name = 'decimal_constant_col', func={f:meta::pure::router::preeval::tests::FinancialInstrument[1]| 3.14})
                    ])
                  };

  assertRoundTrip($input,$expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testPrerouting_castEmptyCollection():Boolean[1]
{
  let input = {b:Integer[*]|$b->uniqueValueOnly()};

  let expected = {b:Integer[*]|if($b->distinct()->size() == 1, {|$b->max()}, {|[]})};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testEvalWithArgs1():Boolean[1]
{
  let input = {|
      {x:Integer[1]|$x+1}->eval(5);
    };

  let expected = {|6};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testEvalWithArgs2():Boolean[1]
{
  let input = {|{t:TabularDataSet[1]|$t->filter(r:TDSRow[1]|$r.getString('firstName') == 'firstName')}
                                       ->eval({|meta::pure::router::preeval::tests::Person.all()->project(col(p:meta::pure::router::preeval::tests::Person[1]|$p.firstName, 'firstName'))}->eval())};

  let expected = {|meta::pure::router::preeval::tests::Person.all()
                      ->project(^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'firstName', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.firstName}))
                      ->filter(r:TDSRow[1]|$r.getString('firstName') == 'firstName')
                  };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testEvalWithArgs3():Boolean[1]
{
  let input = {a:Integer[1]|{b:Integer[1]|$b+1}->eval($a)};

  let expected = {a:Integer[1]| $a+1 };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testProjectWithInferredParameterType():Boolean[1]
{
  let input = {|meta::pure::router::preeval::tests::myFunc888()};

  let expected = {| meta::pure::router::preeval::tests::Person.all()
    	->project([
        ^BasicColumnSpecification<meta::pure::router::preeval::tests::Person>(name = 'age', func = {p:meta::pure::router::preeval::tests::Person[1]|$p.age})
       ])
    };

  assertRoundTrip($input, $expected);
}

function meta::pure::router::preeval::tests::myFunc888() : TabularDataSet[1]
{
  meta::pure::router::preeval::tests::Person.all()
	   ->project([
         col({p:meta::pure::router::preeval::tests::Person[1]|$p.age}, 'age')
      ])
}




function <<test.Test>> meta::pure::router::preeval::tests::testPreroutingRemoveUnnecessaryStatements():Boolean[1]
{
  let input = {|
      range(5)->map(x|$x+1)->map(index|'i' + $index->toString());
      123;
      };

  let expected = {|
      123;
      };

  assertRoundTrip($input, $expected);
}


function meta::pure::router::preeval::tests::myStopFunction(b: Integer[1]) : Integer[1]
{
  $b+1;
}

function <<test.Test>> meta::pure::router::preeval::tests::testAdditionalStopFunction():Boolean[1]
{
  let input = {a:Integer[1]|myStopFunction($a)};

  let expected = {a:Integer[1]| $a+1 };

  assertRoundTrip($input, $expected);
  assertRoundTrip($input, $input, myStopFunction_Integer_1__Integer_1_, [], noDebug());
}

function <<test.Test>> meta::pure::router::preeval::tests::testFilterFalseSimplification():Boolean[1]
{
  let input = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01)->filter(p | false).id};

  let expected = {a:OrganizationalEntity[1]| []};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testFilterFalseSimplificationAll():Boolean[1]
{
  let input = {s:String[0..1]| OrganizationalEntity.all(%2023-01-01)->filter(c | 1 == 2)->project(c | $c.name, 'name')};

  let expected = {s:String[0..1]| OrganizationalEntity.all(%2023-01-01)->filter(c | false)->project(c | $c.name, 'name')};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testFilterFalseSimplification2():Boolean[1]
{
  let input = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01)->filter(p | 1 == 2).id};

  let expected = {o:OrganizationalEntity[1]| []};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testFilterFalseConstantSimplification():Boolean[1]
{
  let input = {o:OrganizationalEntity[1]| let bool = false; let date = %2023-01-01; $o.positions($date)->filter(p | $bool).id;};

  let expected = {o:OrganizationalEntity[1]| []};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testFilterFalseSimplificationReturnType():Boolean[1]
{
  let input = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01)->filter(p | false).id;};
  let result = $input->preval([]);

  assertEquals(Integer, $result->functionReturnType().rawType);
}

function <<test.Test>> meta::pure::router::preeval::tests::testFilterTrueSimplification():Boolean[1]
{
  let input = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01)->filter(p | false; true;).id};

  let expected = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01).id};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testFilterTrueSimplification2():Boolean[1]
{
  let input = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01)->filter(p | 1 == 1).id};

  let expected = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01).id};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testFilterTrueConstantSimplification():Boolean[1]
{
  let input = {o:OrganizationalEntity[1]| let bool = true; let date = %2023-01-01; $o.positions($date)->filter(p | $bool).id;};

  let expected = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01).id};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testFilterNoSimplification():Boolean[1]
{
  let input = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01)->filter(p | $p.id == true).id};

  let expected = {o:OrganizationalEntity[1]| $o.positions(%2023-01-01)->filter(p | $p.id == true).id};

  assertRoundTrip($input, $expected);
}


function <<test.Test>> meta::pure::router::preeval::tests::testToOneManyElimination1():Boolean[1]
{
  let input = {| 'hello'->toOneMany()};

  let expected = {| 'hello'};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testToOneManyElimination2():Boolean[1]
{
  let input = {x:String[*]| $x->toOneMany()};

  let expected = $input;

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testToOneManyElimination3():Boolean[1]
{
  let input = {x:String[1..*]| $x->toOneMany()};

  let expected = {x:String[1..*]| $x};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testToOneElimination1():Boolean[1]
{
  let input = {| 'hello'->toOne()};

  let expected = {| 'hello'};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testToOneElimination2():Boolean[1]
{
  let input = {x:String[*]| $x->toOne()};

  let expected = $input;

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testToOneElimination3():Boolean[1]
{
  let input = {x:String[1]| $x->toOne()};

  let expected = {x:String[1]| $x};

  assertRoundTrip($input, $expected);
}


function <<test.Test>> meta::pure::router::preeval::tests::testRecursiveSimpleConcreteFunctionDefinition():Boolean[1]
{
  // This is specially selected to be a single function that is recursive on itself
  // The test is to validate that we don't keep trying to inline ad infinitum

  let input = {s:Class<Any>[1]|meta::pure::functions::meta::hierarchicalProperties($s)};

  let expected = {s:Class<Any>[1]|
    if($s == Any, {|[]}, {|$s.properties->concatenate($s.generalizations->map({g|$g.general.rawType->cast(Any)
      ->toOne()
      ->hierarchicalProperties()}))
      ->removeDuplicates()})
  };

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testLetOnlyStatement():Boolean[1]
{
  let input = {|myFunc2()};

  let expected = {| 'hello'};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testLambdaParamOverride():Boolean[1]
{
  let input    = { | let val = 1;
                     {val:Integer[1]| $val};};

  let expected = { | {val:Integer[1]| $val};};

  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testSchemaStateUnfurl():Boolean[1]
{
  let state = ^meta::pure::tds::schema::SchemaState(columns=[^meta::pure::tds::TDSColumn(name='column1'), ^meta::pure::tds::TDSColumn(name='column2')]);
  let input = {|$state.columns.name};
  let expected = {|['column1', 'column2']};
  assertRoundTrip($input, $expected);
}

function <<test.Test>> meta::pure::router::preeval::tests::testLambdaParamOverride2():Boolean[1]
{
  let val = 1;
  let input    = { | let x = 1;
                     {p:Integer[1]|$p->map(x|$x+$val)};};
  let expected = { | {p:Integer[1]|$p->map(x|$x+1)}};

  assertRoundTrip($input, $expected);
}

function <<access.private>> meta::pure::router::preeval::tests::myFunc2():String[1]
{
  let x = 'hello';
}

function meta::pure::router::preeval::tests::getTestRuntimeWithModelConnection(sourceClass:Class<Any>[1], inputs:Any[*]):Runtime[1]
{
  // Need element as string to allow roundtrip to pass. When using ^ModelStore(), preeval evaluates it to a instance, however expected as it as a new function
  ^Runtime(connectionStores=^ConnectionStore(element = 'DummyStore', connection=^meta::external::store::model::ModelConnection(instances=newMap(pair($sourceClass, list($inputs))))));
}

function <<access.private>> meta::pure::router::preeval::tests::assertRoundTrip(input : FunctionDefinition<Any>[1], expectedOrig : FunctionDefinition<Any>[1]):Boolean[1]
{
  assertRoundTrip($input, $expectedOrig, noDebug())
}

function <<access.private>> meta::pure::router::preeval::tests::assertRoundTrip(input : FunctionDefinition<Any>[1], expectedOrig : FunctionDefinition<Any>[1], debug:meta::pure::tools::DebugContext[1]):Boolean[1]
{
  meta::pure::router::preeval::tests::assertRoundTrip($input, $expectedOrig, [], [], $debug);
}

function <<access.private>> meta::pure::router::preeval::tests::assertRoundTrip(input : FunctionDefinition<Any>[1], expectedOrig : FunctionDefinition<Any>[1], stopInlineFunctions:Function<Any>[*], extensions:Extension[*], debug:meta::pure::tools::DebugContext[1]):Boolean[1]
{
  let expected = $expectedOrig;

  let result = if($stopInlineFunctions->isEmpty(),
    | $input->preval(newMap([]->cast(@Pair<VariableExpression, ValueSpecification>)), $input->openVariableValues(), [], $debug).value->toOne(); ,
    | let inScopeVars = $input->openVariableValues();
      let state       = meta::pure::router::preeval::getPreevalStateWithAdditionalStopInlineFunc($inScopeVars, $extensions, $stopInlineFunctions);
      $input->preval($state, $extensions).value->toOne(););

  let tExpected = $expected->transformFunctionBody($extensions);
  let tResult = $result->transformFunctionBody($extensions);

  let jExpected = $tExpected->toJSON(50000);
  let jResult = $tResult->toJSON(50000);

  let pjExpected = $jExpected->parseJSON()->toPrettyJSONString();
  let pjResult = $jResult->parseJSON()->toPrettyJSONString();

  if($pjExpected == $pjResult,
    | true,
    |
        println($pjExpected);
        println($pjResult);

        let pExpected = $tExpected->toPure($extensions);
        let pResult = $tResult->toPure($extensions);

        assertEquals($pExpected, $pResult, 'Mismatch between expected and actual result content.\nexpected pure:\n%r\n\nactual pure:\n%r', [$pExpected->toOne(), $pResult->toOne()]);
    );

  // Open variables on lambdas should have been inlined / eliminated
  if (!$result->instanceOf(LambdaFunction),
    | true,
    | assertEmpty($result->cast(@LambdaFunction<Any>).openVariables)
  );

  if($input->cast(@Function<Any>)->functionType().parameters->isNotEmpty(),
    | true,
    |
      let inputEvalResult = $input->evaluate([]);
      let expectedEvalResult = $expected->evaluate([]);
      let resultEvalResult = $result->evaluate([]);

      let open = $input->openVariableValues();

      //println($input->cast(@Function<Any>)->functionReturnMultiplicity());

      let mInput = $input->cast(@Function<Any>)->functionReturnMultiplicity();
      let mExpected = $expected->cast(@Function<Any>)->functionReturnMultiplicity();
      let mResult = $result->cast(@Function<Any>)->functionReturnMultiplicity();

      let jInputEvalResult = $inputEvalResult->transformAny([], $open, $mExpected, $extensions)->toJSON(50000);
      let jExpectedEvalResult = $expectedEvalResult->transformAny([], $open, $mExpected, $extensions)->toJSON(50000);
      println($jExpectedEvalResult);
      let jResultEvalResult = $resultEvalResult->transformAny([], $open, $mExpected, $extensions)->toJSON(50000);


      assertEquals($jExpectedEvalResult, $jResultEvalResult, '\nexpected eval result: %r\nactual eval result:   %r', [$jExpectedEvalResult->toOne(), $jResultEvalResult->toOne()]);

      if(!$inputEvalResult->exists(x|$x->match([b:BasicColumnSpecification<Any>[*]|true, a:Any[*]|false])),
          | assertEquals($jInputEvalResult, $jExpectedEvalResult, '\nexpected input eval: %r\nactual expected eval:   %r', [$jInputEvalResult->toOne(), $jExpectedEvalResult->toOne()]),
          | true //The lambda on the BCS can get confused for assertion checking (as it can be "un-optimised")
          );
    );

  true;
}


function <<test.Test>> meta::pure::router::preeval::tests::testParseDate():Boolean[1]
{
  let input = {| parseDate('9999-01-01 01:01:01')};
  let preEval =  $input->preval(newMap([]->cast(@Pair<VariableExpression, ValueSpecification>)), $input->openVariableValues(), [], noDebug()).value->toOne(); 
  assert($preEval->evaluateAndDeactivate()->cast(@LambdaFunction<Any>).expressionSequence->at(0)->cast(@SimpleFunctionExpression).functionName=='parseDate');

}
