import meta::pure::graphFetch::domain::*;
function meta::pure::graphFetch::domain::extractDomainTypeClassFromFunction<T>(func:FunctionDefinition<{->T[*]}>[1]):Pair<String, FunctionDefinition<{->Any[*]}>>[*]
{
   meta::pure::graphFetch::domain::extractDomainTypeClassFromFunction($func,false)->map(r| pair($r.propertyName,$r.functionDef->cast(@FunctionDefinition<{->Any[*]}>)));

}


function meta::pure::graphFetch::domain::extractDomainTypeClassFromFunction<T>(func:FunctionDefinition<{->T[*]}>[1],extractVars:Boolean[1]):meta::pure::graphFetch::domain::ExtractedDomainClassWithParameters[*]
{
  let main = $func.expressionSequence->evaluateAndDeactivate();
  if ($main->size() == 1 && $main->toOne()->instanceOf(FunctionExpression),
    | let treeContainer = if ($main->toOne()->cast(@FunctionExpression).func == meta::pure::graphFetch::execution::graphFetch_T_MANY__RootGraphFetchTree_1__T_MANY_,
                            | $main->cast(@FunctionExpression).parametersValues->at(1)->cast(@InstanceValue),
                            | if ($main->toOne()->cast(@FunctionExpression).func == meta::pure::graphFetch::execution::serialize_T_MANY__RootGraphFetchTree_1__String_1_,
                                | $main->cast(@FunctionExpression).parametersValues->at(1)->cast(@InstanceValue),
                                | fail('GraphQL translation only supports graphFetch')
                            )
                          )->cast(@InstanceValue);
      let tree = $treeContainer.values->toOne()->cast(@meta::pure::graphFetch::RootGraphFetchTree<Any>);
      let domainWithVars = $tree->extractDomainTypeClassFromGraphFetchTree($extractVars,false,[],[],[]);


      ,
    | fail('GraphQL translation only supports graphFetch');
  )->cast(@meta::pure::graphFetch::domain::ExtractedDomainClassWithParameters);
}

Class meta::pure::graphFetch::domain::ExtractedDomainClassWithParameters
{
  functionDef: LambdaFunction<Any>[1];
  propertyName:String[1];

}

function meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphFetchTree(tree:meta::pure::graphFetch::RootGraphFetchTree<Any>[1]):Pair<String, FunctionDefinition<{->Any[*]}>>[*]
{
   meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphFetchTree($tree,false,false,[],[],[])->map(r| pair($r.propertyName,$r.functionDef->cast(@FunctionDefinition<{->Any[*]}>)));
}

function meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphFetchTree(tree:meta::pure::graphFetch::RootGraphFetchTree<Any>[1], isMutation:Boolean[1], mapping:meta::pure::mapping::Mapping[0..1], runtime:meta::core::runtime::Runtime[0..1], binding:meta::external::format::shared::binding::Binding[0..1]):Pair<String, FunctionDefinition<{->Any[*]}>>[*]
{
   meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphFetchTree($tree,false,$isMutation, $mapping, $runtime, $binding)->map(r| pair($r.propertyName,$r.functionDef->cast(@FunctionDefinition<{->Any[*]}>)));
}

function meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphFetchTree(tree:meta::pure::graphFetch::RootGraphFetchTree<Any>[1], extractVars:Boolean[1]):meta::pure::graphFetch::domain::ExtractedDomainClassWithParameters[*]
{
   meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphFetchTree($tree,$extractVars,false,[],[],[]);
}

function meta::pure::graphFetch::domain::extractDomainTypeClassFromGraphFetchTree(tree:meta::pure::graphFetch::RootGraphFetchTree<Any>[1], extractVars:Boolean[1], isMutation:Boolean[1], mapping:meta::pure::mapping::Mapping[0..1], runtime:meta::core::runtime::Runtime[0..1], binding:meta::external::format::shared::binding::Binding[0..1]):meta::pure::graphFetch::domain::ExtractedDomainClassWithParameters[*]
{
    let subTrees = $tree.subTrees->cast(@meta::pure::graphFetch::PropertyGraphFetchTree)->evaluateAndDeactivate();
    let properties = $subTrees.property;
    let result = $properties->findGetAllInQualifiedProperties();
    if ($result->isEmpty(),
      |fail('The system can\'t find a \'set definition\' (i.e. .all()) in any property of the query type leveraged in the tree navigation.'),
      |if ($properties->size() == $result->size(),
           | $result->zip($subTrees)->map(x|


            let parametersValueByName = $x.second.property->functionType().parameters->tail().name->zip($x.second.parameters)->newMap();
            let newFunc = $x.first;
            let genType = ^GenericType(rawType=meta::pure::graphFetch::RootGraphFetchTree, typeArguments=$x.first.genericType);
            let newTree = ^InstanceValue(
                            genericType = $genType,
                            multiplicity = PureOne,
                            values = ^meta::pure::graphFetch::RootGraphFetchTree<Any>
                                     (
                                        class = $x.first.genericType.rawType->toOne()->cast(@Class<Any>),
                                        subTrees = $x.second.subTrees
                                     )
            );

           let stringType = ^GenericType(rawType=String);
           let paramValues= if($extractVars,|$x.first,|$x.first->reprocessVariables($parametersValueByName));
           let expressionSequenceLengthLess1 = $x.second.property->cast(@QualifiedProperty<Any>).expressionSequence->size() - 1;

           let lambdaWithParams = newLambdaFunction( ^FunctionType(returnMultiplicity = ZeroMany,
                                                                        returnType = ^GenericType(rawType = Any),
                                                                        parameters= $x.second.property.classifierGenericType.typeArguments.rawType->cast(@FunctionType).parameters->tail()->evaluateAndDeactivate()
                                                                 ));


            let func = ^LambdaFunction<{->Any[*]}>
            (
              expressionSequence =
                  $x.second.property->cast(@QualifiedProperty<Any>).expressionSequence->slice(0,$expressionSequenceLengthLess1)->map(x|$x->reprocessVariables($parametersValueByName))->concatenate(
                  meta::pure::graphFetch::domain::generateFunctionExpressionByOperationType($newFunc, $newTree, $paramValues, $x.first.genericType, $isMutation, $x.first.genericType.rawType->toOne()->cast(@Class<Any>), $mapping, $runtime, $binding))->toOneMany()
            );
            let funcWithPossibleUpdatedParam =  if( $extractVars,
                                                       |   let lambdaWithParams = newLambdaFunction( ^FunctionType(returnMultiplicity = ZeroMany,
                                                                        returnType = ^GenericType(rawType = Any),
                                                                        parameters= meta::pure::graphFetch::domain::lambdaParamsByOperationType($x.second, $isMutation)
                                                                                                 ));
                                                          ^$func(classifierGenericType=$lambdaWithParams.classifierGenericType);,
                                                       |$func
                                                 );

             ^ExtractedDomainClassWithParameters(propertyName =$x.second.property.name->toOne(),
                                                 functionDef =$funcWithPossibleUpdatedParam
                                                       );

          );,
        | fail('All properties need to be getAll');
      )
    )->cast(@ExtractedDomainClassWithParameters);
}

function meta::pure::graphFetch::domain::generateFunctionExpressionByOperationType(func: FunctionExpression[1], newTree: InstanceValue[1], paramValues:ValueSpecification[1], genericType: GenericType[1], isMutation: Boolean[1], class: Class<Any>[1], mapping:meta::pure::mapping::Mapping[0..1], runtime:meta::core::runtime::Runtime[0..1], binding:meta::external::format::shared::binding::Binding[0..1]):FunctionExpression[1]
{
  let newFunc = if($isMutation,
                      | generateMutationFunctionExpression($func, $newTree, $genericType, $class, $mapping, $runtime, $binding),
                      | generateQueryFunctionExpression($func, $newTree, $genericType, $paramValues)
                    );

}

function meta::pure::graphFetch::domain::generateMutationFunctionExpression(func: FunctionExpression[1],  newTree: InstanceValue[1], genericType: GenericType[1], class: Class<Any>[1], mapping:meta::pure::mapping::Mapping[0..1], runtime:meta::core::runtime::Runtime[0..1], binding:meta::external::format::shared::binding::Binding[0..1]):FunctionExpression[1]
{
  assertNotEmpty($mapping, 'No mapping is present when generating function for mutation expression');
  assertNotEmpty($runtime, 'No runtime is present when generating function for mutation expression');

  let newMapping = ^InstanceValue(genericType = $mapping->genericType(), multiplicity = ZeroMany, values = $mapping);
  let newRuntime = ^InstanceValue(genericType = $runtime->genericType(), multiplicity = ZeroMany, values = $runtime);

  let saveFunc = ^$func(
    func = meta::pure::mutation::save_T_MANY__RootGraphFetchTree_1__Mapping_1__PackageableRuntime_1__T_MANY_,
    functionName = 'save',
    genericType = $genericType,
    resolvedTypeParameters = $genericType ,
    usageContext = []
  );
  ^$saveFunc(
    parametersValues = [
      ^$func(
        func = meta::pure::graphFetch::execution::graphFetch_T_MANY__RootGraphFetchTree_1__T_MANY_,
        functionName = 'graphFetch',
        genericType = $genericType,
        resolvedTypeParameters = $genericType,
        parametersValues = [
          generateInitializeFunction($func, $class, $binding),
          $newTree
        ],
        usageContext = []
      ),
      $newTree,
      $newMapping,
      $newRuntime
    ]
  );
}

function meta::pure::graphFetch::domain::generateInitializeFunction(func: FunctionExpression[1], class: Class<Any>[1], binding:meta::external::format::shared::binding::Binding[0..1]):FunctionExpression[1]
{
  assertNotEmpty($binding, 'No binding is present when generating function for mutation expression');

  let newClass = ^InstanceValue(genericType = $class->genericType(), multiplicity = PureOne, values = $class);
  let newBinding = ^InstanceValue(genericType =  $binding->genericType(),multiplicity = PureOne, values = $binding);

  ^$func(
    func = meta::external::format::shared::functions::internalize_Class_1__Binding_1__String_1__T_MANY_, 
    functionName = 'internalize',
    genericType = ^GenericType(rawType = $class),
    resolvedTypeParameters = ^GenericType(rawType = $class),
    parametersValues = [
      $newClass,
      $newBinding,
      ^VariableExpression( genericType = ^GenericType(rawType = String), multiplicity = PureOne, name = 'variable')
    ],
    usageContext = []
  );
}

function meta::pure::graphFetch::domain::generateQueryFunctionExpression(func: FunctionExpression[1],  newTree: InstanceValue[1], genericType: GenericType[1], paramValues:ValueSpecification[1]):FunctionExpression[1]
{
  let stringType = ^GenericType(rawType=String);
  ^$func(
    func = meta::pure::graphFetch::execution::serialize_T_MANY__RootGraphFetchTree_1__String_1_,
    functionName = 'serialize',
    genericType = $stringType,
    resolvedTypeParameters = $stringType,
    parametersValues = [
    ^$func(
        func = meta::pure::graphFetch::execution::graphFetch_T_MANY__RootGraphFetchTree_1__T_MANY_,
        functionName = 'graphFetch',
        genericType = $genericType,
        resolvedTypeParameters = $genericType,
        parametersValues = [
          $paramValues,
          $newTree
        ],
        usageContext = []
      ),
    $newTree
    ],
    usageContext = []
  );
}

function meta::pure::graphFetch::domain::lambdaParamsByOperationType(subTrees: meta::pure::graphFetch::PropertyGraphFetchTree[1], isMutation: Boolean[1]):VariableExpression[*]
{
  let parameters= $subTrees.property.classifierGenericType.typeArguments.rawType->cast(@FunctionType).parameters->tail()->evaluateAndDeactivate();
  if($isMutation,
      | $parameters->concatenate(^VariableExpression( genericType = ^GenericType(rawType = String), multiplicity = PureOne, name = 'variable')),
      | $parameters
    );
}

function <<access.private>> meta::pure::graphFetch::domain::findGetAllInQualifiedProperties(properties:AbstractProperty<Any>[*]):SimpleFunctionExpression[*]
{
  $properties->map(
    p | if ($p->instanceOf(QualifiedProperty),
          | let exp =  $p->cast(@QualifiedProperty<Any>).expressionSequence->evaluateAndDeactivate()->last()->toOne();
            let val = $exp->lookForGetAll();
            if ($val->instanceOf(SimpleFunctionExpression) && $val->cast(@SimpleFunctionExpression).func->meta::pure::router::routing::isGetAllFunction(),
              |$exp->cast(@SimpleFunctionExpression),
              |[]
            );,
          |[]
        );
  );
}

function <<access.private>> meta::pure::graphFetch::domain::lookForGetAll(s:ValueSpecification[1]):ValueSpecification[1]
{
  $s->match([
    s:SimpleFunctionExpression[1]|if(!$s.func->meta::pure::router::routing::isGetAllFunction() && !$s.parametersValues->isEmpty(),
                                      |$s.parametersValues->at(0)->lookForGetAll(),
                                      |$s
                                    );,
    i:ValueSpecification[1]|$i
  ]);
}


function <<access.private>> meta::pure::graphFetch::domain::reprocessVariables(vs:ValueSpecification[1], vars:Map<String, ValueSpecification>[1]):ValueSpecification[1]
{
   $vs->match([
      fe : FunctionExpression[1] | ^$fe(parametersValues = $fe.parametersValues->evaluateAndDeactivate()->map(x | $x->reprocessVariables($vars))),
      iv : InstanceValue[1] | ^$iv
                              (
                                 values = $iv.values->evaluateAndDeactivate()->map(val | $val->match([
                                    l : LambdaFunction<Any>[1] | ^$l(expressionSequence = $l.expressionSequence->evaluateAndDeactivate()->at(0)->reprocessVariables($vars)),
                                    v : ValueSpecification[1] | $v->reprocessVariables($vars),
                                    a : Any[1] | $a
                                 ]))

                              ),
      ve : VariableExpression[1] | let resolved = $vars->get($ve.name); if($resolved->isEmpty(), | $ve, | $resolved->toOne());,
      v  : ValueSpecification[1] | $v
   ]);
}
