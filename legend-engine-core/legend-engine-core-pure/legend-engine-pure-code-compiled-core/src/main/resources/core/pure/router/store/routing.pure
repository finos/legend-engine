// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::format::shared::binding::*;
import meta::pure::router::metamodel::clustering::*;
import meta::pure::runtime::*;
import meta::pure::store::*;
import meta::pure::metamodel::relation::*;
import meta::relational::metamodel::*;
import meta::pure::extension::*;
import meta::pure::graphFetch::*;
import meta::pure::mapping::*;
import meta::pure::mapping::relation::*;
import meta::pure::router::builder::*;
import meta::pure::router::metamodel::*;
import meta::pure::router::store::metamodel::*;
import meta::pure::router::store::routing::*;
import meta::pure::router::operations::*;
import meta::pure::router::preeval::*;
import meta::pure::router::printer::*;
import meta::pure::router::routing::*;
import meta::core::runtime::*;
import meta::pure::store::*;

// =========================================================================================
// Store Mapping Routing Strategy Builder Helper
// =========================================================================================
function meta::pure::router::store::routing::getRoutingStrategyFromMappingAndRuntime(mapping:Mapping[1], runtime:Runtime[1]):StoreMappingRoutingStrategy[1]
{
    getRoutingStrategyFromMappingAndRuntime($mapping, $runtime, []);
}

function meta::pure::router::store::routing::getRoutingStrategyFromMappingAndRuntime(mapping:Mapping[1], runtime:Runtime[1], extensions: Extension[*]):StoreMappingRoutingStrategy[1]
{
    getRoutingStrategyFromMappingAndRuntime([],$mapping, $runtime, $extensions);
}

function meta::pure::router::store::routing::getRoutingStrategyFromMappingAndRuntime(routingStrategy: RoutingStrategy[0..1], mapping:Mapping[1], runtime:Runtime[1], extensions: Extension[*]):StoreMappingRoutingStrategy[1]
{
    let modifiedRuntime = $runtime;
    let modifiedMapping = modifyMappingBasedOnRuntimeLocality($mapping, $modifiedRuntime, $extensions);
    let currentStoreMappingRoutingStrategy = $routingStrategy->filter(x | $x->instanceOf(StoreMappingRoutingStrategy))->cast(@StoreMappingRoutingStrategy);
    if($currentStoreMappingRoutingStrategy->isEmpty(),
      | getRoutingStrategy($modifiedMapping, $modifiedRuntime),
      | let newStoreMappingRoutingStrategy = $currentStoreMappingRoutingStrategy->toOne();
        ^$newStoreMappingRoutingStrategy(mapping = $modifiedMapping, runtime = $modifiedRuntime, classMappingsByClass = $modifiedMapping->buildClassMappingsByClassMap(), setsByDepth = ^Map<String, PermutationSet>());
    );
}

function <<access.private>> meta::pure::router::store::routing::modifyMappingBasedOnRuntimeLocality(mapping:Mapping[1], runtime:meta::core::runtime::Runtime[1], extensions: meta::pure::extension::Extension[*]):Mapping[1]
{
  let allMappings = $mapping->getIncludedMappingsRecursively();
  let classMappings = $allMappings.classMappings;
  let associationMappings = $allMappings.associationMappings->map(associationMap|$associationMap->match(
    [
        x:meta::pure::mapping::xStore::XStoreAssociationImplementation[1]|
          let mappingIds = $x.propertyMappings.sourceSetImplementationId->concatenate($x.propertyMappings.targetSetImplementationId);
          let inScopeClassMappings = $classMappings->filter(x|$x.id->in($mappingIds))->distinct();
          let inScopeStores = $inScopeClassMappings->map(setImpl |  $setImpl->match([
                                                                                      r:RelationFunctionInstanceSetImplementation[1]|$runtime.connectionStores.element->cast(@meta::pure::store::Store)->toOne('Relation mapping only supported for queries having a single store definitions!'),
                                                                                      a:SetImplementation[1]|meta::pure::router::clustering::storeContractForSetImplementation($setImpl, $mapping, $extensions).second;
                                                                                    ]));
          if(
            $runtime.connectionStores->size() >= 1,
            | let connection = $inScopeStores->map(s|$runtime->connectionByElementFailSafe($s));
            if(
                $connection->size() == 2 && $connection->distinct()->size() == 1,
                | $inScopeStores->match(
                    $extensions.availableStores.localizeXStoreAssociation
                    ->map(e|$e->eval($x, $inScopeClassMappings))
                    ->concatenate([a:Store[*] | $x;])->toOneMany()
                );,
                | $x
            );,
            | $x
          );,

        a:AssociationImplementation[1]|$a
    ]
  ));
  if(
    $associationMappings->equal($allMappings.associationMappings),
    | $mapping,
    | let newMapping = ^Mapping(name=$mapping.name, includes=[], associationMappings=$associationMappings);
    let includedMappings = $allMappings->map(map|^$map(associationMappings=[]))->map(map|^MappingInclude(owner=$newMapping,included=$map));
    $newMapping->mutateAdd('includes', $includedMappings);
  );
}

function <<access.private>> meta::pure::router::store::routing::getIncludedMappingsRecursively(m : Mapping[1]): Mapping[*]
{
  $m->concatenate(if($m.includes->isEmpty(), |[], |$m.includes.included->map(i|$i->getIncludedMappingsRecursively())));
}

function meta::pure::router::store::routing::potentiallyRouteRelationFunctionSets(sets:SetImplementation[*], mapping:Mapping[1], runtime:Runtime[1], extensions: Extension[*]):SetImplementation[*]
{
  $sets->map(s|$s->potentiallyRouteRelationFunctionSet($mapping, $runtime, $extensions));
}

function meta::pure::router::store::routing::potentiallyRouteRelationFunctionSet(s:SetImplementation[1], mapping:Mapping[1], extensions: Extension[*]):SetImplementation[1]
{
  potentiallyRouteRelationFunctionSet($s, $mapping, ^Runtime(connectionStores=^ConnectionStore(connection=^Connection(),element='Mock')), $extensions);
}

function meta::pure::router::store::routing::potentiallyRouteRelationFunctionSet(s:SetImplementation[1], mapping:Mapping[1], runtime:Runtime[1], extensions: Extension[*]):SetImplementation[1]
{
  $s->match(
    [
      t:RelationFunctionInstanceSetImplementation[1]|^$t(relationFunction=$t->potentiallyRouteRelationFunction($mapping, $runtime, $extensions)),
      s:InstanceSetImplementation[1]|$s,
      o:OperationSetImplementation[1]|^$o(parameters = $o.parameters->map(i| ^$i(setImplementation=$mapping->classMappingById($i.id)->toOne()->potentiallyRouteRelationFunctionSet($mapping, $runtime, $extensions))))
    ]
  );
}

function meta::pure::router::store::routing::isRelationFunctionRouted(r:RelationFunctionInstanceSetImplementation[1]):Boolean[1]
{
  $r.relationFunction->evaluateAndDeactivate().expressionSequence->at(0)->instanceOf(ClusteredValueSpecification);
}

function meta::pure::router::store::routing::potentiallyRouteRelationFunction(r:RelationFunctionInstanceSetImplementation[1], mapping:Mapping[1], runtime:Runtime[1], extensions: Extension[*]):FunctionDefinition<{->Relation<Any>[1]}>[1]
{
  if(isRelationFunctionRouted($r),
    | $r.relationFunction,
    | $r.relationFunction->routeFunction(getRoutingStrategy($mapping, $runtime), ^ExecutionContext(), [], $extensions, noDebug())->cast(@FunctionDefinition<{->Relation<Any>[1]}>)
  );
}

function <<access.private>> meta::pure::router::store::routing::getRoutingStrategy(mapping:Mapping[1], runtime:Runtime[1]):StoreMappingRoutingStrategy[1]
{
  ^StoreMappingRoutingStrategy(
    mapping = $mapping,
    runtime = $runtime,
    setsByDepth = ^Map<String, PermutationSet>(),
    classMappingsByClass = $mapping->buildClassMappingsByClassMap(),
    processClass = processClass_Class_1__InstanceValue_1__RoutingState_1__ExecutionContext_1__Extension_MANY__DebugContext_1__RoutingState_1_,
    processRelationStoreAccessor = processRelationStoreAccessor_RelationStoreAccessor_1__InstanceValue_1__RoutingState_1__ExecutionContext_1__DebugContext_1__RoutingState_1_,
    processProperty = routeFunctionExpressionProperty_Property_1__FunctionExpression_1__RoutingState_1__ExecutionContext_1__Map_1__Map_1__Extension_MANY__DebugContext_1__RoutingState_1_,
    wrapValueSpec = wrapValueSpecificationStoreMapping_ValueSpecification_1__RoutingStrategy_1__String_1__ExecutionContext_1__Extension_MANY__DebugContext_1__ExtendedRoutedValueSpecification_1_,
    toString = {strategy:RoutingStrategy[1] | $strategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()}
  )
}

function meta::pure::router::store::routing::getRoutingStrategyFromRuntime(runtime:Runtime[1]):StoreRoutingStrategy[1]
{
  ^StoreRoutingStrategy(runtime = $runtime,
                        processRelationStoreAccessor = processRelationStoreAccessor_RelationStoreAccessor_1__InstanceValue_1__RoutingState_1__ExecutionContext_1__DebugContext_1__RoutingState_1_,

                        processClass = processClassPassThrough_Class_1__InstanceValue_1__RoutingState_1__ExecutionContext_1__Extension_MANY__DebugContext_1__RoutingState_1_,
                        processProperty = routeFunctionExpressionProperty_Property_1__FunctionExpression_1__RoutingState_1__ExecutionContext_1__Map_1__Map_1__Extension_MANY__DebugContext_1__RoutingState_1_,

                        wrapValueSpec = wrapValueSpecificationStore_ValueSpecification_1__RoutingStrategy_1__String_1__ExecutionContext_1__Extension_MANY__DebugContext_1__ExtendedRoutedValueSpecification_1_,
                        toString = {strategy:RoutingStrategy[1] | 'StoreRoutingStrategy'});
}

function <<access.private>> meta::pure::router::store::routing::processRelationStoreAccessor(c:RelationStoreAccessor<Any>[1], i:InstanceValue[1], s:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], debug:DebugContext[1]):RoutingState[1]
{
  let strategy     = $s.routingStrategy->cast(@StoreRoutingStrategy);
  let nStrategy    = ^$strategy(store=$c.store);
  let runtime      = $strategy.runtime;
  let id = $s.counter + 1;
  let routed = ^StoreRoutedValueSpecification(genericType = $i.genericType,
                                              multiplicity = $i.multiplicity,
                                              id = $id->toString(),
                                              store = $c.store,
                                              runtime = $runtime,
                                              executionContext = $executionContext,
                                              value = $i,
                                              routingStrategy = $nStrategy);
  ^$s(
        counter = $id,
        routingStrategy = $nStrategy,
        value = $routed
  );
}

function <<access.private>> meta::pure::router::store::routing::processClassPassThrough(c:Class<Any>[1], i:InstanceValue[1], s:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], extensions:Extension[*], debug:DebugContext[1]):RoutingState[1]
{
  ^$s(depth = $s.depth + $c->varToString());
}

function meta::pure::router::store::routing::projectFunctions(): Function<Any>[*]
{
  tdsProjectFunctions()->concatenate(relationProjectFunctions())
}

function meta::pure::router::store::routing::tdsProjectFunctions(): Function<Any>[*]
{
  [
    project_T_MANY__Path_MANY__TabularDataSet_1_,
    project_K_MANY__Function_MANY__String_MANY__TabularDataSet_1_,
    project_T_MANY__ColumnSpecification_MANY__TabularDataSet_1_
  ]
}

function meta::pure::router::store::routing::relationProjectFunctions(): Function<Any>[*]
{
  [
    meta::pure::functions::relation::project_C_MANY__FuncColSpecArray_1__Relation_1_
  ]
}

Enum meta::pure::router::store::routing::QueryPattern
{
  FilteredGetAll,
  Project,
  GraphFetch,
  Unknown
}

function <<access.private>> meta::pure::router::store::routing::identifyQueryPattern(state: RoutingState[1]): QueryPattern[1]
{
  // Router union should be retained only for certain pattern of queries
  // Only [getAll, filtered getAll] potentially followed by project or graphFetch 
  // In case of other operations like groupBy, resolution should not happen as its not functionally correct to concatenate results from multiple queries
  // This function identifies the query pattern

  let exprSequenceAfterGetAll = $state.functionExpressionStack->evaluateAndDeactivate()->reverse()->tail();
  let withFiltersRemoved = $exprSequenceAfterGetAll->fold({e, agg | if ($agg->isEmpty() && $e.func->evaluateAndDeactivate() == filter_T_MANY__Function_1__T_MANY_, | [], | $agg->concatenate($e)->evaluateAndDeactivate())}, []);

  if (
    [
      pair(|$withFiltersRemoved->isEmpty(), |QueryPattern.FilteredGetAll),
      pair(|$withFiltersRemoved->at(0)->evaluateAndDeactivate().func->evaluateAndDeactivate()->in(projectFunctions()), |QueryPattern.Project),
      pair(|$withFiltersRemoved->at(0)->evaluateAndDeactivate().func->evaluateAndDeactivate()->in(meta::pure::graphFetch::execution::graphFetchFunctions()), |QueryPattern.GraphFetch)
    ],
    |QueryPattern.Unknown
  );
}

function <<access.private>> meta::pure::router::store::routing::isClassEncounteredInGetAllFunction(state: RoutingState[1]): Boolean[1]
{
  let exprSequence = $state.functionExpressionStack->evaluateAndDeactivate()->reverse();
  $exprSequence->isNotEmpty() && $exprSequence->at(0).func->evaluateAndDeactivate()->isGetAllFunction();
}

function <<access.private>> meta::pure::router::store::routing::potentiallyConvertRouterUnionToStoreUnionAndResolveSets(set: SetImplementation[0..1], state: RoutingState[1], mapping: Mapping[1], debug: DebugContext[1]): SetImplementation[*]
{
  let isRouterUnionSet = $set->match([o:OperationSetImplementation[1] | ($o.operation == meta::pure::router::operations::special_union_OperationSetImplementation_1__SetImplementation_MANY_) && ($o->resolveOperation($mapping)->size() > 1), a:Any[*] | false]);
  if ($isRouterUnionSet && $state->isClassEncounteredInGetAllFunction(),
      | let opSet = $set->toOne()->cast(@OperationSetImplementation);
        let queryPattern = $state->identifyQueryPattern();
        if (
          [
            // For unknown pattern, convert to store union as concatenate might not be functionally correct (groupBy queries etc.)
            pair(|$queryPattern == QueryPattern.Unknown, |^$opSet(operation = meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_)->potentiallyResolveOperation($mapping)),

            // For project, concatenation should happen just after project but not for the full query. This will be handled in further routing of project function if router union set is encountered
            pair(|$queryPattern == QueryPattern.Project, |$opSet->reprocessOperationForAssociationMapping($mapping))
          ],

          // For getAll and graphFetch, concatenate at the top is fine. So, resolve the router union into multiple sets
          |$opSet->potentiallyResolveOperation($mapping)
        );,
      | $set->potentiallyResolveOperation($mapping)
  );
}

function <<access.private>> meta::pure::router::store::routing::potentiallyRouteRelationFunctionSets(classMappings:SetImplementation[*], c:Class<Any>[1], strategy:StoreMappingRoutingStrategy[1], extensions:Extension[*]):Pair<List<SetImplementation>, StoreMappingRoutingStrategy>[1]
{
  let partitionedMappings = $classMappings->partition(cm | $cm->instanceOf(RelationFunctionInstanceSetImplementation));
  let relFuncMappings = $partitionedMappings.first.values->cast(@RelationFunctionInstanceSetImplementation);
  let nonRelFuncMappings = $partitionedMappings.second.values;
  let partitionedRelFuncMappings = $relFuncMappings->partition(r | $r->isRelationFunctionRouted());
  // Routed relation function set maybe cached in classMappingsByClass, if not route and update cache
  let routedRelFuncMappings = $partitionedRelFuncMappings.first.values->concatenate(
                                $partitionedRelFuncMappings.second.values->map(r | $strategy.classMappingsByClass->get($c).values->toOne()->potentiallyRouteRelationFunctionSet($strategy.mapping, $strategy.runtime, $extensions))
                              );
  let updatedClassMappings = $nonRelFuncMappings->concatenate($routedRelFuncMappings);
  let updatedRoutingStrategy = ^$strategy(classMappingsByClass = $strategy.classMappingsByClass->put($c, list($updatedClassMappings)));
  pair(list($updatedClassMappings), $updatedRoutingStrategy);
}

function <<access.private>> meta::pure::router::store::routing::processClass(c:Class<Any>[1], i:InstanceValue[1], s:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], extensions:Extension[*], debug:DebugContext[1]):RoutingState[1]
{
    // Route a Class using the Mapping
    let strategy     = $s.routingStrategy->cast(@StoreMappingRoutingStrategy);
    let mapping      = $strategy.mapping;
    let runtime      = $strategy.runtime;
    let state        = ^$s(depth = $s.depth + $c->varToString());
    let classMapping =  if($strategy.toChooseSet->isEmpty(),
                          | $mapping
                              ->rootClassMappingByClass($c)
                              ->potentiallyConvertRouterUnionToStoreUnionAndResolveSets($s, $mapping, $debug), 
                          | $strategy.toChooseSet
                        );

    // Possible when the mapping is 'embedded'
    if ($classMapping->isEmpty(),
        | print(if($debug.debug,|$debug.space+'~>C) ('+$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$state.value->toOne()->toString()+'\n',|''));
          $state;,
        | let updatedClassMappingAndRoutingStrategy = $classMapping->potentiallyRouteRelationFunctionSets($c, $state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne(), $extensions);
          let updatedClassMapping = $updatedClassMappingAndRoutingStrategy.first.values;
          let currentRoutingStrategy = $updatedClassMappingAndRoutingStrategy.second;
          let existingSet = $state->findExistingPemutationSet($debug);
          let existingSetCanBeUsed = $existingSet->permutationSetOnlyHasImplementation($updatedClassMapping);
          let newID = if($existingSetCanBeUsed,
                        | $existingSet->toOne().id->cast(@Integer),
                        | $state.counter+1
                      )->toString();
          let newSet = if (!$existingSetCanBeUsed,|^PermutationSet(id = $state.counter+1, sets = $updatedClassMapping),|[]);
          let updatedRoutingStrategy = ^$currentRoutingStrategy(setsByDepth = if (!$existingSetCanBeUsed,
                                                                                      |let setByD = $state.routingStrategy->cast(@StoreMappingRoutingStrategy).setsByDepth;
                                                                                      $setByD->put(getSetPath($state), $newSet->toOne());,
                                                                                      |$state.routingStrategy->cast(@StoreMappingRoutingStrategy).setsByDepth
                                                                                  ),
                                                                    sets = if (!$existingSetCanBeUsed,|$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->add($newSet->toOne()),|$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets));
          let routed = ^StoreMappingRoutedValueSpecification(genericType = $i.genericType,
                                                            multiplicity = $i.multiplicity,
                                                            id = $newID,
                                                            sets = $updatedClassMapping,
                                                            runtime = $runtime,
                                                            mapping = $mapping,
                                                            executionContext = $executionContext,
                                                            value = $i,
                                                            routingStrategy = $updatedRoutingStrategy);
          let res = ^$state(
                        counter = if (!$existingSetCanBeUsed,|$state.counter+1,|$state.counter),
                        routingStrategy = $updatedRoutingStrategy,
                        value = $routed
                    );
          print(if($debug.debug,|$debug.space+'~>C) ('+$res.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$routed->evaluateAndDeactivate()->asString()+'\n',|''));
          $res;
      );
}

function <<access.private>> meta::pure::router::store::routing::routeFunctionExpressionProperty(p:Property<Nil,Any|*>[1], fe:FunctionExpression[1], v:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):RoutingState[1]
{
   let mapping = $v.routingStrategy->cast(@StoreMappingRoutingStrategy).mapping;
   let runtime = $v.routingStrategy->cast(@StoreMappingRoutingStrategy).runtime;

   let results = $v->processCollection($fe.parametersValues->evaluateAndDeactivate(), $executionContext, $vars, $inScopeVars, v:Any[1]|true, $extensions, $debug)->evaluateAndDeactivate();
   let newPV   = $results.value->cast(@ValueSpecification)->toOneMany();
   let preLast = $results->last()->toOne();

   let res = if($results.value->size() == 1 && $results.value->toOne()->instanceOf(InstanceValue),
                | let val  = $results.value->toOne()->cast(@InstanceValue).values->map(v | $p->eval($v));
                  let iv   = ^InstanceValue(genericType = $p->functionReturnType(),multiplicity = $p.multiplicity, values = $val);
                  let last = ^$preLast(depth = $preLast.depth + $p.name->toOne());
                  ^$last(value = $iv);,
                | let srcSets   = $preLast.value->match([v:StoreMappingRoutedValueSpecification[1]|$v.sets, a:Any[*]|[]->cast(@SetImplementation)]);
                  let isPropertyAutoMapped = $srcSets->isPropertyAutoMapped($p, $extensions, $mapping);
                  if (!$v.shouldBeRouted || !$preLast.shouldBeRouted || $isPropertyAutoMapped,
                      | ^$preLast(value=^NoSetRoutedValueSpecification(genericType = $fe.genericType, multiplicity = $fe.multiplicity, value=^$fe(parametersValues = $results.value->cast(@ValueSpecification)->toOneMany())), shouldBeRouted=false)->evaluateAndDeactivate();,
                      | let last = ^$preLast(depth = $preLast.depth + $p.name->toOne());

                        print(if($debug.debug,|$debug.space+$fe->asString()+'\n',|''));
                        let targetType = $p.classifierGenericType.typeArguments->at(1).rawType->toOne();
                        if($targetType->instanceOf(DataType),
                          | let sourceClass = $fe.parametersValues->at(0).genericType.rawType->toOne();
                            let subTypes = $sourceClass->cast(@Class<Any>)->getMappedLeafClasses($mapping, $v);
                            let classes = if ($subTypes->isEmpty(), | $sourceClass, | $subTypes);
                            let classMappings = $classes->map( c | $v.routingStrategy->cast(@StoreMappingRoutingStrategy).classMappingsForClass($c->cast(@Class<Any>)));

                            let classMapping = if ($classMappings->isEmpty() && !$subTypes->isEmpty(),
                                                      | //look for direct mapping of base class, as none of the sub types have mappings
                                                        //Ideally (per Pierre) these mappings should not be allowed
                                                          $v.routingStrategy->cast(@StoreMappingRoutingStrategy).classMappingsForClass($sourceClass->cast(@Class<Any>)),
                                                      | $classMappings);

                            let resolvedClassMappings = if($classMapping->isNotEmpty(),
                                                            | $classMapping,
                                                            | $subTypes->map(s|$s->cast(@Class<Any>)->getClassMappings($v))->removeDuplicates()
                                                        );
                            assert($resolvedClassMappings->isNotEmpty(), | 'The class \''+$sourceClass.name->toOne()+'\' can\'t be found in the mapping \''+$mapping.name->toOne()+'\'');
                            let updatedClassMappingAndRoutingStrategy = $resolvedClassMappings->potentiallyRouteRelationFunctionSets($sourceClass->cast(@Class<Any>), $last.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne(), $extensions);

                            let r = ^StoreMappingRoutedValueSpecification(
                                      genericType = $fe.genericType,
                                      multiplicity = $fe.multiplicity,
                                      id = $last.counter->toString(),
                                      sets = $updatedClassMappingAndRoutingStrategy.first.values,
                                      runtime = $runtime,
                                      mapping = $mapping,
                                      executionContext = $executionContext,
                                      value = ^$fe(parametersValues = $newPV),
                                      routingStrategy = $updatedClassMappingAndRoutingStrategy.second
                                    );
                            ^$last(value = $r, routingStrategy = $updatedClassMappingAndRoutingStrategy.second);,
                          | let propId = $v.lambdaContext->toOne()+$fe->propToString($vars, $inScopeVars);
                            let found = $v.propertyMap.v->filter(p|$p.first == $propId);
                            if (!$found->isEmpty(),
                                | let routed = $found.second->toOne();
                                  ^$last(
                                    value= $routed
                                  );,
                                | let foundSets = $p->findMappingsFromProperty($mapping, $srcSets, $v, $extensions); //is this for embedded?
                                  let updatedClassMappingAndRoutingStrategy = $foundSets->potentiallyRouteRelationFunctionSets($p->functionReturnType().rawType->toOne()->cast(@Class<Any>), $last.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne(), $extensions);
                                  let updatedFoundSets = $updatedClassMappingAndRoutingStrategy.first.values;
                                  if ($updatedFoundSets->isEmpty(),
                                    | ^$last(value=^$fe(parametersValues = $newPV)),
                                    | let existingSet = $last->findExistingPemutationSet($debug);
                                      let existingSetCanBeUsed  = $existingSet->permutationSetOnlyHasImplementation($updatedFoundSets);
                                      let newID = if($existingSetCanBeUsed,
                                                  |$existingSet->toOne().id,
                                                  |$last.counter+1
                                                  )->toString();

                                      let oldPropertyMap = $last.propertyMap->toOne();
                                      let newSet = if (!$existingSetCanBeUsed,|^PermutationSet(id = $last.counter+1, sets = $updatedFoundSets),|[]);

                                      let currentRoutingStrategy = $updatedClassMappingAndRoutingStrategy.second;
                                      let updatedRoutingStrategy = ^$currentRoutingStrategy(setsByDepth = if (!$existingSetCanBeUsed,|let setByD = $last.routingStrategy->cast(@StoreMappingRoutingStrategy).setsByDepth;$setByD->put(getSetPath($last), $newSet->toOne());,|$last.routingStrategy->cast(@StoreMappingRoutingStrategy).setsByDepth),
                                                                                            sets        = if (!$existingSetCanBeUsed,|$last.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->add($newSet->toOne()),|$last.routingStrategy->cast(@StoreMappingRoutingStrategy).sets));

                                      let added = ^StoreMappingRoutedValueSpecification(
                                                        genericType = $fe.genericType,
                                                        multiplicity = $fe.multiplicity,
                                                        id = $newID,
                                                        sets = $updatedFoundSets,
                                                        runtime = $runtime,
                                                        mapping = $mapping,
                                                        executionContext = $executionContext,
                                                        value = ^$fe(parametersValues = $newPV),
                                                        routingStrategy = $updatedRoutingStrategy
                                                    );
                                      ^$last(
                                          counter = if (!$existingSetCanBeUsed,|$last.counter+1,|$last.counter),
                                          routingStrategy = $updatedRoutingStrategy,
                                          propertyMap = ^$oldPropertyMap(v += pair($propId, $added->cast(@Any))),
                                          value = $added
                                      );
                                  );
                            );
                        );
                   ););
   print(if($debug.debug,|$debug.space+'~>FEP) ('+$res.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$res.value->toOne()->cast(@ValueSpecification)->asString()+'\n',|''));
   $res;
}

function <<access.private>> meta::pure::router::store::routing::wrapValueSpecificationStoreMapping(value:ValueSpecification[1], routingStrategy:RoutingStrategy[1], id:String[1], executionContext:meta::pure::runtime::ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):ExtendedRoutedValueSpecification[1]
{
   let strategy = $routingStrategy->cast(@StoreMappingRoutingStrategy);

   ^StoreMappingRoutedValueSpecification
   (
      genericType = $value.genericType,
      multiplicity = $value.multiplicity,
      id = $id,
      runtime = $strategy.runtime,
      mapping = $strategy.mapping,
      executionContext = $executionContext,
      value = $value,
      routingStrategy = $strategy
   );
}

function <<access.private>> meta::pure::router::store::routing::wrapValueSpecificationStore(value:ValueSpecification[1], routingStrategy:RoutingStrategy[1], id:String[1], executionContext:meta::pure::runtime::ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):ExtendedRoutedValueSpecification[1]
{
   let strategy = $routingStrategy->cast(@StoreRoutingStrategy);
   ^StoreRoutedValueSpecification
   (
      genericType = $value.genericType,
      multiplicity = $value.multiplicity,
      store = $strategy.store,
      id = $id,
      runtime = $strategy.runtime,
      executionContext = $executionContext,
      value = $value,
      routingStrategy = $strategy
   );
}

// ===================================================================================
// Special Functions
// ===================================================================================

function  meta::pure::router::store::routing::specializedFunctionExpressionRouterProcessorForStore(extensions:meta::pure::extension::Extension[*]):Pair<Function<{FunctionExpression[1]->Boolean[1]}>, Function<{Function<Any>[1], FunctionExpression[1], RoutingState[1], meta::pure::runtime::ExecutionContext[1], Map<VariableExpression, ValueSpecification>[1], Map<String, List<Any>>[1], meta::pure::extension::Extension[*], DebugContext[1]->RoutingState[1]}>>[*]
{
  [
    pair(fe:FunctionExpression[1] | $fe.func->in([meta::pure::mapping::from_T_m__Runtime_1__T_m_,
                                                  meta::pure::mapping::from_T_m__PackageableRuntime_1__T_m_,
                                                  meta::pure::mapping::with_T_m__Runtime_1__T_m_,
                                                  meta::pure::mapping::with_T_m__PackageableRuntime_1__T_m_]),
        {f:Function<Any>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |
                let resolvedParameters     = $fe.parametersValues->tail()->map(p|$p->evaluateAndDeactivate()->match([v:VariableExpression[1] |let iv = meta::pure::functions::meta::resolve($v, $vars, $inScopeVars)->cast(@InstanceValue).values,
                                                                                                                     f:FunctionExpression[1] |let r = $f->meta::pure::router::preeval::preval($inScopeVars, $extensions, $debug);
                                                                                                                                              $r->reactivate($inScopeVars);,
                                                                                                                     i:InstanceValue[1]      |$i.values]));
                let fromRuntime            = $resolvedParameters->at(0)->match([runtime:Runtime[1] | $runtime;, packageableRuntime:PackageableRuntime[1] | $packageableRuntime.runtimeValue;]);
                routeValueSpecification(
                  ^$state(value = $fe.parametersValues->at(0), 
                  routingStrategy = getRoutingStrategyFromRuntime($fromRuntime)), 
                  $executionContext,
                  $vars,
                  $inScopeVars,
                  $extensions,
                  $debug
                );
        }
    ),
    pair(fe:FunctionExpression[1] | $fe.func->in([
                                                  meta::pure::mapping::from_FunctionDefinition_1__Runtime_1__T_m_,
                                                  meta::pure::mapping::from_FunctionDefinition_1__Mapping_1__Runtime_1__T_m_,
                                                  meta::pure::mapping::from_FunctionDefinition_1__PackageableRuntime_1__T_m_,
                                                  meta::pure::mapping::from_FunctionDefinition_1__Mapping_1__PackageableRuntime_1__T_m_
                                                ]),
        {f:Function<Any>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |
                let resolvedParameters     = $fe.parametersValues->tail()->map(p|$p->evaluateAndDeactivate()->match([v:VariableExpression[1] |let iv = meta::pure::functions::meta::resolve($v, $vars, $inScopeVars)->cast(@InstanceValue).values,
                                                                                                                     f:FunctionExpression[1] |let r = $f->meta::pure::router::preeval::preval($inScopeVars, $extensions, $debug);
                                                                                                                                              $r->reactivate($inScopeVars);,
                                          
                                                                                                                        i:InstanceValue[1]      |$i.values]));
                let fromRuntime = $resolvedParameters->last()->match([runtime:Runtime[1] | $runtime;, packageableRuntime:PackageableRuntime[1] | $packageableRuntime.runtimeValue;]);
                
                let routingStrategy = $resolvedParameters->init()->head()->match([
                  fromMapping: Mapping[1] | getRoutingStrategyFromMappingAndRuntime($state.routingStrategy, $fromMapping, $fromRuntime, $extensions),
                  m: Any[0] | getRoutingStrategyFromRuntime($fromRuntime)
                ]);

                let exCtx = $state.executionContext;

                let funcToRoute = $fe.parametersValues->at(0)->cast(@InstanceValue).values->toOne()->cast(@FunctionDefinition<Any>);

                let preEvalFuncToRoute = meta::pure::router::preeval::preval($funcToRoute, $extensions, $debug->indent());

                let routedFunc = routeFunction($preEvalFuncToRoute, $routingStrategy, $exCtx, [], $extensions, $debug->indent());

                let clusters = $routedFunc.expressionSequence->evaluateAndDeactivate()->cast(@ClusteredValueSpecification);
                let uniqueClusters = $clusters->removeDuplicates({x, y | meta::pure::router::clustering::areClustersCompatible($x, $y, $extensions)});
                assert($uniqueClusters->size() == 1, |'Function definition on ->with(..) accesses multiple stores and runtimes, and this is not supported:\n' + $uniqueClusters->map(c | $c->asString())->joinStrings(',\n'));
                
                let unclusteredRoutedFunc = ^$routedFunc(expressionSequence = $clusters.val);

                let routedVs = ^SimpleFunctionExpression(
                          func = $unclusteredRoutedFunc,
                          genericType = $funcToRoute->functionReturnType(),                      
                          multiplicity = $funcToRoute->functionReturnMultiplicity(),
                          importGroup=system::imports::coreImport                      
                        )->evaluateAndDeactivate();

                let wrapped = $routingStrategy.wrapValueSpec($routedVs, 'from_function_wrapper', $exCtx, $extensions, $debug);

                ^$state(value = $wrapped, routingStrategy = $routingStrategy);
        }
    ),
    pair(fe:FunctionExpression[1] | $fe.func->in([meta::pure::mapping::from_TabularDataSet_1__Mapping_1__Runtime_1__TabularDataSet_1_,
                                                  meta::pure::mapping::from_TabularDataSet_1__Mapping_1__PackageableRuntime_1__TabularDataSet_1_,
                                                  meta::pure::mapping::from_TabularDataSet_1__Mapping_1__Runtime_1__ExecutionContext_1__TabularDataSet_1_,
                                                  meta::pure::mapping::from_TabularDataSet_1__Mapping_1__PackageableRuntime_1__ExecutionContext_1__TabularDataSet_1_,
                                                  meta::pure::mapping::from_T_m__Mapping_1__Runtime_1__T_m_,
                                                  meta::pure::mapping::from_T_m__Mapping_1__PackageableRuntime_1__T_m_,
                                                  meta::pure::mapping::with_T_m__Mapping_1__Runtime_1__T_m_,
                                                  meta::pure::mapping::with_T_m__Mapping_1__PackageableRuntime_1__T_m_]),
        {f:Function<Any>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |
                let resolvedParameters     = $fe.parametersValues->tail()->map(p|$p->evaluateAndDeactivate()->match([v:VariableExpression[1] |let iv = meta::pure::functions::meta::resolve($v, $vars, $inScopeVars)->cast(@InstanceValue).values,
                                                                                                                     f:FunctionExpression[1] |let r = $f->meta::pure::router::preeval::preval($inScopeVars, $extensions, $debug);
                                                                                                                                              $r->reactivate($inScopeVars);,
                                                                                                                     i:InstanceValue[1]      |$i.values]));
                let fromMapping            = $resolvedParameters->at(0)->cast(@Mapping);
                let fromRuntime            = $resolvedParameters->at(1)
                                              ->match([
                                                 r:Runtime[1]| $r,
                                                 pr:PackageableRuntime[1] | $pr.runtimeValue;,
                                                 fe: FunctionExpression[1] | $fe->meta::pure::router::preeval::preval($inScopeVars, $extensions, $debug)->reactivate($inScopeVars)          
                                              ])->toOne()->cast(@Runtime);
                let fromExecutionContext   = if($resolvedParameters->size() == 3, | $resolvedParameters->at(2)->cast(@meta::pure::runtime::ExecutionContext), | $executionContext);

                let currentRoutingStrategy = $state.routingStrategy;
                let newRoutingStrategy     = getRoutingStrategyFromMappingAndRuntime($currentRoutingStrategy, $fromMapping, $fromRuntime, $extensions);
                let newState               = ^$state(routingStrategy = $newRoutingStrategy);

                let processedFunction      = ^$newState(value = $fe.parametersValues->at(0)->match([v:VariableExpression[1] | meta::pure::functions::meta::resolve($v, $vars, $inScopeVars)->cast(@InstanceValue).values->cast(@FunctionExpression)->at(0),
                                                                                 f:FunctionExpression[1] |$f])->evaluateAndDeactivate())->routeValueSpecification($fromExecutionContext, $vars, $inScopeVars, $extensions, $debug);
                let valueSpec              = $processedFunction.value;
                let wrappedValueSpec       = $valueSpec->evaluateAndDeactivate()->match([
                                                          evs: ExtendedRoutedValueSpecification[1] | $evs,
                                                          vs: ValueSpecification[1]                | $processedFunction.routingStrategy.wrapValueSpec($vs, 'from wrapper', $executionContext, $extensions, $debug)
                                                        ]);
                ^$processedFunction(value = $wrappedValueSpec);
        }
    ),
    pair(fe:FunctionExpression[1] | $fe.func->in(meta::pure::graphFetch::execution::graphFetchFunctions()),
      {f:Function<Any>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |

            let processedFunction  = routeFunctionExpressionFunctionDefinition($f, $fe, $state, $executionContext, $vars, $inScopeVars, $extensions, $debug);
            let valueSpec = $processedFunction.value->toOne();

            let x  = if($valueSpec->meta::pure::functions::meta::instanceOf(StoreMappingRoutedValueSpecification),
            |
              let funcExpression = $valueSpec->cast(@StoreMappingRoutedValueSpecification)->evaluateAndDeactivate().value;
              let params = $funcExpression->cast(@SimpleFunctionExpression).parametersValues;
              let rootGraphFetchTree = $params->at(1)->cast(@InstanceValue).values->cast(@RootGraphFetchTree<Any>);
              let routingStrategy    = $processedFunction.routingStrategy->cast(@StoreMappingRoutingStrategy);
              let mapping            = $routingStrategy.mapping;
              let permSetsHavingRootClassImpl  = $routingStrategy.sets->filter(x | $x.sets->exists(setImpl | $setImpl.class == $rootGraphFetchTree.class));
              let permSetsNotHavingRootClassImpl =  $routingStrategy.sets->filter(x | !$x->in($permSetsHavingRootClassImpl));


              let resolvedPermSetsHavingRootClassImpl = $permSetsHavingRootClassImpl->map(pSet | ^$pSet(sets = $pSet.sets->map(s |  let setImplToBeProcessed = [inheritance_OperationSetImplementation_1__SetImplementation_MANY_,union_OperationSetImplementation_1__SetImplementation_MANY_];
                                                                                                                                    assert(!($rootGraphFetchTree.subTypeTrees->size() > 0 && !($s->instanceOf(OperationSetImplementation) && $s->cast(@OperationSetImplementation).operation->in($setImplToBeProcessed))), 'union or inheritance mapping should be used with subTypeGraphFetchTree');
                                                                                                                                    if($s->instanceOf(OperationSetImplementation) && $s->cast(@OperationSetImplementation).operation->in($setImplToBeProcessed),
                                                                                                                                      | $s->resolveOperation($mapping),
                                                                                                                                      | $s
                                                                                                                                    );
                                                                                                                              )
                                                                                                       );
                                                                                          );
              ^$processedFunction(routingStrategy = ^$routingStrategy(sets = $resolvedPermSetsHavingRootClassImpl->concatenate($permSetsNotHavingRootClassImpl)));,
            | $processedFunction);
      }
    ),
    pair(fe:FunctionExpression[1] | $fe.func->in(meta::pure::mutation::mutationFunctions()),
        {f:Function<Any>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |
                let prevalFunc = $fe->preval($inScopeVars, $extensions, $debug)->cast(@SimpleFunctionExpression);

                let mapping = $prevalFunc.parametersValues->at(2)->cast(@InstanceValue).values->toOne()->cast(@Mapping);
                let runtime = $prevalFunc.parametersValues->at(3)->cast(@InstanceValue).values->toOne()->match([runtime:Runtime[1] | $runtime, packageableRuntime:PackageableRuntime[1] | $packageableRuntime.runtimeValue]);

                let currentRoutingStrategy = $state.routingStrategy;
                let newRoutingStrategy     = getRoutingStrategyFromMappingAndRuntime($currentRoutingStrategy, $mapping, $runtime, $extensions);
                let processedFirstParam  = processCollection($state, $fe.parametersValues->at(0), $executionContext, $vars, $inScopeVars, {x:Any[1] | true}, $extensions, $debug)->toOne();

                let processedSave = ^$fe(parametersValues = $processedFirstParam.value->cast(@ValueSpecification)->concatenate($fe.parametersValues->tail()));
                let routedSave =
                  ^StoreMappingRoutedValueSpecification(
                    executionContext = $executionContext,
                    routingStrategy = $newRoutingStrategy,
                    id = $fe->id(),
                    multiplicity = $fe.multiplicity,
                    genericType = $fe.genericType,
                    value = $processedSave,
                    mapping = $mapping,
                    runtime = $runtime
                  );
                ^$processedFirstParam(
                  routingStrategy = $newRoutingStrategy,
                  value           = $routedSave);
        }
    ),
    pair(
      {fe:FunctionExpression[1] | $fe.func->in([projectFunctions()])},
      {f:Function<Any>[1], fe:FunctionExpression[1], state:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], vars:Map<VariableExpression, ValueSpecification>[1], inScopeVars:Map<String, List<Any>>[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1] |
        let processedFunction = $f->routeFunctionExpressionFunctionDefinition($fe, $state, $executionContext, $vars, $inScopeVars->putAll($f->openVariableValues()), $extensions, $debug);
        let processedExpr = $processedFunction.value->evaluateAndDeactivate()->match([
          {rfe: FunctionExpression[1] | 
            $rfe.parametersValues->evaluateAndDeactivate()->at(0)->match([
              {smrv: StoreMappingRoutedValueSpecification[1] |
                if (($smrv.sets->size() == 1) && $smrv.sets->toOne()->instanceOf(OperationSetImplementation) && ($smrv.sets->toOne()->cast(@OperationSetImplementation).operation == meta::pure::router::operations::special_union_OperationSetImplementation_1__SetImplementation_MANY_),
                    | let opSet = $smrv.sets->toOne()->cast(@OperationSetImplementation);
                      let resolvedSets = $opSet->resolveOperation($smrv.mapping);
                      let filteredGetAllClass = $smrv->fetchFilteredGetAllClass();
                      if ($filteredGetAllClass->isNotEmpty(),
                          | if ($resolvedSets->size() > 1,
                                | print(if($debug.debug,|$debug.space+'Identified project function with root class \'' + $filteredGetAllClass->toOne()->elementToPath() + '\' mapped as a special_union with sets ' + $resolvedSets.id->joinStrings('[', ', ', ']') + '. Converting to concatenation query on individual sets.\n',|''));
                                  let routedSubExpressions = $resolvedSets->map({rset |
                                    let newDebug = $debug->indent();
                                    print(if($newDebug.debug,|$newDebug.space+'Routing query with root set (' + $rset.id + ')\n',|''));
                                    let openVars = $inScopeVars->putAll($f->openVariableValues());
                                    let singleSetRoutingStrategy = getRoutingStrategyFromMappingAndRuntime($smrv.mapping->updateRouterUnionSetWithSingleSet($opSet.id, $rset.id), $smrv.runtime);
                                    let singleSetProcessedFunc = $f->routeFunctionExpressionFunctionDefinition($fe, ^$state(routingStrategy = $singleSetRoutingStrategy), $executionContext, $vars, $openVars, $extensions, $newDebug);
                                    let result = $singleSetProcessedFunc.routingStrategy.wrapValueSpec($singleSetProcessedFunc.value->evaluateAndDeactivate()->at(0)->cast(@ValueSpecification), 'special_unon_project_wrapper', $singleSetProcessedFunc.executionContext, $extensions, $newDebug->indent())->evaluateAndDeactivate()
                                      ->enrichExpressionWithStrategyBasedEnrichment($singleSetProcessedFunc.executionContext, $extensions, $newDebug->indent())->evaluateAndDeactivate()
                                      ->clusterFunctionExpressions($openVars, $singleSetProcessedFunc.executionContext, $extensions, $newDebug->indent())->evaluateAndDeactivate();
                                    print(if($newDebug.debug,|$newDebug.space+'Routing result with root set (' + $rset.id + '): ' + $result->map(r | $r->meta::pure::router::printer::asString())->joinStrings('[', ', ', ']') + '\n',|''));
                                    $result;
                                  });
                                  let routingStrategy = $smrv.routingStrategy->cast(@StoreMappingRoutingStrategy);
                                  ^$processedFunction(value = buildConcatenate($routedSubExpressions, $fe.genericType), routingStrategy=^$routingStrategy(sets = []));,
                                | $processedFunction
                            ),
                          | $processedFunction
                      );,
                    | $processedFunction
                )
              },
              {a: Any[*] | $processedFunction}
            ])
          },
          {a: Any[*] | $processedFunction}
        ]);
      }
    )
  ];
}

function <<access.private>> meta::pure::router::store::routing::updateRouterUnionSetWithSingleSet(m: Mapping[1], opSetId: String[1], paramSetId: String[1]): Mapping[1]
{
  ^$m
  (
    classMappings = $m.classMappings->map({cm |
      if (($cm.id == $opSetId) && $cm->instanceOf(OperationSetImplementation) && ($cm->cast(@OperationSetImplementation).operation == meta::pure::router::operations::special_union_OperationSetImplementation_1__SetImplementation_MANY_),
          | let rSet = $cm->cast(@OperationSetImplementation);
            ^$rSet(parameters = $rSet.parameters->filter(p | $p.id == $paramSetId));,
          | $cm
      )
    }),
    includes = $m.includes->map(i | ^$i(included = $i.included->updateRouterUnionSetWithSingleSet($opSetId, $paramSetId)))
  )
}

function <<access.private>> meta::pure::router::store::routing::buildConcatenate(v: ValueSpecification[*], type: GenericType[1]): ValueSpecification[1]
{
  let isRelation = $type.rawType->isNotEmpty() && ($type.rawType->toOne()->elementToPath() == 'meta::pure::metamodel::relation::Relation');
  let func =  if($isRelation, | 'meta::pure::functions::relation::concatenate_Relation_1__Relation_1__Relation_1_', | 'meta::pure::tds::concatenate_TabularDataSet_1__TabularDataSet_1__TabularDataSet_1_')->pathToElement()->cast(@Function<Any>);
  $v->tail()->fold({a, b|
    ^SimpleFunctionExpression(
      func = $func,
      functionName = 'concatenate',
      genericType = $type,
      multiplicity = PureOne,
      importGroup = system::imports::coreImport,
      parametersValues = [$b, $a]->evaluateAndDeactivate()
    )->evaluateAndDeactivate();
  }, $v->head()->toOne());
}

function <<access.private>> meta::pure::router::store::routing::fetchFilteredGetAllClass(vs: ValueSpecification[1]): Class<Any>[0..1]
{
  $vs->byPassRouterInfo()->match([
    {fe: FunctionExpression[1] |
      if (
        [
          pair(
            {|$fe.func == meta::pure::functions::collection::filter_T_MANY__Function_1__T_MANY_},
            {|$fe.parametersValues->evaluateAndDeactivate()->at(0)->fetchFilteredGetAllClass()}
          ),
          pair(
            {|$fe.func->meta::pure::router::routing::isGetAllFunction()},
            {|
              $fe.parametersValues->evaluateAndDeactivate()->at(0)->meta::pure::router::utils::deepByPassRouterInfo()->match([
                iv: InstanceValue[1] | $iv.values->evaluateAndDeactivate()->match([cls: Class<Any>[1] | $cls, a: Any[*] | []]),
                a: Any[*] | []
              ])
            }
          )
        ],
        {|[]}
      )
    },
    {a: Any[*] | []}
  ])
}

// ===================================================================================
// Helper Functions
// ===================================================================================

function meta::pure::router::store::routing::processProperty(p:AbstractProperty<Any>[1], i:InstanceValue[1], state:RoutingState[1], executionContext:meta::pure::runtime::ExecutionContext[1], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):RoutingState[1]
{
   let mapping = $state.routingStrategy->cast(@StoreMappingRoutingStrategy).mapping;
   let runtime = $state.routingStrategy->cast(@StoreMappingRoutingStrategy).runtime;

   let s             = $state.propertyMap.v->filter(p|$p.first == '__propertyOwner').second->evaluateAndDeactivate();
   let permSets      = if($s == 0,|[]->cast(@SetImplementation), |$s->cast(@StoreMappingRoutedValueSpecification).sets);
   let foundMappings = $p->findMappingsFromProperty($mapping, $permSets, $state, $extensions);

   if($foundMappings->isEmpty(),
      | let found = $state.propertyMap.v->filter(p|$p.first == '__propertyOwner').second->evaluateAndDeactivate();
        if($found == 0,
           | ^$state(value=$i),
           | let res = $found->toOne()->cast(@StoreMappingRoutedValueSpecification);
             print(if($debug.debug,|$debug.space+'~>P '+$p.name->toOne()+') ('+$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$res->evaluateAndDeactivate()->asString()+'\n',|''));
             ^$state(value=^$res(value = $i));
        );,
      | let existingSet = $state->findExistingSet($debug);

        let newSet = if ($existingSet->isEmpty(),|^PermutationSet(id = $state.counter+1, sets = $foundMappings),|[]);

        let currentRoutingStrategy = $state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne();
        let updatedRoutingStrategy = ^$currentRoutingStrategy(setsByDepth = if($existingSet->isEmpty(),
                                                                              | let setByD = $state.routingStrategy->cast(@StoreMappingRoutingStrategy).setsByDepth;
                                                                                $setByD->put(getSetPath($state), $newSet->toOne());,
                                                                              | $state.routingStrategy->cast(@StoreMappingRoutingStrategy)->toOne().setsByDepth
                                                                            ),
                                                              sets = if ($existingSet->isEmpty(),|$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->add($newSet->toOne()),|$state.routingStrategy->cast(@StoreMappingRoutingStrategy).sets));

        let routed = ^StoreMappingRoutedValueSpecification(
                                genericType = $i.genericType,
                                multiplicity = $i.multiplicity,
                                id = if ($existingSet->isEmpty(),|$state.counter+1, |$existingSet->toOne())->toString(),
                                sets = $foundMappings,
                                runtime = $runtime,
                                mapping = $mapping,
                                executionContext = $executionContext,
                                value = $i,
                                routingStrategy = $updatedRoutingStrategy
                    );

        let res= ^$state(
              counter = if ($existingSet->isEmpty(),|$state.counter+1, |$state.counter),
              routingStrategy = $updatedRoutingStrategy,
              value = $routed
          );
        print(if($debug.debug,|$debug.space+'~>P '+$p.name->toOne()+') ('+$res.routingStrategy->cast(@StoreMappingRoutingStrategy).sets->size()->toString()+') '+$routed->evaluateAndDeactivate()->asString()+'\n',|''));
        $res;
   );
}

function meta::pure::router::store::routing::isPropertyAutoMapped(srcSets:SetImplementation[*], p:AbstractProperty<Any>[1], extensions:meta::pure::extension::Extension[*], mapping: Mapping[1]): Boolean[1]
{
  $srcSets->size() == 1 
  && (
    isAutoMappedRelationFunctionPropertyMapping($srcSets, $p)
    || (
      // We only support pass through mapping when source set is InstanceSetImpls and not OperationSetImpls
      $srcSets->toOne()->instanceOf(InstanceSetImplementation)
      && !$srcSets->toOne()->instanceOf(RelationFunctionInstanceSetImplementation)
      && $extensions->meta::pure::extension::_storeContractForSetImplementation($srcSets->toOne()).isPropertyAutoMapped->isNotEmpty()
      && $extensions->meta::pure::extension::_storeContractForSetImplementation($srcSets->toOne()).isPropertyAutoMapped->toOne()->eval($p, $srcSets->toOne()->cast(@InstanceSetImplementation))
    )
    || $srcSets->toOne()->instanceOf(OperationSetImplementation) && $srcSets->toOne()->cast(@OperationSetImplementation)->meta::pure::router::routing::resolveOperation($mapping)->forAll(s | $s->isPropertyAutoMapped($p,$extensions, $mapping))
  );
}

function meta::pure::router::store::routing::isAutoMappedRelationFunctionPropertyMapping(set:SetImplementation[*], p:AbstractProperty<Any>[1]):Boolean[1]
{
  $set->match([
    r:RelationFunctionInstanceSetImplementation[1] | $r->_propertyMappingsByPropertyName($p.name->toOne())->match([
      pm: RelationFunctionPropertyMapping[1] | $pm.transformer->isNotEmpty() && $pm.transformer->toOne()->instanceOf(BindingTransformer),
      a: Any[*] | false
    ]),
    a: Any[*] | false
  ])
}

function meta::pure::router::routing::getClassMappings(c:Class<Any>[1], r:RoutingState[1]):SetImplementation[*]
{
   let classMappings = $r.routingStrategy->cast(@StoreMappingRoutingStrategy).classMappingsForClass($c)->concatenate($c.generalizations.general.rawType->cast(@Class<Any>)->map(g|$g->getClassMappings($r)));
   assert($classMappings.class->removeDuplicates()->size() <= 1, 'Expected class mapping for only 1 class [Class: ' + $c.name->toOne() + ']');
   $classMappings;
}

function meta::pure::router::routing::propogateSubType(vs:ValueSpecification[1], subTypeId:String[1], subTypeSets:SetImplementation[*], extensions:meta::pure::extension::Extension[*]): ValueSpecification[1]
{
    $vs->evaluateAndDeactivate()->match([e: StoreMappingRoutedValueSpecification[1] | let castClass   = $subTypeSets->at(0).class;
                                                                                      let routedClass = $e.genericType.rawType->toOne();
                                                                                      if($castClass->_subTypeOf($routedClass),| ^$e(sets=$subTypeSets, id=$subTypeId, value=$e.value->evaluateAndDeactivate()->propogateSubType($subTypeId, $subTypeSets, $extensions));,|$e);,
                                         f: SimpleFunctionExpression[1] |if(shouldStop($f.func, $extensions),
                                                                            |$f,
                                                                            |let func = $f.func;
                                                                             let newFunc = if($func->instanceOf(FunctionDefinition),
                                                                                              |let fd=$func->cast(@FunctionDefinition<Any>);
                                                                                               let newEs=$fd.expressionSequence->map(e|$e->propogateSubType($subTypeId,$subTypeSets, $extensions));
                                                                                               ^$fd(expressionSequence=$newEs);,
                                                                                              |$func
                                                                                            );
                                                                             ^$f(func=$newFunc, parametersValues=$f.parametersValues->map(p|$p->propogateSubType($subTypeId,$subTypeSets, $extensions))););,
                                         vs: ValueSpecification[1] | $vs
                                       ])->cast(@ValueSpecification);
}
