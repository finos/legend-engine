// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::legend::service::metamodel::*;

import meta::relational::runtime::*;
import meta::relational::metamodel::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::datatype::*;
import meta::pure::alloy::connections::alloy::specification::*;

import meta::pure::persistence::metamodel::*;
import meta::pure::persistence::metamodel::trigger::*;
import meta::pure::persistence::metamodel::notifier::*;
import meta::pure::persistence::metamodel::persister::*;
import meta::pure::persistence::metamodel::persister::sink::*;
import meta::pure::persistence::metamodel::persister::targetshape::*;
import meta::pure::persistence::metamodel::persister::deduplication::*;
import meta::pure::persistence::metamodel::persister::ingestmode::*;
import meta::pure::persistence::metamodel::persister::ingestmode::snapshot::*;
import meta::pure::persistence::metamodel::persister::audit::*;
import meta::pure::persistence::metamodel::persister::transactionmilestoning::*;

import meta::external::persistence::aws::metamodel::connection::*;

import meta::external::persistence::aws::cnas::generation::*;
import meta::external::persistence::aws::cnas::spec::*;
import meta::external::persistence::aws::cnas::serialization::*;

import meta::pure::alloy::connections::*;
import meta::pure::functions::meta::*;
import meta::pure::runtime::*;
import meta::pure::store::*;


function  meta::external::persistence::aws::cnas::serialization::serialize(config: AwsPersistenceConfig[1], pc: PersistenceContext[1]): meta::external::persistence::aws::cnas::spec::AwsPersistenceContext[1]
{
  assertInstanceOf($pc.platform, meta::external::persistence::aws::metamodel::AwsGluePersistencePlatform, |'Expected only AwsGluePersistencePlatform in the persistence context');
  let platform = $pc.platform->cast(@meta::external::persistence::aws::metamodel::AwsGluePersistencePlatform);

  let p = $pc.persistence;
  let notifier = $p.notifier;
  let nonpd = $notifier.notifyees->filter(n|!$n->instanceOf(PagerDutyNotifyee));
  assertEmpty($nonpd, | 'Cloud persistence can currently only support PagerDuty notifees');

  assert($p.persister->instanceOf(BatchPersister), | 'Cloud persistence can currently only handle batch persistence');
  let bp = $p.persister->cast(@BatchPersister);

  let apt = $config->serializeShape($bp, $pc.sinkConnection);

  let mc = $config->getModelClass($bp);

  let as = $config->annotatedService($p.service, $mc);

  let jp = ^meta::external::persistence::aws::cnas::spec::AwsPersistence(
      documentation=$p.documentation,
      notifier=$p.notifier,
      trigger=$p.trigger,
      service=$as,
      target=$apt
    );
  
  ^meta::external::persistence::aws::cnas::spec::AwsPersistenceContext(
      persistence=$jp,
      platform = $platform,
      serviceParameters = $pc.serviceParameters,
      sinkConnection = $pc.sinkConnection
    );
}

function <<access.private>> meta::external::persistence::aws::cnas::serialization::annotatedService(config: AwsPersistenceConfig[1], s: Service[1], mc: meta::external::persistence::aws::cnas::spec::ModelClass[1..*]): meta::external::persistence::aws::cnas::spec::AwsPersistenceService[1]
{
  ^meta::external::persistence::aws::cnas::spec::AwsPersistenceService(
    service = $s,
    modelClass = $mc
  );
}


function <<access.private>> meta::external::persistence::aws::cnas::serialization::serializeShape(config: AwsPersistenceConfig[1], bp: BatchPersister[1], conn: Connection[0..1]): meta::external::persistence::aws::cnas::spec::AwsPersistenceTarget[1..*]
{
  assert($bp.targetShape->instanceOf(FlatTarget), | 'Cloud persistence can currently only handle flat target shapes');
  let ft = $bp.targetShape->cast(@FlatTarget);

  let canHandle = 'NontemporalSnapshot, UnitemporalSnapshot';
  $bp.ingestMode->match([
    u:UnitemporalSnapshot[1]|assert($u.transactionMilestoning->instanceOf(BatchIdTransactionMilestoning), 'In FlatTarget %s, for UnitemporalSnapshot, only BatchIdTransactionMilestoning is supported', [$ft.targetName]),
    n:NontemporalSnapshot[1]|assert($n.auditing->instanceOf(NoAuditing), 'In FlatTarget %s, for NontemporalSnapshot, only NoAuditing is supported', [$ft.targetName]),
    a:Any[*]|assert(false, 'Cloud persistence can currently only handle %s milestoning in FlatTarget <%s>', [$canHandle, $ft.targetName])
  ]);

  let apt = $config->serializeAwsPersistenceTarget($ft, $bp.sink, $conn, $bp.ingestMode);
  $apt->toOneMany();
}


function <<access.private>> meta::external::persistence::aws::cnas::serialization::serializeAwsPersistenceTarget(config: AwsPersistenceConfig[1], ft: FlatTarget[1], ts: Sink[1], conn: Connection[0..1], im: IngestMode[1]): meta::external::persistence::aws::cnas::spec::AwsPersistenceTarget[1]
{
  assertSize($ft.modelClass, 1, 'Expecting exactly one modelClass, found %s', [$ft.modelClass->size()]);
  let modelClass = $ft.modelClass->toOne();
  
  assert($ft.deduplicationStrategy->instanceOf(NoDeduplicationStrategy), 'Cloud persistence can currently only handle NoDeduplicationStrategy in FlatTarget <%s>', [$ft.targetName]);

  ^meta::external::persistence::aws::cnas::spec::AwsPersistenceTarget(
      name = $ft.targetName,
      connection = $config->getTargetConnection($ts, $conn, $modelClass),
      deduplicationStrategy=$ft.deduplicationStrategy,
      ingestMode = $im
    );
}

function <<access.private>> meta::external::persistence::aws::cnas::serialization::getModelClass(config: AwsPersistenceConfig[1], bp: BatchPersister[1]): meta::external::persistence::aws::cnas::spec::ModelClass[1..*]
{
  assert($bp.targetShape->instanceOf(FlatTarget), | 'Cloud persistence can currently only handle flat target shapes');
  let ft = $bp.targetShape->cast(@FlatTarget);

  // Note: This can be common validation for all persistence code generators
  assertNotEmpty($ft.modelClass, |'Expecting a ModelClass in the BatchPersister but found none');
  assertSize($ft.modelClass, 1, 'Expecting exactly one modelClass, found %s', [$ft.modelClass->size()]);
  let modelClass = $ft.modelClass->toOne();
  assert($modelClass.generalizations.general.rawType == Any, | 'AwsPersistence requires the class in targetShape to not be generalized (i.e., not extend another class)');
  assertSize($modelClass.name, 1, 'Expecting exactly one modelClass name, found %s', [$modelClass.name->size()]);
  assertSize($modelClass.package, 1, 'Expecting exactly one modelClass package, found %s', [$modelClass.package->size()]);

  let properties = $modelClass.properties;
  let nonprimitives = $properties->filter(p|! $p.genericType.rawType->toOne()->instanceOf(PrimitiveType));
  assertEmpty($nonprimitives, 'Found non-primitive types in FlatTarget <%s>, only primitive types can be persisted', [$ft.targetName]);

  let pts = $properties->map(p|
    assertSize($p.name, 1, 'In FlatTarget <%s>, expected exactly one property name, found %s', [$ft.targetName, $p.name->size()]);
    assertSize($p.genericType.rawType, 1, 'In FlatTarget <%s> for property <%s>, expected exactly one type, found %s', [$ft.targetName, $p.name->toOne(), $p.genericType.rawType->size()]);
    ^meta::external::persistence::aws::cnas::spec::ModelClassProperty(name=$p.name->toOne(), type=$p.genericType.rawType->toOne());
  );
  
  let mc = ^meta::external::persistence::aws::cnas::spec::ModelClass(name=$ft.modelClass.name->toOne(), package=$ft.modelClass.package->toOne(), properties=$pts);

  $mc;
}

function <<access.private>> meta::external::persistence::aws::cnas::serialization::getTargetConnection(config: AwsPersistenceConfig[1], ts: Sink[1], conn: Connection[0..1], modelClass: Class<Any>[1]): meta::external::persistence::aws::cnas::spec::AwsPersistenceTargetConnection[1]
{
  let aptc = $ts->match([
    sink:RelationalSink[1]|
      assertNotEmpty($conn, |'Expecting Connection in Relational Sink, found none');
      let c = $conn->toOne();
      $c->match([
        rdb:RelationalDatabaseConnection[1]|
          if ($rdb.type == DatabaseType.Snowflake || $rdb.type == DatabaseType.Redshift,
            | $config->getDbConnection($rdb, $modelClass),
            | assert(false,'Cloud persistence can currently only handle RelationalDB targets of type Snowflake or Redshift');
              [];
            ),
        x:Any[1]|
          assert(false,'Expected only a Relational connection in a Relational sink');
          [];
      ]);,
    sink:ObjectStorageSink[1]|
      // We have a connection and a binding for sure
      let c = $conn->toOne();
      assertInstanceOf($c, meta::external::persistence::aws::metamodel::connection::AwsS3Connection, |'Expected only S3 connection in an object storage sink');
      let s3 = $c->cast(@meta::external::persistence::aws::metamodel::connection::AwsS3Connection);
      let ct = $sink.binding.contentType;
      ^meta::external::persistence::aws::cnas::spec::S3Connection(
        partition = $s3.partition,
        region = $s3.region,
        bucket = $s3.bucket,
        key = $s3.key,
        contentType = $sink.binding.contentType
      );,
    sink:FinancialCloudSink[1]|
      // We have a connection for sure
      let c = $conn->toOne();
      assertInstanceOf($c, meta::external::persistence::aws::metamodel::connection::AwsFinCloudConnection, |'Expected only FinCloud connection in a FinCloud sink');
      let fc = $c->cast(@meta::external::persistence::aws::metamodel::connection::AwsFinCloudConnection);
      ^meta::external::persistence::aws::cnas::spec::AwsFinCloudConnection(
        datasetId = $fc.datasetId,
        authenticationStrategy = $fc.authenticationStrategy,
        apiUrl = $fc.apiUrl,
        queryInfo = $fc.queryInfo
      );,
    x:Any[1]|
      assert(false,'Can only handle Relational, Object Storage, or Financial Cloud sinks');
      [];
  ]);

  assertNotEmpty($aptc, |'Unexpectedly found no target connection');
  $aptc->toOne();
}


function <<access.private>> meta::external::persistence::aws::cnas::serialization::getDbConnection(config: AwsPersistenceConfig[1], rdb: RelationalDatabaseConnection[1], modelClass: Class<Any>[1]): meta::external::persistence::aws::cnas::spec::RelationalConnection[1]
{
  assertInstanceOf($rdb.element, meta::relational::metamodel::Database, 'Expected engine to present element with type Database, instead found type %s', [ $rdb.element->type() ]);
  let db = $rdb.element->cast(@Database);
  let x = $config.allPackageScopeElements()->filter(p|$p->instanceOf(Store) && $p->fullPackageName('::')==$db->fullPackageName('::'));
  assertSize($x, 1, 'Expected exactly one store in Connection, found <%d> (should be precluded by engine pureModel construction)', [$x->size()]);
  let store = $x->toOne()->cast(@Database);
  let storeName = $store->fullPackageName('::');

  // The databasename is specified in the SnowflakeDatasourceSpecification or RedshiftDatasourceSpecification
  // The schema is specified in the Store specification. We were enforcing the convention that the tablename 
  // in the database corresponds to the modelclass name in the Persister, and then check to make sure exactly 
  // one such schema exists. But with modelclass up in the air, don't do this check for now. Here is what
  // it would look like for Snowflake:
  //          let dbName = $rdb.datasourceSpecification->cast(@SnowflakeDatasourceSpecification).databaseName;
  //          let schemas = $store.schemas->filter(s|$s.name == $dbName);
  //          assertSize($schemas, 1, 'In store <%s>, expected a schema with name <%s> as that is the name provided in the datasourceSpecification, instead found <%s>', [$storeName, $dbName, $store.schemas->fold({item,accum|$accum->concatenate($item.name)}, [])->makeString(',')]);

  let tables = $store.schemas->fold({item, accum|$accum->concatenate($item.tables)} , []);
  assertNotEmpty($tables, 'In connection which points to store <%s>, expected to see at least one table but found none', [ $storeName ]);

  let t = if ($tables->size() == 1,
    | $tables->toOne(), // The schema containing this table is the schema we will use
    | $config->getTableForModelClass($tables, $modelClass, $storeName);
  );

  // Here is where we would validate the model class against the store types through the mapping. Doing so is non-trivial
  // $config->validateRelationalTargetWithModel($t, $modelClass, $storeName);

  let targetRelType = $t.columns->cast(@Column)->map(c|^meta::external::persistence::aws::cnas::spec::RelationalProperty(name=$c.name, sqlType=$c.type->meta::relational::metamodel::datatype::dataTypeToSqlText()));

  ^meta::external::persistence::aws::cnas::spec::RelationalConnection(
    schemaName = $t.schema.name,
    tableName = $t.name,
    authenticationStrategy = $rdb.authenticationStrategy,
    targetSpecification = $rdb.datasourceSpecification,
    columns = $targetRelType
  );  
}

function <<access.private>> meta::external::persistence::aws::cnas::serialization::getTableForModelClass(config: AwsPersistenceConfig[1], tables: Table[*], modelClass: Class<Any>[1], storeName: String[1]): Table[1]
{
  let mcn = $modelClass.name->toOne();
  let t = $tables->filter(t|$t.name == $modelClass.name);
  assertSize($t, 1, 'Of the <%d> total tables provided across all schemas for store <%s>, none match the modelclass name of <%s>', [$tables->size(), $storeName, $mcn]);
  $t->toOne();
}

