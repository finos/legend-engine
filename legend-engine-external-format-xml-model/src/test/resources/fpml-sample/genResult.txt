>>>test::gen::Account
Class {meta::pure::profiles::doc.doc = 'A generic account that represents any party\'s account at another party. Parties may be identified by the account at another party.'} test::gen::Account
[
  c1_choice: $this.accountBeneficiary->isNotEmpty() || ($this.accountBeneficiary->isEmpty() && $this.servicingParty->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'An account identifier. For example an Account number.'} accountId: test::gen::AccountId[1..*];
  {meta::pure::profiles::doc.doc = 'The name by which the account is known.'} accountName: test::gen::AccountName[0..1];
  {meta::pure::profiles::doc.doc = 'The type of account. e.g., Client, House'} accountType: test::gen::AccountType[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party beneficiary of the account.'} accountBeneficiary: test::gen::PartyReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party that services/supports the account.'} servicingParty: test::gen::PartyReference[0..1];
  {meta::pure::profiles::doc.doc = 'The unique identifier for the account within the document.'} id: String[1];
}

>>>test::gen::AccountId
Class {meta::pure::profiles::doc.doc = 'The data type used for account identifiers.'} test::gen::AccountId
[
  c1_length: $this.accountIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  {meta::pure::profiles::doc.doc = 'The identifier scheme used with this accountId. A unique URI to determine the authoritative issuer of these identifiers.'} accountIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::AccountName
Class {meta::pure::profiles::doc.doc = 'The data type used for the name of the account.'} test::gen::AccountName
[
  c1_length: $this.accountNameScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  {meta::pure::profiles::doc.doc = 'The identifier scheme used with this accountName. A unique URI to determine the source of the account name.'} accountNameScheme: String[0..1];
  value: String[1];
}

>>>test::gen::AccountReference
Class {meta::pure::profiles::doc.doc = 'Reference to an account.'} test::gen::AccountReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::AccountType
Class {meta::pure::profiles::doc.doc = 'The data type used for account type.'} test::gen::AccountType
[
  c1_length: $this.accountTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  {meta::pure::profiles::doc.doc = 'The identifier scheme used with this accountType. A unique URI to determine the the type of account.'} accountTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::AccrualReferenceAmountTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The type of automatic adjustment that a Letter of Credit can exhibit.'} test::gen::AccrualReferenceAmountTypeEnum
{
  Commitment,
  Funded,
  Other,
  Unfunded,
  Unutilized,
  Utilized
}

>>>test::gen::ActionType
Class {meta::pure::profiles::doc.doc = 'The data type used for ESMA action type.'} test::gen::ActionType
[
  c1_length: $this.value->length() <= 255
]
{
  {meta::pure::profiles::doc.doc = 'The identifier scheme used with this actionType. A unique URI to determine the the type of action.'} actionTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::Address
Class {meta::pure::profiles::doc.doc = 'A type that represents a physical postal address.'} test::gen::Address
[
  c1_length: $this.city->forAll(x: String[1]|$x->length() <= 255),
  c2_length: $this.state->forAll(x: String[1]|$x->length() <= 255),
  c3_length: $this.postalCode->forAll(x: String[1]|$x->length() <= 255)
]
{
  {meta::pure::profiles::doc.doc = 'The set of street and building number information that identifies a postal address within a city.'} streetAddress: test::gen::StreetAddress[0..1];
  {meta::pure::profiles::doc.doc = 'The city component of a postal address.'} city: String[0..1];
  {meta::pure::profiles::doc.doc = 'A country subdivision used in postal addresses in some countries. For example, US states, Canadian provinces, Swiss cantons.'} state: String[0..1];
  {meta::pure::profiles::doc.doc = 'The ISO 3166 standard code for the country within which the postal address is located.'} country: test::gen::CountryCode[0..1];
  {meta::pure::profiles::doc.doc = 'The code, required for computerised mail sorting systems, that is allocated to a physical address by a national postal authority.'} postalCode: String[0..1];
}

>>>test::gen::AdjustableDate
Class {meta::pure::profiles::doc.doc = 'A type for defining a date that shall be subject to adjustment if it would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.'} test::gen::AdjustableDate
{
  {meta::pure::profiles::doc.doc = 'A date subject to adjustment.'} unadjustedDate: test::gen::IdentifiedDate[1];
  {meta::pure::profiles::doc.doc = 'The business day convention and financial business centers used for adjusting the date if it would otherwise fall on a day that is not a business date in the specified business centers.'} dateAdjustments: test::gen::BusinessDayAdjustments[1];
  {meta::pure::profiles::doc.doc = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).'} adjustedDate: test::gen::IdentifiedDate[0..1];
  id: String[0..1];
}

>>>test::gen::AdjustableDate2
Class {meta::pure::profiles::doc.doc = 'A type that is different from AdjustableDate in two regards. First, date adjustments can be specified with either a dateAdjustments element or a reference to an existing dateAdjustments element. Second, it does not require the specification of date adjustments.'} test::gen::AdjustableDate2
[
  c1_choice: ($this.dateAdjustments->isNotEmpty() && $this.dateAdjustmentsReference->isEmpty()) || ($this.dateAdjustments->isEmpty() && $this.dateAdjustmentsReference->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'A date subject to adjustment.'} unadjustedDate: test::gen::IdentifiedDate[1];
  {meta::pure::profiles::doc.doc = 'The business day convention and financial business centers used for adjusting the date if it would otherwise fall on a day that is not a business dat in the specified business centers.'} dateAdjustments: test::gen::BusinessDayAdjustments[0..1];
  {meta::pure::profiles::doc.doc = 'A pointer style reference to date adjustments defined elsewhere in the document.'} dateAdjustmentsReference: test::gen::BusinessDayAdjustmentsReference[0..1];
  {meta::pure::profiles::doc.doc = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).'} adjustedDate: test::gen::IdentifiedDate[0..1];
  id: String[0..1];
}

>>>test::gen::AdjustableDates
Class {meta::pure::profiles::doc.doc = 'A type for defining a series of dates that shall be subject to adjustment if they would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the dates.'} test::gen::AdjustableDates
{
  {meta::pure::profiles::doc.doc = 'A date subject to adjustment.'} unadjustedDate: test::gen::IdentifiedDate[1..*];
  {meta::pure::profiles::doc.doc = 'The business day convention and financial business centers used for adjusting the date if it would otherwise fall on a day that is not a business dat in the specified business centers.'} dateAdjustments: test::gen::BusinessDayAdjustments[1];
  {meta::pure::profiles::doc.doc = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).'} adjustedDate: test::gen::IdentifiedDate[*];
  id: String[0..1];
}

>>>test::gen::AdjustableDatesOrRelativeDateOffset
Class {meta::pure::profiles::doc.doc = 'A type for defining a series of dates, either as a list of adjustable dates, or a as a repeating sequence from a base date'} test::gen::AdjustableDatesOrRelativeDateOffset
[
  c1_choice: ($this.adjustableDates->isNotEmpty() && $this.relativeDate->isEmpty()) || ($this.adjustableDates->isEmpty() && $this.relativeDate->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'A series of adjustable dates'} adjustableDates: test::gen::AdjustableDates[0..1];
  {meta::pure::profiles::doc.doc = 'A series of dates specified as a repeating sequence from a base date.'} relativeDate: test::gen::RelativeDateOffset[0..1];
}

>>>test::gen::AdjustableOrAdjustedDate
Class {meta::pure::profiles::doc.doc = 'A type for defining a date that shall be subject to adjustment if it would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.'} test::gen::AdjustableOrAdjustedDate
[
  c1_choice: ($this.unadjustedDate->isNotEmpty() && $this.dateAdjustments->isNotEmpty()) || ($this.unadjustedDate->isEmpty() && ($this.dateAdjustments->isEmpty() && $this.adjustedDate->isNotEmpty()))
]
{
  {meta::pure::profiles::doc.doc = 'A date subject to adjustment.'} unadjustedDate: test::gen::IdentifiedDate[0..1];
  {meta::pure::profiles::doc.doc = 'The business day convention and financial business centers used for adjusting the date if it would otherwise fall on a day that is not a business date in the specified business centers.'} dateAdjustments: test::gen::BusinessDayAdjustments[0..1];
  {meta::pure::profiles::doc.doc = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).'} adjustedDate: test::gen::IdentifiedDate[0..1];
  id: String[0..1];
}

>>>test::gen::AdjustableOrRelativeDate
Class {meta::pure::profiles::doc.doc = 'A type giving the choice between defining a date as an explicit date together with applicable adjustments or as relative to some other (anchor) date.'} test::gen::AdjustableOrRelativeDate
[
  c1_choice: ($this.adjustableDate->isNotEmpty() && $this.relativeDate->isEmpty()) || ($this.adjustableDate->isEmpty() && $this.relativeDate->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'A date that shall be subject to adjustment if it would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.'} adjustableDate: test::gen::AdjustableDate[0..1];
  {meta::pure::profiles::doc.doc = 'A date specified as some offset to another date (the anchor date).'} relativeDate: test::gen::RelativeDateOffset[0..1];
  id: String[0..1];
}

>>>test::gen::AdjustableOrRelativeDates
Class {meta::pure::profiles::doc.doc = 'A type giving the choice between defining a series of dates as an explicit list of dates together with applicable adjustments or as relative to some other series of (anchor) dates.'} test::gen::AdjustableOrRelativeDates
[
  c1_choice: ($this.adjustableDates->isNotEmpty() && $this.relativeDates->isEmpty()) || ($this.adjustableDates->isEmpty() && $this.relativeDates->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'A series of dates that shall be subject to adjustment if they would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.'} adjustableDates: test::gen::AdjustableDates[0..1];
  {meta::pure::profiles::doc.doc = 'A series of dates specified as some offset to another series of dates (the anchor dates).'} relativeDates: test::gen::RelativeDates[0..1];
  id: String[0..1];
}

>>>test::gen::AdjustableRelativeOrPeriodicDates
Class test::gen::AdjustableRelativeOrPeriodicDates
[
  c1_choice: ($this.adjustableDates->isNotEmpty() && ($this.relativeDateSequence->isEmpty() && $this.periodicDates->isEmpty())) || (($this.adjustableDates->isEmpty() && ($this.relativeDateSequence->isNotEmpty() && $this.periodicDates->isEmpty())) || ($this.adjustableDates->isEmpty() && ($this.relativeDateSequence->isEmpty() && $this.periodicDates->isNotEmpty())))
]
{
  {meta::pure::profiles::doc.doc = 'A series of dates that shall be subject to adjustment if they would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.'} adjustableDates: test::gen::AdjustableDates[0..1];
  {meta::pure::profiles::doc.doc = 'A series of dates specified as some offset to other dates (the anchor dates) which can'} relativeDateSequence: test::gen::RelativeDateSequence[0..1];
  periodicDates: test::gen::PeriodicDates[0..1];
  id: String[0..1];
}

>>>test::gen::AdjustableRelativeOrPeriodicDates2
Class {meta::pure::profiles::doc.doc = 'A type giving the choice between defining a series of dates as an explicit list of dates together with applicable adjustments, or as relative to some other series of (anchor) dates, or as a set of factors to specify periodic occurences.'} test::gen::AdjustableRelativeOrPeriodicDates2
[
  c1_choice: ($this.adjustableDates->isNotEmpty() && ($this.relativeDates->isEmpty() && $this.periodicDates->isEmpty())) || (($this.adjustableDates->isEmpty() && ($this.relativeDates->isNotEmpty() && $this.periodicDates->isEmpty())) || ($this.adjustableDates->isEmpty() && ($this.relativeDates->isEmpty() && $this.periodicDates->isNotEmpty())))
]
{
  {meta::pure::profiles::doc.doc = 'A series of dates that shall be subject to adjustment if they would otherwise fall on a day that is not a business day in the specified business centers, together with the convention for adjusting the date.'} adjustableDates: test::gen::AdjustableDates[0..1];
  {meta::pure::profiles::doc.doc = 'A series of dates specified as some offset to another series of dates (the anchor dates).'} relativeDates: test::gen::RelativeDates[0..1];
  periodicDates: test::gen::PeriodicDates[0..1];
  id: String[0..1];
}

>>>test::gen::AdjustedRelativeDateOffset
Class {meta::pure::profiles::doc.doc = 'A type defining a date (referred to as the derived date) as a relative offset from another date (referred to as the anchor date) plus optional date adjustments.'} test::gen::AdjustedRelativeDateOffset extends test::gen::RelativeDateOffset
{
  {meta::pure::profiles::doc.doc = 'The business day convention and financial business centers used for adjusting the relative date if it would otherwise fall on a day that is not a business date in the specified business centers.'} relativeDateAdjustments: test::gen::BusinessDayAdjustments[0..1];
}

>>>test::gen::AmericanExercise
Class {meta::pure::profiles::doc.doc = 'A type defining the exercise period for an American style option together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fees.'} test::gen::AmericanExercise extends test::gen::Exercise
{
  {meta::pure::profiles::doc.doc = 'The first day of the exercise period for an American style option.'} commencementDate: test::gen::AdjustableOrRelativeDate[1];
  {meta::pure::profiles::doc.doc = 'The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.'} expirationDate: test::gen::AdjustableOrRelativeDate[1];
  {meta::pure::profiles::doc.doc = 'The date on the underlying set by the exercise of an option. What this date is depends on the option (e.g. in a swaption it is the swap effective date, in an extendible/cancelable provision it is the swap termination date).'} relevantUnderlyingDate: test::gen::AdjustableOrRelativeDates[0..1];
  {meta::pure::profiles::doc.doc = 'The earliest time at which notice of exercise can be given by the buyer to the seller (or seller\'s agent) i) on the expriation date, in the case of a European style option, (ii) on each bermuda option exercise date and the expiration date, in the case of a Bermuda style option the commencement date to, and including, the expiration date , in the case of an American option.'} earliestExerciseTime: test::gen::BusinessCenterTime[1];
  {meta::pure::profiles::doc.doc = 'For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller\'s agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.'} latestExerciseTime: test::gen::BusinessCenterTime[0..1];
  {meta::pure::profiles::doc.doc = 'The latest time for exercise on expirationDate.'} expirationTime: test::gen::BusinessCenterTime[1];
  {meta::pure::profiles::doc.doc = 'As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more that the maximum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an intergral multiple of, the integral multiple amount.'} multipleExercise: test::gen::MultipleExercise[0..1];
  {meta::pure::profiles::doc.doc = 'The fees associated with an exercise date. The fees are conditional on the exercise occuring. The fees can be specified as actual currency amounts or as percentages of the notional amount being exercised.'} exerciseFeeSchedule: test::gen::ExerciseFeeSchedule[0..1];
}

>>>test::gen::AmountAdjustmentEnum
Enum {meta::pure::profiles::doc.doc = 'The type of adjustment applied to any amount.'} test::gen::AmountAdjustmentEnum
{
  Decrease,
  Increase
}

>>>test::gen::AmountReference
Class {meta::pure::profiles::doc.doc = 'Specifies a reference to a monetary amount.'} test::gen::AmountReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::AmountSchedule
Class {meta::pure::profiles::doc.doc = 'A type defining a currency amount or a currency amount schedule.'} test::gen::AmountSchedule extends test::gen::Schedule
{
  {meta::pure::profiles::doc.doc = 'The currency in which an amount is denominated.'} currency: test::gen::Currency[1];
}

>>>test::gen::AssetClass
Class test::gen::AssetClass
[
  c1_length: $this.assetClassScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  assetClassScheme: String[0..1];
  value: String[1];
}

>>>test::gen::AutomaticExercise
Class {meta::pure::profiles::doc.doc = 'A type to define automatic exercise of a swaption. With automatic exercise the option is deemed to have exercised if it is in the money by more than the threshold amount on the exercise date.'} test::gen::AutomaticExercise
{
  {meta::pure::profiles::doc.doc = 'A threshold rate. The threshold of 0.10% would be represented as 0.001'} thresholdRate: Decimal[1];
}

>>>test::gen::AverageDailyTradingVolumeLimit
Class {meta::pure::profiles::doc.doc = 'To indicate the limitation percentage and limitation period.'} test::gen::AverageDailyTradingVolumeLimit
[
  c1_range: $this.limitationPercentage >= 0,
  c2_range: $this.limitationPercentage <= 1
]
{
  {meta::pure::profiles::doc.doc = 'Specifies the limitation percentage in Average Daily trading volume.'} limitationPercentage: Decimal[1];
  {meta::pure::profiles::doc.doc = 'Specifies the limitation period for Average Daily trading volume in number of days.'} limitationPeriod: Decimal[1];
}

>>>test::gen::AveragingInOutEnum
Enum {meta::pure::profiles::doc.doc = 'The type of averaging used in an Asian option.'} test::gen::AveragingInOutEnum
{
  In,
  Out,
  Both
}

>>>test::gen::AveragingMethodEnum
Enum {meta::pure::profiles::doc.doc = 'The method of calculation to be used when averaging rates. Per ISDA 2000 Definitions, Section 6.2. Certain Definitions Relating to Floating Amounts.'} test::gen::AveragingMethodEnum
{
  Unweighted,
  Weighted
}

>>>test::gen::Beneficiary
Class {meta::pure::profiles::doc.doc = 'A type defining the beneficiary of the funds.'} test::gen::Beneficiary
[
  c1_choice: ($this.routingIds->isNotEmpty() && ($this.routingExplicitDetails->isEmpty() && $this.routingIdsAndExplicitDetails->isEmpty())) || (($this.routingIds->isEmpty() && ($this.routingExplicitDetails->isNotEmpty() && $this.routingIdsAndExplicitDetails->isEmpty())) || ($this.routingIds->isEmpty() && ($this.routingExplicitDetails->isEmpty() && $this.routingIdsAndExplicitDetails->isNotEmpty())))
]
{
  {meta::pure::profiles::doc.doc = 'A set of unique identifiers for a party, eachone identifying the party within a payment system. The assumption is that each party will not have more than one identifier within the same payment system.'} routingIds: test::gen::RoutingIds[0..1];
  {meta::pure::profiles::doc.doc = 'A set of details that is used to identify a party involved in the routing of a payment when the party does not have a code that identifies it within one of the recognized payment systems.'} routingExplicitDetails: test::gen::RoutingExplicitDetails[0..1];
  {meta::pure::profiles::doc.doc = 'A combination of coded payment system identifiers and details for physical addressing for a party involved in the routing of a payment.'} routingIdsAndExplicitDetails: test::gen::RoutingIdsAndExplicitDetails[0..1];
  {meta::pure::profiles::doc.doc = 'Link to the party acting as beneficiary. This element can only appear within the beneficiary container element.'} beneficiaryPartyReference: test::gen::PartyReference[0..1];
}

>>>test::gen::BermudaExercise
Class {meta::pure::profiles::doc.doc = 'A type defining the Bermuda option exercise dates and the expiration date together with any rules govenerning the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fee.'} test::gen::BermudaExercise extends test::gen::Exercise
{
  {meta::pure::profiles::doc.doc = 'The dates the define the Bermuda option exercise dates and the expiration date. The last specified date is assumed to be the expiration date. The dates can either be specified as a series of explicit dates and associated adjustments or as a series of dates defined relative to another schedule of dates, for example, the calculation period start dates. Where a relative series of dates are defined the first and last possible exercise dates can be separately specified.'} bermudaExerciseDates: test::gen::AdjustableOrRelativeDates[1];
  {meta::pure::profiles::doc.doc = 'The date on the underlying set by the exercise of an option. What this date is depends on the option (e.g. in a swaption it is the swap effective date, in an extendible/cancelable provision it is the swap termination date).'} relevantUnderlyingDate: test::gen::AdjustableOrRelativeDates[0..1];
  {meta::pure::profiles::doc.doc = 'The earliest time at which notice of exercise can be given by the buyer to the seller (or seller\'s agent) i) on the expriation date, in the case of a European style option, (ii) on each bermuda option exercise date and the expiration date, in the case of a Bermuda style option the commencement date to, and including, the expiration date , in the case of an American option.'} earliestExerciseTime: test::gen::BusinessCenterTime[1];
  {meta::pure::profiles::doc.doc = 'For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller\'s agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.'} latestExerciseTime: test::gen::BusinessCenterTime[0..1];
  {meta::pure::profiles::doc.doc = 'The latest time for exercise on expirationDate.'} expirationTime: test::gen::BusinessCenterTime[1];
  {meta::pure::profiles::doc.doc = 'As defined in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more that the maximum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an intergral multiple of, the integral multiple amount.'} multipleExercise: test::gen::MultipleExercise[0..1];
  {meta::pure::profiles::doc.doc = 'The fees associated with an exercise date. The fees are conditional on the exercise occuring. The fees can be specified as actual currency amounts or as percentages of the notional amount being exercised.'} exerciseFeeSchedule: test::gen::ExerciseFeeSchedule[0..1];
}

>>>test::gen::BreakageCalculatedByEnum
Enum {meta::pure::profiles::doc.doc = 'When breakage cost is applicable, this defines who is calculating it.'} test::gen::BreakageCalculatedByEnum
{
  Agent_Bank,
  Lender
}

>>>test::gen::BrokerConfirmation
Class {meta::pure::profiles::doc.doc = 'Identifies the market sector in which the trade has been arranged.'} test::gen::BrokerConfirmation
{
  {meta::pure::profiles::doc.doc = 'The type of broker confirmation executed between the parties.'} brokerConfirmationType: test::gen::BrokerConfirmationType[1];
}

>>>test::gen::BrokerConfirmationType
Class {meta::pure::profiles::doc.doc = 'Identifies the market sector in which the trade has been arranged.'} test::gen::BrokerConfirmationType
[
  c1_length: $this.brokerConfirmationTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  brokerConfirmationTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::BullionTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Defines which type of bullion is applicable for a Bullion Transaction.'} test::gen::BullionTypeEnum
{
  Gold,
  Palladium,
  Platinum,
  Silver,
  Rhodium,
  RhodiumSponge,
  Iridium,
  Ruthenium,
  Osmium
}

>>>test::gen::BusinessCenter
Class {meta::pure::profiles::doc.doc = 'A code identifying a business day calendar location. A business day calendar location is drawn from the list identified by the business day calendar location scheme.'} test::gen::BusinessCenter
[
  c1_length: $this.businessCenterScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  businessCenterScheme: String[0..1];
  id: String[0..1];
  value: String[1];
}

>>>test::gen::BusinessCenterTime
Class {meta::pure::profiles::doc.doc = 'A type for defining a time with respect to a business day calendar location. For example, 11:00am London time.'} test::gen::BusinessCenterTime
{
  {meta::pure::profiles::doc.doc = 'A time specified in hh:mm:ss format where the second component must be \'00\', e.g. 11am would be represented as 11:00:00.'} hourMinuteTime: String[1];
  businessCenter: test::gen::BusinessCenter[1];
}

>>>test::gen::BusinessCenters
Class {meta::pure::profiles::doc.doc = 'A type for defining business day calendar used in determining whether a day is a business day or not. A list of business day calendar locations may be ordered in the document alphabetically based on business day calendar location code. An FpML document containing an unordered business day calendar location list is still regarded as a conformant document.'} test::gen::BusinessCenters
{
  businessCenter: test::gen::BusinessCenter[1..*];
  id: String[0..1];
}

>>>test::gen::BusinessCentersReference
Class {meta::pure::profiles::doc.doc = 'A pointer style reference to a set of business day calendar defined elsewhere in the document.'} test::gen::BusinessCentersReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::BusinessDateRange
Class {meta::pure::profiles::doc.doc = 'A type defining a range of contiguous business days by defining an unadjusted first date, an unadjusted last date and a business day convention and business centers for adjusting the first and last dates if they would otherwise fall on a non business day in the specified business centers. The days between the first and last date must also be good business days in the specified centers to be counted in the range.'} test::gen::BusinessDateRange extends test::gen::DateRange
{
  {meta::pure::profiles::doc.doc = 'The convention for adjusting a date if it would otherwise fall on a day that is not a business day.'} businessDayConvention: test::gen::BusinessDayConventionEnum[1];
  {meta::pure::profiles::doc.doc = 'A pointer style reference to a set of financial business centers defined elsewhere in the document. This set of business centers is used to determine whether a particular day is a business day or not.'} businessCentersReference: test::gen::BusinessCentersReference[0..1];
  businessCenters: test::gen::BusinessCenters[0..1];
}

>>>test::gen::BusinessDayAdjustments
Class {meta::pure::profiles::doc.doc = 'A type defining the business day convention and financial business centers used for adjusting any relevant date if it would otherwise fall on a day that is not a business day in the specified business centers.'} test::gen::BusinessDayAdjustments
[
  c1_choice: ($this.businessCentersReference->isNotEmpty() && $this.businessCenters->isEmpty()) || ($this.businessCentersReference->isEmpty() && $this.businessCenters->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'The convention for adjusting a date if it would otherwise fall on a day that is not a business day.'} businessDayConvention: test::gen::BusinessDayConventionEnum[1];
  {meta::pure::profiles::doc.doc = 'A pointer style reference to a set of financial business centers defined elsewhere in the document. This set of business centers is used to determine whether a particular day is a business day or not.'} businessCentersReference: test::gen::BusinessCentersReference[0..1];
  businessCenters: test::gen::BusinessCenters[0..1];
  id: String[0..1];
}

>>>test::gen::BusinessDayAdjustmentsReference
Class {meta::pure::profiles::doc.doc = 'Reference to a business day adjustments structure.'} test::gen::BusinessDayAdjustmentsReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::BusinessDayConventionEnum
Enum {meta::pure::profiles::doc.doc = 'The convention for adjusting any relevant date if it would otherwise fall on a day that is not a valid business day. Note that FRN is included here as a type of business day convention although it does not strictly fall within ISDA\'s definition of a Business Day Convention and does not conform to the simple definition given above.'} test::gen::BusinessDayConventionEnum
{
  FOLLOWING,
  FRN,
  MODFOLLOWING,
  PRECEDING,
  MODPRECEDING,
  NEAREST,
  NONE,
  NotApplicable
}

>>>test::gen::BusinessUnit
Class {meta::pure::profiles::doc.doc = 'A type that represents information about a unit within an organization.'} test::gen::BusinessUnit
[
  c1_length: $this.name->forAll(x: String[1]|$x->length() <= 255)
]
{
  {meta::pure::profiles::doc.doc = 'A name used to describe the organization unit'} name: String[0..1];
  {meta::pure::profiles::doc.doc = 'An identifier used to uniquely identify organization unit'} businessUnitId: test::gen::Unit[0..1];
  {meta::pure::profiles::doc.doc = 'Information on how to contact the unit using various means.'} contactInfo: test::gen::ContactInformation[0..1];
  {meta::pure::profiles::doc.doc = 'The ISO 3166 standard code for the country where the individual works.'} country: test::gen::CountryCode[0..1];
  id: String[0..1];
}

>>>test::gen::BusinessUnitReference
Class {meta::pure::profiles::doc.doc = 'Reference to an organizational unit.'} test::gen::BusinessUnitReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::BusinessUnitRole
Class {meta::pure::profiles::doc.doc = 'A type describing a role played by a unit in one or more transactions. Examples include roles such as Trader, Collateral, Confirmation, Settlement, etc. This can be extended to provide custom roles.'} test::gen::BusinessUnitRole
[
  c1_length: $this.unitRoleScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  unitRoleScheme: String[0..1];
  value: String[1];
}

>>>test::gen::BuySellEnum
Enum test::gen::BuySellEnum
{
  Buyer,
  Seller
}

>>>test::gen::CalculationAgent
Class {meta::pure::profiles::doc.doc = 'A type defining the ISDA calculation agent responsible for performing duties as defined in the applicable product definitions.'} test::gen::CalculationAgent
[
  c1_choice: ($this.calculationAgentPartyReference->isNotEmpty() && $this.calculationAgentParty->isEmpty()) || ($this.calculationAgentPartyReference->isEmpty() && $this.calculationAgentParty->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'A pointer style reference to a party identifier defined elsewhere in the document. The party referenced is the ISDA Calculation Agent for the trade. If more than one party is referenced then the parties are assumed to be co-calculation agents, i.e. they have joint responsibility.'} calculationAgentPartyReference: test::gen::PartyReference[*];
  {meta::pure::profiles::doc.doc = 'The ISDA calculation agent responsible for performing duties as defined in the applicable product definitions. For example, the Calculation Agent may be defined as being the Non-exercising Party.'} calculationAgentParty: test::gen::CalculationAgentPartyEnum[0..1];
}

>>>test::gen::CalculationAgentPartyEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of how a calculation agent will be determined.'} test::gen::CalculationAgentPartyEnum
{
  ExercisingParty,
  NonExercisingParty,
  AsSpecifiedInMasterAgreement,
  AsSpecifiedInStandardTermsSupplement,
  Both
}

>>>test::gen::CalculationPeriodFrequency
Class {meta::pure::profiles::doc.doc = 'A type defining the frequency at which calculation period end dates occur within the regular part of the calculation period schedule and thier roll date convention. In case the calculation frequency is of value T (term), the period is defined by the swap\\swapStream\\calculationPerioDates\\effectiveDate and the swap\\swapStream\\calculationPerioDates\\terminationDate.'} test::gen::CalculationPeriodFrequency extends test::gen::Frequency
{
  {meta::pure::profiles::doc.doc = 'Used in conjunction with a frequency and the regular period start date of a calculation period, determines each calculation period end date within the regular part of a calculation period schedule.'} rollConvention: test::gen::RollConventionEnum[1];
}

>>>test::gen::CalendarSourceEnum
Enum {meta::pure::profiles::doc.doc = 'Describes the date source calendar for a contract whereby the prices are from the underlying commodity price source (e.g. exchange traded futures contract), but the dates are based off another calendar (e.g. the listed option on the futures contract).'} test::gen::CalendarSourceEnum
{
  ListedOption,
  Future
}

>>>test::gen::CallingPartyEnum
Enum {meta::pure::profiles::doc.doc = 'Identifies a party to the on-demand repo transaction that has a right to demand for termination of the repo transaction.'} test::gen::CallingPartyEnum
{
  InitialBuyer,
  InitialSeller,
  Either,
  AsDefinedInMasterAgreement
}

>>>test::gen::CashSettlementReferenceBanks
Class {meta::pure::profiles::doc.doc = 'A type defining the list of reference institutions polled for relevant rates or prices when determining the cash settlement amount for a product where cash settlement is applicable.'} test::gen::CashSettlementReferenceBanks
{
  {meta::pure::profiles::doc.doc = 'An institution (party) identified by means of a coding scheme and an optional name.'} referenceBank: test::gen::ReferenceBank[1..*];
  id: String[0..1];
}

>>>test::gen::CashflowId
Class {meta::pure::profiles::doc.doc = 'An identifier used to identify a single component cashflow.'} test::gen::CashflowId
[
  c1_length: $this.cashflowIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  cashflowIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::CashflowNotional
Class {meta::pure::profiles::doc.doc = 'The notional/principal value/quantity/volume used to compute the cashflow.'} test::gen::CashflowNotional
[
  c1_length: $this.units->forAll(x: String[1]|$x->length() >= 0),
  c2_choice: ($this.currency->isNotEmpty() && $this.units->isEmpty()) || ($this.currency->isEmpty() && $this.units->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'The currency in which an amount is denominated.'} currency: test::gen::Currency[0..1];
  {meta::pure::profiles::doc.doc = 'The units in which an amount (not monetary) is denominated.'} units: String[0..1];
  {meta::pure::profiles::doc.doc = 'The quantity of notional (in currency or other units).'} amount: Decimal[1];
  id: String[0..1];
}

>>>test::gen::CashflowType
Class {meta::pure::profiles::doc.doc = 'A coding scheme used to describe the type or purpose of a cash flow or cash flow component.'} test::gen::CashflowType
[
  c1_length: $this.cashflowTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  cashflowTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ClearanceSystem
Class {meta::pure::profiles::doc.doc = 'Unless otherwise specified, the principal clearance system customarily used for settling trades in the relevant underlying.'} test::gen::ClearanceSystem
[
  c1_length: $this.clearanceSystemScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  clearanceSystemScheme: String[0..1];
  value: String[1];
}

>>>test::gen::Collateral
Class {meta::pure::profiles::doc.doc = 'A type for defining the obligations of the counterparty subject to credit support requirements.'} test::gen::Collateral
{
  {meta::pure::profiles::doc.doc = 'Independent Amount is an amount that usually less creditworthy counterparties are asked to provide. It can either be a fixed amount or a percentage of the Transaction\'s value. The Independent Amount can be: (i) transferred before any trading between the parties occurs (as a deposit at a third party\'s account or with the counterparty) or (ii) callable after trading has occurred (typically because a downgrade has occurred). In situation (i), the Independent Amount is not included in the calculation of Exposure, but in situation (ii), it is included in the calculation of Exposure. Thus, for situation (ii), the Independent Amount may be transferred along with any collateral call. Independent Amount is a defined term in the ISDA Credit Support Annex. ("with respect to a party, the amount specified as such for that party in Paragraph 13; if no amount is specified, zero").'} independentAmount: test::gen::IndependentAmount[1];
}

>>>test::gen::CollateralValueAllocation
Class test::gen::CollateralValueAllocation
{
  {meta::pure::profiles::doc.doc = 'The type of allocation e.g. Full or ExcessOverMargin'} type: test::gen::CollateralValueAllocationEnum[1];
  value: test::gen::Money[1..*];
}

>>>test::gen::CollateralValueAllocationEnum
Enum {meta::pure::profiles::doc.doc = 'Denotes the method of collateral value allocation'} test::gen::CollateralValueAllocationEnum
{
  Buffer,
  Full,
  ExcessOverMargin,
  Margin
}

>>>test::gen::CommissionDenominationEnum
Enum {meta::pure::profiles::doc.doc = 'The unit in which a commission is denominated.'} test::gen::CommissionDenominationEnum
{
  BPS,
  Percentage,
  CentsPerShare,
  FixedAmount
}

>>>test::gen::CommodityBullionSettlementDisruptionEnum
Enum {meta::pure::profiles::doc.doc = 'The consequences of Bullion Settlement Disruption Events.'} test::gen::CommodityBullionSettlementDisruptionEnum
{
  Negotiation,
  Cancellation_and_Payment
}

>>>test::gen::CommodityDayTypeEnum
Enum {meta::pure::profiles::doc.doc = 'A day type classification used in counting the number of days between two dates for a commodity transaction.'} test::gen::CommodityDayTypeEnum
{
  Business,
  Calendar,
  CommodityBusiness,
  CurrencyBusiness,
  ExchangeBusiness,
  ScheduledTradingDay,
  GasFlow,
  NearbyContractDay
}

>>>test::gen::CommodityKnockEnum
Enum {meta::pure::profiles::doc.doc = 'Barrier Knock In or Out.'} test::gen::CommodityKnockEnum
{
  In,
  Out
}

>>>test::gen::CommodityPayRelativeToEnum
Enum {meta::pure::profiles::doc.doc = 'The Commodity specification of whether payments occur relative e.g. to the Trade Date, or the end of the month, etc.'} test::gen::CommodityPayRelativeToEnum
{
  CalculationPeriodStartDate,
  CalculationPeriodEndDate,
  LastPricingDate,
  ResetDate,
  ValuationDate,
  CalculationDate,
  CalculationPeriodMonthEnd,
  CalculationPeriodMonthStart,
  EffectiveDate,
  PricingPeriodMonthEnd,
  TerminationOrExpirationDate,
  TradeDate,
  PricingPeriodEndOfWeek,
  FirstPricingDate
}

>>>test::gen::CommodityReturnCalculationFormulaEnum
Enum {meta::pure::profiles::doc.doc = 'Defines the value of the commodity return calculation formula as simple or compound. The simple return formula is: [ [P sub t - P sub (t-1)] / [P sub (t-1)] ] - 1 where: P sub t is the price or index level at time period t and P sub t-1 is the price or index level in time period t-1. The compound return formula is the geometric average return for the period: PI from d=1 to d=n [ [ [ [P sub t - P sub (t-1)] / [P sub (t-1)] ] + 1] sup (1 / n) ] - 1 where: PI is the product operator, p sub t is the price or index level at time period t, p sub t -1 is the price or index level at time period t-1'} test::gen::CommodityReturnCalculationFormulaEnum
{
  SimpleFormula,
  CompoundFormula
}

>>>test::gen::CompoundingMethodEnum
Enum {meta::pure::profiles::doc.doc = 'The compounding calculation method'} test::gen::CompoundingMethodEnum
{
  Flat,
  None,
  Straight,
  SpreadExclusive
}

>>>test::gen::ConditionEnum
Enum {meta::pure::profiles::doc.doc = 'Defines a condition when an event applies.'} test::gen::ConditionEnum
{
  AtOrAbove,
  AtOrBelow,
  Above,
  Below
}

>>>test::gen::ConditionsPrecedentMetEnum
Enum {meta::pure::profiles::doc.doc = 'Defines whether conditions precedent have been met in a given syndicated loan deal.'} test::gen::ConditionsPrecedentMetEnum
{
  No,
  Waived,
  Yes
}

>>>test::gen::ContactInformation
Class {meta::pure::profiles::doc.doc = 'A type that represents how to contact an individual or organization.'} test::gen::ContactInformation
[
  c1_length: $this.email->forAll(x: String[1]|$x->length() >= 0)
]
{
  {meta::pure::profiles::doc.doc = 'A telephonic contact.'} telephone: test::gen::TelephoneNumber[*];
  {meta::pure::profiles::doc.doc = 'An address on an electronic mail or messaging sysem .'} email: String[*];
  {meta::pure::profiles::doc.doc = 'A postal or street address.'} address: test::gen::Address[0..1];
}

>>>test::gen::ContractualDefinitions
Class {meta::pure::profiles::doc.doc = 'The definitions, such as those published by ISDA, that will define the terms of the trade.'} test::gen::ContractualDefinitions
[
  c1_length: $this.contractualDefinitionsScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  contractualDefinitionsScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ContractualMatrix
Class test::gen::ContractualMatrix
{
  {meta::pure::profiles::doc.doc = 'Identifies the form of applicable matrix.'} matrixType: test::gen::MatrixType[1];
  {meta::pure::profiles::doc.doc = 'Specifies the publication date of the applicable version of the matrix. When this element is omitted, the ISDA supplemental language for incorporation of the relevant matrix will generally define rules for which version of the matrix is applicable.'} publicationDate: StrictDate[0..1];
  {meta::pure::profiles::doc.doc = 'Defines any applicable key into the relevant matrix. For example, the Transaction Type would be the single term required for the Credit Derivatives Physical Settlement Matrix. This element should be omitted in the case of the 2000 ISDA Definitions Settlement Matrix for Early Termination and Swaptions.'} matrixTerm: test::gen::MatrixTerm[0..1];
}

>>>test::gen::ContractualSupplement
Class {meta::pure::profiles::doc.doc = 'A contractual supplement (such as those published by ISDA) that will apply to the trade.'} test::gen::ContractualSupplement
[
  c1_length: $this.contractualSupplementScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  contractualSupplementScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ContractualTermsSupplement
Class {meta::pure::profiles::doc.doc = 'A contractual supplement (such as those published by ISDA) and its publication date that will apply to the trade.'} test::gen::ContractualTermsSupplement
{
  {meta::pure::profiles::doc.doc = 'Identifies the form of applicable contractual supplement.'} type: test::gen::ContractualSupplement[1];
  {meta::pure::profiles::doc.doc = 'Specifies the publication date of the applicable version of the contractual supplement.'} publicationDate: StrictDate[0..1];
}

>>>test::gen::CorrespondentInformation
Class {meta::pure::profiles::doc.doc = 'A type that describes the information to identify a correspondent bank that will make delivery of the funds on the paying bank\'s behalf in the country where the payment is to be made.'} test::gen::CorrespondentInformation
[
  c1_choice: ($this.routingIds->isNotEmpty() && ($this.routingExplicitDetails->isEmpty() && $this.routingIdsAndExplicitDetails->isEmpty())) || (($this.routingIds->isEmpty() && ($this.routingExplicitDetails->isNotEmpty() && $this.routingIdsAndExplicitDetails->isEmpty())) || ($this.routingIds->isEmpty() && ($this.routingExplicitDetails->isEmpty() && $this.routingIdsAndExplicitDetails->isNotEmpty())))
]
{
  {meta::pure::profiles::doc.doc = 'A set of unique identifiers for a party, eachone identifying the party within a payment system. The assumption is that each party will not have more than one identifier within the same payment system.'} routingIds: test::gen::RoutingIds[0..1];
  {meta::pure::profiles::doc.doc = 'A set of details that is used to identify a party involved in the routing of a payment when the party does not have a code that identifies it within one of the recognized payment systems.'} routingExplicitDetails: test::gen::RoutingExplicitDetails[0..1];
  {meta::pure::profiles::doc.doc = 'A combination of coded payment system identifiers and details for physical addressing for a party involved in the routing of a payment.'} routingIdsAndExplicitDetails: test::gen::RoutingIdsAndExplicitDetails[0..1];
  {meta::pure::profiles::doc.doc = 'Link to the party acting as correspondent. This element can only appear within the correspondentInformation container element.'} correspondentPartyReference: test::gen::PartyReference[0..1];
}

>>>test::gen::CountryCode
Class {meta::pure::profiles::doc.doc = 'The code representation of a country or an area of special sovereignty. By default it is a valid 2 character country code as defined by the ISO standard 3166-1 alpha-2 - Codes for representation of countries http://www.niso.org/standards/resources/3166.html.'} test::gen::CountryCode
[
  c1_length: $this.countryScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 0
]
{
  countryScheme: String[0..1];
  value: String[1];
}

>>>test::gen::CreditRating
Class {meta::pure::profiles::doc.doc = 'A party\'s credit rating.'} test::gen::CreditRating
[
  c1_length: $this.creditRatingScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  creditRatingScheme: String[0..1];
  value: String[1];
}

>>>test::gen::CreditSeniority
Class {meta::pure::profiles::doc.doc = 'The repayment precedence of a debt instrument.'} test::gen::CreditSeniority
[
  c1_length: $this.creditSeniorityScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  {meta::pure::profiles::doc.doc = 'creditSeniorityTradingScheme overrides creditSeniorityScheme when the underlyer defines the reference obligation used in a single name credit default swap trade.'} creditSeniorityScheme: String[0..1];
  value: String[1];
}

>>>test::gen::CreditSupportAgreement
Class {meta::pure::profiles::doc.doc = 'The agreement executed between the parties and intended to govern collateral arrangement for all OTC derivatives transactions between those parties.'} test::gen::CreditSupportAgreement
{
  {meta::pure::profiles::doc.doc = 'The type of ISDA Credit Support Agreement'} type: test::gen::CreditSupportAgreementType[1];
  {meta::pure::profiles::doc.doc = 'The date of the agreement executed between the parties and intended to govern collateral arrangements for all OTC derivatives transactions between those parties.'} date: StrictDate[1];
  {meta::pure::profiles::doc.doc = 'An identifier used to uniquely identify the CSA'} identifier: test::gen::CreditSupportAgreementIdentifier[0..1];
}

>>>test::gen::CreditSupportAgreementIdentifier
Class test::gen::CreditSupportAgreementIdentifier
[
  c1_length: $this.creditSupportAgreementIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  creditSupportAgreementIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::CreditSupportAgreementType
Class test::gen::CreditSupportAgreementType
[
  c1_length: $this.creditSupportAgreementTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  creditSupportAgreementTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::Currency
Class {meta::pure::profiles::doc.doc = 'The code representation of a currency or fund. By default it is a valid currency code as defined by the ISO standard 4217 - Codes for representation of currencies and funds http://www.iso.org/iso/en/prods-services/popstds/currencycodeslist.html.'} test::gen::Currency
[
  c1_length: $this.currencyScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  currencyScheme: String[0..1];
  value: String[1];
}

>>>test::gen::DateList
Class {meta::pure::profiles::doc.doc = 'List of Dates'} test::gen::DateList
{
  date: StrictDate[1..*];
}

>>>test::gen::DateOffset
Class {meta::pure::profiles::doc.doc = 'A type defining an offset used in calculating a date when this date is defined in reference to another date through a date offset. The type includes the convention for adjusting the date and an optional sequence element to indicate the order in a sequence of multiple date offsets.'} test::gen::DateOffset extends test::gen::Offset
{
  {meta::pure::profiles::doc.doc = 'The convention for adjusting a date if it would otherwise fall on a day that is not a business day.'} businessDayConvention: test::gen::BusinessDayConventionEnum[1];
}

>>>test::gen::DateRange
Class {meta::pure::profiles::doc.doc = 'A type defining a contiguous series of calendar dates. The date range is defined as all the dates between and including the first and the last date. The first date must fall before the last date.'} test::gen::DateRange
{
  {meta::pure::profiles::doc.doc = 'The first date of a date range.'} unadjustedFirstDate: StrictDate[1];
  {meta::pure::profiles::doc.doc = 'The last date of a date range.'} unadjustedLastDate: StrictDate[1];
}

>>>test::gen::DateReference
Class {meta::pure::profiles::doc.doc = 'Reference to an identified date or a complex date structure.'} test::gen::DateReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::DateTimeList
Class {meta::pure::profiles::doc.doc = 'List of DateTimes'} test::gen::DateTimeList
{
  dateTime: DateTime[1..*];
}

>>>test::gen::DayCountFraction
Class {meta::pure::profiles::doc.doc = 'The specification for how the number of days between two dates is calculated for purposes of calculation of a fixed or floating payment amount and the basis for how many days are assumed to be in a year. Day Count Fraction is an ISDA term. The equivalent AFB (Association Francaise de Banques) term is Calculation Basis.'} test::gen::DayCountFraction
[
  c1_length: $this.dayCountFractionScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  dayCountFractionScheme: String[0..1];
  value: String[1];
}

>>>test::gen::DayOfWeekEnum
Enum {meta::pure::profiles::doc.doc = 'A day of the seven-day week.'} test::gen::DayOfWeekEnum
{
  MON,
  TUE,
  WED,
  THU,
  FRI,
  SAT,
  SUN
}

>>>test::gen::DayOfWeekExtEnum
Enum {meta::pure::profiles::doc.doc = 'A day of the seven-day week, plus codes for weekends and weekdays.'} test::gen::DayOfWeekExtEnum
{
  MON,
  TUE,
  WED,
  THU,
  FRI,
  SAT,
  SUN,
  WD,
  WN
}

>>>test::gen::DayTypeEnum
Enum {meta::pure::profiles::doc.doc = 'A day type classification used in counting the number of days between two dates.'} test::gen::DayTypeEnum
{
  Business,
  Calendar,
  CommodityBusiness,
  CurrencyBusiness,
  ExchangeBusiness,
  ScheduledTradingDay
}

>>>test::gen::DealtCurrencyEnum
Enum test::gen::DealtCurrencyEnum
{
  ExchangedCurrency1,
  ExchangedCurrency2
}

>>>test::gen::DeliveryDatesEnum
Enum {meta::pure::profiles::doc.doc = 'Deprecated: In respect of a Transaction and a Commodity Reference Price, the relevant date or month for delivery of the underlying Commodity.'} test::gen::DeliveryDatesEnum
{
  CalculationPeriod,
  FirstNearby,
  SecondNearby,
  ThirdNearby,
  FourthNearby,
  FifthNearby,
  SixthNearby,
  SeventhNearby,
  EighthNearby,
  NinthNearby,
  TenthNearby,
  EleventhNearby,
  TwelfthNearby,
  ThirteenthNearby,
  FourteenthNearby,
  FifteenthNearby,
  SixteenthNearby,
  SeventeenthNearby,
  EighteenthNearby,
  NineteenthNearby,
  TwentiethNearby,
  TwentyFirstNearby,
  TwentySecondNearby,
  TwentyThirdNearby,
  TwentyFourthNearby,
  TwentyFifthNearby,
  TwentySixthNearby,
  TwentySeventhNearby,
  TwentyEighthNearby,
  TwentyNinthNearby,
  ThirtiethNearby,
  ThirtyFirstNearby,
  ThirtySecondNearby,
  ThirtyThirdNearby,
  ThirtyFourthNearby,
  ThirtyFifthNearby,
  ThirtySixthNearby,
  ThirtySeventhNearby,
  ThirtyEighthNearby,
  ThirtyNinthNearby,
  FortiethNearby,
  FortyFirstNearby,
  FortySecondNearby,
  FortyThirdNearby,
  FortyFourthNearby,
  FortyFifthNearby,
  FortySixthNearby,
  FortySeventhNearby,
  FortyEighthNearby,
  FortyNinthNearby,
  FiftiethNearby,
  FiftyFirstNearby,
  FiftySecondNearby,
  FiftyThirdNearby,
  FiftyFourthNearby,
  FiftyFifthNearby,
  FiftySixthNearby,
  FiftySeventhNearby,
  FiftyEighthNearby,
  FiftyNinthNearby,
  Spot,
  FirstNearbyWeek,
  SecondNearbyWeek,
  ThirdNearbyWeek,
  FourthNearbyWeek,
  FifthNearbyWeek,
  SixthNearbyWeek,
  SeventhNearbyWeek,
  EighthNearbyWeek,
  NinthNearbyWeek,
  TenthNearbyWeek,
  EleventhNearbyWeek,
  TwelfthNearbyWeek,
  ThirteenthNearbyWeek,
  FourteenthNearbyWeek,
  FifteenthNearbyWeek,
  SixteenthNearbyWeek,
  SeventeenthNearbyWeek,
  EighteenthNearbyWeek,
  NineteenthNearbyWeek,
  TwentiethNearbyWeek,
  TwentyFirstNearbyWeek,
  TwentySecondNearbyWeek,
  TwentyThirdNearbyWeek,
  TwentyFourthearbyWeek,
  TwentyFifthNearbyWeek,
  TwentySixthNearbyWeek,
  TwentySeventhNearbyWeek,
  TwentyEighthNearbyWeek,
  TwentyNinthNearbyWeek,
  ThirtiethNearbyWeek,
  ThirtyFirstNearbyWeek,
  ThirtySecondNearbyWeek,
  ThirtyThirdNearbyWeek,
  ThirtyFourthNearbyWeek,
  ThirtyFifthNearbyWeek,
  ThirtySixthNearbyWeek,
  ThirtySeventhNearbyWeek,
  ThirtyEighthNearbyWeek,
  ThirtyNinthNearbyWeek,
  FortiethNearbyWeek,
  FortyFirstNearbyWeek,
  FortySecondNearbyWeek,
  FortyThirdNearbyWeek,
  FortyFourthNearbyWeek,
  FortyFifthNearbyWeek,
  FortySixthNearbyWeek,
  FortySeventhNearbyWeek,
  FortyEighthNearbyWeek,
  FortyNinthNearbyWeek,
  FiftiethNearbyWeek,
  FiftyFirstNearbyWeek,
  FiftySecondNearbyWeek
}

>>>test::gen::DeliveryNearbyTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The type of nearby qualifier, expect to be used in conjunction with a nearby count.'} test::gen::DeliveryNearbyTypeEnum
{
  CalculationPeriod,
  NearbyMonth,
  NearbyWeek
}

>>>test::gen::DeliveryTypeEnum
Enum test::gen::DeliveryTypeEnum
{
  Firm,
  Interruptible
}

>>>test::gen::DeterminationMethod
Class {meta::pure::profiles::doc.doc = 'Coding scheme that specifies the method according to which an amount or a date is determined.'} test::gen::DeterminationMethod
[
  c1_length: $this.determinationMethodScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  determinationMethodScheme: String[0..1];
  id: String[0..1];
  value: String[1];
}

>>>test::gen::DeterminationMethodReference
Class {meta::pure::profiles::doc.doc = 'A reference to the return swap notional determination method.'} test::gen::DeterminationMethodReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::DifferenceSeverityEnum
Enum {meta::pure::profiles::doc.doc = 'The ISDA defined value indicating the severity of a difference.'} test::gen::DifferenceSeverityEnum
{
  Warning,
  Error
}

>>>test::gen::DifferenceTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The ISDA defined value indicating the nature of a difference.'} test::gen::DifferenceTypeEnum
{
  Value,
  Reference,
  Structure,
  Scheme
}

>>>test::gen::DirectionalLeg
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'An abstract base class for all directional leg types with effective date, termination date, where a payer makes a stream of payments of greater than zero value to a receiver.'} test::gen::DirectionalLeg extends test::gen::Leg
{
  {meta::pure::profiles::doc.doc = 'Version aware identification of this leg.'} legIdentifier: test::gen::LegIdentifier[*];
  {meta::pure::profiles::doc.doc = 'A reference to the party responsible for making the payments defined by this structure.'} payerPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account responsible for making the payments defined by this structure.'} payerAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party that receives the payments corresponding to this structure.'} receiverPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account that receives the payments corresponding to this structure.'} receiverAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'Specifies the effective date of this leg of the swap. When defined in relation to a date specified somewhere else in the document (through the relativeDate component), this element will typically point to the effective date of the other leg of the swap.'} effectiveDate: test::gen::AdjustableOrRelativeDate[0..1];
  {meta::pure::profiles::doc.doc = 'Specifies the termination date of this leg of the swap. When defined in relation to a date specified somewhere else in the document (through the relativeDate component), this element will typically point to the termination date of the other leg of the swap.'} terminationDate: test::gen::AdjustableOrRelativeDate[0..1];
}

>>>test::gen::DiscountingTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The method of calculating discounted payment amounts.'} test::gen::DiscountingTypeEnum
{
  Standard,
  FRA,
  FRAYield
}

>>>test::gen::DisruptionFallbacksEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of how disruption fallbacks will be represented.'} test::gen::DisruptionFallbacksEnum
{
  AsSpecifiedInMasterAgreement,
  AsSpecifiedInConfirmation
}

>>>test::gen::DividendAmountTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Refers to one on the 3 Amounts'} test::gen::DividendAmountTypeEnum
{
  RecordAmount,
  ExAmount,
  PaidAmount,
  AsSpecifiedInMasterConfirmation
}

>>>test::gen::DividendCompositionEnum
Enum {meta::pure::profiles::doc.doc = 'Defines how the composition of dividends is to be determined.'} test::gen::DividendCompositionEnum
{
  EquityAmountReceiverElection,
  CalculationAgentElection
}

>>>test::gen::DividendDateReferenceEnum
Enum {meta::pure::profiles::doc.doc = 'The reference to a dividend date.'} test::gen::DividendDateReferenceEnum
{
  ExDate,
  DividendPaymentDate,
  DividendValuationDate,
  RecordDate,
  TerminationDate,
  EquityPaymentDate,
  FollowingPaymentDate,
  AdHocDate,
  CumulativeEquityPaid,
  CumulativeLiborPaid,
  CumulativeEquityExDiv,
  CumulativeLiborExDiv,
  SharePayment,
  CashSettlementPaymentDate,
  FloatingAmountPaymentDate,
  CashSettlePaymentDateExDiv,
  CashSettlePaymentDateIssuerPayment,
  ExDividendPaymentDate
}

>>>test::gen::DividendEntitlementEnum
Enum {meta::pure::profiles::doc.doc = 'The date on which the receiver of the equity return is entitled to the dividend.'} test::gen::DividendEntitlementEnum
{
  ExDate,
  RecordDate
}

>>>test::gen::DividendPeriodEnum
Enum {meta::pure::profiles::doc.doc = 'Defines the First Period or the Second Period, as specified in the 2002 ISDA Equity Derivatives Definitions.'} test::gen::DividendPeriodEnum
{
  FirstPeriod,
  SecondPeriod
}

>>>test::gen::Documentation
Class {meta::pure::profiles::doc.doc = 'An entity for defining the definitions that govern the document and should include the year and type of definitions referenced, along with any relevant documentation (such as master agreement) and the date it was signed.'} test::gen::Documentation
[
  c1_choice: ($this.masterConfirmation->isNotEmpty() && $this.brokerConfirmation->isEmpty()) || ($this.masterConfirmation->isEmpty() && $this.brokerConfirmation->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'The agreement executed between the parties and intended to govern all OTC derivatives transactions between those parties.'} masterAgreement: test::gen::MasterAgreement[0..1];
  {meta::pure::profiles::doc.doc = 'The agreement executed between the parties and intended to govern all OTC derivatives transactions between those parties.'} masterConfirmation: test::gen::MasterConfirmation[0..1];
  {meta::pure::profiles::doc.doc = 'Specifies the deails for a broker confirm.'} brokerConfirmation: test::gen::BrokerConfirmation[0..1];
  {meta::pure::profiles::doc.doc = 'The definitions such as those published by ISDA that will define the terms of the trade.'} contractualDefinitions: test::gen::ContractualDefinitions[*];
  {meta::pure::profiles::doc.doc = 'A contractual supplement (such as those published by ISDA) that will apply to the trade.'} contractualTermsSupplement: test::gen::ContractualTermsSupplement[*];
  {meta::pure::profiles::doc.doc = 'A reference to a contractual matrix of elected terms/values (such as those published by ISDA) that shall be deemed to apply to the trade. The applicable matrix is identified by reference to a name and optionally a publication date. Depending on the structure of the matrix, an additional term (specified in the matrixTerm element) may be required to further identify a subset of applicable terms/values within the matrix.'} contractualMatrix: test::gen::ContractualMatrix[*];
  {meta::pure::profiles::doc.doc = 'The agreement executed between the parties and intended to govern collateral arrangement for all OTC derivatives transactions between those parties.'} creditSupportAgreement: test::gen::CreditSupportAgreement[0..1];
  {meta::pure::profiles::doc.doc = 'Any other agreement executed between the parties.'} otherAgreement: test::gen::OtherAgreement[*];
  {meta::pure::profiles::doc.doc = 'A human readable document related to this transaction, for example a confirmation.'} attachment: test::gen::Resource[*];
}

>>>test::gen::DualCurrencyStrikeQuoteBasisEnum
Enum {meta::pure::profiles::doc.doc = 'A type which permits the Dual Currency strike quote basis to be expressed in terms of the deposit and alternate currencies.'} test::gen::DualCurrencyStrikeQuoteBasisEnum
{
  DepositCurrencyPerAlternateCurrency,
  AlternateCurrencyPerDepositCurrency
}

>>>test::gen::EarlyTerminationDateEnum
Enum {meta::pure::profiles::doc.doc = 'Symbolic specification of early termination date.'} test::gen::EarlyTerminationDateEnum
{
  AnyDay,
  ValuationDate,
  ResetDate,
  AfterFirstResetDate,
  AsSpecifiedInMCA
}

>>>test::gen::ElectricityProductTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The type of electricity product.'} test::gen::ElectricityProductTypeEnum
{
  Electricity
}

>>>test::gen::Empty
Class {meta::pure::profiles::doc.doc = 'A special type meant to be used for elements with no content and no attributes.'} test::gen::Empty
{
}

>>>test::gen::EntityId
Class {meta::pure::profiles::doc.doc = 'A legal entity identifier (e.g. RED entity code).'} test::gen::EntityId
[
  c1_length: $this.entityIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  entityIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::EntityName
Class {meta::pure::profiles::doc.doc = 'The name of the reference entity. A free format string. FpML does not define usage rules for this element.'} test::gen::EntityName
[
  c1_length: $this.entityNameScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  entityNameScheme: String[0..1];
  value: String[1];
}

>>>test::gen::EnvironmentalAbandonmentOfSchemeEnum
Enum {meta::pure::profiles::doc.doc = 'Upon the occurrence of an Abandonment of Scheme, as defined in clause (h)(iv) of the Emissions Annex, one of the following elections, the specific terms of which are set forth in clause (b)(iii) of the Emissions Annex, will govern the parties\' rights and obligations with respect to this Emissions Transaction. If none of the above options is selected, Option A(1) will apply.'} test::gen::EnvironmentalAbandonmentOfSchemeEnum
{
  OptionA_1_,
  OptionA_2_,
  OptionB,
  OptionC
}

>>>test::gen::EnvironmentalProductTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Environmental Product (e.g. allowance, certificate or unit).'} test::gen::EnvironmentalProductTypeEnum
{
  EUAllowance,
  EUCredit,
  AlternativeAllowance,
  NOXEmissionsProduct,
  RegionalEmissionsProduct,
  RGGIEmissionsProduct,
  SO2EmissionsProduct,
  StateEmissionProduct,
  VoluntaryEmissionProduct,
  RenewableEnergyCertificate,
  AUSCarbonCreditUnit,
  AUSCarbonUnit,
  AUSEnergySavingCertificate,
  AUSLargeScaleGenerationCertificate,
  AUSSmallScaleTechnologyCertificate,
  AUSVictorianEnergyEfficiencyCertificate,
  MXCCFECRTINTLODS,
  NZEmissionsUnits,
  UKRenewableObligationCertificate
}

>>>test::gen::EquityOptionTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Specifies an additional Forward type.'} test::gen::EquityOptionTypeEnum
{
  Put,
  Call,
  Forward
}

>>>test::gen::EuropeanExercise
Class {meta::pure::profiles::doc.doc = 'A type defining the exercise period for a European style option together with any rules governing the notional amount of the underlying which can be exercised on any given exercise date and any associated exercise fees.'} test::gen::EuropeanExercise extends test::gen::Exercise
{
  {meta::pure::profiles::doc.doc = 'The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.'} expirationDate: test::gen::AdjustableOrRelativeDate[1];
  {meta::pure::profiles::doc.doc = 'The date on the underlying set by the exercise of an option. What this date is depends on the option (e.g. in a swaption it is the swap effective date, in an extendible/cancelable provision it is the swap termination date).'} relevantUnderlyingDate: test::gen::AdjustableOrRelativeDates[0..1];
  {meta::pure::profiles::doc.doc = 'The earliest time at which notice of exercise can be given by the buyer to the seller (or seller\'s agent) i) on the expriation date, in the case of a European style option, (ii) on each bermuda option exercise date and the expiration date, in the case of a Bermuda style option the commencement date to, and including, the expiration date , in the case of an American option.'} earliestExerciseTime: test::gen::BusinessCenterTime[1];
  {meta::pure::profiles::doc.doc = 'The latest time for exercise on expirationDate.'} expirationTime: test::gen::BusinessCenterTime[1];
  {meta::pure::profiles::doc.doc = 'As defined in the 2000 ISDA Definitions, Section 12.3. Partial Exercise, the buyer of the option has the right to exercise all or less than all the notional amount of the underlying swap on the expiration date, but may not exercise less than the minimum notional amount, and if an integral multiple amount is specified, the notional amount exercised must be equal to, or be an integral multiple of, the integral multiple amount.'} partialExercise: test::gen::PartialExercise[0..1];
  {meta::pure::profiles::doc.doc = 'A fee to be paid on exercise. This could be represented as an amount or a rate and notional reference on which to apply the rate.'} exerciseFee: test::gen::ExerciseFee[0..1];
}

>>>test::gen::ExchangeId
Class {meta::pure::profiles::doc.doc = 'A short form unique identifier for an exchange. If the element is not present then the exchange shall be the primary exchange on which the underlying is listed. The term "Exchange" is assumed to have the meaning as defined in the ISDA 2002 Equity Derivatives Definitions.'} test::gen::ExchangeId
[
  c1_length: $this.exchangeIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  exchangeIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::Exercise
Class {meta::pure::profiles::doc.doc = 'The abstract base class for all types which define way in which options may be exercised.'} test::gen::Exercise
{
  id: String[0..1];
}

>>>test::gen::ExerciseActionEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of whether an OTC option will be exercised.'} test::gen::ExerciseActionEnum
{
  FullExercise,
  PartialExercise,
  Abandon
}

>>>test::gen::ExerciseFee
Class {meta::pure::profiles::doc.doc = 'A type defining the fee payable on exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised.'} test::gen::ExerciseFee
[
  c1_choice: ($this.feeAmount->isNotEmpty() && $this.feeRate->isEmpty()) || ($this.feeAmount->isEmpty() && $this.feeRate->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'A reference to the party responsible for making the payments defined by this structure.'} payerPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account responsible for making the payments defined by this structure.'} payerAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party that receives the payments corresponding to this structure.'} receiverPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account that receives the payments corresponding to this structure.'} receiverAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A pointer style reference to the associated notional schedule defined elsewhere in the document.'} notionalReference: test::gen::NotionalReference[1];
  {meta::pure::profiles::doc.doc = 'The amount of fee to be paid on exercise. The fee currency is that of the referenced notional.'} feeAmount: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'A fee represented as a percentage of some referenced notional. A percentage of 5% would be represented as 0.05.'} feeRate: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The date on which exercise fee(s) will be paid. It is specified as a relative date.'} feePaymentDate: test::gen::RelativeDateOffset[1];
}

>>>test::gen::ExerciseFeeSchedule
Class {meta::pure::profiles::doc.doc = 'A type to define a fee or schedule of fees to be payable on the exercise of an option. This fee may be defined as an amount or a percentage of the notional exercised.'} test::gen::ExerciseFeeSchedule
[
  c1_choice: ($this.feeAmountSchedule->isNotEmpty() && $this.feeRateSchedule->isEmpty()) || ($this.feeAmountSchedule->isEmpty() && $this.feeRateSchedule->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'A reference to the party responsible for making the payments defined by this structure.'} payerPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account responsible for making the payments defined by this structure.'} payerAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party that receives the payments corresponding to this structure.'} receiverPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account that receives the payments corresponding to this structure.'} receiverAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A pointer style reference to the associated notional schedule defined elsewhere in the document.'} notionalReference: test::gen::ScheduleReference[1];
  {meta::pure::profiles::doc.doc = 'The exercise fee amount schedule. The fees are expressed as currency amounts. The currency of the fee is assumed to be that of the notional schedule referenced.'} feeAmountSchedule: test::gen::AmountSchedule[0..1];
  {meta::pure::profiles::doc.doc = 'The exercise free rate schedule. The fees are expressed as percentage rates of the notional being exercised. The currency of the fee is assumed to be that of the notional schedule referenced.'} feeRateSchedule: test::gen::Schedule[0..1];
  {meta::pure::profiles::doc.doc = 'The date on which exercise fee(s) will be paid. It is specified as a relative date.'} feePaymentDate: test::gen::RelativeDateOffset[1];
}

>>>test::gen::ExerciseNotice
Class {meta::pure::profiles::doc.doc = 'A type defining to whom and where notice of execution should be given. The partyReference refers to one of the principal parties of the trade. If present the exerciseNoticePartyReference refers to a party, other than the principal party, to whome notice should be given.'} test::gen::ExerciseNotice
{
  {meta::pure::profiles::doc.doc = 'The party referenced has allocated the trade identifier.'} partyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'The party referenced is the party to which notice of exercise should be given by the buyer.'} exerciseNoticePartyReference: test::gen::PartyReference[0..1];
  businessCenter: test::gen::BusinessCenter[1];
}

>>>test::gen::ExerciseProcedure
Class {meta::pure::profiles::doc.doc = 'A type describing how notice of exercise should be given. This can be either manual or automatic.'} test::gen::ExerciseProcedure
[
  c1_choice: ($this.manualExercise->isNotEmpty() && $this.automaticExercise->isEmpty()) || ($this.manualExercise->isEmpty() && $this.automaticExercise->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'Specifies that the notice of exercise must be given by the buyer to the seller or seller\'s agent.'} manualExercise: test::gen::ManualExercise[0..1];
  {meta::pure::profiles::doc.doc = 'If automatic is specified then the notional amount of the underlying swap, not previously exercised under the swaption will be automatically exercised at the expriration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than the specified threshold rate. The term in-the-money is assumed to have the meaning defining in the 2000 ISDA Definitions, Section 17.4 In-the-money.'} automaticExercise: test::gen::AutomaticExercise[0..1];
  {meta::pure::profiles::doc.doc = 'A flag to indicate whether follow-up confirmation of exercise (written or electronic) is required following telephonic notice by the buyer to the seller or seller\'s agent.'} followUpConfirmation: Boolean[1];
  {meta::pure::profiles::doc.doc = 'Has the meaning defined as part of the 1997 ISDA Government Bond Option Definitions, section 4.5 Limited Right to Confirm Exercise. If present, (i) the Seller may request the Buyer to confirm its intent if not done on or before the expiration time on the Expiration date (ii) specific rules will apply in relation to the settlement mode.'} limitedRightToConfirm: Boolean[0..1];
  {meta::pure::profiles::doc.doc = 'Typically applicable to the physical settlement of bond and convertible bond options. If present, means that the Party required to deliver the bonds will divide those to be delivered as notifying party desires to facilitate delivery obligations.'} splitTicket: Boolean[0..1];
}

>>>test::gen::ExerciseProcedureOption
Class {meta::pure::profiles::doc.doc = 'A type describing how notice of exercise should be given. This can be either manual or automatic.'} test::gen::ExerciseProcedureOption
[
  c1_choice: ($this.manualExercise->isNotEmpty() && $this.automaticExercise->isEmpty()) || ($this.manualExercise->isEmpty() && $this.automaticExercise->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'Specifies that the notice of exercise must be given by the buyer to the seller or seller\'s agent.'} manualExercise: test::gen::Empty[0..1];
  {meta::pure::profiles::doc.doc = 'If automatic is specified then the notional amount of the underlying swap, not previously exercised under the swaption will be automatically exercised at the expriration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than the specified threshold rate. The term in-the-money is assumed to have the meaning defining in the 2000 ISDA Definitions, Section 17.4 In-the-money.'} automaticExercise: test::gen::Empty[0..1];
}

>>>test::gen::ExerciseSideEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of which of the pay-side or the receive-side should be exercised when a straddle is exercised.'} test::gen::ExerciseSideEnum
{
  Put,
  Call,
  Payer,
  Receiver
}

>>>test::gen::ExerciseStyleEnum
Enum test::gen::ExerciseStyleEnum
{
  American,
  Bermuda,
  European
}

>>>test::gen::ExerciseTimingEnum
Enum {meta::pure::profiles::doc.doc = 'When a requested option exercise event is desired to be performed.'} test::gen::ExerciseTimingEnum
{
  Immediate,
  OnExpiration
}

>>>test::gen::FeeElectionEnum
Enum {meta::pure::profiles::doc.doc = 'Defines the fee type.'} test::gen::FeeElectionEnum
{
  FlatFee,
  AmortizedFee,
  FundingFee,
  FlatFeeAndFundingFee,
  AmortizedFeeAndFundingFee
}

>>>test::gen::FlatRateEnum
Enum {meta::pure::profiles::doc.doc = 'The method by which the Flat Rate is calculated for a commodity freight transaction.'} test::gen::FlatRateEnum
{
  Fixed,
  Floating
}

>>>test::gen::FloatingRate
Class {meta::pure::profiles::doc.doc = 'A type defining a floating rate.'} test::gen::FloatingRate extends test::gen::Rate
{
  floatingRateIndex: test::gen::FloatingRateIndex[1];
  {meta::pure::profiles::doc.doc = 'The ISDA Designated Maturity, i.e. the tenor of the floating rate.'} indexTenor: test::gen::Period[0..1];
  {meta::pure::profiles::doc.doc = 'A rate multiplier or multiplier schedule to apply to the floating rate. A multiplier schedule is expressed as explicit multipliers and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in the calculationPeriodDatesAdjustments. The multiplier can be a positive or negative decimal. This element should only be included if the multiplier is not equal to 1 (one) for the term of the stream.'} floatingRateMultiplierSchedule: test::gen::Schedule[0..1];
  {meta::pure::profiles::doc.doc = 'The ISDA Spread or a Spread schedule expressed as explicit spreads and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The spread is a per annum rate, expressed as a decimal. For purposes of determining a calculation period amount, if positive the spread will be added to the floating rate and if negative the spread will be subtracted from the floating rate. A positive 10 basis point (0.1%) spread would be represented as 0.001.'} spreadSchedule: test::gen::SpreadSchedule[*];
  {meta::pure::profiles::doc.doc = 'The specification of any rate conversion which needs to be applied to the observed rate before being used in any calculations. The two common conversions are for securities quoted on a bank discount basis which will need to be converted to either a Money Market Yield or Bond Equivalent Yield. See the Annex to the 2000 ISDA Definitions, Section 7.3. Certain General Definitions Relating to Floating Rate Options, paragraphs (g) and (h) for definitions of these terms.'} rateTreatment: test::gen::RateTreatmentEnum[0..1];
  {meta::pure::profiles::doc.doc = 'The cap rate or cap rate schedule, if any, which applies to the floating rate. The cap rate (strike) is only required where the floating rate on a swap stream is capped at a certain level. A cap rate schedule is expressed as explicit cap rates and dates and the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The cap rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. A cap rate of 5% would be represented as 0.05.'} capRateSchedule: test::gen::StrikeSchedule[*];
  {meta::pure::profiles::doc.doc = 'The floor rate or floor rate schedule, if any, which applies to the floating rate. The floor rate (strike) is only required where the floating rate on a swap stream is floored at a certain strike level. A floor rate schedule is expressed as explicit floor rates and dates and the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The floor rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. A floor rate of 5% would be represented as 0.05.'} floorRateSchedule: test::gen::StrikeSchedule[*];
}

>>>test::gen::FloatingRateCalculation
Class {meta::pure::profiles::doc.doc = 'A type defining the floating rate and definitions relating to the calculation of floating rate amounts.'} test::gen::FloatingRateCalculation extends test::gen::FloatingRate
{
  {meta::pure::profiles::doc.doc = 'The initial floating rate reset agreed between the principal parties involved in the trade. This is assumed to be the first required reset rate for the first regular calculation period. It should only be included when the rate is not equal to the rate published on the source implied by the floating rate index. An initial rate of 5% would be represented as 0.05.'} initialRate: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The rounding convention to apply to the final rate used in determination of a calculation period amount.'} finalRateRounding: test::gen::Rounding[0..1];
  {meta::pure::profiles::doc.doc = 'If averaging is applicable, this component specifies whether a weighted or unweighted average method of calculation is to be used. The component must only be included when averaging applies.'} averagingMethod: test::gen::AveragingMethodEnum[0..1];
  {meta::pure::profiles::doc.doc = 'The specification of any provisions for calculating payment obligations when a floating rate is negative (either due to a quoted negative floating rate or by operation of a spread that is subtracted from the floating rate).'} negativeInterestRateTreatment: test::gen::NegativeInterestRateTreatmentEnum[0..1];
}

>>>test::gen::FloatingRateIndex
Class {meta::pure::profiles::doc.doc = 'The ISDA Floating Rate Option, i.e. the floating rate index.'} test::gen::FloatingRateIndex
[
  c1_length: $this.floatingRateIndexScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  floatingRateIndexScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ForecastRateIndex
Class {meta::pure::profiles::doc.doc = 'A type defining a rate index.'} test::gen::ForecastRateIndex
{
  {meta::pure::profiles::doc.doc = 'The ISDA Floating Rate Option, i.e. the floating rate index.'} floatingRateIndex: test::gen::FloatingRateIndex[1];
  {meta::pure::profiles::doc.doc = 'The ISDA Designated Maturity, i.e. the tenor of the floating rate.'} indexTenor: test::gen::Period[1];
}

>>>test::gen::Formula
Class {meta::pure::profiles::doc.doc = 'A type describing a financial formula, with its description and components.'} test::gen::Formula
[
  c1_length: $this.formulaDescription->forAll(x: String[1]|$x->length() <= 255)
]
{
  {meta::pure::profiles::doc.doc = 'Text description of the formula'} formulaDescription: String[0..1];
  {meta::pure::profiles::doc.doc = 'An element for containing an XML representation of the formula. Defined using xsd:any currently for flexibility in choice of language (MathML, OpenMath)'} math: test::gen::Math[0..1];
  {meta::pure::profiles::doc.doc = 'Elements describing the components of the formula. The name attribute points to a value used in the math element. The href attribute points to a value elsewhere in the document'} formulaComponent: test::gen::FormulaComponent[*];
}

>>>test::gen::FormulaComponent
Class {meta::pure::profiles::doc.doc = 'Elements describing the components of the formula. The name attribute points to a value used in the math element. The href attribute points to a numeric value defined elsewhere in the document that is used by the formula component.'} test::gen::FormulaComponent
[
  c1_length: $this.componentDescription->length() <= 255,
  c2_length: $this.name->forAll(x: String[1]|$x->length() >= 0)
]
{
  {meta::pure::profiles::doc.doc = 'Text description of the component'} componentDescription: String[1];
  {meta::pure::profiles::doc.doc = 'Additional formulas required to describe this component'} formula: test::gen::Formula[0..1];
  name: String[0..1];
}

>>>test::gen::FpvFinalPriceElectionFallbackEnum
Enum {meta::pure::profiles::doc.doc = 'Specifies the fallback provisions in respect to the applicable Futures Price Valuation.'} test::gen::FpvFinalPriceElectionFallbackEnum
{
  FPVClose,
  FPVHedgeExecution
}

>>>test::gen::FraDiscountingEnum
Enum {meta::pure::profiles::doc.doc = 'The method of FRA discounting, if any, that will apply.'} test::gen::FraDiscountingEnum
{
  ISDA,
  AFMA,
  NONE,
  ISDAYield
}

>>>test::gen::Frequency
Class {meta::pure::profiles::doc.doc = 'A type defining a time frequency, e.g. one day, three months. Used for specifying payment or calculation frequencies at which the value T (Term) is applicable.'} test::gen::Frequency
{
  {meta::pure::profiles::doc.doc = 'A time period multiplier, e.g. 1, 2 or 3 etc. If the period value is T (Term) then periodMultiplier must contain the value 1.'} periodMultiplier: Decimal[1];
  {meta::pure::profiles::doc.doc = 'A time period, e.g. a day, week, month, year or term of the stream.'} period: test::gen::PeriodExtendedEnum[1];
  id: String[0..1];
}

>>>test::gen::FutureValueAmount
Class {meta::pure::profiles::doc.doc = 'A type defining a currency amount as at a future value date.'} test::gen::FutureValueAmount extends test::gen::NonNegativeMoney
{
  {meta::pure::profiles::doc.doc = 'The number of days from the adjusted calculation period start date to the adjusted value date, calculated in accordance with the applicable day count fraction.'} calculationPeriodNumberOfDays: Decimal[1];
  {meta::pure::profiles::doc.doc = 'Adjusted value date of the future value amount.'} valueDate: StrictDate[1];
}

>>>test::gen::FxAccrualKnockoutBarrierRetentionEnum
Enum {meta::pure::profiles::doc.doc = 'The type of a knockout barrier used in an accrual product (e.g. American or European)'} test::gen::FxAccrualKnockoutBarrierRetentionEnum
{
  Keep,
  Lose
}

>>>test::gen::FxAveragingMethodEnum
Enum {meta::pure::profiles::doc.doc = 'Average calculation method e.g. Arithmetic, Harmonic)'} test::gen::FxAveragingMethodEnum
{
  Arithmetic,
  Harmonic
}

>>>test::gen::FxBarrierDirectionEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of whether the direction of a barrier within an FX OTC option is Down or Up.'} test::gen::FxBarrierDirectionEnum
{
  Down,
  Up
}

>>>test::gen::FxBarrierScopeEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of whether a barrier has effect for the current expiry period, or globally to the whole product.'} test::gen::FxBarrierScopeEnum
{
  Global,
  PerExpiry
}

>>>test::gen::FxBarrierStyleEnum
Enum {meta::pure::profiles::doc.doc = 'Defines the barrier observation style i.e. continuous (American) or discrete (Euriopean).'} test::gen::FxBarrierStyleEnum
{
  American,
  European
}

>>>test::gen::FxBarrierTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of whether a barrier within an FX OTC option is a knockin or knockout.'} test::gen::FxBarrierTypeEnum
{
  Knockin,
  Knockout,
  ReverseKnockin,
  ReverseKnockout
}

>>>test::gen::FxBarrierTypeSimpleEnum
Enum {meta::pure::profiles::doc.doc = 'Defines the outcome in the event that the barrier is triggered i.e. whether the product becomes active (Knockin) or is extinguished (Knockout). Omitting superseded values ReverseKnock[in|out].'} test::gen::FxBarrierTypeSimpleEnum
{
  Knockin,
  Knockout
}

>>>test::gen::FxCashSettlement
Class {meta::pure::profiles::doc.doc = 'A type that is used for describing cash settlement of an option / non deliverable forward. It includes the currency to settle into together with the fixings required to calculate the currency amount.'} test::gen::FxCashSettlement
[
  c1_choice: ($this.fixing->isNotEmpty() && $this.rateSourceFixing->isEmpty()) || ($this.fixing->isEmpty() && $this.rateSourceFixing->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'The currency in which cash settlement occurs for non-deliverable forwards and cash-settled options (non-deliverable or otherwise).'} settlementCurrency: test::gen::Currency[1];
  referenceCurrency: test::gen::Currency[0..1];
  {meta::pure::profiles::doc.doc = 'The amount of money that the settlement will be derived from.'} notionalAmount: test::gen::PositiveMoney[0..1];
  {meta::pure::profiles::doc.doc = 'Specifies the source for and timing of a fixing of an exchange rate. This is used in the agreement of non-deliverable forward trades as well as various types of FX OTC options that require observations against a particular rate. This element is optional, permitting it to be omitted where fixing details are unavailable at the point of message creation. It has multiple occurrence to support the case where fixing details must be specified for more than one currency pair e.g. on an option settled into a third currency (that is not one of the option currencies).'} fixing: test::gen::FxFixing[*];
  {meta::pure::profiles::doc.doc = 'Specifies the source for and timing of a fixing of an exchange rate. This is used in the agreement of non-deliverable forward trades as well as various types of FX OTC options that require observations against a particular rate. This element is optional, permitting it to be omitted where fixing details are unavailable at the point of message creation. It has multiple occurrence to support the case where fixing details must be specified for more than one currency pair e.g. on an option settled into a third currency (that is not one of the option currencies).'} rateSourceFixing: test::gen::FxRateSourceFixing[*];
  {meta::pure::profiles::doc.doc = 'The date on which settlement is scheduled to occur'} settlementDate: test::gen::AdjustableDate[0..1];
}

>>>test::gen::FxCashSettlementSimple
Class {meta::pure::profiles::doc.doc = 'A type that is used for describing cash settlement of a variance or volatility swap option. It includes the settlement currency together with the spot currency exchange required to calculate the settlement currency amount.'} test::gen::FxCashSettlementSimple
[
  c1_choice: ($this.fixing->isNotEmpty() && $this.rateSourceFixing->isEmpty()) || ($this.fixing->isEmpty() && $this.rateSourceFixing->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'The currency in which cash settlement occurs.'} settlementCurrency: test::gen::Currency[1];
  {meta::pure::profiles::doc.doc = 'Reference Currency.'} referenceCurrency: test::gen::Currency[0..1];
  {meta::pure::profiles::doc.doc = 'Quoted currency pair.'} fixing: test::gen::FxFixing[*];
  {meta::pure::profiles::doc.doc = 'Settlement Rate Source and Fixing Date.'} rateSourceFixing: test::gen::FxRateSourceFixing[*];
}

>>>test::gen::FxFixing
Class {meta::pure::profiles::doc.doc = 'A type that specifies the source for and timing of a fixing of an exchange rate. This is used in the agreement of non-deliverable forward trades as well as various types of FX OTC options that require observations against a particular rate.'} test::gen::FxFixing
{
  {meta::pure::profiles::doc.doc = 'Defines the two currencies for an FX trade and the quotation relationship between the two currencies.'} quotedCurrencyPair: test::gen::QuotedCurrencyPair[1];
  {meta::pure::profiles::doc.doc = 'Describes the specific date when a non-deliverable forward or cash-settled option will "fix" against a particular rate, which will be used to compute the ultimate cash settlement. This element should be omitted where a single, discrete fixing date cannot be identified e.g. on an american option, where fixing may occur at any date on a continuous range.'} fixingDate: StrictDate[0..1];
  {meta::pure::profiles::doc.doc = 'Specifies the methodology (reference source and, optionally, fixing time) to be used for determining a currency conversion rate.'} fxSpotRateSource: test::gen::FxSpotRateSource[0..1];
}

>>>test::gen::FxInformationSource
Class test::gen::FxInformationSource extends test::gen::InformationSource
{
  {meta::pure::profiles::doc.doc = 'The time that the fixing will be taken along with a business center to define the time zone'} fixingTime: test::gen::BusinessCenterTime[0..1];
}

>>>test::gen::FxOffsetConventionEnum
Enum {meta::pure::profiles::doc.doc = 'Standard FX Spot and Forward offset conventions.'} test::gen::FxOffsetConventionEnum
{
  FxSpot,
  FxForward
}

>>>test::gen::FxRate
Class {meta::pure::profiles::doc.doc = 'A type describing the rate of a currency conversion: pair of currency, quotation mode and exchange rate.'} test::gen::FxRate
{
  {meta::pure::profiles::doc.doc = 'Defines the two currencies for an FX trade and the quotation relationship between the two currencies.'} quotedCurrencyPair: test::gen::QuotedCurrencyPair[1];
  {meta::pure::profiles::doc.doc = 'The rate of exchange between the two currencies of the leg of a deal. Must be specified with a quote basis.'} rate: Decimal[1];
}

>>>test::gen::FxRateSourceFixing
Class {meta::pure::profiles::doc.doc = 'Describes a rate source to be fixed and the date the fixing occurs'} test::gen::FxRateSourceFixing
{
  settlementRateSource: test::gen::FxSettlementRateSource[1];
  {meta::pure::profiles::doc.doc = 'The date on which the fixing is scheduled to occur.'} fixingDate: test::gen::AdjustableDate[1];
}

>>>test::gen::FxRegionLowerBoundDirectionEnum
Enum {meta::pure::profiles::doc.doc = 'The Lower Bound Direction. It only contains the AtOrAbove and Above values.'} test::gen::FxRegionLowerBoundDirectionEnum
{
  AtOrAbove,
  Above
}

>>>test::gen::FxRegionUpperBoundDirectionEnum
Enum {meta::pure::profiles::doc.doc = 'The Upper Bound Direction. It only contains the AtOrBelow and Below values.'} test::gen::FxRegionUpperBoundDirectionEnum
{
  AtOrBelow,
  Below
}

>>>test::gen::FxSettlementAdjustmentMethodEnum
Enum {meta::pure::profiles::doc.doc = 'Target specific settlement adjustment method.'} test::gen::FxSettlementAdjustmentMethodEnum
{
  VariedStrike,
  VariedNotional
}

>>>test::gen::FxSettlementRateSource
Class test::gen::FxSettlementRateSource
[
  c1_choice: ($this.settlementRateOption->isNotEmpty() && $this.nonstandardSettlementRate->isEmpty()) || ($this.settlementRateOption->isEmpty() && $this.nonstandardSettlementRate->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'Indicates that an officially defined rate settlement rate option will be the used for the fixing.'} settlementRateOption: test::gen::SettlementRateOption[0..1];
  {meta::pure::profiles::doc.doc = 'Indicates that a non-standard rate source will be used for the fixing.'} nonstandardSettlementRate: test::gen::FxInformationSource[0..1];
}

>>>test::gen::FxSpotRateSource
Class {meta::pure::profiles::doc.doc = 'A type defining the rate source and fixing time for an fx rate.'} test::gen::FxSpotRateSource
{
  {meta::pure::profiles::doc.doc = 'The primary source for where the rate observation will occur. Will typically be either a page or a reference bank published rate.'} primaryRateSource: test::gen::InformationSource[1];
  {meta::pure::profiles::doc.doc = 'An alternative, or secondary, source for where the rate observation will occur. Will typically be either a page or a reference bank published rate.'} secondaryRateSource: test::gen::InformationSource[0..1];
  {meta::pure::profiles::doc.doc = 'The time at which the spot currency exchange rate will be observed. It is specified as a time in a business day calendar location, e.g. 11:00am London time.'} fixingTime: test::gen::BusinessCenterTime[0..1];
}

>>>test::gen::FxStraddleTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Forward Volatility Agreement Straddle Type.'} test::gen::FxStraddleTypeEnum
{
  AtTheMoneyForward,
  DeltaNeutral
}

>>>test::gen::FxTargetStyleEnum
Enum {meta::pure::profiles::doc.doc = 'Defines the method for calculating the gain in the period where the Target Knock-Out event occurs (Exact, Exclusive, Inclusive).'} test::gen::FxTargetStyleEnum
{
  Exact,
  Exclusive,
  Inclusive
}

>>>test::gen::FxTenorPeriodEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of a time period containing values such as Today, Tomorrow etc.'} test::gen::FxTenorPeriodEnum
{
  Broken,
  Today,
  Tomorrow,
  TomorrowNext,
  Spot,
  SpotNext
}

>>>test::gen::GasProductTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The type of gas product.'} test::gen::GasProductTypeEnum
{
  Butane,
  CarbonDioxide,
  EPMix,
  Ethane,
  Gasoline,
  Helium,
  HydrogenSulfide,
  Isobutane,
  Methane,
  Naphtha,
  NaturalGas,
  Nitrogen,
  Pentane,
  Propane,
  Propylene,
  Water
}

>>>test::gen::GoverningLaw
Class {meta::pure::profiles::doc.doc = 'Identification of the law governing the transaction.'} test::gen::GoverningLaw
[
  c1_length: $this.governingLawScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  governingLawScheme: String[0..1];
  value: String[1];
}

>>>test::gen::GrossCashflow
Class {meta::pure::profiles::doc.doc = 'A payment component owed from one party to the other for the cash flow date. This payment component should by of only a single type, e.g. a fee or a cashflow from a cashflow stream.'} test::gen::GrossCashflow
{
  {meta::pure::profiles::doc.doc = 'Unique identifier for a cash flow.'} cashflowId: test::gen::CashflowId[1];
  {meta::pure::profiles::doc.doc = 'Pointer-style reference to the partyTradeIdentifier block within the tradeIdentifyingItems collection, which identifies the parent trade for this cashflow.'} partyTradeIdentifierReference: test::gen::PartyTradeIdentifierReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party responsible for making the payments defined by this structure.'} payerPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account responsible for making the payments defined by this structure.'} payerAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party that receives the payments corresponding to this structure.'} receiverPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account that receives the payments corresponding to this structure.'} receiverAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'Cash flow amount in a given currency to be paid/received.'} cashflowAmount: test::gen::Money[1];
  {meta::pure::profiles::doc.doc = 'Defines the type of cash flow. For instance, a type of fee, premium, principal exchange, leg fee.'} cashflowType: test::gen::CashflowType[0..1];
}

>>>test::gen::IdentifiedCurrency
Class {meta::pure::profiles::doc.doc = 'Specifies Currency with ID attribute.'} test::gen::IdentifiedCurrency extends test::gen::Currency
{
  id: String[0..1];
}

>>>test::gen::IdentifiedCurrencyReference
Class {meta::pure::profiles::doc.doc = 'Reference to a currency with ID attribute'} test::gen::IdentifiedCurrencyReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::IdentifiedDate
Class {meta::pure::profiles::doc.doc = 'A date which can be referenced elsewhere.'} test::gen::IdentifiedDate
{
  id: String[0..1];
  value: StrictDate[1];
}

>>>test::gen::IdentifiedPayerReceiver
Class {meta::pure::profiles::doc.doc = 'A type extending the PayerReceiverEnum type wih an id attribute.'} test::gen::IdentifiedPayerReceiver
{
  id: String[0..1];
  value: test::gen::PayerReceiverEnum[1];
}

>>>test::gen::IdentifiedRate
Class {meta::pure::profiles::doc.doc = 'A rate which can be referenced elsewhere.'} test::gen::IdentifiedRate
{
  id: String[0..1];
  value: Decimal[1];
}

>>>test::gen::IndependentAmount
Class test::gen::IndependentAmount
{
  {meta::pure::profiles::doc.doc = 'A reference to the party responsible for making the payments defined by this structure.'} payerPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account responsible for making the payments defined by this structure.'} payerAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party that receives the payments corresponding to this structure.'} receiverPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account that receives the payments corresponding to this structure.'} receiverAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A container element allowing a schedule of payments associated with the Independent Amount.'} paymentDetail: test::gen::PaymentDetail[1..*];
}

>>>test::gen::IndexEventConsequenceEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of the consequences of Index Events.'} test::gen::IndexEventConsequenceEnum
{
  CalculationAgentAdjustment,
  NegotiatedCloseOut,
  CancellationAndPayment,
  RelatedExchange
}

>>>test::gen::IndustryClassification
Class {meta::pure::profiles::doc.doc = 'A party\'s industry sector classification.'} test::gen::IndustryClassification
[
  c1_length: $this.industryClassificationScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  industryClassificationScheme: String[0..1];
  value: String[1];
}

>>>test::gen::InformationProvider
Class test::gen::InformationProvider
[
  c1_length: $this.informationProviderScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  informationProviderScheme: String[0..1];
  value: String[1];
}

>>>test::gen::InformationSource
Class {meta::pure::profiles::doc.doc = 'A type defining the source for a piece of information (e.g. a rate refix or an fx fixing).'} test::gen::InformationSource
[
  c1_length: $this.rateSourcePageHeading->forAll(x: String[1]|$x->length() <= 255)
]
{
  {meta::pure::profiles::doc.doc = 'An information source for obtaining a market rate. For example Bloomberg, Reuters, Telerate etc.'} rateSource: test::gen::InformationProvider[1];
  {meta::pure::profiles::doc.doc = 'A specific page for the rate source for obtaining a market rate.'} rateSourcePage: test::gen::RateSourcePage[0..1];
  {meta::pure::profiles::doc.doc = 'The heading for the rate source on a given rate source page.'} rateSourcePageHeading: String[0..1];
}

>>>test::gen::InstrumentId
Class {meta::pure::profiles::doc.doc = 'A short form unique identifier for a security.'} test::gen::InstrumentId
[
  c1_length: $this.instrumentIdScheme->length() >= 1,
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  instrumentIdScheme: String[1];
  value: String[1];
}

>>>test::gen::InterestAccrualsCompoundingMethod
Class {meta::pure::profiles::doc.doc = 'A type defining the way in which interests are accrued: the applicable rate (fixed or floating reference) and the compounding method.'} test::gen::InterestAccrualsCompoundingMethod extends test::gen::InterestAccrualsMethod
{
  {meta::pure::profiles::doc.doc = 'If more that one calculation period contributes to a single payment amount this element specifies whether compounding is applicable, and if so, what compounding method is to be used. This element must only be included when more that one calculation period contributes to a single payment amount.'} compoundingMethod: test::gen::CompoundingMethodEnum[1];
}

>>>test::gen::InterestAccrualsMethod
Class {meta::pure::profiles::doc.doc = 'A type describing the method for accruing interests on dividends. Can be either a fixed rate reference or a floating rate reference.'} test::gen::InterestAccrualsMethod
[
  c1_choice: ($this.floatingRateCalculation->isNotEmpty() && $this.fixedRate->isEmpty()) || ($this.floatingRateCalculation->isEmpty() && $this.fixedRate->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'The floating rate calculation definitions'} floatingRateCalculation: test::gen::FloatingRateCalculation[0..1];
  {meta::pure::profiles::doc.doc = 'The calculation period fixed rate. A per annum rate, expressed as a decimal. A fixed rate of 5% would be represented as 0.05.'} fixedRate: Decimal[0..1];
}

>>>test::gen::InterestCalculationMethodEnum
Enum {meta::pure::profiles::doc.doc = 'Defines whether the agent bank is making an interest payment based on the lender pro-rata share at the end of the period (snapshot) or based on the lender position throughout the period.'} test::gen::InterestCalculationMethodEnum
{
  ContractPositionThruPeriod,
  ProRataShareSnapshot
}

>>>test::gen::InterestShortfallCapEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of the interest shortfall cap, applicable to mortgage derivatives.'} test::gen::InterestShortfallCapEnum
{
  Fixed,
  Variable
}

>>>test::gen::IntermediaryInformation
Class {meta::pure::profiles::doc.doc = 'A type that describes the information to identify an intermediary through which payment will be made by the correspondent bank to the ultimate beneficiary of the funds.'} test::gen::IntermediaryInformation
[
  c1_choice: ($this.routingIds->isNotEmpty() && ($this.routingExplicitDetails->isEmpty() && $this.routingIdsAndExplicitDetails->isEmpty())) || (($this.routingIds->isEmpty() && ($this.routingExplicitDetails->isNotEmpty() && $this.routingIdsAndExplicitDetails->isEmpty())) || ($this.routingIds->isEmpty() && ($this.routingExplicitDetails->isEmpty() && $this.routingIdsAndExplicitDetails->isNotEmpty())))
]
{
  {meta::pure::profiles::doc.doc = 'A set of unique identifiers for a party, eachone identifying the party within a payment system. The assumption is that each party will not have more than one identifier within the same payment system.'} routingIds: test::gen::RoutingIds[0..1];
  {meta::pure::profiles::doc.doc = 'A set of details that is used to identify a party involved in the routing of a payment when the party does not have a code that identifies it within one of the recognized payment systems.'} routingExplicitDetails: test::gen::RoutingExplicitDetails[0..1];
  {meta::pure::profiles::doc.doc = 'A combination of coded payment system identifiers and details for physical addressing for a party involved in the routing of a payment.'} routingIdsAndExplicitDetails: test::gen::RoutingIdsAndExplicitDetails[0..1];
  {meta::pure::profiles::doc.doc = 'A sequence number that gives the position of the current intermediary in the chain of payment intermediaries. The assumed domain value set is an ascending sequence of integers starting from 1.'} intermediarySequenceNumber: Decimal[1];
  {meta::pure::profiles::doc.doc = 'Reference to the party acting as intermediary.'} intermediaryPartyReference: test::gen::PartyReference[0..1];
}

>>>test::gen::InterpolationMethod
Class {meta::pure::profiles::doc.doc = 'The type of interpolation used.'} test::gen::InterpolationMethod
[
  c1_length: $this.interpolationMethodScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  interpolationMethodScheme: String[0..1];
  value: String[1];
}

>>>test::gen::InterpolationPeriodEnum
Enum {meta::pure::profiles::doc.doc = 'Defines applicable periods for interpolation.'} test::gen::InterpolationPeriodEnum
{
  Initial,
  InitialAndFinal,
  Final,
  AnyPeriod
}

>>>test::gen::IssuerId
Class {meta::pure::profiles::doc.doc = 'The data type used for issuer identifiers.'} test::gen::IssuerId
[
  c1_length: $this.issuerIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  issuerIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::IssuerTradeId
Class {meta::pure::profiles::doc.doc = 'A complex type for a two part identifier such as a USI.'} test::gen::IssuerTradeId
{
  issuer: test::gen::IssuerId[1];
  tradeId: test::gen::TradeId[1];
}

>>>test::gen::Language
Class {meta::pure::profiles::doc.doc = 'The data type used for indicating the language of the resource, described using the ISO 639-2/T Code.'} test::gen::Language
[
  c1_length: $this.languageScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  languageScheme: String[0..1];
  value: String[1];
}

>>>test::gen::LcAutoAdjustEnum
Enum {meta::pure::profiles::doc.doc = 'The type of automatic adjustment that a Letter of Credit can exhibit.'} test::gen::LcAutoAdjustEnum
{
  AutoDecrease,
  AutoIncrease,
  AutoIncreaseOrDecrease
}

>>>test::gen::Leg
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'A supertype of leg. All swap legs extend this type.'} test::gen::Leg
{
  id: String[0..1];
}

>>>test::gen::LegId
Class {meta::pure::profiles::doc.doc = 'Leg identity.'} test::gen::LegId
[
  c1_length: $this.legIdScheme->length() >= 1,
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 60
]
{
  legIdScheme: String[1];
  value: String[1];
}

>>>test::gen::LegIdentifier
Class {meta::pure::profiles::doc.doc = 'Version aware identification of a leg.'} test::gen::LegIdentifier
{
  {meta::pure::profiles::doc.doc = 'Identity of this leg.'} legId: test::gen::LegId[1];
  {meta::pure::profiles::doc.doc = 'The version number'} version: Decimal[1];
  {meta::pure::profiles::doc.doc = 'Optionally it is possible to specify a version effective date when a versionId is supplied.'} effectiveDate: test::gen::IdentifiedDate[0..1];
}

>>>test::gen::LegalEntity
Class {meta::pure::profiles::doc.doc = 'A type defining a legal entity.'} test::gen::LegalEntity
[
  c1_choice: $this.entityName->isNotEmpty() || ($this.entityName->isEmpty() && $this.entityId->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'The name of the reference entity. A free format string. FpML does not define usage rules for this element.'} entityName: test::gen::EntityName[0..1];
  {meta::pure::profiles::doc.doc = 'A legal entity identifier (e.g. RED entity code)..'} entityId: test::gen::EntityId[*];
  id: String[0..1];
}

>>>test::gen::LegalEntityReference
Class {meta::pure::profiles::doc.doc = 'References a credit entity defined elsewhere in the document.'} test::gen::LegalEntityReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::LengthUnitEnum
Enum {meta::pure::profiles::doc.doc = 'Used for indicating the length unit in the Resource type.'} test::gen::LengthUnitEnum
{
  Pages,
  TimeUnit
}

>>>test::gen::LimitModelEnum
Enum {meta::pure::profiles::doc.doc = 'The type of credit approval request.'} test::gen::LimitModelEnum
{
  Ping,
  Plus1ToStop,
  Plus1ToPing,
  PushToPing,
  PushToStop
}

>>>test::gen::LoadTypeEnum
Enum {meta::pure::profiles::doc.doc = 'LoadType is a summary of the full description of the settlement periods with respect to the region. Used for describing Electricity delivery schedules.'} test::gen::LoadTypeEnum
{
  Base,
  Peak,
  OffPeak,
  BlockHours,
  Custom
}

>>>test::gen::LoanTradingAccrualSettlementEnum
Enum {meta::pure::profiles::doc.doc = 'A list that defines how the interest accrued during the settlement period is calculated and paid.'} test::gen::LoanTradingAccrualSettlementEnum
{
  Flat,
  SettledWithAccrued,
  SettledWithoutAccrued
}

>>>test::gen::LoanTradingAccruingFeeTypeEnum
Enum {meta::pure::profiles::doc.doc = 'A list of accruing fee types associated with a facility.'} test::gen::LoanTradingAccruingFeeTypeEnum
{
  Commitment,
  Facility,
  LetterOfCreditIssuance,
  Ticking,
  Utilization
}

>>>test::gen::LoanTradingAssocEnum
Enum {meta::pure::profiles::doc.doc = 'A list that defines the loan trading association responsible for defining the standardized legal framework that governs the trade.'} test::gen::LoanTradingAssocEnum
{
  LMA,
  LSTA
}

>>>test::gen::LoanTradingDocTypeEnum
Enum {meta::pure::profiles::doc.doc = 'A list describing the type of documentation used to settle a secondary market syndicated loan trade.'} test::gen::LoanTradingDocTypeEnum
{
  Distressed,
  Par
}

>>>test::gen::LoanTradingFormOfPurchaseEnum
Enum {meta::pure::profiles::doc.doc = 'A list describing forms of purchase.'} test::gen::LoanTradingFormOfPurchaseEnum
{
  Assignment,
  AssignmentOnly,
  Other,
  LMAFundedParticipation,
  LMAFundedRiskParticipation,
  LMARiskParticipation,
  LMARiskToFundedParticipation,
  LMATransferAgreement,
  LMATransferCertificate,
  Participation
}

>>>test::gen::LoanTradingNonRecurringFeeTypeEnum
Enum {meta::pure::profiles::doc.doc = 'A list of accruing fee types associated with a facility.'} test::gen::LoanTradingNonRecurringFeeTypeEnum
{
  Amendment,
  Consent,
  Facility,
  FacilityExension,
  Upfront,
  Waiver
}

>>>test::gen::LoanTradingSettlementTaskStatusEnum
Enum {meta::pure::profiles::doc.doc = 'A list that defines the status of a settlement task.'} test::gen::LoanTradingSettlementTaskStatusEnum
{
  Active,
  Cleared,
  Cancelled
}

>>>test::gen::LoanTradingTypeEnum
Enum {meta::pure::profiles::doc.doc = 'A list that specifies whether a trade was executed during the syndication period or in the post-syndication market.'} test::gen::LoanTradingTypeEnum
{
  Primary,
  Secondary
}

>>>test::gen::LoanTradingVotingRightsEnum
Enum {meta::pure::profiles::doc.doc = 'A list that specifies type of voting rights process, i.e. whether voting rights are passed along to buyer or retained by seller.'} test::gen::LoanTradingVotingRightsEnum
{
  PassedOnToBuyer,
  RetainedBySeller
}

>>>test::gen::LoanTransferFeePaidByEnum
Enum {meta::pure::profiles::doc.doc = 'A list of standard market rules for the treatment of split of assignment fees between counterparties.'} test::gen::LoanTransferFeePaidByEnum
{
  BuyerSplitOneHalf,
  OneFeePaidByBuyer,
  OneFeePaidBySeller,
  PaidByBuyer,
  PaidBySeller,
  SellerSplitOneHalf,
  SplitFull
}

>>>test::gen::MainPublication
Class {meta::pure::profiles::doc.doc = 'A type to define the main publication source.'} test::gen::MainPublication
[
  c1_length: $this.mainPublicationScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  mainPublicationScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ManualExercise
Class {meta::pure::profiles::doc.doc = 'A type defining manual exercise, i.e. that the option buyer counterparty must give notice to the option seller of exercise.'} test::gen::ManualExercise
{
  {meta::pure::profiles::doc.doc = 'Definition of the party to whom notice of exercise should be given.'} exerciseNotice: test::gen::ExerciseNotice[0..1];
  {meta::pure::profiles::doc.doc = 'If fallback exercise is specified then the notional amount of the underlying swap, not previously exercised under the swaption, will be automatically exercised at the expiration time on the expiration date if at such time the buyer is in-the-money, provided that the difference between the settlement rate and the fixed rate under the relevant underlying swap is not less than one tenth of a percentage point (0.10% or 0.001). The term in-the-money is assumed to have the meaning defined in the 2000 ISDA Definitions, Section 17.4. In-the-money.'} fallbackExercise: Boolean[0..1];
}

>>>test::gen::MarginTypeEnum
Enum {meta::pure::profiles::doc.doc = 'This indicator defines which type of assets (cash or securities) is specified to apply as margin to the repo transaction.'} test::gen::MarginTypeEnum
{
  Cash,
  Instrument
}

>>>test::gen::MarketDisruptionEventsEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of how market disruption events will be represented.'} test::gen::MarketDisruptionEventsEnum
{
  Applicable,
  NotApplicable,
  AsSpecifiedInMasterAgreement,
  AsSpecifiedInConfirmation
}

>>>test::gen::MasterAgreement
Class {meta::pure::profiles::doc.doc = 'An entity for defining the agreement executed between the parties and intended to govern all OTC derivatives transactions between those parties.'} test::gen::MasterAgreement
{
  {meta::pure::profiles::doc.doc = 'An identifier that has been created to identify the master agreement.'} masterAgreementId: test::gen::MasterAgreementId[*];
  {meta::pure::profiles::doc.doc = 'The agreement executed between the parties and intended to govern product-specific derivatives transactions between those parties.'} masterAgreementType: test::gen::MasterAgreementType[1];
  {meta::pure::profiles::doc.doc = 'The version of the master agreement.'} masterAgreementVersion: test::gen::MasterAgreementVersion[0..1];
  {meta::pure::profiles::doc.doc = 'The date on which the master agreement was signed.'} masterAgreementDate: StrictDate[0..1];
}

>>>test::gen::MasterAgreementId
Class {meta::pure::profiles::doc.doc = 'A master agreement identifier allocated by a party. FpML does not define the domain values associated with this element. Note that the domain values for this element are not strictly an enumerated list.'} test::gen::MasterAgreementId
[
  c1_length: $this.masterAgreementIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  masterAgreementIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::MasterAgreementType
Class test::gen::MasterAgreementType
[
  c1_length: $this.masterAgreementTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  masterAgreementTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::MasterAgreementVersion
Class test::gen::MasterAgreementVersion
[
  c1_length: $this.masterAgreementVersionScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  masterAgreementVersionScheme: String[0..1];
  value: String[1];
}

>>>test::gen::MasterConfirmation
Class {meta::pure::profiles::doc.doc = 'An entity for defining the master confirmation agreement executed between the parties.'} test::gen::MasterConfirmation
{
  {meta::pure::profiles::doc.doc = 'The type of master confirmation executed between the parties.'} masterConfirmationType: test::gen::MasterConfirmationType[1];
  {meta::pure::profiles::doc.doc = 'The date of the confirmation executed between the parties and intended to govern all relevant transactions between those parties.'} masterConfirmationDate: StrictDate[1];
  {meta::pure::profiles::doc.doc = 'The date that an annex to the master confirmation was executed between the parties.'} masterConfirmationAnnexDate: StrictDate[0..1];
  {meta::pure::profiles::doc.doc = 'The type of master confirmation annex executed between the parties.'} masterConfirmationAnnexType: test::gen::MasterConfirmationAnnexType[0..1];
}

>>>test::gen::MasterConfirmationAnnexType
Class test::gen::MasterConfirmationAnnexType
[
  c1_length: $this.masterConfirmationAnnexTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  masterConfirmationAnnexTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::MasterConfirmationType
Class test::gen::MasterConfirmationType
[
  c1_length: $this.masterConfirmationTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  masterConfirmationTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::MatchId
Class {meta::pure::profiles::doc.doc = 'An identifier used to identify matched cashflows.'} test::gen::MatchId
[
  c1_length: $this.matchIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  matchIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::Math
Class {meta::pure::profiles::doc.doc = 'A type defining a mathematical expression.'} test::gen::Math
{
}

>>>test::gen::MatrixTerm
Class test::gen::MatrixTerm
[
  c1_length: $this.matrixTermScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  matrixTermScheme: String[0..1];
  value: String[1];
}

>>>test::gen::MatrixType
Class test::gen::MatrixType
[
  c1_length: $this.matrixTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  matrixTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::MetalTitleEnum
Enum {meta::pure::profiles::doc.doc = 'Describes how and when title to the commodity transfers.'} test::gen::MetalTitleEnum
{
  TransfersWithRiskOfLoss,
  DoesNotTransferWithRiskOfLoss
}

>>>test::gen::MethodOfAdjustmentEnum
Enum {meta::pure::profiles::doc.doc = 'Defines how adjustments will be made to the contract should one or more of the extraordinary events occur.'} test::gen::MethodOfAdjustmentEnum
{
  CalculationAgent,
  OptionsExchange
}

>>>test::gen::MimeType
Class {meta::pure::profiles::doc.doc = 'The type that indicates the type of media used to store the content. MimeType is used to determine the software product(s) that can read the content. MIME types are described in RFC 2046.'} test::gen::MimeType
[
  c1_length: $this.mimeTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  mimeTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::Money
Class {meta::pure::profiles::doc.doc = 'A type defining a currency amount.'} test::gen::Money extends test::gen::MoneyBase
{
  {meta::pure::profiles::doc.doc = 'The monetary quantity in currency units.'} amount: Decimal[1];
}

>>>test::gen::MoneyBase
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'Abstract base class for all money types.'} test::gen::MoneyBase
{
  {meta::pure::profiles::doc.doc = 'The currency in which an amount is denominated.'} currency: test::gen::Currency[1];
  id: String[0..1];
}

>>>test::gen::MultipleExercise
Class {meta::pure::profiles::doc.doc = 'A type defining multiple exercises. As defining in the 2000 ISDA Definitions, Section 12.4. Multiple Exercise, the buyer of the option has the right to exercise all or less than all the unexercised notional amount of the underlying swap on one or more days in the exercise period, but on any such day may not exercise less than the minimum notional amount or more than the maximum notional amount, and if an integral multiple amount is specified, the notional exercised must be equal to or, be an integral multiple of, the integral multiple amount.'} test::gen::MultipleExercise
[
  c1_range: $this.maximumNumberOfOptions->forAll(x: Decimal[1]|$x >= 0),
  c2_choice: ($this.minimumNotionalAmount->isNotEmpty() && $this.minimumNumberOfOptions->isEmpty()) || ($this.minimumNotionalAmount->isEmpty() && $this.minimumNumberOfOptions->isNotEmpty()),
  c3_choice: ($this.maximumNotionalAmount->isNotEmpty() && $this.maximumNumberOfOptions->isEmpty()) || ($this.maximumNotionalAmount->isEmpty() && $this.maximumNumberOfOptions->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'A pointer style reference to the associated notional schedule defined elsewhere in the document. This element has been made optional as part of its integration in the OptionBaseExtended, because not required for the options on securities.'} notionalReference: test::gen::NotionalReference[*];
  {meta::pure::profiles::doc.doc = 'A notional amount which restricts the amount of notional that can be exercised when partial exercise or multiple exercise is applicable. The integral multiple amount defines a lower limit of notional that can be exercised and also defines a unit multiple of notional that can be exercised, i.e. only integer multiples of this amount can be exercised.'} integralMultipleAmount: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The minimum notional amount that can be exercised on a given exercise date. See multipleExercise.'} minimumNotionalAmount: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The minimum number of options that can be exercised on a given exercise date.'} minimumNumberOfOptions: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The maximum notional amount that can be exercised on a given exercise date.'} maximumNotionalAmount: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The maximum number of options that can be exercised on a given exercise date. If the number is not specified, it means that the maximum number of options corresponds to the remaining unexercised options.'} maximumNumberOfOptions: Decimal[0..1];
}

>>>test::gen::NationalisationOrInsolvencyOrDelistingEventEnum
Enum {meta::pure::profiles::doc.doc = 'Defines the consequences of nationalisation, insolvency and delisting events relating to the underlying.'} test::gen::NationalisationOrInsolvencyOrDelistingEventEnum
{
  NegotiatedCloseout,
  CancellationAndPayment
}

>>>test::gen::NegativeInterestRateTreatmentEnum
Enum {meta::pure::profiles::doc.doc = 'The method of calculating payment obligations when a floating rate is negative (either due to a quoted negative floating rate or by operation of a spread that is subtracted from the floating rate).'} test::gen::NegativeInterestRateTreatmentEnum
{
  NegativeInterestRateMethod,
  ZeroInterestRateMethod
}

>>>test::gen::NonCashDividendTreatmentEnum
Enum {meta::pure::profiles::doc.doc = 'Defines treatment of non-cash dividends.'} test::gen::NonCashDividendTreatmentEnum
{
  PotentialAdjustmentEvent,
  CashEquivalent
}

>>>test::gen::NonNegativeAmountSchedule
Class {meta::pure::profiles::doc.doc = 'A type defining a currency amount or a currency amount schedule.'} test::gen::NonNegativeAmountSchedule extends test::gen::NonNegativeSchedule
{
  {meta::pure::profiles::doc.doc = 'The currency in which an amount is denominated.'} currency: test::gen::Currency[1];
}

>>>test::gen::NonNegativeMoney
Class {meta::pure::profiles::doc.doc = 'A type defining a non negative money amount.'} test::gen::NonNegativeMoney extends test::gen::MoneyBase
[
  c1_range: $this.amount >= 0
]
{
  {meta::pure::profiles::doc.doc = 'The non negative monetary quantity in currency units.'} amount: Decimal[1];
}

>>>test::gen::NonNegativePayment
Class {meta::pure::profiles::doc.doc = 'A complex type to specify non negative payments.'} test::gen::NonNegativePayment extends test::gen::PaymentBaseExtended
{
  {meta::pure::profiles::doc.doc = 'Non negative payment amount.'} paymentAmount: test::gen::NonNegativeMoney[1];
}

>>>test::gen::NonNegativeSchedule
Class {meta::pure::profiles::doc.doc = 'A type defining a schedule of non-negative rates or amounts in terms of an initial value and then a series of step date and value pairs. On each step date the rate or amount changes to the new step value. The series of step date and value pairs are optional. If not specified, this implies that the initial value remains unchanged over time.'} test::gen::NonNegativeSchedule
[
  c1_range: $this.initialValue >= 0
]
{
  {meta::pure::profiles::doc.doc = 'The non-negative initial rate or amount, as the case may be. An initial rate of 5% would be represented as 0.05.'} initialValue: Decimal[1];
  {meta::pure::profiles::doc.doc = 'The schedule of step date and non-negative value pairs. On each step date the associated step value becomes effective. A list of steps may be ordered in the document by ascending step date. An FpML document containing an unordered list of steps is still regarded as a conformant document.'} step: test::gen::NonNegativeStep[*];
  id: String[0..1];
}

>>>test::gen::NonNegativeStep
Class {meta::pure::profiles::doc.doc = 'A type defining a step date and non-negative step value pair. This step definitions are used to define varying rate or amount schedules, e.g. a notional amortization or a step-up coupon schedule.'} test::gen::NonNegativeStep extends test::gen::StepBase
[
  c1_range: $this.stepValue >= 0
]
{
  {meta::pure::profiles::doc.doc = 'The non-negative rate or amount which becomes effective on the associated stepDate. A rate of 5% would be represented as 0.05.'} stepValue: Decimal[1];
}

>>>test::gen::NotionalAdjustmentEnum
Enum {meta::pure::profiles::doc.doc = 'The conditions that govern the adjustment to the number of units of the equity swap.'} test::gen::NotionalAdjustmentEnum
{
  Execution,
  PortfolioRebalancing,
  Standard
}

>>>test::gen::NotionalAmount
Class {meta::pure::profiles::doc.doc = 'A complex type to specify the notional amount.'} test::gen::NotionalAmount extends test::gen::NonNegativeMoney
{
}

>>>test::gen::NotionalAmountReference
Class {meta::pure::profiles::doc.doc = 'A reference to the notional amount.'} test::gen::NotionalAmountReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::NotionalChangeEnum
Enum {meta::pure::profiles::doc.doc = 'Indicator as to the type of transaction in accordance with Articles 20(3)(a) and 21(5)(a) of Regulation (EU) 600/2014.'} test::gen::NotionalChangeEnum
{
  Increase,
  Decrease
}

>>>test::gen::NotionalReference
Class {meta::pure::profiles::doc.doc = 'A reference to the notional amount.'} test::gen::NotionalReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::NumberOfOptionsReference
Class {meta::pure::profiles::doc.doc = 'A reference to the number of options.'} test::gen::NumberOfOptionsReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::NumberOfUnitsReference
Class {meta::pure::profiles::doc.doc = 'A reference to the number of units.'} test::gen::NumberOfUnitsReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::ObligationCategoryEnum
Enum {meta::pure::profiles::doc.doc = 'Used in both the obligations and deliverable obligations of the credit default swap to represent a class or type of securities which apply.'} test::gen::ObligationCategoryEnum
{
  Payment,
  BorrowedMoney,
  ReferenceObligationsOnly,
  Bond,
  Loan,
  BondOrLoan
}

>>>test::gen::ObservationFrequency
Class {meta::pure::profiles::doc.doc = 'A type defining the frequency at which calculation period end dates occur within the regular part of the calculation period schedule and thier roll date convention. In case the calculation frequency is of value T (term), the period is defined by the swap\\swapStream\\calculationPerioDates\\effectiveDate and the swap\\swapStream\\calculationPerioDates\\terminationDate.'} test::gen::ObservationFrequency extends test::gen::Period
{
  {meta::pure::profiles::doc.doc = 'Used in conjunction with a frequency and the regular period start date of an observation period, determines each observation period end date within the regular part of a observation period schedule.'} periodConvention: test::gen::RollConventionEnum[0..1];
}

>>>test::gen::Offset
Class {meta::pure::profiles::doc.doc = 'A type defining an offset used in calculating a new date relative to a reference date. E.g. calendar days, business days, Commodity Business days, etc..'} test::gen::Offset extends test::gen::Period
{
  {meta::pure::profiles::doc.doc = 'In the case of an offset specified as a number of days, this element defines whether consideration is given as to whether a day is a good business day or not. If a day type of business days is specified then non-business days are ignored when calculating the offset. The financial business centers to use for determination of business days are implied by the context in which this element is used. This element must only be included when the offset is specified as a number of days. If the offset is zero days then the dayType element should not be included.'} dayType: test::gen::DayTypeEnum[0..1];
}

>>>test::gen::OffsetPrevailingTime
Class {meta::pure::profiles::doc.doc = 'Allows the specification of a time that may be on a day prior or subsequent to the day in question. This type is intended for use with a day of the week (i.e. where no actual date is specified) as part of, for example, a period that runs from 23:00-07:00 on a series of days and where holidays on the actual days would affect the entire time period.'} test::gen::OffsetPrevailingTime
{
  time: test::gen::PrevailingTime[1];
  {meta::pure::profiles::doc.doc = 'Indicates whether time applies to the actual day specified (in which case this element should be omitted) the day prior to that day (in which case periodMultiplier should be -1 and period should be Day) or the day subsequent to that day (in which case periodMultiplier should be 1 and period should be Day).'} offset: test::gen::Offset[0..1];
}

>>>test::gen::OnBehalfOf
Class test::gen::OnBehalfOf
{
  {meta::pure::profiles::doc.doc = 'The party for which the message reciever should work.'} partyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'Identifies the account(s) related to the party when they cannot be determined from the party alone, for example in a inter-book trade.'} accountReference: test::gen::AccountReference[*];
}

>>>test::gen::OptionTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Specifies the type of the option.'} test::gen::OptionTypeEnum
{
  Put,
  Call,
  Payer,
  Receiver,
  Straddle
}

>>>test::gen::OrganizationType
Class {meta::pure::profiles::doc.doc = 'A code that describes what type of role an organization plays, for example a SwapsDealer, a Major Swaps Participant, or Other'} test::gen::OrganizationType
[
  c1_length: $this.organizationTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 0
]
{
  organizationTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::OriginatingEvent
Class test::gen::OriginatingEvent
[
  c1_length: $this.originatingEventScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  originatingEventScheme: String[0..1];
  value: String[1];
}

>>>test::gen::OtherAgreement
Class {meta::pure::profiles::doc.doc = 'An entity for defining the an agreement executed between parties.'} test::gen::OtherAgreement
{
  {meta::pure::profiles::doc.doc = 'An identifier that has been created to identify the agreement.'} identifier: test::gen::OtherAgreementId[*];
  {meta::pure::profiles::doc.doc = 'The agreement executed between the parties and intended to govern product-specific derivatives transactions between those parties.'} type: test::gen::OtherAgreementType[1];
  {meta::pure::profiles::doc.doc = 'The version of the agreement.'} version: test::gen::OtherAgreementVersion[0..1];
  {meta::pure::profiles::doc.doc = 'The date on which the agreement was signed.'} date: StrictDate[0..1];
}

>>>test::gen::OtherAgreementId
Class {meta::pure::profiles::doc.doc = 'A agreement identifier allocated by a party. FpML does not define the domain values associated with this element. Note that the domain values for this element are not strictly an enumerated list.'} test::gen::OtherAgreementId
[
  c1_length: $this.agreementIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  agreementIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::OtherAgreementType
Class test::gen::OtherAgreementType
[
  c1_length: $this.agreementTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  agreementTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::OtherAgreementVersion
Class test::gen::OtherAgreementVersion
[
  c1_length: $this.agreementVersionScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  agreementVersionScheme: String[0..1];
  value: String[1];
}

>>>test::gen::PartialExercise
Class {meta::pure::profiles::doc.doc = 'A type defining partial exercise. As defined in the 2000 ISDA Definitions, Section 12.3 Partial Exercise, the buyer of the option may exercise all or less than all the notional amount of the underlying swap but may not be less than the minimum notional amount (if specified) and must be an integral multiple of the integral multiple amount if specified.'} test::gen::PartialExercise
[
  c1_choice: ($this.minimumNotionalAmount->isNotEmpty() && $this.minimumNumberOfOptions->isEmpty()) || ($this.minimumNotionalAmount->isEmpty() && $this.minimumNumberOfOptions->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'A pointer style reference to the associated notional schedule defined elsewhere in the document. This element has been made optional as part of its integration in the OptionBaseExtended, because not required for the options on securities.'} notionalReference: test::gen::NotionalReference[*];
  {meta::pure::profiles::doc.doc = 'A notional amount which restricts the amount of notional that can be exercised when partial exercise or multiple exercise is applicable. The integral multiple amount defines a lower limit of notional that can be exercised and also defines a unit multiple of notional that can be exercised, i.e. only integer multiples of this amount can be exercised.'} integralMultipleAmount: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The minimum notional amount that can be exercised on a given exercise date. See multipleExercise.'} minimumNotionalAmount: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The minimum number of options that can be exercised on a given exercise date.'} minimumNumberOfOptions: Decimal[0..1];
}

>>>test::gen::Party
Class {meta::pure::profiles::doc.doc = 'A type defining a legal entity or a subdivision of a legal entity. Parties can perform multiple roles in a trade lifecycle. For example, the principal parties obligated to make payments from time to time during the term of the trade, but may include other parties involved in, or incidental to, the trade, such as parties acting in the role of novation transferor/transferee, broker, calculation agent, etc. In FpML roles are defined in multiple places within a document.'} test::gen::Party
[
  c1_choice: ($this.partyId->isNotEmpty() && ($this.groupType->isEmpty() && $this.partyReference->isEmpty())) || ($this.partyId->isEmpty() && ($this.partyName->isEmpty() && ($this.classification->isEmpty() && ($this.creditRating->isEmpty() && ($this.country->isEmpty() && ($this.region->isEmpty() && ($this.jurisdiction->isEmpty() && ($this.organizationType->isEmpty() && ($this.contactInfo->isEmpty() && ($this.businessUnit->isEmpty() && ($this.person->isEmpty() && ($this.groupType->isNotEmpty() && $this.partyReference->isNotEmpty()))))))))))))
]
{
  {meta::pure::profiles::doc.doc = 'A party identifier, e.g. a S.W.I.F.T. bank identifier code (BIC).'} partyId: test::gen::PartyId[*];
  {meta::pure::profiles::doc.doc = 'The legal name of the organization. A free format string. FpML does not define usage rules for this element.'} partyName: test::gen::PartyName[0..1];
  {meta::pure::profiles::doc.doc = 'The party\'s industry sector classification.'} classification: test::gen::IndustryClassification[*];
  {meta::pure::profiles::doc.doc = 'The party\'s credit rating.'} creditRating: test::gen::CreditRating[*];
  {meta::pure::profiles::doc.doc = 'The country where the party is domiciled.'} country: test::gen::CountryCode[0..1];
  {meta::pure::profiles::doc.doc = 'A code for a grouping of countries to which this belongs.'} region: test::gen::Region[*];
  {meta::pure::profiles::doc.doc = 'The legal jurisdiction of the entity\'s registration.'} jurisdiction: test::gen::GoverningLaw[*];
  {meta::pure::profiles::doc.doc = 'The type of an organization\'s participantion in the OTC derivatives market.'} organizationType: test::gen::OrganizationType[0..1];
  {meta::pure::profiles::doc.doc = 'Information on how to contact the party using various means.'} contactInfo: test::gen::ContactInformation[0..1];
  {meta::pure::profiles::doc.doc = 'Optional organization unit information used to describe the organization units (e.g. trading desks) involved in a transaction or business process .'} businessUnit: test::gen::BusinessUnit[*];
  {meta::pure::profiles::doc.doc = 'Optional information about people involved in a transaction or busines process. (These are eomployees of the party).'} person: test::gen::Person[*];
  {meta::pure::profiles::doc.doc = 'Party Group Type, e.g. JointAndSeveralLiability'} groupType: test::gen::PartyGroupType[0..1];
  {meta::pure::profiles::doc.doc = 'Reference to a party that is a member of the group of entities that are acting together as a single party in a transaction.'} partyReference: test::gen::PartyReference[*];
  {meta::pure::profiles::doc.doc = 'The id uniquely identifying the Party within the document.'} id: String[1];
}

>>>test::gen::PartyGroupType
Class {meta::pure::profiles::doc.doc = 'The data type used for party group classification.'} test::gen::PartyGroupType
[
  c1_length: $this.partyGroupTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  partyGroupTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::PartyId
Class {meta::pure::profiles::doc.doc = 'The data type used for party identifiers.'} test::gen::PartyId
[
  c1_length: $this.partyIdScheme->length() >= 1,
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  partyIdScheme: String[1];
  value: String[1];
}

>>>test::gen::PartyName
Class {meta::pure::profiles::doc.doc = 'The data type used for the legal name of an organization.'} test::gen::PartyName
[
  c1_length: $this.partyNameScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  partyNameScheme: String[0..1];
  value: String[1];
}

>>>test::gen::PartyReference
Class {meta::pure::profiles::doc.doc = 'Reference to a party.'} test::gen::PartyReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::PartyRole
Class {meta::pure::profiles::doc.doc = 'A type describing a role played by a party in one or more transactions. Examples include roles such as guarantor, custodian, confirmation service provider, etc. This can be extended to provide custom roles.'} test::gen::PartyRole
[
  c1_length: $this.partyRoleScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  partyRoleScheme: String[0..1];
  value: String[1];
}

>>>test::gen::PartyRoleType
Class {meta::pure::profiles::doc.doc = 'A type refining the role a role played by a party in one or more transactions. Examples include "AllPositions" and "SomePositions" for Guarantor. This can be extended to provide custom types.'} test::gen::PartyRoleType
[
  c1_length: $this.partyRoleTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  partyRoleTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::PartyTradeIdentifierReference
Class {meta::pure::profiles::doc.doc = 'A reference to a partyTradeIdentifier object.'} test::gen::PartyTradeIdentifierReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::PayRelativeToEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of whether payments occur relative to the calculation period start or end date, or the reset date.'} test::gen::PayRelativeToEnum
{
  CalculationPeriodStartDate,
  CalculationPeriodEndDate,
  LastPricingDate,
  ResetDate,
  ValuationDate
}

>>>test::gen::PayerReceiverEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of an interest rate stream payer or receiver party.'} test::gen::PayerReceiverEnum
{
  Payer,
  Receiver
}

>>>test::gen::Payment
Class {meta::pure::profiles::doc.doc = 'A type for defining payments. In Transparency view, normally the payer and receiver party references are not used; however they may be provided if necessary for administrative activities such as Reporting Party Determination in FX.'} test::gen::Payment extends test::gen::PaymentBase
{
  {meta::pure::profiles::doc.doc = 'A reference to the party responsible for making the payments defined by this structure.'} payerPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account responsible for making the payments defined by this structure.'} payerAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party that receives the payments corresponding to this structure.'} receiverPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account that receives the payments corresponding to this structure.'} receiverAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'The currency amount of the payment.'} paymentAmount: test::gen::NonNegativeMoney[1];
  {meta::pure::profiles::doc.doc = 'The payment date. This date is subject to adjustment in accordance with any applicable business day convention.'} paymentDate: test::gen::AdjustableOrAdjustedDate[0..1];
  {meta::pure::profiles::doc.doc = 'A classification of the type of fee or additional payment, e.g. brokerage, upfront fee etc. FpML does not define domain values for this element.'} paymentType: test::gen::PaymentType[0..1];
  {meta::pure::profiles::doc.doc = 'The information required to settle a currency payment that results from a trade.'} settlementInformation: test::gen::SettlementInformation[0..1];
  {meta::pure::profiles::doc.doc = 'The value representing the discount factor used to calculate the present value of the cash flow.'} discountFactor: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The amount representing the present value of the forecast payment.'} presentValueAmount: test::gen::Money[0..1];
  {meta::pure::profiles::doc.doc = 'Can be used to reference the yield curve used to estimate the discount factor.'} href: String[0..1];
}

>>>test::gen::PaymentBase
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'An abstract base class for payment types.'} test::gen::PaymentBase
{
  id: String[0..1];
}

>>>test::gen::PaymentBaseExtended
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'Base type for payments.'} test::gen::PaymentBaseExtended extends test::gen::PaymentBase
{
  {meta::pure::profiles::doc.doc = 'A reference to the party responsible for making the payments defined by this structure.'} payerPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account responsible for making the payments defined by this structure.'} payerAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party that receives the payments corresponding to this structure.'} receiverPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account that receives the payments corresponding to this structure.'} receiverAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'The payment date, which can be expressed as either an adjustable or relative date.'} paymentDate: test::gen::AdjustableOrRelativeDate[1];
}

>>>test::gen::PaymentDetail
Class test::gen::PaymentDetail extends test::gen::PaymentBase
{
  {meta::pure::profiles::doc.doc = 'Payment date.'} paymentDate: test::gen::AdjustableOrRelativeDate[0..1];
  {meta::pure::profiles::doc.doc = 'A fixed payment amount.'} paymentAmount: test::gen::Money[0..1];
  {meta::pure::profiles::doc.doc = 'A type defining the calculation rule.'} paymentRule: test::gen::PaymentRule[0..1];
}

>>>test::gen::PaymentDetails
Class {meta::pure::profiles::doc.doc = 'Details on the referenced payment. e.g. Its cashflow components, settlement details.'} test::gen::PaymentDetails
{
  {meta::pure::profiles::doc.doc = 'The reference to the identified payment strucutre.'} paymentReference: test::gen::PaymentReference[1];
  {meta::pure::profiles::doc.doc = 'Payment details of this cash flow component, including currency, amount and payer/payee.'} grossCashflow: test::gen::GrossCashflow[1..*];
  {meta::pure::profiles::doc.doc = 'The information required to settle a currency payment.'} settlementInformation: test::gen::SettlementInformation[0..1];
}

>>>test::gen::PaymentReference
Class {meta::pure::profiles::doc.doc = 'Reference to a payment.'} test::gen::PaymentReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::PaymentRule
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'The abstract base type from which all calculation rules of the independent amount must be derived.'} test::gen::PaymentRule
{
}

>>>test::gen::PaymentType
Class test::gen::PaymentType
[
  c1_length: $this.paymentTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  paymentTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::PayoutEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of how an FX OTC option with a trigger payout will be paid if the trigger condition is met. The contract will specify whether the payout will occur immediately or on the original value date of the option.'} test::gen::PayoutEnum
{
  Deferred,
  Immediate
}

>>>test::gen::Period
Class {meta::pure::profiles::doc.doc = 'A type to define recurring periods or time offsets.'} test::gen::Period
{
  {meta::pure::profiles::doc.doc = 'A time period multiplier, e.g. 1, 2 or 3 etc. A negative value can be used when specifying an offset relative to another date, e.g. -2 days.'} periodMultiplier: Decimal[1];
  {meta::pure::profiles::doc.doc = 'A time period, e.g. a day, week, month or year of the stream. If the periodMultiplier value is 0 (zero) then period must contain the value D (day).'} period: test::gen::PeriodEnum[1];
  id: String[0..1];
}

>>>test::gen::PeriodEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of a time period'} test::gen::PeriodEnum
{
  D,
  W,
  M,
  Y
}

>>>test::gen::PeriodExtendedEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of a time period containing additional values such as Term.'} test::gen::PeriodExtendedEnum
{
  D,
  W,
  M,
  Y,
  T
}

>>>test::gen::PeriodTimeEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of a time period containing additional values such as Term.'} test::gen::PeriodTimeEnum
{
  D,
  W,
  M,
  Y,
  Hour,
  Minute,
  Second
}

>>>test::gen::PeriodicDates
Class test::gen::PeriodicDates
{
  calculationStartDate: test::gen::AdjustableOrRelativeDate[1];
  calculationEndDate: test::gen::AdjustableOrRelativeDate[0..1];
  {meta::pure::profiles::doc.doc = 'The frequency at which calculation period end dates occur with the regular part of the calculation period schedule and their roll date convention.'} calculationPeriodFrequency: test::gen::CalculationPeriodFrequency[1];
  {meta::pure::profiles::doc.doc = 'The business day convention to apply to each calculation period end date if it would otherwise fall on a day that is not a business day in the specified financial business centers.'} calculationPeriodDatesAdjustments: test::gen::BusinessDayAdjustments[1];
}

>>>test::gen::Person
Class {meta::pure::profiles::doc.doc = 'A type that represents information about a person connected with a trade or business process.'} test::gen::Person
[
  c1_length: $this.honorific->forAll(x: String[1]|$x->length() >= 0),
  c2_length: $this.firstName->length() >= 0,
  c3_length: $this.middleName->forAll(x: String[1]|$x->length() >= 0),
  c4_length: $this.initial->forAll(x: String[1]|$x->length() == 1),
  c5_length: $this.surname->length() >= 0,
  c6_length: $this.suffix->forAll(x: String[1]|$x->length() >= 0),
  c7_choice: ($this.middleName->isNotEmpty() && $this.initial->isEmpty()) || ($this.middleName->isEmpty() && $this.initial->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'An honorific title, such as Mr., Ms., Dr. etc.'} honorific: String[0..1];
  {meta::pure::profiles::doc.doc = 'Given name, such as John or Mary.'} firstName: String[1];
  middleName: String[*];
  initial: String[*];
  {meta::pure::profiles::doc.doc = 'Family name, such as Smith or Jones.'} surname: String[1];
  {meta::pure::profiles::doc.doc = 'Name suffix, such as Jr., III, etc.'} suffix: String[0..1];
  {meta::pure::profiles::doc.doc = 'An identifier assigned by a system for uniquely identifying the individual'} personId: test::gen::PersonId[*];
  {meta::pure::profiles::doc.doc = 'The unit for which the indvidual works.'} businessUnitReference: test::gen::BusinessUnitReference[0..1];
  {meta::pure::profiles::doc.doc = 'Information on how to contact the individual using various means.'} contactInfo: test::gen::ContactInformation[0..1];
  {meta::pure::profiles::doc.doc = 'The birth date of the person, e.g. 1970-01-01'} dateOfBirth: StrictDate[0..1];
  {meta::pure::profiles::doc.doc = 'The ISO 3166 standard code for the country where the individual works.'} country: test::gen::CountryCode[0..1];
  id: String[0..1];
}

>>>test::gen::PersonId
Class {meta::pure::profiles::doc.doc = 'An identifier used to identify an individual person.'} test::gen::PersonId
[
  c1_length: $this.personIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  personIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::PersonReference
Class {meta::pure::profiles::doc.doc = 'Reference to an individual.'} test::gen::PersonReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::PersonRole
Class {meta::pure::profiles::doc.doc = 'A type describing a role played by a person in one or more transactions. Examples include roles such as Trader, Broker, MiddleOffice, Legal, etc. This can be extended to provide custom roles.'} test::gen::PersonRole
[
  c1_length: $this.personRoleScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  personRoleScheme: String[0..1];
  value: String[1];
}

>>>test::gen::PositiveMoney
Class {meta::pure::profiles::doc.doc = 'A type defining a positive money amount'} test::gen::PositiveMoney extends test::gen::MoneyBase
[
  c1_range: $this.amount > 0
]
{
  {meta::pure::profiles::doc.doc = 'The positive monetary quantity in currency units.'} amount: Decimal[1];
}

>>>test::gen::PremiumQuoteBasisEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of how the premium for an FX OTC option is quoted.'} test::gen::PremiumQuoteBasisEnum
{
  PercentageOfCallCurrencyAmount,
  PercentageOfPutCurrencyAmount,
  CallCurrencyPerPutCurrency,
  PutCurrencyPerCallCurrency,
  Explicit
}

>>>test::gen::PremiumTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Premium Type for Forward Start Equity Option'} test::gen::PremiumTypeEnum
{
  PrePaid,
  PostPaid,
  Variable,
  Fixed
}

>>>test::gen::PrevailingTime
Class {meta::pure::profiles::doc.doc = 'A type for defining a time with respect to a geographic location, for example 11:00 Phoenix, USA. This type should be used where a wider range of locations than those available as business centres is required.'} test::gen::PrevailingTime
{
  {meta::pure::profiles::doc.doc = 'A time specified in hh:mm:ss format where the second component must be \'00\', e.g. 11am would be represented as 11:00:00.'} hourMinuteTime: String[1];
  {meta::pure::profiles::doc.doc = 'The geographic location to which the hourMinuteTime applies. The time takes into account any current day light saving changes or other adjustments i.e. it is the prevaling time at the location.'} location: test::gen::TimezoneLocation[1];
}

>>>test::gen::PriceExpressionEnum
Enum {meta::pure::profiles::doc.doc = 'The mode of expression of a price.'} test::gen::PriceExpressionEnum
{
  AbsoluteTerms,
  PercentageOfNotional
}

>>>test::gen::PricingStructure
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'An abstract pricing structure base type. Used as a base for structures such as yield curves and volatility matrices.'} test::gen::PricingStructure
[
  c1_length: $this.name->forAll(x: String[1]|$x->length() >= 0)
]
{
  {meta::pure::profiles::doc.doc = 'The name of the structure, e.g "USDLIBOR-3M EOD Curve".'} name: String[0..1];
  {meta::pure::profiles::doc.doc = 'The currency that the structure is expressed in (this is relevant mostly for the Interes Rates asset class).'} currency: test::gen::Currency[0..1];
  id: String[0..1];
}

>>>test::gen::PricingStructureReference
Class {meta::pure::profiles::doc.doc = 'Reference to a pricing structure or any derived components (i.e. yield curve).'} test::gen::PricingStructureReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::PrincipalExchanges
Class {meta::pure::profiles::doc.doc = 'A type defining which principal exchanges occur for the stream.'} test::gen::PrincipalExchanges
{
  {meta::pure::profiles::doc.doc = 'A true/false flag to indicate whether there is an initial exchange of principal on the effective date.'} initialExchange: Boolean[1];
  {meta::pure::profiles::doc.doc = 'A true/false flag to indicate whether there is a final exchange of principal on the termination date.'} finalExchange: Boolean[1];
  {meta::pure::profiles::doc.doc = 'A true/false flag to indicate whether there are intermediate or interim exchanges of principal during the term of the swap.'} intermediateExchange: Boolean[1];
  id: String[0..1];
}

>>>test::gen::Product
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'The base type which all FpML products extend.'} test::gen::Product
{
  {meta::pure::profiles::doc.doc = 'A classification of the most important risk class of the trade. FpML defines a simple asset class categorization using a coding scheme.'} primaryAssetClass: test::gen::AssetClass[0..1];
  {meta::pure::profiles::doc.doc = 'A classification of additional risk classes of the trade, if any. FpML defines a simple asset class categorization using a coding scheme.'} secondaryAssetClass: test::gen::AssetClass[*];
  {meta::pure::profiles::doc.doc = 'A classification of the type of product. FpML defines a simple product categorization using a coding scheme.'} productType: test::gen::ProductType[*];
  {meta::pure::profiles::doc.doc = 'A product reference identifier. The product ID is an identifier that describes the key economic characteristics of the trade type, with the exception of concepts such as size (notional, quantity, number of units) and price (fixed rate, strike, etc.) that are negotiated for each transaction. It can be used to hold identifiers such as the "UPI" (universal product identifier) required by certain regulatory reporting rules. It can also be used to hold identifiers of benchmark products or product temnplates used by certain trading systems or facilities. FpML does not define the domain values associated with this element. Note that the domain values for this element are not strictly an enumerated list.'} productId: test::gen::ProductId[*];
  {meta::pure::profiles::doc.doc = 'A classification of the risk class of the trade. FpML defines a simple asset class categorization using a coding scheme.'} assetClass: test::gen::AssetClass[*];
  id: String[0..1];
}

>>>test::gen::ProductId
Class test::gen::ProductId
[
  c1_length: $this.productIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 1023
]
{
  productIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ProductReference
Class {meta::pure::profiles::doc.doc = 'Reference to a full FpML product.'} test::gen::ProductReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::ProductType
Class test::gen::ProductType
[
  c1_length: $this.productTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 1023
]
{
  productTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ProposedCollateralAllocation
Class {meta::pure::profiles::doc.doc = 'The proposed collateral allocation.'} test::gen::ProposedCollateralAllocation
{
  {meta::pure::profiles::doc.doc = 'Reference to a party.'} allocationPartyReference: test::gen::PartyReference[0..1];
  {meta::pure::profiles::doc.doc = 'Reference to an account.'} allocationAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'Collateral allocation by value.'} collateralValueAllocation: test::gen::CollateralValueAllocation[1];
}

>>>test::gen::PutCallEnum
Enum {meta::pure::profiles::doc.doc = 'Specifies whether the option is a call or a put.'} test::gen::PutCallEnum
{
  Put,
  Call
}

>>>test::gen::QuotationRateTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of the type of quotation rate to be obtained from each cash settlement reference bank.'} test::gen::QuotationRateTypeEnum
{
  Bid,
  Ask,
  Mid,
  ExercisingPartyPays
}

>>>test::gen::QuotationSideEnum
Enum {meta::pure::profiles::doc.doc = 'The side from which perspective a value is quoted.'} test::gen::QuotationSideEnum
{
  Bid,
  Ask,
  Mid
}

>>>test::gen::QuotationStyleEnum
Enum {meta::pure::profiles::doc.doc = 'Indicates the actual quotation style of of PointsUpFront or TradedSpread that was used to quote this trade.'} test::gen::QuotationStyleEnum
{
  PointsUpFront,
  TradedSpread,
  Price
}

>>>test::gen::QuoteBasisEnum
Enum {meta::pure::profiles::doc.doc = 'How an exchange rate is quoted.'} test::gen::QuoteBasisEnum
{
  Currency1PerCurrency2,
  Currency2PerCurrency1
}

>>>test::gen::QuotedCurrencyPair
Class {meta::pure::profiles::doc.doc = 'A type that describes the composition of a rate that has been quoted or is to be quoted. This includes the two currencies and the quotation relationship between the two currencies and is used as a building block throughout the FX specification.'} test::gen::QuotedCurrencyPair
{
  {meta::pure::profiles::doc.doc = 'The first currency specified when a pair of currencies is to be evaluated.'} currency1: test::gen::Currency[1];
  {meta::pure::profiles::doc.doc = 'The second currency specified when a pair of currencies is to be evaluated.'} currency2: test::gen::Currency[1];
  {meta::pure::profiles::doc.doc = 'The method by which the exchange rate is quoted.'} quoteBasis: test::gen::QuoteBasisEnum[1];
}

>>>test::gen::Rate
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'The abstract base class for all types which define interest rate streams.'} test::gen::Rate
{
  id: String[0..1];
}

>>>test::gen::RateObservation
Class {meta::pure::profiles::doc.doc = 'A type defining parameters associated with an individual observation or fixing. This type forms part of the cashflow representation of a stream.'} test::gen::RateObservation
{
  {meta::pure::profiles::doc.doc = 'The reset date.'} resetDate: StrictDate[0..1];
  {meta::pure::profiles::doc.doc = 'The adjusted fixing date, i.e. the actual date the rate is observed. The date should already be adjusted for any applicable business day convention.'} adjustedFixingDate: StrictDate[0..1];
  {meta::pure::profiles::doc.doc = 'The actual observed rate before any required rate treatment is applied, e.g. before converting a rate quoted on a discount basis to an equivalent yield. An observed rate of 5% would be represented as 0.05.'} observedRate: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The observed rate after any required rate treatment is applied. A treated rate of 5% would be represented as 0.05.'} treatedRate: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The number of days weighting to be associated with the rate observation, i.e. the number of days such rate is in effect. This is applicable in the case of a weighted average method of calculation where more than one reset date is established for a single calculation period.'} observationWeight: Decimal[1];
  {meta::pure::profiles::doc.doc = 'A pointer style reference to a floating rate component defined as part of a stub calculation period amount component. It is only required when it is necessary to distinguish two rate observations for the same fixing date which could occur when linear interpolation of two different rates occurs for a stub calculation period.'} rateReference: test::gen::RateReference[0..1];
  {meta::pure::profiles::doc.doc = 'The value representing the forecast rate used to calculate the forecast future value of the accrual period.A value of 1% should be represented as 0.01'} forecastRate: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The value representing the forecast rate after applying rate treatment rules. A value of 1% should be represented as 0.01'} treatedForecastRate: Decimal[0..1];
  id: String[0..1];
}

>>>test::gen::RateReference
Class {meta::pure::profiles::doc.doc = 'Reference to any rate (floating, inflation) derived from the abstract Rate component.'} test::gen::RateReference
{
  href: String[1];
}

>>>test::gen::RateSourcePage
Class test::gen::RateSourcePage
[
  c1_length: $this.rateSourcePageScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  rateSourcePageScheme: String[0..1];
  value: String[1];
}

>>>test::gen::RateTreatmentEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of methods for converting rates from one basis to another.'} test::gen::RateTreatmentEnum
{
  BondEquivalentYield,
  MoneyMarketYield
}

>>>test::gen::RealisedVarianceMethodEnum
Enum {meta::pure::profiles::doc.doc = 'The contract specifies whether which price must satisfy the boundary condition.'} test::gen::RealisedVarianceMethodEnum
{
  Previous,
  Last,
  Both
}

>>>test::gen::Reference
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'The abstract base class for all types which define intra-document pointers.'} test::gen::Reference
{
}

>>>test::gen::ReferenceAmount
Class {meta::pure::profiles::doc.doc = 'Specifies the reference amount using a scheme.'} test::gen::ReferenceAmount
[
  c1_length: $this.referenceAmountScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  referenceAmountScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ReferenceBank
Class {meta::pure::profiles::doc.doc = 'A type to describe an institution (party) identified by means of a coding scheme and an optional name.'} test::gen::ReferenceBank
[
  c1_length: $this.referenceBankName->forAll(x: String[1]|$x->length() <= 255)
]
{
  {meta::pure::profiles::doc.doc = 'An institution (party) identifier, e.g. a bank identifier code (BIC).'} referenceBankId: test::gen::ReferenceBankId[1];
  {meta::pure::profiles::doc.doc = 'The name of the institution (party). A free format string. FpML does not define usage rules for the element.'} referenceBankName: String[0..1];
}

>>>test::gen::ReferenceBankId
Class test::gen::ReferenceBankId
[
  c1_length: $this.referenceBankIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  referenceBankIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::Region
Class {meta::pure::profiles::doc.doc = 'A code that describes the world region of a counterparty. For example, NorthAmerica, Europe, Asia.'} test::gen::Region
[
  c1_length: $this.regionScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  regionScheme: String[0..1];
  value: String[1];
}

>>>test::gen::RelatedBusinessUnit
Class test::gen::RelatedBusinessUnit
{
  {meta::pure::profiles::doc.doc = 'The unit that is related to this.'} businessUnitReference: test::gen::BusinessUnitReference[1];
  {meta::pure::profiles::doc.doc = 'The category of the relationship. The related unit performs the role specified in this field for the base party. For example, if the role is "Trader", the related unit acts acts or acted as the base party\'s trading unit.'} role: test::gen::BusinessUnitRole[1];
}

>>>test::gen::RelatedParty
Class test::gen::RelatedParty
{
  {meta::pure::profiles::doc.doc = 'Reference to a party.'} partyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'Reference to an account.'} accountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'The category of the relationship. The related party performs the role specified in this field for the base party. For example, if the role is "Guarantor", the related party acts as a guarantor for the base party.'} role: test::gen::PartyRole[1];
  {meta::pure::profiles::doc.doc = 'Additional definition refining the type of relationship. For example, if the "role" is Guarantor, this element may be used to specify whether all positions are guaranteed, or only a subset of them.'} type: test::gen::PartyRoleType[0..1];
}

>>>test::gen::RelatedPerson
Class test::gen::RelatedPerson
{
  {meta::pure::profiles::doc.doc = 'The individual person that is related to this.'} personReference: test::gen::PersonReference[1];
  {meta::pure::profiles::doc.doc = 'The category of the relationship. The related individual performs the role specified in this field for the base party. For example, if the role is "Trader", the related person acts acts or acted as the base party\'s trader.'} role: test::gen::PersonRole[1];
}

>>>test::gen::RelativeDateOffset
Class {meta::pure::profiles::doc.doc = 'A type defining a date (referred to as the derived date) as a relative offset from another date (referred to as the anchor date). If the anchor date is itself an adjustable date then the offset is assumed to be calculated from the adjusted anchor date. A number of different scenarios can be supported, namely; 1) the derived date may simply be a number of calendar periods (days, weeks, months or years) preceding or following the anchor date; 2) the unadjusted derived date may be a number of calendar periods (days, weeks, months or years) preceding or following the anchor date with the resulting unadjusted derived date subject to adjustment in accordance with a specified business day convention, i.e. the derived date must fall on a good business day; 3) the derived date may be a number of business days preceding or following the anchor date. Note that the businessDayConvention specifies any required adjustment to the unadjusted derived date. A negative or positive value in the periodMultiplier indicates whether the unadjusted derived precedes or follows the anchor date. The businessDayConvention should contain a value NONE if the day type element contains a value of Business (since specifying a negative or positive business days offset would already guarantee that the derived date would fall on a good business day in the specified business centers).'} test::gen::RelativeDateOffset extends test::gen::Offset
{
  {meta::pure::profiles::doc.doc = 'The convention for adjusting a date if it would otherwise fall on a day that is not a business day.'} businessDayConvention: test::gen::BusinessDayConventionEnum[1];
  {meta::pure::profiles::doc.doc = 'A pointer style reference to a set of financial business centers defined elsewhere in the document. This set of business centers is used to determine whether a particular day is a business day or not.'} businessCentersReference: test::gen::BusinessCentersReference[0..1];
  businessCenters: test::gen::BusinessCenters[0..1];
  {meta::pure::profiles::doc.doc = 'Specifies the anchor as an href attribute. The href attribute value is a pointer style reference to the element or component elsewhere in the document where the anchor date is defined.'} dateRelativeTo: test::gen::DateReference[1];
  {meta::pure::profiles::doc.doc = 'The date once the adjustment has been performed. (Note that this date may change if the business center holidays change).'} adjustedDate: test::gen::IdentifiedDate[0..1];
}

>>>test::gen::RelativeDateSequence
Class {meta::pure::profiles::doc.doc = 'A type describing a date when this date is defined in reference to another date through one or several date offsets.'} test::gen::RelativeDateSequence
[
  c1_choice: ($this.businessCentersReference->isNotEmpty() && $this.businessCenters->isEmpty()) || ($this.businessCentersReference->isEmpty() && $this.businessCenters->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'Specifies the anchor as an href attribute. The href attribute value is a pointer style reference to the element or component elsewhere in the document where the anchor date is defined.'} dateRelativeTo: test::gen::DateReference[1];
  dateOffset: test::gen::DateOffset[1..*];
  {meta::pure::profiles::doc.doc = 'A pointer style reference to a set of financial business centers defined elsewhere in the document. This set of business centers is used to determine whether a particular day is a business day or not.'} businessCentersReference: test::gen::BusinessCentersReference[0..1];
  businessCenters: test::gen::BusinessCenters[0..1];
}

>>>test::gen::RelativeDates
Class {meta::pure::profiles::doc.doc = 'A type describing a set of dates defined as relative to another set of dates.'} test::gen::RelativeDates extends test::gen::RelativeDateOffset
{
  {meta::pure::profiles::doc.doc = 'The number of periods in the referenced date schedule that are between each date in the relative date schedule. Thus a skip of 2 would mean that dates are relative to every second date in the referenced schedule. If present this should have a value greater than 1.'} periodSkip: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The first and last dates of a schedule. This can be used to restrict the range of values in a reference series of dates.'} scheduleBounds: test::gen::DateRange[0..1];
}

>>>test::gen::RepoDurationEnum
Enum {meta::pure::profiles::doc.doc = 'A duration code for a Repo (or Securities Lending) transaction. There are many business and market rules that are derived from the duration of the transaction.'} test::gen::RepoDurationEnum
{
  Overnight,
  Term
}

>>>test::gen::ReportingRegimeName
Class {meta::pure::profiles::doc.doc = 'An identifier of an reporting regime or format used for regulatory reporting, for example DoddFrankAct, MiFID, HongKongOTCDRepository, etc.'} test::gen::ReportingRegimeName
[
  c1_length: $this.reportingRegimeNameScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  reportingRegimeNameScheme: String[0..1];
  value: String[1];
}

>>>test::gen::RequestedAction
Class test::gen::RequestedAction
[
  c1_length: $this.requestedActionScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  requestedActionScheme: String[0..1];
  value: String[1];
}

>>>test::gen::RequiredIdentifierDate
Class {meta::pure::profiles::doc.doc = 'A date with a required identifier which can be referenced elsewhere.'} test::gen::RequiredIdentifierDate
{
  id: String[1];
  value: StrictDate[1];
}

>>>test::gen::ResetFrequency
Class {meta::pure::profiles::doc.doc = 'A type defining the reset frequency. In the case of a weekly reset, also specifies the day of the week that the reset occurs. If the reset frequency is greater than the calculation period frequency the this implies that more or more reset dates is established for each calculation period and some form of rate averaginhg is applicable. The specific averaging method of calculation is specified in FloatingRateCalculation. In case the reset frequency is of value T (term), the period is defined by the swap\\swapStream\\calculationPerioDates\\effectiveDate and the swap\\swapStream\\calculationPerioDates\\terminationDate.'} test::gen::ResetFrequency extends test::gen::Frequency
{
  {meta::pure::profiles::doc.doc = 'The day of the week on which a weekly reset date occurs. This element must be included if the reset frequency is defined as weekly and not otherwise.'} weeklyRollConvention: test::gen::WeeklyRollConventionEnum[0..1];
}

>>>test::gen::ResetRelativeToEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of whether resets occur relative to the first or last day of a calculation period.'} test::gen::ResetRelativeToEnum
{
  CalculationPeriodStartDate,
  CalculationPeriodEndDate
}

>>>test::gen::Resource
Class {meta::pure::profiles::doc.doc = 'Describes the resource that contains the media representation of a business event (i.e used for stating the Publicly Available Information). For example, can describe a file or a URL that represents the event. This type is an extended version of a type defined by RIXML (www.rixml.org).'} test::gen::Resource
[
  c1_length: $this.name->forAll(x: String[1]|$x->length() >= 0),
  c2_length: $this.comments->forAll(x: String[1]|$x->length() <= 255),
  c3_length: $this.string->forAll(x: String[1]|$x->length() <= 255),
  c4_length: $this.url->forAll(x: String[1]|$x->length() >= 1),
  c5_choice: ($this.string->isNotEmpty() && ($this.hexadecimalBinary->isEmpty() && ($this.base64Binary->isEmpty() && $this.url->isEmpty()))) || (($this.string->isEmpty() && ($this.hexadecimalBinary->isNotEmpty() && ($this.base64Binary->isEmpty() && $this.url->isEmpty()))) || (($this.string->isEmpty() && ($this.hexadecimalBinary->isEmpty() && ($this.base64Binary->isNotEmpty() && $this.url->isEmpty()))) || ($this.string->isEmpty() && ($this.hexadecimalBinary->isEmpty() && ($this.base64Binary->isEmpty() && $this.url->isNotEmpty())))))
]
{
  {meta::pure::profiles::doc.doc = 'The unique identifier of the resource within the event.'} resourceId: test::gen::ResourceId[1];
  {meta::pure::profiles::doc.doc = 'A description of the type of the resource, e.g. a confirmation.'} resourceType: test::gen::ResourceType[0..1];
  {meta::pure::profiles::doc.doc = 'Indicates the language of the resource, described using the ISO 639-2/T Code.'} language: test::gen::Language[0..1];
  {meta::pure::profiles::doc.doc = 'Indicates the size of the resource in bytes. It could be used by the end user to estimate the download time and storage needs.'} sizeInBytes: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'Indicates the length of the resource. For example, if the resource were a PDF file, the length would be in pages.'} length: test::gen::ResourceLength[0..1];
  {meta::pure::profiles::doc.doc = 'Indicates the type of media used to store the content. mimeType is used to determine the software product(s) that can read the content. MIME Types are described in RFC 2046.'} mimeType: test::gen::MimeType[1];
  {meta::pure::profiles::doc.doc = 'The name of the resource.'} name: String[0..1];
  {meta::pure::profiles::doc.doc = 'Any additional comments that are deemed necessary. For example, which software version is required to open the document? Or, how does this resource relate to the others for this event?'} comments: String[0..1];
  {meta::pure::profiles::doc.doc = 'Provides extra information as string. In case the extra information is in XML format, a CDATA section must be placed around the source message to prevent its interpretation as XML content.'} string: String[0..1];
  {meta::pure::profiles::doc.doc = 'Provides extra information as binary contents coded in hexadecimal.'} hexadecimalBinary: String[0..1];
  {meta::pure::profiles::doc.doc = 'Provides extra information as binary contents coded in base64.'} base64Binary: String[0..1];
  {meta::pure::profiles::doc.doc = 'Indicates where the resource can be found, as a URL that references the information on a web server accessible to the message recipient.'} url: String[0..1];
}

>>>test::gen::ResourceId
Class {meta::pure::profiles::doc.doc = 'The data type used for resource identifiers.'} test::gen::ResourceId
[
  c1_length: $this.resourceIdScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  resourceIdScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ResourceLength
Class {meta::pure::profiles::doc.doc = 'The type that indicates the length of the resource.'} test::gen::ResourceLength
{
  {meta::pure::profiles::doc.doc = 'The length unit of the resource. For example, pages (pdf, text documents) or time (audio, video files).'} lengthUnit: test::gen::LengthUnitEnum[1];
  {meta::pure::profiles::doc.doc = 'The length value of the resource.'} lengthValue: Decimal[1];
}

>>>test::gen::ResourceType
Class {meta::pure::profiles::doc.doc = 'The data type used for describing the type or purpose of a resource, e.g. "Confirmation".'} test::gen::ResourceType
[
  c1_length: $this.resourceTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  resourceTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ReturnSwapNotionalAmountReference
Class {meta::pure::profiles::doc.doc = 'A reference to the return swap notional amount.'} test::gen::ReturnSwapNotionalAmountReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::ReturnTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The type of return associated with the equity swap.'} test::gen::ReturnTypeEnum
{
  Dividend,
  Price,
  Total
}

>>>test::gen::RollConventionEnum
Enum {meta::pure::profiles::doc.doc = 'The convention for determining the sequence of calculation period end dates. It is used in conjunction with a specified frequency and the regular period start date of a calculation period, e.g. semi-annual IMM roll dates.'} test::gen::RollConventionEnum
{
  EOM,
  FRN,
  IMM,
  IMMCAD,
  IMMAUD,
  IMMNZD,
  SFE,
  NONE,
  TBILL,
  _1,
  _2,
  _3,
  _4,
  _5,
  _6,
  _7,
  _8,
  _9,
  _10,
  _11,
  _12,
  _13,
  _14,
  _15,
  _16,
  _17,
  _18,
  _19,
  _20,
  _21,
  _22,
  _23,
  _24,
  _25,
  _26,
  _27,
  _28,
  _29,
  _30,
  MON,
  TUE,
  WED,
  THU,
  FRI,
  SAT,
  SUN
}

>>>test::gen::Rounding
Class {meta::pure::profiles::doc.doc = 'A type defining a rounding direction and precision to be used in the rounding of a rate.'} test::gen::Rounding
{
  {meta::pure::profiles::doc.doc = 'Specifies the rounding direction.'} roundingDirection: test::gen::RoundingDirectionEnum[1];
  {meta::pure::profiles::doc.doc = 'Specifies the rounding precision in terms of a number of decimal places. Note how a percentage rate rounding of 5 decimal places is expressed as a rounding precision of 7 in the FpML document since the percentage is expressed as a decimal, e.g. 9.876543% (or 0.09876543) being rounded to the nearest 5 decimal places is 9.87654% (or 0.0987654).'} precision: Decimal[1];
}

>>>test::gen::RoundingDirectionEnum
Enum {meta::pure::profiles::doc.doc = 'The method of rounding a fractional number.'} test::gen::RoundingDirectionEnum
{
  Up,
  Down,
  Nearest
}

>>>test::gen::Routing
Class {meta::pure::profiles::doc.doc = 'A type that provides three alternative ways of identifying a party involved in the routing of a payment. The identification may use payment system identifiers only; actual name, address and other reference information; or a combination of both.'} test::gen::Routing
[
  c1_choice: ($this.routingIds->isNotEmpty() && ($this.routingExplicitDetails->isEmpty() && $this.routingIdsAndExplicitDetails->isEmpty())) || (($this.routingIds->isEmpty() && ($this.routingExplicitDetails->isNotEmpty() && $this.routingIdsAndExplicitDetails->isEmpty())) || ($this.routingIds->isEmpty() && ($this.routingExplicitDetails->isEmpty() && $this.routingIdsAndExplicitDetails->isNotEmpty())))
]
{
  {meta::pure::profiles::doc.doc = 'A set of unique identifiers for a party, eachone identifying the party within a payment system. The assumption is that each party will not have more than one identifier within the same payment system.'} routingIds: test::gen::RoutingIds[0..1];
  {meta::pure::profiles::doc.doc = 'A set of details that is used to identify a party involved in the routing of a payment when the party does not have a code that identifies it within one of the recognized payment systems.'} routingExplicitDetails: test::gen::RoutingExplicitDetails[0..1];
  {meta::pure::profiles::doc.doc = 'A combination of coded payment system identifiers and details for physical addressing for a party involved in the routing of a payment.'} routingIdsAndExplicitDetails: test::gen::RoutingIdsAndExplicitDetails[0..1];
}

>>>test::gen::RoutingExplicitDetails
Class {meta::pure::profiles::doc.doc = 'A type that models name, address and supplementary textual information for the purposes of identifying a party involved in the routing of a payment.'} test::gen::RoutingExplicitDetails
[
  c1_length: $this.routingName->length() <= 255,
  c2_length: $this.routingAccountNumber->forAll(x: String[1]|$x->length() <= 255),
  c3_length: $this.routingReferenceText->forAll(x: String[1]|$x->length() <= 255)
]
{
  {meta::pure::profiles::doc.doc = 'A real name that is used to identify a party involved in the routing of a payment.'} routingName: String[1];
  {meta::pure::profiles::doc.doc = 'A physical postal address via which a payment can be routed.'} routingAddress: test::gen::Address[0..1];
  {meta::pure::profiles::doc.doc = 'An account number via which a payment can be routed.'} routingAccountNumber: String[0..1];
  {meta::pure::profiles::doc.doc = 'A piece of free-format text used to assist the identification of a party involved in the routing of a payment.'} routingReferenceText: String[*];
}

>>>test::gen::RoutingId
Class test::gen::RoutingId
[
  c1_length: $this.routingIdCodeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  routingIdCodeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::RoutingIds
Class {meta::pure::profiles::doc.doc = 'A type that provides for identifying a party involved in the routing of a payment by means of one or more standard identification codes. For example, both a SWIFT BIC code and a national bank identifier may be required.'} test::gen::RoutingIds
{
  {meta::pure::profiles::doc.doc = 'A unique identifier for party that is a participant in a recognized payment system.'} routingId: test::gen::RoutingId[1..*];
}

>>>test::gen::RoutingIdsAndExplicitDetails
Class {meta::pure::profiles::doc.doc = 'A type that provides a combination of payment system identification codes with physical postal address details, for the purposes of identifying a party involved in the routing of a payment.'} test::gen::RoutingIdsAndExplicitDetails
[
  c1_length: $this.routingName->length() <= 255,
  c2_length: $this.routingAccountNumber->forAll(x: String[1]|$x->length() <= 255),
  c3_length: $this.routingReferenceText->forAll(x: String[1]|$x->length() <= 255)
]
{
  {meta::pure::profiles::doc.doc = 'A set of unique identifiers for a party, eachone identifying the party within a payment system. The assumption is that each party will not have more than one identifier within the same payment system.'} routingIds: test::gen::RoutingIds[1..*];
  {meta::pure::profiles::doc.doc = 'A real name that is used to identify a party involved in the routing of a payment.'} routingName: String[1];
  {meta::pure::profiles::doc.doc = 'A physical postal address via which a payment can be routed.'} routingAddress: test::gen::Address[0..1];
  {meta::pure::profiles::doc.doc = 'An account number via which a payment can be routed.'} routingAccountNumber: String[0..1];
  {meta::pure::profiles::doc.doc = 'A piece of free-format text used to assist the identification of a party involved in the routing of a payment.'} routingReferenceText: String[*];
}

>>>test::gen::Schedule
Class {meta::pure::profiles::doc.doc = 'A type defining a schedule of rates or amounts in terms of an initial value and then a series of step date and value pairs. On each step date the rate or amount changes to the new step value. The series of step date and value pairs are optional. If not specified, this implies that the initial value remains unchanged over time.'} test::gen::Schedule
{
  {meta::pure::profiles::doc.doc = 'The initial rate or amount, as the case may be. An initial rate of 5% would be represented as 0.05.'} initialValue: Decimal[1];
  {meta::pure::profiles::doc.doc = 'The schedule of step date and value pairs. On each step date the associated step value becomes effective A list of steps may be ordered in the document by ascending step date. An FpML document containing an unordered list of steps is still regarded as a conformant document.'} step: test::gen::Step[*];
  id: String[0..1];
}

>>>test::gen::ScheduleReference
Class {meta::pure::profiles::doc.doc = 'Reference to a schedule of rates or amounts.'} test::gen::ScheduleReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::SettlementInformation
Class {meta::pure::profiles::doc.doc = 'A type that represents the choice of methods for settling a potential currency payment resulting from a trade: by means of a standard settlement instruction, by netting it out with other payments, or with an explicit settlement instruction.'} test::gen::SettlementInformation
[
  c1_choice: ($this.standardSettlementStyle->isNotEmpty() && $this.settlementInstruction->isEmpty()) || ($this.standardSettlementStyle->isEmpty() && $this.settlementInstruction->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'An optional element used to describe how a trade will settle. This defines a scheme and is used for identifying trades that are identified as settling standard and/or flagged for settlement netting.'} standardSettlementStyle: test::gen::StandardSettlementStyleEnum[0..1];
  {meta::pure::profiles::doc.doc = 'An explicit specification of how a currency payment is to be made, when the payment is not netted and the route is other than the recipient\'s standard settlement instruction.'} settlementInstruction: test::gen::SettlementInstruction[0..1];
}

>>>test::gen::SettlementInstruction
Class {meta::pure::profiles::doc.doc = 'A type that models a complete instruction for settling a currency payment, including the settlement method to be used, the correspondent bank, any intermediary banks and the ultimate beneficary.'} test::gen::SettlementInstruction
{
  {meta::pure::profiles::doc.doc = 'The mechanism by which settlement is to be made. The scheme of domain values will include standard mechanisms such as CLS, Fedwire, Chips ABA, Chips UID, SWIFT, CHAPS and DDA.'} settlementMethod: test::gen::SettlementMethod[0..1];
  {meta::pure::profiles::doc.doc = 'The information required to identify the correspondent bank that will make delivery of the funds on the paying bank\'s behalf in the country where the payment is to be made'} correspondentInformation: test::gen::CorrespondentInformation[0..1];
  {meta::pure::profiles::doc.doc = 'Information to identify an intermediary through which payment will be made by the correspondent bank to the ultimate beneficiary of the funds.'} intermediaryInformation: test::gen::IntermediaryInformation[*];
  {meta::pure::profiles::doc.doc = 'The bank that acts for the ultimate beneficiary of the funds in receiving payments.'} beneficiaryBank: test::gen::Beneficiary[0..1];
  {meta::pure::profiles::doc.doc = 'The ultimate beneficiary of the funds. The beneficiary can be identified either by an account at the beneficiaryBank (qv) or by explicit routingInformation. This element provides for the latter.'} beneficiary: test::gen::Beneficiary[1];
  {meta::pure::profiles::doc.doc = 'Reference to the depository of the settlement.'} depositoryPartyReference: test::gen::PartyReference[0..1];
  {meta::pure::profiles::doc.doc = 'The set of individual payments that are to be made when a currency payment settling a trade needs to be split between a number of ultimate beneficiaries. Each split payment may need to have its own routing information.'} splitSettlement: test::gen::SplitSettlement[*];
}

>>>test::gen::SettlementMethod
Class test::gen::SettlementMethod
[
  c1_length: $this.settlementMethodScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  settlementMethodScheme: String[0..1];
  value: String[1];
}

>>>test::gen::SettlementPeriodDurationEnum
Enum {meta::pure::profiles::doc.doc = 'Defines the Settlement Period Duration for an Electricity Transaction.'} test::gen::SettlementPeriodDurationEnum
{
  _2Hours,
  _1Hour,
  _30Minutes,
  _15Minutes
}

>>>test::gen::SettlementPriceDefaultElection
Class {meta::pure::profiles::doc.doc = 'Coding scheme that specifies the settlement price default election.'} test::gen::SettlementPriceDefaultElection
[
  c1_length: $this.settlementPriceDefaultElectionScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  settlementPriceDefaultElectionScheme: String[0..1];
  value: String[1];
}

>>>test::gen::SettlementPriceSource
Class {meta::pure::profiles::doc.doc = 'The source from which the settlement price is to be obtained, e.g. a Reuters page, Prezzo di Riferimento, etc.'} test::gen::SettlementPriceSource
[
  c1_length: $this.settlementPriceSourceScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  settlementPriceSourceScheme: String[0..1];
  value: String[1];
}

>>>test::gen::SettlementRateOption
Class {meta::pure::profiles::doc.doc = 'A type defining the settlement rate options through a scheme reflecting the terms of the Annex A to the 1998 FX and Currency Option Definitions.'} test::gen::SettlementRateOption
[
  c1_length: $this.settlementRateOptionScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  settlementRateOptionScheme: String[0..1];
  value: String[1];
}

>>>test::gen::SettlementRateSource
Class {meta::pure::profiles::doc.doc = 'A type describing the method for obtaining a settlement rate.'} test::gen::SettlementRateSource
[
  c1_choice: ($this.informationSource->isNotEmpty() && $this.cashSettlementReferenceBanks->isEmpty()) || ($this.informationSource->isEmpty() && $this.cashSettlementReferenceBanks->isNotEmpty())
]
{
  {meta::pure::profiles::doc.doc = 'The information source where a published or displayed market rate will be obtained, e.g. Telerate Page 3750.'} informationSource: test::gen::InformationSource[0..1];
  {meta::pure::profiles::doc.doc = 'A container for a set of reference institutions. These reference institutions may be called upon to provide rate quotations as part of the method to determine the applicable cash settlement amount. If institutions are not specified, it is assumed that reference institutions will be agreed between the parties on the exercise date, or in the case of swap transaction to which mandatory early termination is applicable, the cash settlement valuation date.'} cashSettlementReferenceBanks: test::gen::CashSettlementReferenceBanks[0..1];
}

>>>test::gen::SettlementTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Shows how the transaction is to be settled when it is exercised.'} test::gen::SettlementTypeEnum
{
  Cash,
  Physical,
  Election,
  CashOrPhysical
}

>>>test::gen::ShareExtraordinaryEventEnum
Enum {meta::pure::profiles::doc.doc = 'Defines the consequences of extraordinary events relating to the underlying.'} test::gen::ShareExtraordinaryEventEnum
{
  AlternativeObligation,
  CancellationAndPayment,
  OptionsExchange,
  CalculationAgent,
  ModifiedCalculationAgent,
  PartialCancellationAndPayment,
  Component
}

>>>test::gen::SharedAmericanExercise
Class {meta::pure::profiles::doc.doc = 'TBA'} test::gen::SharedAmericanExercise extends test::gen::Exercise
{
  {meta::pure::profiles::doc.doc = 'The first day of the exercise period for an American style option.'} commencementDate: test::gen::AdjustableOrRelativeDate[1];
  {meta::pure::profiles::doc.doc = 'The last day within an exercise period for an American style option. For a European style option it is the only day within the exercise period.'} expirationDate: test::gen::AdjustableOrRelativeDate[1];
  {meta::pure::profiles::doc.doc = 'For a Bermuda or American style option, the latest time on an exercise business day (excluding the expiration date) within the exercise period that notice can be given by the buyer to the seller or seller\'s agent. Notice of exercise given after this time will be deemed to have been given on the next exercise business day.'} latestExerciseTime: test::gen::BusinessCenterTime[0..1];
  {meta::pure::profiles::doc.doc = 'Latest exercise time determination method.'} latestExerciseTimeDetermination: test::gen::DeterminationMethod[0..1];
}

>>>test::gen::SimplePayment
Class {meta::pure::profiles::doc.doc = 'A complex type to specified payments in a simpler fashion than the Payment type. This construct should be used from the version 4.3 onwards.'} test::gen::SimplePayment extends test::gen::PaymentBase
{
  {meta::pure::profiles::doc.doc = 'A reference to the party responsible for making the payments defined by this structure.'} payerPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account responsible for making the payments defined by this structure.'} payerAccountReference: test::gen::AccountReference[0..1];
  {meta::pure::profiles::doc.doc = 'A reference to the party that receives the payments corresponding to this structure.'} receiverPartyReference: test::gen::PartyReference[1];
  {meta::pure::profiles::doc.doc = 'A reference to the account that receives the payments corresponding to this structure.'} receiverAccountReference: test::gen::AccountReference[0..1];
  paymentAmount: test::gen::NonNegativeMoney[1];
  {meta::pure::profiles::doc.doc = 'The payment date. This date is subject to adjustment in accordance with any applicable business day convention.'} paymentDate: test::gen::AdjustableOrRelativeDate[1];
}

>>>test::gen::SpecifiedPriceEnum
Enum {meta::pure::profiles::doc.doc = 'The Specified Price in respect of a Transaction and a Commodity Reference Price.'} test::gen::SpecifiedPriceEnum
{
  Afternoon,
  Ask,
  Bid,
  Closing,
  High,
  Index,
  MeanOfBidAndAsk,
  LocationalMarginal,
  Low,
  MarginalHourly,
  MarketClearing,
  MeanOfHighAndLow,
  Morning,
  Official,
  Opening,
  OSP,
  Settlement,
  Spot,
  Midpoint,
  NationalSingle,
  WeightedAverage,
  UnWeightedAverage
}

>>>test::gen::SplitSettlement
Class {meta::pure::profiles::doc.doc = 'A type that supports the division of a gross settlement amount into a number of split settlements, each requiring its own settlement instruction.'} test::gen::SplitSettlement
{
  {meta::pure::profiles::doc.doc = 'One of the monetary amounts in a split settlement payment.'} splitSettlementAmount: test::gen::Money[1];
  {meta::pure::profiles::doc.doc = 'The bank that acts for the ultimate beneficiary of the funds in receiving payments.'} beneficiaryBank: test::gen::Routing[0..1];
  {meta::pure::profiles::doc.doc = 'The ultimate beneficiary of the funds. The beneficiary can be identified either by an account at the beneficiaryBank (qv) or by explicit routingInformation. This element provides for the latter.'} beneficiary: test::gen::Routing[1];
}

>>>test::gen::SpreadSchedule
Class {meta::pure::profiles::doc.doc = 'Adds an optional spread type element to the Schedule to identify a long or short spread value.'} test::gen::SpreadSchedule extends test::gen::Schedule
{
  type: test::gen::SpreadScheduleType[0..1];
}

>>>test::gen::SpreadScheduleReference
Class {meta::pure::profiles::doc.doc = 'Provides a reference to a spread schedule.'} test::gen::SpreadScheduleReference extends test::gen::Reference
{
  href: String[1];
}

>>>test::gen::SpreadScheduleType
Class {meta::pure::profiles::doc.doc = 'Defines a Spread Type Scheme to identify a long or short spread value.'} test::gen::SpreadScheduleType
[
  c1_length: $this.spreadScheduleTypeScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  spreadScheduleTypeScheme: String[0..1];
  value: String[1];
}

>>>test::gen::StandardSettlementStyleEnum
Enum {meta::pure::profiles::doc.doc = 'The code specification of whether a trade is settling using standard settlement instructions as well as whether it is a candidate for settlement netting.'} test::gen::StandardSettlementStyleEnum
{
  Standard,
  Net,
  StandardAndNet
}

>>>test::gen::Step
Class {meta::pure::profiles::doc.doc = 'A type defining a step date and step value pair. This step definitions are used to define varying rate or amount schedules, e.g. a notional amortization or a step-up coupon schedule.'} test::gen::Step extends test::gen::StepBase
{
  {meta::pure::profiles::doc.doc = 'The rate or amount which becomes effective on the associated stepDate. A rate of 5% would be represented as 0.05.'} stepValue: Decimal[1];
}

>>>test::gen::StepBase
Class <<meta::pure::profiles::typemodifiers.abstract>> {meta::pure::profiles::doc.doc = 'A type defining a step date and step value pair. This step definitions are used to define varying rate or amount schedules, e.g. a notional amortization or a step-up coupon schedule.'} test::gen::StepBase
{
  {meta::pure::profiles::doc.doc = 'The date on which the associated stepValue becomes effective. This day may be subject to adjustment in accordance with a business day convention.'} stepDate: StrictDate[1];
  id: String[0..1];
}

>>>test::gen::StepRelativeToEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of whether a percentage rate change, used to calculate a change in notional outstanding, is expressed as a percentage of the initial notional amount or the previously outstanding notional amount.'} test::gen::StepRelativeToEnum
{
  Initial,
  Previous
}

>>>test::gen::StreetAddress
Class {meta::pure::profiles::doc.doc = 'A type that describes the set of street and building number information that identifies a postal address within a city.'} test::gen::StreetAddress
[
  c1_length: $this.streetLine->forAll(x: String[1]|$x->length() <= 255)
]
{
  {meta::pure::profiles::doc.doc = 'An individual line of street and building number information, forming part of a postal address.'} streetLine: String[1..*];
}

>>>test::gen::Strike
Class {meta::pure::profiles::doc.doc = 'A type describing a single cap or floor rate.'} test::gen::Strike
{
  {meta::pure::profiles::doc.doc = 'The rate for a cap or floor.'} strikeRate: Decimal[1];
  {meta::pure::profiles::doc.doc = 'The buyer of the option'} buyer: test::gen::IdentifiedPayerReceiver[0..1];
  {meta::pure::profiles::doc.doc = 'The party that has sold.'} seller: test::gen::IdentifiedPayerReceiver[0..1];
  id: String[0..1];
}

>>>test::gen::StrikeQuoteBasisEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of how an FX OTC option strike price is quoted.'} test::gen::StrikeQuoteBasisEnum
{
  PutCurrencyPerCallCurrency,
  CallCurrencyPerPutCurrency
}

>>>test::gen::StrikeSchedule
Class {meta::pure::profiles::doc.doc = 'A type describing a schedule of cap or floor rates.'} test::gen::StrikeSchedule extends test::gen::Schedule
{
  {meta::pure::profiles::doc.doc = 'The buyer of the option'} buyer: test::gen::IdentifiedPayerReceiver[0..1];
  {meta::pure::profiles::doc.doc = 'The party that has sold.'} seller: test::gen::IdentifiedPayerReceiver[0..1];
}

>>>test::gen::Stub
Class {meta::pure::profiles::doc.doc = 'A type defining how a stub calculation period amount is calculated and the start and end date of the stub. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating rate tenors many be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3 Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.'} test::gen::Stub extends test::gen::StubValue
{
  {meta::pure::profiles::doc.doc = 'Start date of stub period. This was created to support use of the InterestRateStream within the Equity Derivative sphere, and this element is not expected to be produced in the representation of Interest Rate products.'} stubStartDate: test::gen::AdjustableOrRelativeDate[0..1];
  {meta::pure::profiles::doc.doc = 'End date of stub period. This was created to support use of the InterestRateStream within the Equity Derivative sphere, and this element is not expected to be produced in the representation of Interest Rate products.'} stubEndDate: test::gen::AdjustableOrRelativeDate[0..1];
}

>>>test::gen::StubFloatingRate
Class {meta::pure::profiles::doc.doc = 'A type defining a floating rate.'} test::gen::StubFloatingRate extends test::gen::Rate
{
  floatingRateIndex: test::gen::FloatingRateIndex[1];
  {meta::pure::profiles::doc.doc = 'The ISDA Designated Maturity, i.e. the tenor of the floating rate.'} indexTenor: test::gen::Period[0..1];
  {meta::pure::profiles::doc.doc = 'A rate multiplier or multiplier schedule to apply to the floating rate. A multiplier schedule is expressed as explicit multipliers and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in the calculationPeriodDatesAdjustments. The multiplier can be a positive or negative decimal. This element should only be included if the multiplier is not equal to 1 (one) for the term of the stream.'} floatingRateMultiplierSchedule: test::gen::Schedule[0..1];
  {meta::pure::profiles::doc.doc = 'The ISDA Spread or a Spread schedule expressed as explicit spreads and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The spread is a per annum rate, expressed as a decimal. For purposes of determining a calculation period amount, if positive the spread will be added to the floating rate and if negative the spread will be subtracted from the floating rate. A positive 10 basis point (0.1%) spread would be represented as 0.001.'} spreadSchedule: test::gen::SpreadSchedule[*];
  {meta::pure::profiles::doc.doc = 'The specification of any rate conversion which needs to be applied to the observed rate before being used in any calculations. The two common conversions are for securities quoted on a bank discount basis which will need to be converted to either a Money Market Yield or Bond Equivalent Yield. See the Annex to the 2000 ISDA Definitions, Section 7.3. Certain General Definitions Relating to Floating Rate Options, paragraphs (g) and (h) for definitions of these terms.'} rateTreatment: test::gen::RateTreatmentEnum[0..1];
  {meta::pure::profiles::doc.doc = 'The cap rate or cap rate schedule, if any, which applies to the floating rate. The cap rate (strike) is only required where the floating rate on a swap stream is capped at a certain level. A cap rate schedule is expressed as explicit cap rates and dates and the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The cap rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. A cap rate of 5% would be represented as 0.05.'} capRateSchedule: test::gen::StrikeSchedule[*];
  {meta::pure::profiles::doc.doc = 'The floor rate or floor rate schedule, if any, which applies to the floating rate. The floor rate (strike) is only required where the floating rate on a swap stream is floored at a certain strike level. A floor rate schedule is expressed as explicit floor rates and dates and the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The floor rate is assumed to be exclusive of any spread and is a per annum rate, expressed as a decimal. A floor rate of 5% would be represented as 0.05.'} floorRateSchedule: test::gen::StrikeSchedule[*];
}

>>>test::gen::StubPeriodTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Element to define how to deal with a none standard calculation period within a swap stream.'} test::gen::StubPeriodTypeEnum
{
  ShortInitial,
  ShortFinal,
  LongInitial,
  LongFinal
}

>>>test::gen::StubValue
Class {meta::pure::profiles::doc.doc = 'A type defining how a stub calculation period amount is calculated. A single floating rate tenor different to that used for the regular part of the calculation periods schedule may be specified, or two floating rate tenors many be specified. If two floating rate tenors are specified then Linear Interpolation (in accordance with the 2000 ISDA Definitions, Section 8.3 Interpolation) is assumed to apply. Alternatively, an actual known stub rate or stub amount may be specified.'} test::gen::StubValue
[
  c1_choice: ($this.floatingRate->isNotEmpty() && ($this.stubRate->isEmpty() && $this.stubAmount->isEmpty())) || (($this.floatingRate->isEmpty() && ($this.stubRate->isNotEmpty() && $this.stubAmount->isEmpty())) || ($this.floatingRate->isEmpty() && ($this.stubRate->isEmpty() && $this.stubAmount->isNotEmpty())))
]
{
  {meta::pure::profiles::doc.doc = 'The rates to be applied to the initial or final stub may be the linear interpolation of two different rates. While the majority of the time, the rate indices will be the same as that specified in the stream and only the tenor itself will be different, it is possible to specift two different rates. For example, a 2 month stub period may use the linear interpolation of a 1 month and 3 month rate. The different rates would be specified in this component. Note that a maximum of two rates can be specified. If a stub period uses the same floating rate index, including tenor, as the regular calculation periods then this should not be specified again within this component, i.e. the stub calculation period amount component may not need to be specified even if there is an initial or final stub period. If a stub period uses a different floating rate index compared to the regular calculation periods then this should be specified within this component. If specified here, they are likely to have id attributes, allowing them to be referenced from within the cashflows component.'} floatingRate: test::gen::StubFloatingRate[0..2];
  {meta::pure::profiles::doc.doc = 'An actual rate to apply for the initial or final stub period may have been agreed between the principal parties (in a similar way to how an initial rate may have been agreed for the first regular period). If an actual stub rate has been agreed then it would be included in this component. It will be a per annum rate, expressed as a decimal. A stub rate of 5% would be represented as 0.05.'} stubRate: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'An actual amount to apply for the initial or final stub period may have been agreed between th two parties. If an actual stub amount has been agreed then it would be included in this component.'} stubAmount: test::gen::Money[0..1];
}

>>>test::gen::SupervisoryBody
Class {meta::pure::profiles::doc.doc = 'An identifier of an organization that supervises or regulates trading activity, e.g. CFTC, SEC, FSA, ODRF, etc.'} test::gen::SupervisoryBody
[
  c1_length: $this.supervisoryBodyScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  supervisoryBodyScheme: String[0..1];
  value: String[1];
}

>>>test::gen::SwaptionPhysicalSettlement
Class test::gen::SwaptionPhysicalSettlement
{
  {meta::pure::profiles::doc.doc = 'Specifies whether the swap resulting from physical settlement of the swaption transaction will clear through a clearing house. The meaning of Cleared Physical Settlement is defined in the 2006 ISDA Definitions, Section 15.2 (published in Supplement number 28).'} clearedPhysicalSettlement: Boolean[1];
  {meta::pure::profiles::doc.doc = 'A reference to the clearing organization (CCP, DCO) to which the trade should be cleared.'} predeterminedClearingOrganizationPartyReference: test::gen::PartyReference[0..1];
}

>>>test::gen::TelephoneNumber
Class {meta::pure::profiles::doc.doc = 'A type that represents a telephonic contact.'} test::gen::TelephoneNumber
[
  c1_length: $this.number->length() <= 255
]
{
  {meta::pure::profiles::doc.doc = 'The type of telephone number (work, personal, mobile).'} type: test::gen::TelephoneTypeEnum[0..1];
  {meta::pure::profiles::doc.doc = 'A telephonic contact.'} number: String[1];
}

>>>test::gen::TelephoneTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The type of telephone number used to reach a contact.'} test::gen::TelephoneTypeEnum
{
  Work,
  Mobile,
  Fax,
  Personal
}

>>>test::gen::TimeTypeEnum
Enum {meta::pure::profiles::doc.doc = 'Defines points in the day when equity option exercise and valuation can occur.'} test::gen::TimeTypeEnum
{
  Close,
  Open,
  OSP,
  SpecificTime,
  XETRA,
  DerivativesClose,
  AsSpecifiedInMasterConfirmation
}

>>>test::gen::TimezoneLocation
Class {meta::pure::profiles::doc.doc = 'A geophraphic location for the purposes of defining a prevailing time according to the tz database.'} test::gen::TimezoneLocation
[
  c1_length: $this.timezoneLocationScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  timezoneLocationScheme: String[0..1];
  value: String[1];
}

>>>test::gen::TouchConditionEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of, for American-style digitals, whether the trigger level must be touched or not touched.'} test::gen::TouchConditionEnum
{
  Touch,
  Notouch
}

>>>test::gen::TradeId
Class {meta::pure::profiles::doc.doc = 'A trade reference identifier allocated by a party. FpML does not define the domain values associated with this element. Note that the domain values for this element are not strictly an enumerated list.'} test::gen::TradeId
[
  c1_length: $this.tradeIdScheme->length() >= 1,
  c2_length: $this.value->length() >= 1,
  c3_length: $this.value->length() <= 255
]
{
  tradeIdScheme: String[1];
  id: String[0..1];
  value: String[1];
}

>>>test::gen::TriggerConditionEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of whether a payout will occur on an option depending upon whether the spot rate is at or above or at or below the trigger rate.'} test::gen::TriggerConditionEnum
{
  AtOrAbove,
  AtOrBelow,
  Above,
  Below
}

>>>test::gen::TriggerTimeTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The time of day which would be considered for valuing the knock event.'} test::gen::TriggerTimeTypeEnum
{
  Closing,
  Anytime
}

>>>test::gen::TriggerTypeEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of whether an option will trigger or expire depending upon whether the spot rate is above or below the barrier rate.'} test::gen::TriggerTypeEnum
{
  EqualOrLess,
  EqualOrGreater,
  Equal,
  Less,
  Greater
}

>>>test::gen::UnderlyerInterestLeg
Class {meta::pure::profiles::doc.doc = 'A type describing interest payments associated with and underlyer, such as financing'} test::gen::UnderlyerInterestLeg extends test::gen::DirectionalLeg
{
  {meta::pure::profiles::doc.doc = 'The calculation period fixed rate. A per annum rate, expressed as a decimal. A fixed rate of 5% would be represented as 0.05.'} fixedRate: Decimal[0..1];
  {meta::pure::profiles::doc.doc = 'The ISDA Spread or a Spread schedule expressed as explicit spreads and dates. In the case of a schedule, the step dates may be subject to adjustment in accordance with any adjustments specified in calculationPeriodDatesAdjustments. The spread is a per annum rate, expressed as a decimal. For purposes of determining a calculation period amount, if positive the spread will be added to the floating rate and if negative the spread will be subtracted from the floating rate. A positive 10 basis point (0.1%) spread would be represented as 0.001.'} spreadSchedule: test::gen::SpreadSchedule[*];
}

>>>test::gen::Unit
Class {meta::pure::profiles::doc.doc = 'A type used to record information about a unit, subdivision, desk, or other similar business entity.'} test::gen::Unit
[
  c1_length: $this.unitScheme->forAll(x: String[1]|$x->length() >= 1),
  c2_length: $this.value->length() <= 255
]
{
  unitScheme: String[0..1];
  value: String[1];
}

>>>test::gen::ValuationMethodEnum
Enum {meta::pure::profiles::doc.doc = 'The ISDA defined methodology for determining the final price of the reference obligation for purposes of cash settlement.'} test::gen::ValuationMethodEnum
{
  Market,
  Highest,
  AverageMarket,
  AverageHighest,
  BlendedMarket,
  BlendedHighest,
  AverageBlendedMarket,
  AverageBlendedHighest
}

>>>test::gen::ValuationTypeEnum
Enum {meta::pure::profiles::doc.doc = 'How a valuation for a trade was determined'} test::gen::ValuationTypeEnum
{
  Model,
  Market
}

>>>test::gen::WeatherSettlementLevelEnum
Enum test::gen::WeatherSettlementLevelEnum
{
  Cumulative,
  Average,
  Mximum,
  Minimum
}

>>>test::gen::WeeklyRollConventionEnum
Enum {meta::pure::profiles::doc.doc = 'The specification of a weekly roll day.'} test::gen::WeeklyRollConventionEnum
{
  MON,
  TUE,
  WED,
  THU,
  FRI,
  SAT,
  SUN,
  TBILL
}
