{
  "_type": "simple",
  "authDependent": false,
  "globalImplementationSupport": {
    "_type": "java",
    "classes": [
      {
        "name": "Firm",
        "package": "_pure.app.domain",
        "source": "package _pure.app.domain;\n\nimport java.math.*;\nimport java.util.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n\npublic interface Firm extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject\n{\n    String getLegalName();\n    List<Person> getEmployees();\n    String getAlloyStoreObjectReference$();\n}"
      },
      {
        "name": "Person",
        "package": "_pure.app.domain",
        "source": "package _pure.app.domain;\n\nimport java.math.*;\nimport java.util.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n\npublic interface Person extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject\n{\n    String getFirstName();\n    String getLastName();\n    Firm getFirm();\n    String getAlloyStoreObjectReference$();\n}"
      },
      {
        "name": "Serialize",
        "package": "_pure.plan.root",
        "source": "package _pure.plan.root;\n\nimport org.finos.legend.engine.plan.dependencies.store.platform.IGraphSerializer;\nimport org.finos.legend.engine.plan.dependencies.store.platform.IPlatformPureExpressionExecutionNodeSerializeSpecifics;\nimport org.finos.legend.engine.plan.dependencies.store.platform.ISerializationWriter;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n\npublic class Serialize implements IPlatformPureExpressionExecutionNodeSerializeSpecifics\n{\n    public IGraphSerializer<?> serializer(ISerializationWriter writer,\n                                          IExecutionNodeContext context)\n    {\n        return new Serializer(writer, context);\n    }\n}"
      },
      {
        "name": "Serializer",
        "package": "_pure.plan.root",
        "source": "package _pure.plan.root;\n\nimport _pure.app.domain.Firm;\nimport _pure.app.domain.Person;\nimport java.util.List;\nimport org.finos.legend.engine.plan.dependencies.domain.dataQuality.EnforcementLevel;\nimport org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked;\nimport org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect;\nimport org.finos.legend.engine.plan.dependencies.domain.dataQuality.RelativePathNode;\nimport org.finos.legend.engine.plan.dependencies.domain.dataQuality.RuleType;\nimport org.finos.legend.engine.plan.dependencies.store.platform.IGraphSerializer;\nimport org.finos.legend.engine.plan.dependencies.store.platform.ISerializationWriter;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject;\n\npublic class Serializer implements IGraphSerializer<IChecked>\n{\n    private ISerializationWriter writer;\n    private IExecutionNodeContext context;\n\n    Serializer(ISerializationWriter writer, IExecutionNodeContext context)\n    {\n        this.writer = writer;\n        this.context = context;\n    }\n\n    public void serialize(IChecked value)\n    {\n        this.writer.startObject(\"meta::pure::dataQuality::Checked\");\n        this.writer\n            .writeComplexProperty(\"defects\",\n                                  value.getDefects(),\n                                  this::writeIDefect_defects);\n        this.writer\n            .writeComplexProperty(\"value\",\n                                  (Firm) value.getValue(),\n                                  this::writeFirm_value);\n        this.writer.endObject();\n    }\n\n    public void writeIDefect_defects(IDefect value)\n    {\n        this.writer.startObject(\"meta::pure::dataQuality::Defect\");\n        this.writer.writeStringProperty(\"id\", value.getId());\n        this.writer.writeStringProperty(\"externalId\", value.getExternalId());\n        this.writer.writeStringProperty(\"message\", value.getMessage());\n        this.writer\n            .writeEnumProperty(\"enforcementLevel\",\n                               \"meta::pure::dataQuality::EnforcementLevel\",\n                               value.getEnforcementLevel() == null\n                                    ? null\n                                    : value.getEnforcementLevel().name());\n        this.writer\n            .writeEnumProperty(\"ruleType\",\n                               \"meta::pure::dataQuality::RuleType\",\n                               value.getRuleType() == null\n                                    ? null\n                                    : value.getRuleType().name());\n        this.writer\n            .writeStringProperty(\"ruleDefinerPath\",\n                                 value.getRuleDefinerPath());\n        this.writer\n            .writeComplexProperty(\"path\",\n                                  value.getPath(),\n                                  this::writeRelativePathNode_defects_path);\n        this.writer.endObject();\n    }\n\n    public void writeRelativePathNode_defects_path(RelativePathNode value)\n    {\n        this.writer.startObject(\"meta::pure::dataQuality::RelativePathNode\");\n        this.writer\n            .writeStringProperty(\"propertyName\",\n                                 value.getPropertyName());\n        this.writer.writeIntegerProperty(\"index\", value.getIndex());\n        this.writer.endObject();\n    }\n\n    public void writeFirm_value(Firm value)\n    {\n        if (value instanceof IReferencedObject)\n        {\n            this.writer\n                .startObject(\"domain::Firm\",\n                             ((IReferencedObject) value).getAlloyStoreObjectReference$());\n        }\n        else\n        {\n            this.writer.startObject(\"domain::Firm\");\n        }\n        this.writer.writeStringProperty(\"legalName\", value.getLegalName());\n        this.writer\n            .writeComplexProperty(\"employees\",\n                                  value.getEmployees(),\n                                  this::writePerson_value_employees);\n        this.writer.endObject();\n    }\n\n    public void writePerson_value_employees(Person value)\n    {\n        this.writer.startObject(\"domain::Person\");\n        this.writer.writeStringProperty(\"firstName\", value.getFirstName());\n        this.writer.writeStringProperty(\"lastName\", value.getLastName());\n        this.writer.endObject();\n    }\n}"
      },
      {
        "name": "Execute",
        "package": "_pure.plan.root.n1.localGraph",
        "source": "package _pure.plan.root.n1.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.relational.graphFetch.IRelationalRootQueryTempTableGraphFetchExecutionNodeSpecifics;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject;\n\npublic class Execute implements IRelationalRootQueryTempTableGraphFetchExecutionNodeSpecifics\n{\n    private Specifics specifics;\n\n    public Execute()\n    {\n        this.specifics = new Specifics();\n    }\n\n    public void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        this.specifics.prepare(resultSet, databaseTimeZone, databaseConnection);\n    }\n\n    public IGraphInstance<? extends IReferencedObject> nextGraphInstance()\n    {\n        return this.specifics.nextGraphInstance();\n    }\n\n    public List<Method> primaryKeyGetters()\n    {\n        return this.specifics.primaryKeyGetters();\n    }\n\n    public List<Pair<String, String>> allInstanceSetImplementations()\n    {\n        return this.specifics.allInstanceSetImplementations();\n    }\n\n    public List<String> primaryKeyColumns(int setIndex)\n    {\n        return this.specifics.primaryKeyColumns(setIndex);\n    }\n\n    public boolean supportsCaching()\n    {\n        return true;\n    }\n}"
      },
      {
        "name": "GraphFetch_Node0_Firm_Impl",
        "package": "_pure.plan.root.n1.localGraph",
        "source": "package _pure.plan.root.n1.localGraph;\n\nimport java.math.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DayOfWeek;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.util.Library;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport java.io.IOException;\n\npublic class GraphFetch_Node0_Firm_Impl implements _pure.app.domain.Firm, org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.domain.Firm>, java.io.Serializable\n{\n    private String legalName;\n    private List<_pure.app.domain.Person> employees;\n    private Object pk$_0;\n    private static final ObjectMapper objectMapper$ = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).registerModule(new SimpleModule().addSerializer(PureDate.class, new JsonSerializer<PureDate>() { @Override public void serialize(PureDate value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeRawValue(\"\\\"\" + value.toString() + \"\\\"\"); } }));\n    private String setId$;\n    public static String databaseConnection$;\n    private String alloyStoreObjectReference$;\n    private static final long serialVersionUID = 643055848L;\n\n    public String getLegalName()\n    {\n        return this.legalName;\n    }\n\n    public void setLegalName(String legalName)\n    {\n        this.legalName = legalName;\n    }\n\n    public void addLegalName(String object)\n    {\n        if ((Object) this.legalName != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'legalName' of multiplicity with bound 1\");\n        }\n        this.legalName = object;\n    }\n\n    public List<_pure.app.domain.Person> getEmployees()\n    {\n        return this.employees == null\n                   ? Collections.<_pure.app.domain.Person>emptyList()\n                   : this.employees;\n    }\n\n    public void setEmployees(List<_pure.app.domain.Person> employees)\n    {\n        this.employees = employees;\n    }\n\n    public void addEmployees(_pure.app.domain.Person object)\n    {\n        if (this.employees == null)\n        {\n            this.employees = new ArrayList<_pure.app.domain.Person>();\n        }\n        this.employees.add(object);\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints()\n    {\n        return this.allConstraints(new org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext());\n    }\n\n    public _pure.app.domain.Firm withConstraintsApplied()\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = allConstraints();\n        if (!defects.isEmpty())\n        {\n            throw new IllegalStateException(defects.stream().map(org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect::getMessage).collect(java.util.stream.Collectors.joining(\"\\n\")));\n        }\n        return this;\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Firm> toChecked()\n    {\n        return this.toChecked(null, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Firm> toChecked(boolean applyConstraints)\n    {\n        return this.toChecked(null, applyConstraints);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Firm> toChecked(Object source)\n    {\n        return this.toChecked(source, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Firm> toChecked(Object source,\n                                                                                                                  boolean applyConstraints)\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = applyConstraints ? allConstraints() : java.util.Collections.emptyList();\n        return new org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Firm>() {\n            public java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> getDefects() { return defects; }\n            public Object getSource() { return source; }\n            public _pure.app.domain.Firm getValue() { return GraphFetch_Node0_Firm_Impl.this; }\n        };\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints(org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext context)\n    {\n        List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> result = new ArrayList<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect>();\n        if (!context.visited.contains(this))\n        {\n            context.visited.add(this);\n            if (this.getEmployees() != null)\n            {\n                for (int i = 0; i < this.getEmployees().size(); i++)\n                {\n                    final int index = i;\n                    result.addAll(((org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.domain.Person>) this.getEmployees()\n                                                                                                                                           .get(i))\n                                                                                                                                           .allConstraints(context)\n                                                                                                                                           .stream()\n                                                                                                                                           .map((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect d) -> org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicDefect.prefixPath(d,\n                                                                                                                                                                                                                                                                                                                org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicRelativePathNode.newRelativePathNode(\"employees\", index)))\n                                                                                                                                           .filter((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect x) -> x != null)\n                                                                                                                                           .collect(Collectors.toList()));\n                }\n            }\n        }\n        return result;\n    }\n\n    public Object getPk$_0()\n    {\n        return this.pk$_0;\n    }\n\n    public void setPk$_0(Object pk$_0)\n    {\n        this.pk$_0 = pk$_0;\n    }\n\n    public String getSetId$()\n    {\n        return this.setId$;\n    }\n\n    public void setSetId$(String setId)\n    {\n        this.setId$ = setId;\n    }\n\n    public String getAlloyStoreObjectReference$()\n    {\n        if (this.alloyStoreObjectReference$ == null)\n        {\n            try\n            {\n                StringBuilder referenceBuilder = new StringBuilder();\n                referenceBuilder.append(\"001:\");\n                referenceBuilder.append(\"010:\");\n\n                referenceBuilder.append(\"0000000010:\");\n                referenceBuilder.append(\"Relational:\");\n\n                referenceBuilder.append(\"0000000032:\");\n                referenceBuilder.append(\"mapping::relational::Firm_Person:\");\n\n                referenceBuilder.append(\"0000000011:\");\n                referenceBuilder.append(\"domain_Firm:\");\n\n                String setId = this.getSetId$();\n                referenceBuilder.append(String.format(\"%010d\", setId.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(setId);\n                referenceBuilder.append(\":\");\n\n                String databaseConnectionString = _pure.plan.root.n1.localGraph.GraphFetch_Node0_Firm_Impl.databaseConnection$;\n                referenceBuilder.append(String.format(\"%010d\", databaseConnectionString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(databaseConnectionString);\n                referenceBuilder.append(\":\");\n\n                Map<String, Object> pkMap = new HashMap<>();\n\n                pkMap.put(\"pk$_0\", this.getPk$_0());\n                String pkMapString = objectMapper$.writeValueAsString(pkMap);\n                referenceBuilder.append(String.format(\"%010d\", pkMapString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(pkMapString);\n\n                this.alloyStoreObjectReference$ = \"ASOR:\" + org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(referenceBuilder.toString().getBytes());\n            }\n            catch (Exception e)\n            {\n               throw new RuntimeException(e);\n            }\n        }\n\n        return this.alloyStoreObjectReference$;\n    }\n\n    public void setAlloyStoreObjectReference$(String reference)\n    {\n        this.alloyStoreObjectReference$ = reference;\n    }\n\n    private static long getClassSize$()\n    {\n        return 132L;\n    }\n\n    public long getInstanceSize$()\n    {\n        long size = GraphFetch_Node0_Firm_Impl.getClassSize$();\n        if (this.legalName != null)\n        {\n            size = size + this.legalName.length();\n        }\n        if (this.setId$ != null)\n        {\n            size = size + this.setId$.length();\n        }\n        if (this.alloyStoreObjectReference$ != null)\n        {\n            size = size + this.alloyStoreObjectReference$.length();\n        }\n        if (this.employees != null)\n        {\n            for (_pure.app.domain.Person i: this.employees)\n            {\n                if (i != null)\n                {\n                    size = size + 20L;\n                }\n            }\n        }\n        return size;\n    }\n}"
      },
      {
        "name": "Specifics",
        "package": "_pure.plan.root.n1.localGraph",
        "source": "package _pure.plan.root.n1.localGraph;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.Types;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.eclipse.collections.impl.tuple.Tuples;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IConstantResult;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n\nclass Specifics\n{\n    private static final List<Integer> STRING_TYPES = Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL);\n    private static final List<Integer> INT_TYPES = Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL);\n    private static final List<Integer> FLOAT_TYPES = Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> DECIMAL_TYPES = Arrays.asList(Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> BOOL_TYPES = Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL);\n    private static final List<Integer> STRICT_DATE_TYPES = Arrays.asList(Types.DATE, Types.NULL);\n    private static final List<Integer> DATE_TIME_TYPES = Arrays.asList(Types.TIMESTAMP, Types.NULL);\n    private ResultSet resultSet;\n    private String databaseTimeZone;\n    private String databaseConnection;\n    private List<Integer> columnTypes;\n    private List<List<Integer>> propertyIndices;\n    private List<List<Supplier<Object>>> propertyGetters;\n    private Calendar calendar;\n    private Method parentPropertyAdder;\n    private Method parentEdgePointPropertyAdder;\n\n    private Object getAlloyNativeValueFromResultSet(ResultSet resultSet,\n                                                    int columnIndex,\n                                                    int columnType)\n    {\n        try\n        {\n            Object result = null;\n            switch (columnType)\n            {\n                case Types.DATE:\n                {\n                    java.sql.Date date = resultSet.getDate(columnIndex);\n                    if (date != null)\n                    {\n                        result = PureDate.fromSQLDate(date);\n                    }\n                    break;\n                }\n                case Types.TIMESTAMP:\n                {\n                    java.sql.Timestamp timestamp = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (timestamp != null)\n                    {\n                        result = PureDate.fromSQLTimestamp(timestamp);\n                    }\n                    break;\n                }\n                case Types.TINYINT:\n                case Types.SMALLINT:\n                case Types.INTEGER:\n                case Types.BIGINT:\n                {\n                    long num = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Long.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.REAL:\n                case Types.FLOAT:\n                case Types.DOUBLE:\n                {\n                    double num = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Double.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.DECIMAL:\n                case Types.NUMERIC:\n                {\n                    result = resultSet.getBigDecimal(columnIndex);\n                    break;\n                }\n                case Types.CHAR:\n                case Types.VARCHAR:\n                case Types.LONGVARCHAR:\n                case Types.NCHAR:\n                case Types.NVARCHAR:\n                case Types.LONGNVARCHAR:\n                case Types.OTHER:\n                {\n                    result = resultSet.getString(columnIndex);\n                    break;\n                }\n                case Types.BIT:\n                case Types.BOOLEAN:\n                {\n                    boolean bool = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Boolean.valueOf(bool);\n                    }\n                }\n                case Types.BINARY:\n                case Types.VARBINARY:\n                case Types.LONGVARBINARY:\n                {\n                    byte[] bytes = resultSet.getBytes(columnIndex);\n                    if (bytes != null)\n                    {\n                        result = this.encodeHex(bytes);\n                    }\n                    break;\n                }\n                case Types.NULL:\n                {\n                    // do nothing: value is already assigned to null\n                    break;\n                }\n                default:\n                {\n                    result = resultSet.getObject(columnIndex);\n                }\n            }\n            return result;}\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String encodeHex(byte[] data)\n    {\n        final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n        final int l = data.length;\n        final char[] out = new char[l << 1];\n        for (int i = 0, j = 0; i < l; i++)\n        {\n            out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS_LOWER[0x0F & data[i]];\n        }\n        return new String(out);\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStringProperty(ResultSet resultSet,\n                                                                         int columnIndex,\n                                                                         int columnType,\n                                                                         String propertyName)\n    {\n        if (STRING_TYPES.contains(columnType))\n        {\n           return () -> {\n                try\n                {\n                    return resultSet.getString(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        else\n        {\n            throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type String from SQL column of type '\" + columnType + \"'.\");\n        }\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForIntegerProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Long res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Long.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Integer from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForFloatProperty(ResultSet resultSet,\n                                                                        int columnIndex,\n                                                                        int columnType,\n                                                                        String propertyName)\n    {\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Float from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDecimalProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (DECIMAL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    return resultSet.getBigDecimal(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Decimal from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForBooleanProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (BOOL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    boolean r = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r == 1);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Boolean from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStrictDateProperty(ResultSet resultSet,\n                                                                             int columnIndex,\n                                                                             int columnType,\n                                                                             String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type StrictDate from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateTimeProperty(ResultSet resultSet,\n                                                                           int columnIndex,\n                                                                           int columnType,\n                                                                           String propertyName)\n    {\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type DateTime from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateProperty(ResultSet resultSet,\n                                                                       int columnIndex,\n                                                                       int columnType,\n                                                                       String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException1)\n                        {\n                            try\n                            {\n                                res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                            }\n                            catch (java.time.format.DateTimeParseException dateTimeParseException2)\n                            {\n                                res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                            }\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Date from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        try\n        {\n            this.resultSet = resultSet;\n            this.databaseTimeZone = databaseTimeZone;\n            this.databaseConnection = databaseConnection;\n            this.calendar = new GregorianCalendar(TimeZone.getTimeZone(this.databaseTimeZone));\n            ResultSetMetaData resultSetMetaData = this.resultSet.getMetaData();\n            int columnCount = resultSetMetaData.getColumnCount();\n            this.columnTypes = new ArrayList<Integer>();\n            List<String> columnNames = new ArrayList<String>();\n            for (int i = 1; i <= columnCount; i++)\n            {\n                String columnLabel = resultSetMetaData.getColumnLabel(i);\n                columnNames.add(columnLabel.startsWith(\"\\\"\") && columnLabel\n                                           .endsWith(\"\\\"\")\n                                           ? columnLabel.substring(1, columnLabel.length() - 1)\n                                                        .toUpperCase()\n                                           : columnLabel.toUpperCase());\n                this.columnTypes.add(resultSetMetaData.getColumnType(i));\n            }\n            this.propertyIndices = new ArrayList<List<Integer>>();\n            List<Integer> index_0 = new ArrayList<Integer>();\n            index_0.add(columnNames.indexOf(\"LEGALNAME\") + 1);\n            index_0.add(columnNames.indexOf(\"PK_0\") + 1);\n            this.propertyIndices.add(index_0);\n            GraphFetch_Node0_Firm_Impl.databaseConnection$ = databaseConnection;\n            this.propertyGetters = new ArrayList<List<Supplier<Object>>>();\n            int propertyIndex;\n            Supplier<Object> propertyGetter = null;\n            List<Supplier<Object>> propertyGetter_0 = new ArrayList<Supplier<Object>>();\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"legalName\");\n            propertyGetter_0.add(propertyGetter);\n            this.propertyGetters.add(propertyGetter_0);\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    IGraphInstance<? extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject> nextGraphInstance()\n    {\n        try\n        {\n            final GraphFetch_Node0_Firm_Impl object = new GraphFetch_Node0_Firm_Impl();\n            object.setSetId$(\"domain_Firm\");\n            int pkColIndex;\n            int propertyIndex;\n            pkColIndex = this.propertyIndices.get(0).get(1);\n            Object pk$_0 = this.getAlloyNativeValueFromResultSet(resultSet,\n                                                                 pkColIndex,\n                                                                 this.columnTypes.get(pkColIndex - 1));\n            object.setPk$_0(pk$_0);\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            {\n                String res = (String) this.propertyGetters.get(0).get(0).get();\n                if (res == null)\n                {\n                    throw new RuntimeException(\"Error reading in property 'legalName'. Property of multiplicity [1] can not be null\");\n                }\n                object.setLegalName(res);\n            }\n            return new IGraphInstance<GraphFetch_Node0_Firm_Impl>()\n            {\n                public GraphFetch_Node0_Firm_Impl getValue()\n                {\n                    return object;\n                }\n                public long instanceSize()\n                {\n                    return object.getInstanceSize$();\n                }\n            };\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<Method> primaryKeyGetters()\n    {\n        try\n        {\n            return Arrays.asList(GraphFetch_Node0_Firm_Impl.class.getMethod(\"getPk$_0\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<Pair<String, String>> allInstanceSetImplementations()\n    {\n        return Arrays.asList(Tuples.pair(\"mapping::relational::Firm_Person\", \"domain_Firm\"));\n    }\n\n    List<String> primaryKeyColumns(int setIndex)\n    {\n        if (setIndex == 0)\n        {\n            return Arrays.asList(\"pk_0\");\n        }\n        return null;\n    }\n}"
      },
      {
        "name": "Execute",
        "package": "_pure.plan.root.n1.localGraph.localChild0",
        "source": "package _pure.plan.root.n1.localGraph.localChild0;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.relational.graphFetch.IRelationalClassQueryTempTableGraphFetchExecutionNodeSpecifics;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject;\n\npublic class Execute implements IRelationalClassQueryTempTableGraphFetchExecutionNodeSpecifics\n{\n    private Specifics specifics;\n\n    public Execute()\n    {\n        this.specifics = new Specifics();\n    }\n\n    public void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        this.specifics.prepare(resultSet, databaseTimeZone, databaseConnection);\n    }\n\n    public IGraphInstance<? extends IReferencedObject> nextGraphInstance()\n    {\n        return this.specifics.nextGraphInstance();\n    }\n\n    public List<Method> primaryKeyGetters()\n    {\n        return this.specifics.primaryKeyGetters();\n    }\n\n    public List<Pair<String, String>> allInstanceSetImplementations()\n    {\n        return this.specifics.allInstanceSetImplementations();\n    }\n\n    public List<String> primaryKeyColumns(int setIndex)\n    {\n        return this.specifics.primaryKeyColumns(setIndex);\n    }\n\n    public void addChildToParent(Object parent,\n                                 Object child,\n                                 IExecutionNodeContext executionNodeContext)\n    {\n        this.specifics.addChildToParent(parent, child, executionNodeContext);\n    }\n\n    public List<String> parentPrimaryKeyColumns(List<String> queryResultColumns)\n    {\n        return this.specifics.parentPrimaryKeyColumns(queryResultColumns);\n    }\n}"
      },
      {
        "name": "GraphFetch_Node2_Person_Impl",
        "package": "_pure.plan.root.n1.localGraph.localChild0",
        "source": "package _pure.plan.root.n1.localGraph.localChild0;\n\nimport java.math.*;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DayOfWeek;\nimport org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.util.Library;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonSerializer;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializerProvider;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport java.io.IOException;\n\npublic class GraphFetch_Node2_Person_Impl implements _pure.app.domain.Person, org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.domain.Person>, java.io.Serializable\n{\n    private String firstName;\n    private String lastName;\n    private _pure.app.domain.Firm firm;\n    private Object pk$_0;\n    private static final ObjectMapper objectMapper$ = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).registerModule(new SimpleModule().addSerializer(PureDate.class, new JsonSerializer<PureDate>() { @Override public void serialize(PureDate value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeRawValue(\"\\\"\" + value.toString() + \"\\\"\"); } }));\n    private String setId$;\n    public static String databaseConnection$;\n    private String alloyStoreObjectReference$;\n    private static final long serialVersionUID = 2087317339L;\n\n    public String getFirstName()\n    {\n        return this.firstName;\n    }\n\n    public void setFirstName(String firstName)\n    {\n        this.firstName = firstName;\n    }\n\n    public void addFirstName(String object)\n    {\n        if ((Object) this.firstName != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'firstName' of multiplicity with bound 1\");\n        }\n        this.firstName = object;\n    }\n\n    public String getLastName()\n    {\n        return this.lastName;\n    }\n\n    public void setLastName(String lastName)\n    {\n        this.lastName = lastName;\n    }\n\n    public void addLastName(String object)\n    {\n        if ((Object) this.lastName != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'lastName' of multiplicity with bound 1\");\n        }\n        this.lastName = object;\n    }\n\n    public _pure.app.domain.Firm getFirm()\n    {\n        return this.firm;\n    }\n\n    public void setFirm(_pure.app.domain.Firm firm)\n    {\n        this.firm = firm;\n    }\n\n    public void addFirm(_pure.app.domain.Firm object)\n    {\n        if ((Object) this.firm != null)\n        {\n            throw new IllegalStateException(\"Found multiple objects for property 'firm' of multiplicity with bound 1\");\n        }\n        this.firm = object;\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints()\n    {\n        return this.allConstraints(new org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext());\n    }\n\n    public _pure.app.domain.Person withConstraintsApplied()\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = allConstraints();\n        if (!defects.isEmpty())\n        {\n            throw new IllegalStateException(defects.stream().map(org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect::getMessage).collect(java.util.stream.Collectors.joining(\"\\n\")));\n        }\n        return this;\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Person> toChecked()\n    {\n        return this.toChecked(null, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Person> toChecked(boolean applyConstraints)\n    {\n        return this.toChecked(null, applyConstraints);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Person> toChecked(Object source)\n    {\n        return this.toChecked(source, true);\n    }\n\n    public org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Person> toChecked(Object source,\n                                                                                                                    boolean applyConstraints)\n    {\n        java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> defects = applyConstraints ? allConstraints() : java.util.Collections.emptyList();\n        return new org.finos.legend.engine.plan.dependencies.domain.dataQuality.IChecked<_pure.app.domain.Person>() {\n            public java.util.List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> getDefects() { return defects; }\n            public Object getSource() { return source; }\n            public _pure.app.domain.Person getValue() { return GraphFetch_Node2_Person_Impl.this; }\n        };\n    }\n\n    public List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> allConstraints(org.finos.legend.engine.plan.dependencies.domain.dataQuality.GraphContext context)\n    {\n        List<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect> result = new ArrayList<org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect>();\n        if (!context.visited.contains(this))\n        {\n            context.visited.add(this);\n            if (this.getFirm() != null)\n            {\n                result.addAll(((org.finos.legend.engine.plan.dependencies.domain.dataQuality.Constrained<_pure.app.domain.Firm>) this.getFirm())\n                                                                                                                                     .allConstraints(context)\n                                                                                                                                     .stream()\n                                                                                                                                     .map((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect d) -> org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicDefect.prefixPath(d,\n                                                                                                                                                                                                                                                                                                          org.finos.legend.engine.plan.dependencies.domain.dataQuality.BasicRelativePathNode.newRelativePathNode(\"firm\")))\n                                                                                                                                     .filter((org.finos.legend.engine.plan.dependencies.domain.dataQuality.IDefect x) -> x != null)\n                                                                                                                                     .collect(Collectors.toList()));\n            }\n        }\n        return result;\n    }\n\n    public Object getPk$_0()\n    {\n        return this.pk$_0;\n    }\n\n    public void setPk$_0(Object pk$_0)\n    {\n        this.pk$_0 = pk$_0;\n    }\n\n    public String getSetId$()\n    {\n        return this.setId$;\n    }\n\n    public void setSetId$(String setId)\n    {\n        this.setId$ = setId;\n    }\n\n    public String getAlloyStoreObjectReference$()\n    {\n        if (this.alloyStoreObjectReference$ == null)\n        {\n            try\n            {\n                StringBuilder referenceBuilder = new StringBuilder();\n                referenceBuilder.append(\"001:\");\n                referenceBuilder.append(\"010:\");\n\n                referenceBuilder.append(\"0000000010:\");\n                referenceBuilder.append(\"Relational:\");\n\n                referenceBuilder.append(\"0000000032:\");\n                referenceBuilder.append(\"mapping::relational::Firm_Person:\");\n\n                referenceBuilder.append(\"0000000013:\");\n                referenceBuilder.append(\"domain_Person:\");\n\n                String setId = this.getSetId$();\n                referenceBuilder.append(String.format(\"%010d\", setId.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(setId);\n                referenceBuilder.append(\":\");\n\n                String databaseConnectionString = _pure.plan.root.n1.localGraph.localChild0.GraphFetch_Node2_Person_Impl.databaseConnection$;\n                referenceBuilder.append(String.format(\"%010d\", databaseConnectionString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(databaseConnectionString);\n                referenceBuilder.append(\":\");\n\n                Map<String, Object> pkMap = new HashMap<>();\n\n                pkMap.put(\"pk$_0\", this.getPk$_0());\n                String pkMapString = objectMapper$.writeValueAsString(pkMap);\n                referenceBuilder.append(String.format(\"%010d\", pkMapString.length()));\n                referenceBuilder.append(\":\");\n                referenceBuilder.append(pkMapString);\n\n                this.alloyStoreObjectReference$ = \"ASOR:\" + org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(referenceBuilder.toString().getBytes());\n            }\n            catch (Exception e)\n            {\n               throw new RuntimeException(e);\n            }\n        }\n\n        return this.alloyStoreObjectReference$;\n    }\n\n    public void setAlloyStoreObjectReference$(String reference)\n    {\n        this.alloyStoreObjectReference$ = reference;\n    }\n\n    private static long getClassSize$()\n    {\n        return 156L;\n    }\n\n    public long getInstanceSize$()\n    {\n        long size = GraphFetch_Node2_Person_Impl.getClassSize$();\n        if (this.firstName != null)\n        {\n            size = size + this.firstName.length();\n        }\n        if (this.lastName != null)\n        {\n            size = size + this.lastName.length();\n        }\n        if (this.setId$ != null)\n        {\n            size = size + this.setId$.length();\n        }\n        if (this.alloyStoreObjectReference$ != null)\n        {\n            size = size + this.alloyStoreObjectReference$.length();\n        }\n        return size;\n    }\n}"
      },
      {
        "name": "Specifics",
        "package": "_pure.plan.root.n1.localGraph.localChild0",
        "source": "package _pure.plan.root.n1.localGraph.localChild0;\n\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.Types;\nimport java.util.*;\nimport java.util.function.*;\nimport java.util.stream.*;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.eclipse.collections.impl.tuple.Tuples;\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\nimport org.finos.legend.engine.plan.dependencies.domain.graphFetch.IGraphInstance;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IConstantResult;\nimport org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n\nclass Specifics\n{\n    private static final List<Integer> STRING_TYPES = Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL);\n    private static final List<Integer> INT_TYPES = Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL);\n    private static final List<Integer> FLOAT_TYPES = Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> DECIMAL_TYPES = Arrays.asList(Types.DECIMAL, Types.NUMERIC, Types.NULL);\n    private static final List<Integer> BOOL_TYPES = Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL);\n    private static final List<Integer> STRICT_DATE_TYPES = Arrays.asList(Types.DATE, Types.NULL);\n    private static final List<Integer> DATE_TIME_TYPES = Arrays.asList(Types.TIMESTAMP, Types.NULL);\n    private ResultSet resultSet;\n    private String databaseTimeZone;\n    private String databaseConnection;\n    private List<Integer> columnTypes;\n    private List<List<Integer>> propertyIndices;\n    private List<List<Supplier<Object>>> propertyGetters;\n    private Calendar calendar;\n    private Method parentPropertyAdder;\n    private Method parentEdgePointPropertyAdder;\n\n    private Object getAlloyNativeValueFromResultSet(ResultSet resultSet,\n                                                    int columnIndex,\n                                                    int columnType)\n    {\n        try\n        {\n            Object result = null;\n            switch (columnType)\n            {\n                case Types.DATE:\n                {\n                    java.sql.Date date = resultSet.getDate(columnIndex);\n                    if (date != null)\n                    {\n                        result = PureDate.fromSQLDate(date);\n                    }\n                    break;\n                }\n                case Types.TIMESTAMP:\n                {\n                    java.sql.Timestamp timestamp = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (timestamp != null)\n                    {\n                        result = PureDate.fromSQLTimestamp(timestamp);\n                    }\n                    break;\n                }\n                case Types.TINYINT:\n                case Types.SMALLINT:\n                case Types.INTEGER:\n                case Types.BIGINT:\n                {\n                    long num = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Long.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.REAL:\n                case Types.FLOAT:\n                case Types.DOUBLE:\n                {\n                    double num = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Double.valueOf(num);\n                    }\n                    break;\n                }\n                case Types.DECIMAL:\n                case Types.NUMERIC:\n                {\n                    result = resultSet.getBigDecimal(columnIndex);\n                    break;\n                }\n                case Types.CHAR:\n                case Types.VARCHAR:\n                case Types.LONGVARCHAR:\n                case Types.NCHAR:\n                case Types.NVARCHAR:\n                case Types.LONGNVARCHAR:\n                case Types.OTHER:\n                {\n                    result = resultSet.getString(columnIndex);\n                    break;\n                }\n                case Types.BIT:\n                case Types.BOOLEAN:\n                {\n                    boolean bool = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        result = Boolean.valueOf(bool);\n                    }\n                }\n                case Types.BINARY:\n                case Types.VARBINARY:\n                case Types.LONGVARBINARY:\n                {\n                    byte[] bytes = resultSet.getBytes(columnIndex);\n                    if (bytes != null)\n                    {\n                        result = this.encodeHex(bytes);\n                    }\n                    break;\n                }\n                case Types.NULL:\n                {\n                    // do nothing: value is already assigned to null\n                    break;\n                }\n                default:\n                {\n                    result = resultSet.getObject(columnIndex);\n                }\n            }\n            return result;}\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private String encodeHex(byte[] data)\n    {\n        final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n        final int l = data.length;\n        final char[] out = new char[l << 1];\n        for (int i = 0, j = 0; i < l; i++)\n        {\n            out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];\n            out[j++] = DIGITS_LOWER[0x0F & data[i]];\n        }\n        return new String(out);\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStringProperty(ResultSet resultSet,\n                                                                         int columnIndex,\n                                                                         int columnType,\n                                                                         String propertyName)\n    {\n        if (STRING_TYPES.contains(columnType))\n        {\n           return () -> {\n                try\n                {\n                    return resultSet.getString(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        else\n        {\n            throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type String from SQL column of type '\" + columnType + \"'.\");\n        }\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForIntegerProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Long res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Long.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Integer from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForFloatProperty(ResultSet resultSet,\n                                                                        int columnIndex,\n                                                                        int columnType,\n                                                                        String propertyName)\n    {\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Double res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Double.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Float from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDecimalProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (DECIMAL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    return resultSet.getBigDecimal(columnIndex);\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (FLOAT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    double r = resultSet.getDouble(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    java.math.BigDecimal res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = java.math.BigDecimal.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Decimal from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForBooleanProperty(ResultSet resultSet,\n                                                                          int columnIndex,\n                                                                          int columnType,\n                                                                          String propertyName)\n    {\n        if (BOOL_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    boolean r = resultSet.getBoolean(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (INT_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    Boolean res = null;\n                    long r = resultSet.getLong(columnIndex);\n                    if (!resultSet.wasNull())\n                    {\n                        res = Boolean.valueOf(r == 1);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Boolean from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForStrictDateProperty(ResultSet resultSet,\n                                                                             int columnIndex,\n                                                                             int columnType,\n                                                                             String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type StrictDate from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateTimeProperty(ResultSet resultSet,\n                                                                           int columnIndex,\n                                                                           int columnType,\n                                                                           String propertyName)\n    {\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\n                        {\n                            res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type DateTime from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    private Supplier<Object> getResultSetPropertyGetterForDateProperty(ResultSet resultSet,\n                                                                       int columnIndex,\n                                                                       int columnType,\n                                                                       String propertyName)\n    {\n        if (STRICT_DATE_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Date r = resultSet.getDate(columnIndex);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLDate(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (DATE_TIME_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\n                    if (r != null)\n                    {\n                        res = PureDate.fromSQLTimestamp(r);\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        if (STRING_TYPES.contains(columnType))\n        {\n            return () -> {\n                try\n                {\n                    PureDate res = null;\n                    String r = resultSet.getString(columnIndex);\n                    if (r != null)\n                    {\n                        try\n                        {\n                            res = PureDate.parsePureDate(r);\n                        }\n                        catch (java.lang.IllegalArgumentException dateTimeParseException1)\n                        {\n                            try\n                            {\n                                res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\n                            }\n                            catch (java.time.format.DateTimeParseException dateTimeParseException2)\n                            {\n                                res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\n                            }\n                        }\n                    }\n                    return res;\n                }\n                catch (Exception e)\n                {\n                    throw new RuntimeException(e);\n                }\n            };\n        }\n        throw new RuntimeException(\"Error reading in property '\" + propertyName + \"' of type Date from SQL column of type '\" + columnType + \"'.\");\n    }\n\n    void prepare(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\n    {\n        try\n        {\n            this.resultSet = resultSet;\n            this.databaseTimeZone = databaseTimeZone;\n            this.databaseConnection = databaseConnection;\n            this.calendar = new GregorianCalendar(TimeZone.getTimeZone(this.databaseTimeZone));\n            ResultSetMetaData resultSetMetaData = this.resultSet.getMetaData();\n            int columnCount = resultSetMetaData.getColumnCount();\n            this.columnTypes = new ArrayList<Integer>();\n            List<String> columnNames = new ArrayList<String>();\n            for (int i = 1; i <= columnCount; i++)\n            {\n                String columnLabel = resultSetMetaData.getColumnLabel(i);\n                columnNames.add(columnLabel.startsWith(\"\\\"\") && columnLabel\n                                           .endsWith(\"\\\"\")\n                                           ? columnLabel.substring(1, columnLabel.length() - 1)\n                                                        .toUpperCase()\n                                           : columnLabel.toUpperCase());\n                this.columnTypes.add(resultSetMetaData.getColumnType(i));\n            }\n            this.propertyIndices = new ArrayList<List<Integer>>();\n            List<Integer> index_0 = new ArrayList<Integer>();\n            index_0.add(columnNames.indexOf(\"FIRSTNAME\") + 1);\n            index_0.add(columnNames.indexOf(\"LASTNAME\") + 1);\n            index_0.add(columnNames.indexOf(\"PK_0\") + 1);\n            this.propertyIndices.add(index_0);\n            GraphFetch_Node2_Person_Impl.databaseConnection$ = databaseConnection;\n            this.propertyGetters = new ArrayList<List<Supplier<Object>>>();\n            int propertyIndex;\n            Supplier<Object> propertyGetter = null;\n            List<Supplier<Object>> propertyGetter_0 = new ArrayList<Supplier<Object>>();\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"firstName\");\n            propertyGetter_0.add(propertyGetter);\n            propertyIndex = this.propertyIndices.get(0).get(1);\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(this.resultSet,\n                                                                              propertyIndex,\n                                                                              resultSetMetaData.getColumnType(propertyIndex),\n                                                                              \"lastName\");\n            propertyGetter_0.add(propertyGetter);\n            this.propertyGetters.add(propertyGetter_0);\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    IGraphInstance<? extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject> nextGraphInstance()\n    {\n        try\n        {\n            final GraphFetch_Node2_Person_Impl object = new GraphFetch_Node2_Person_Impl();\n            object.setSetId$(\"domain_Person\");\n            int pkColIndex;\n            int propertyIndex;\n            pkColIndex = this.propertyIndices.get(0).get(2);\n            Object pk$_0 = this.getAlloyNativeValueFromResultSet(resultSet,\n                                                                 pkColIndex,\n                                                                 this.columnTypes.get(pkColIndex - 1));\n            object.setPk$_0(pk$_0);\n            propertyIndex = this.propertyIndices.get(0).get(0);\n            {\n                String res = (String) this.propertyGetters.get(0).get(0).get();\n                if (res == null)\n                {\n                    throw new RuntimeException(\"Error reading in property 'firstName'. Property of multiplicity [1] can not be null\");\n                }\n                object.setFirstName(res);\n            }\n            propertyIndex = this.propertyIndices.get(0).get(1);\n            {\n                String res = (String) this.propertyGetters.get(0).get(1).get();\n                if (res == null)\n                {\n                    throw new RuntimeException(\"Error reading in property 'lastName'. Property of multiplicity [1] can not be null\");\n                }\n                object.setLastName(res);\n            }\n            return new IGraphInstance<GraphFetch_Node2_Person_Impl>()\n            {\n                public GraphFetch_Node2_Person_Impl getValue()\n                {\n                    return object;\n                }\n                public long instanceSize()\n                {\n                    return object.getInstanceSize$();\n                }\n            };\n        }\n        catch (RuntimeException e)\n        {\n            throw e;\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<Method> primaryKeyGetters()\n    {\n        try\n        {\n            return Arrays.asList(GraphFetch_Node2_Person_Impl.class.getMethod(\"getPk$_0\"));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<Pair<String, String>> allInstanceSetImplementations()\n    {\n        return Arrays.asList(Tuples.pair(\"mapping::relational::Firm_Person\", \"domain_Person\"));\n    }\n\n    List<String> primaryKeyColumns(int setIndex)\n    {\n        if (setIndex == 0)\n        {\n            return Arrays.asList(\"pk_0\");\n        }\n        return null;\n    }\n\n    void addChildToParent(Object parent, Object child, IExecutionNodeContext executionNodeContext)\n    {\n        try\n        {\n            if (this.parentPropertyAdder == null)\n            {\n                this.parentPropertyAdder = parent\n                    .getClass()\n                    .getMethod(\"addEmployees\", _pure.app.domain.Person.class);\n            }\n            this.parentPropertyAdder.invoke(parent, child);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    List<String> parentPrimaryKeyColumns(List<String> queryResultColumns)\n    {\n        return queryResultColumns.stream()\n                                 .filter((String x) -> x.toUpperCase().startsWith(\"PARENT_KEY_GEN_\"))\n                                 .collect(Collectors.toList());\n    }\n}"
      }
    ]
  },
  "rootExecutionNode": {
    "_type": "platform",
    "authDependent": false,
    "executionNodes": [
      {
        "_type": "globalGraphFetchExecutionNode",
        "authDependent": false,
        "checked": true,
        "enableConstraints": true,
        "executionNodes": [],
        "graphFetchTree": {
          "_type": "rootGraphFetchTree",
          "class": "domain::Firm",
          "subTrees": [
            {
              "_type": "propertyGraphFetchTree",
              "parameters": [],
              "property": "legalName",
              "subTrees": []
            },
            {
              "_type": "propertyGraphFetchTree",
              "parameters": [],
              "property": "employees",
              "subTrees": [
                {
                  "_type": "propertyGraphFetchTree",
                  "parameters": [],
                  "property": "firstName",
                  "subTrees": []
                },
                {
                  "_type": "propertyGraphFetchTree",
                  "parameters": [],
                  "property": "lastName",
                  "subTrees": []
                }
              ]
            }
          ]
        },
        "localGraphFetchExecutionNode": {
          "_type": "relationalRootQueryTempTableGraphFetch",
          "authDependent": false,
          "batchSize": 1000,
          "checked": true,
          "children": [
            {
              "_type": "relationalClassQueryTempTableGraphFetch",
              "authDependent": false,
              "columns": [
                {
                  "dataType": "INTEGER",
                  "label": "pk_0"
                }
              ],
              "executionNodes": [
                {
                  "_type": "sql",
                  "authDependent": false,
                  "connection": {
                    "_type": "RelationalDatabaseConnection",
                    "authenticationStrategy": {
                      "_type": "h2Default"
                    },
                    "datasourceSpecification": {
                      "_type": "h2Local",
                      "testDataSetupSqls": [
                        "drop table if exists FIRM",
                        "create table FIRM(ID INTEGER, LEGAL_NAME VARCHAR(200))",
                        "insert into FIRM(ID, LEGAL_NAME) values(100, 'ACME Corp.')",
                        "insert into FIRM(ID, LEGAL_NAME) values(200, 'Monsters Inc.')",
                        "drop table if exists PERSON;",
                        "create table PERSON(ID INTEGER, FIRMID INTEGER, FIRST_NAME VARCHAR(200), LAST_NAME VARCHAR(200))",
                        "insert into PERSON(ID, FIRMID, FIRST_NAME, LAST_NAME) values(1, 100, 'Road', 'Runner')",
                        "insert into PERSON(ID, FIRMID, FIRST_NAME, LAST_NAME) values(2, 100, 'Wile', 'Coyote')",
                        "insert into PERSON(ID, FIRMID, FIRST_NAME, LAST_NAME) values(3, 200, 'Jake', 'Sullivan')",
                        "insert into PERSON(ID, FIRMID, FIRST_NAME, LAST_NAME) values(4, 200, 'Mike', 'Wazwoski')"
                      ]
                    },
                    "element": "database::h2",
                    "postProcessorWithParameter": [],
                    "postProcessors": [],
                    "type": "H2"
                  },
                  "executionNodes": [],
                  "resultColumns": [
                    {
                      "dataType": "INTEGER",
                      "label": "\"parent_key_gen_0\""
                    },
                    {
                      "dataType": "INTEGER",
                      "label": "\"pk_0\""
                    },
                    {
                      "dataType": "VARCHAR(200)",
                      "label": "\"firstName\""
                    },
                    {
                      "dataType": "VARCHAR(200)",
                      "label": "\"lastName\""
                    }
                  ],
                  "resultType": {
                    "_type": "dataType",
                    "dataType": "meta::pure::metamodel::type::Any"
                  },
                  "sqlQuery": "select distinct \"temp_table_node_0_0\".pk_0 as \"parent_key_gen_0\", \"person_0\".ID as \"pk_0\", \"person_0\".FIRST_NAME as \"firstName\", \"person_0\".LAST_NAME as \"lastName\" from (select * from (${temp_table_node_0}) as \"root\") as \"temp_table_node_0_0\" inner join FIRM as \"root\" on (\"temp_table_node_0_0\".pk_0 = \"root\".ID) left outer join PERSON as \"person_0\" on (\"person_0\".FIRMID = \"root\".ID) where \"person_0\".ID is not null"
                }
              ],
              "graphFetchTree": {
                "_type": "propertyGraphFetchTree",
                "parameters": [],
                "property": "employees",
                "subTrees": [
                  {
                    "_type": "propertyGraphFetchTree",
                    "parameters": [],
                    "property": "firstName",
                    "subTrees": []
                  },
                  {
                    "_type": "propertyGraphFetchTree",
                    "parameters": [],
                    "property": "lastName",
                    "subTrees": []
                  }
                ]
              },
              "implementation": {
                "_type": "java",
                "executionClassFullName": "_pure.plan.root.n1.localGraph.localChild0.Execute"
              },
              "nodeIndex": 2,
              "parentIndex": 0,
              "resultType": {
                "_type": "partialClass",
                "class": "domain::Person",
                "propertiesWithParameters": [
                  {
                    "property": "firstName"
                  },
                  {
                    "property": "lastName"
                  }
                ],
                "setImplementations": [
                  {
                    "class": "domain::Person",
                    "id": "domain_Person",
                    "mapping": "mapping::relational::Firm_Person",
                    "propertyMappings": [
                      {
                        "enumMapping": {},
                        "property": "firstName",
                        "type": "String"
                      },
                      {
                        "enumMapping": {},
                        "property": "lastName",
                        "type": "String"
                      }
                    ]
                  }
                ]
              },
              "tempTableName": "temp_table_node_2"
            }
          ],
          "columns": [
            {
              "dataType": "INTEGER",
              "label": "pk_0"
            }
          ],
          "executionNodes": [
            {
              "_type": "sql",
              "authDependent": false,
              "connection": {
                "_type": "RelationalDatabaseConnection",
                "authenticationStrategy": {
                  "_type": "h2Default"
                },
                "datasourceSpecification": {
                  "_type": "h2Local",
                  "testDataSetupSqls": [
                    "drop table if exists FIRM",
                    "create table FIRM(ID INTEGER, LEGAL_NAME VARCHAR(200))",
                    "insert into FIRM(ID, LEGAL_NAME) values(100, 'ACME Corp.')",
                    "insert into FIRM(ID, LEGAL_NAME) values(200, 'Monsters Inc.')",
                    "drop table if exists PERSON;",
                    "create table PERSON(ID INTEGER, FIRMID INTEGER, FIRST_NAME VARCHAR(200), LAST_NAME VARCHAR(200))",
                    "insert into PERSON(ID, FIRMID, FIRST_NAME, LAST_NAME) values(1, 100, 'Road', 'Runner')",
                    "insert into PERSON(ID, FIRMID, FIRST_NAME, LAST_NAME) values(2, 100, 'Wile', 'Coyote')",
                    "insert into PERSON(ID, FIRMID, FIRST_NAME, LAST_NAME) values(3, 200, 'Jake', 'Sullivan')",
                    "insert into PERSON(ID, FIRMID, FIRST_NAME, LAST_NAME) values(4, 200, 'Mike', 'Wazwoski')"
                  ]
                },
                "element": "database::h2",
                "postProcessorWithParameter": [],
                "postProcessors": [],
                "type": "H2"
              },
              "executionNodes": [],
              "resultColumns": [
                {
                  "dataType": "INTEGER",
                  "label": "\"pk_0\""
                },
                {
                  "dataType": "VARCHAR(200)",
                  "label": "\"legalName\""
                }
              ],
              "resultType": {
                "_type": "dataType",
                "dataType": "meta::pure::metamodel::type::Any"
              },
              "sqlQuery": "select \"root\".ID as \"pk_0\", \"root\".LEGAL_NAME as \"legalName\" from FIRM as \"root\""
            }
          ],
          "graphFetchTree": {
            "_type": "rootGraphFetchTree",
            "class": "domain::Firm",
            "subTrees": [
              {
                "_type": "propertyGraphFetchTree",
                "parameters": [],
                "property": "legalName",
                "subTrees": []
              },
              {
                "_type": "propertyGraphFetchTree",
                "parameters": [],
                "property": "employees",
                "subTrees": [
                  {
                    "_type": "propertyGraphFetchTree",
                    "parameters": [],
                    "property": "firstName",
                    "subTrees": []
                  },
                  {
                    "_type": "propertyGraphFetchTree",
                    "parameters": [],
                    "property": "lastName",
                    "subTrees": []
                  }
                ]
              }
            ]
          },
          "implementation": {
            "_type": "java",
            "executionClassFullName": "_pure.plan.root.n1.localGraph.Execute"
          },
          "nodeIndex": 0,
          "resultType": {
            "_type": "partialClass",
            "class": "domain::Firm",
            "propertiesWithParameters": [
              {
                "property": "legalName"
              },
              {
                "property": "employees"
              }
            ],
            "setImplementations": [
              {
                "class": "domain::Firm",
                "id": "domain_Firm",
                "mapping": "mapping::relational::Firm_Person",
                "propertyMappings": [
                  {
                    "enumMapping": {},
                    "property": "legalName",
                    "type": "String"
                  }
                ]
              }
            ]
          },
          "tempTableName": "temp_table_node_0"
        },
        "resultSizeRange": {
          "lowerBound": 0
        },
        "resultType": {
          "_type": "partialClass",
          "class": "domain::Firm",
          "propertiesWithParameters": [
            {
              "property": "legalName"
            },
            {
              "property": "employees"
            }
          ],
          "setImplementations": [
            {
              "class": "domain::Firm",
              "id": "domain_Firm",
              "mapping": "mapping::relational::Firm_Person",
              "propertyMappings": [
                {
                  "enumMapping": {},
                  "property": "legalName",
                  "type": "String"
                }
              ]
            }
          ]
        },
        "store": "database::h2"
      }
    ],
    "implementation": {
      "_type": "java",
      "executionClassFullName": "_pure.plan.root.Serialize"
    },
    "pure": {
      "_type": "func",
      "fControl": "serialize_Checked_MANY__RootGraphFetchTree_1__String_1_",
      "function": "serialize",
      "parameters": [
        {
          "_type": "collection",
          "multiplicity": {
            "lowerBound": 0
          },
          "values": []
        },
        {
          "_type": "classInstance",
          "type": "rootGraphFetchTree",
          "value": {
            "_type": "rootGraphFetchTree",
            "class": "domain::Firm",
            "subTrees": [
              {
                "_type": "propertyGraphFetchTree",
                "parameters": [],
                "property": "legalName",
                "subTrees": []
              },
              {
                "_type": "propertyGraphFetchTree",
                "parameters": [],
                "property": "employees",
                "subTrees": [
                  {
                    "_type": "propertyGraphFetchTree",
                    "parameters": [],
                    "property": "firstName",
                    "subTrees": []
                  },
                  {
                    "_type": "propertyGraphFetchTree",
                    "parameters": [],
                    "property": "lastName",
                    "subTrees": []
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    "resultType": {
      "_type": "dataType",
      "dataType": "String"
    }
  },
  "serializer": {
    "name": "pure",
    "version": "vX_X_X"
  },
  "templateFunctions": [
    "<#function renderCollection collection separator prefix suffix defaultValue><#if collection?size == 0><#return defaultValue></#if><#return prefix + collection?join(suffix + separator + prefix) + suffix></#function>",
    "<#function collectionSize collection> <#return collection?size?c> </#function>",
    "<#function optionalVarPlaceHolderOperationSelector optionalParameter trueClause falseClause><#if optionalParameter?has_content || optionalParameter?is_string><#return trueClause><#else><#return falseClause></#if></#function>",
    "<#function varPlaceHolderToString optionalParameter prefix suffix defaultValue><#if optionalParameter?is_enumerable && !optionalParameter?has_content><#return defaultValue><#else><#return prefix + optionalParameter + suffix></#if></#function>",
    "<#function equalEnumOperationSelector enumVal inDyna equalDyna><#assign enumList = enumVal?split(\",\")><#if enumList?size = 1><#return equalDyna><#else><#return inDyna></#if></#function>"
  ]
}