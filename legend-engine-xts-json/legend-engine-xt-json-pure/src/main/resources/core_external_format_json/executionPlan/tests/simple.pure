// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::dataQuality::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::mapping::*;
import meta::core::runtime::*;
import meta::external::format::shared::functions::*;
import meta::external::format::json::executionPlan::model::*;
import meta::external::format::json::executionPlan::test::simple::*;

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQuery(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| Person->internalize($binding, $data)->externalize($binding, #{Person{firstName, lastName}}#)};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe"}'));

  assertEquals('{"firstName":"John","lastName":"Doe"}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithOptionalInput(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[0..1]| Person->internalize($binding, $data->orElse('[]'))->externalize($binding, #{Person{firstName, lastName}}#)};

  let result_with_input  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe"}'));

  assertEquals('{"firstName":"John","lastName":"Doe"}', $result_with_input);

  let result_without_input = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, []);

  assertEquals('[]', $result_without_input);

}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithStaticInput(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {| Person->internalize($binding, '{"firstName": "John", "lastName":"Doe"}')->externalize($binding, #{Person{firstName, lastName}}#)};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, []);

  assertEquals('{"firstName":"John","lastName":"Doe"}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithFunctionalInput(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| Person->internalize($binding, $data->decodeUrl())->externalize($binding, #{Person{firstName, lastName}}#)};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe"}'));

  assertEquals('{"firstName":"John","lastName":"Doe"}', $result);

  let result1 = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe"}'->encodeUrl()));

  assertEquals('{"firstName":"John","lastName":"Doe"}', $result1);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithChecked(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| Person->internalize($binding, $data)->checked()->externalize($binding, checked(#{Person{firstName, lastName}}#, $binding))};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe"}'));

  assertEquals('{"defects":[],"source":{"number":1,"record":"{\\\"firstName\\\":\\\"John\\\",\\\"lastName\\\":\\\"Doe\\\"}"},"value":{"firstName":"John","lastName":"Doe"}}', $result);

  let result1 = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John"}'));

  assertEquals('{"defects":[{"id":null,"externalId":null,"message":"Invalid multiplicity for lastName: expected [1] found [0]","enforcementLevel":"Critical","ruleType":"ClassStructure","ruleDefinerPath":"meta::external::format::json::executionPlan::test::simple::Person","path":[]}],"source":{"number":1,"record":"{\\\"firstName\\\":\\\"John\\\"}"},"value":null}', $result1);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithCustomCheckedTree(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| Person->internalize($binding, $data)->checked()->externalize($binding, checked(#{Person{firstName, lastName}}#, defaultDefectTree()))};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe"}'));

  assertEquals('{"defects":[],"value":{"firstName":"John","lastName":"Doe"}}', $result);

  let result1 = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John"}'));

  assertEquals('{"defects":[{"id":null,"externalId":null,"message":"Invalid multiplicity for lastName: expected [1] found [0]","enforcementLevel":"Critical","ruleType":"ClassStructure","ruleDefinerPath":"meta::external::format::json::executionPlan::test::simple::Person","path":[]}],"value":null}', $result1);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithPartialTree(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| Person->internalize($binding, $data)->graphFetch(#{Person{firstName, lastName}}#)->externalize($binding, #{Person{firstName, lastName}}#)};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe"}'));

  assertEquals('{"firstName":"John","lastName":"Doe"}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithNestedTree(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| Person->internalize($binding, $data)->graphFetch(#{Person{firstName, lastName, firm {legalName}, addresses{street}}}#)->externalize($binding, #{Person{firstName, lastName, firm {legalName}, addresses{street}}}#)};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe", "firm": {"legalName" : "Firm A"}, "addresses": [{"street": "Street A"}]}'));

  assertEquals('{"firstName":"John","lastName":"Doe","firm":{"legalName":"Firm A"},"addresses":[{"street":"Street A"}]}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithPartialTreeInExternalize(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| Person->internalize($binding, $data)->graphFetch(#{Person{firstName, lastName, firm {legalName}, addresses{street}}}#)->externalize($binding, #{Person{firstName, lastName}}#)};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe", "firm": {"legalName" : "Firm A"}, "addresses": [{"street": "Street A"}]}'));

  assertEquals('{"firstName":"John","lastName":"Doe"}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithIncompleteData(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| Person->internalize($binding, $data)->graphFetchChecked(#{Person{firstName, lastName, firm {legalName}, addresses{street}}}#)->externalize($binding, checked(#{Person{firstName, lastName, firm {legalName}, addresses{street}}}#, $binding))};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe"}'));

  assertEquals('{"defects":[{"id":null,"externalId":null,"message":"Invalid multiplicity for firm: expected [1] found [0]","enforcementLevel":"Critical","ruleType":"ClassStructure","ruleDefinerPath":"meta::external::format::json::executionPlan::test::simple::Person","path":[]}],"source":{"number":1,"record":"{\\\"firstName\\\":\\\"John\\\",\\\"lastName\\\":\\\"Doe\\\"}"},"value":null}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithPartialTreeAndChecked(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| Person->internalize($binding, $data)->graphFetchChecked(#{Person{firstName, lastName, firm {legalName}, addresses{street}}}#)->externalize($binding, checked(#{Person{firstName, lastName}}#, $binding))};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe", "firm": {"legalName": "Firm A"}}'));

  assertEquals('{"defects":[],"source":{"number":1,"record":"{\\\"firstName\\\":\\\"John\\\",\\\"lastName\\\":\\\"Doe\\\",\\\"firm\\\":{\\\"legalName\\\":\\\"Firm A\\\"}}"},"value":{"firstName":"John","lastName":"Doe"}}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testSimpleJsonQueryWithChildSubType(): Boolean[1]
{
  let query   = {data:String[1]| Target.all()->graphFetch(#{Target{targetProductId}}#)->serialize(#{Target{targetProductId}}#)->from(M2MMappingWithChild, Source->getRuntimeWithModelQueryConnection('application/json', $data))};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"@type": "Source", "child": {"@type": "ProductExtended", "productId": "123"}}'));

  assertEquals('{"builder":{"_type":"json"},"values":{"targetProductId":"123"}}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testM2MChainingWithJson(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| TargetPerson.all()->graphFetch(#{TargetPerson{fullName, firm {legalName}, addresses{street}}}#)->from(M2MMapping1, getRuntimeWithModelQueryConnection(Person, $binding, $data))->externalize($binding, #{TargetPerson{fullName, firm {legalName}, addresses{street}}}#)};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe", "firm": {"legalName": "Firm A"}}'));

  assertEquals('{"fullName":"John Doe","firm":{"legalName":"Firm A"},"addresses":[]}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testM2MChainingWithJsonAndFunctionalInput(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| TargetPerson.all()->graphFetch(#{TargetPerson{fullName, firm {legalName}, addresses{street}}}#)->from(M2MMapping1, getRuntimeWithModelQueryConnection(Person, $binding, $data->decodeUrl()))->externalize($binding, #{TargetPerson{fullName, firm {legalName}, addresses{street}}}#)};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe", "firm": {"legalName": "Firm A"}}'->encodeUrl()));

  assertEquals('{"fullName":"John Doe","firm":{"legalName":"Firm A"},"addresses":[]}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testM2MChainingWithJsonAndCompleteCheckedTree(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| TargetPerson.all()->graphFetchChecked(#{TargetPerson{fullName, firm {legalName}, addresses{street}}}#)->from(M2MMapping1, getRuntimeWithModelQueryConnection(Person, $binding, $data))->externalize($binding, checked(#{TargetPerson{fullName, firm {legalName}, addresses{street}}}#, defaultDefectTree(), checked(#{Person{firstName, lastName}}#, defaultDefectTree(),  #{JsonDataRecord {number, record}}#)))};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe", "firm": {"legalName": "Firm A"}}'));

  assertEquals('{"defects":[],"source":{"defects":[],"source":{"number":1,"record":"{\\\"firstName\\\":\\\"John\\\",\\\"lastName\\\":\\\"Doe\\\",\\\"firm\\\":{\\\"legalName\\\":\\\"Firm A\\\"}}"},"value":{"firstName":"John","lastName":"Doe"}},"value":{"fullName":"John Doe","firm":{"legalName":"Firm A"},"addresses":[]}}', $result);

  let resultWithDefcts = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John"}'));

  assertEquals('{"defects":[{"id":null,"externalId":null,"message":"No Input Available","enforcementLevel":"Critical","ruleType":"NoInput","ruleDefinerPath":"meta::external::format::json::executionPlan::test::simple::TargetPerson","path":[]}],"source":{"defects":[{"id":null,"externalId":null,"message":"Invalid multiplicity for lastName: expected [1] found [0]","enforcementLevel":"Critical","ruleType":"ClassStructure","ruleDefinerPath":"meta::external::format::json::executionPlan::test::simple::Person","path":[]},{"id":null,"externalId":null,"message":"Invalid multiplicity for firm: expected [1] found [0]","enforcementLevel":"Critical","ruleType":"ClassStructure","ruleDefinerPath":"meta::external::format::json::executionPlan::test::simple::Person","path":[]}],"source":{"number":1,"record":"{\\\"firstName\\\":\\\"John\\\"}"},"value":null},"value":null}', $resultWithDefcts);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testM2MChainingWithJsonAndOnlyDefectsCheckedTree(): Boolean[1]
{
  let binding = getTestBinding();
  let query   = {data:String[1]| TargetPerson.all()->graphFetchChecked(#{TargetPerson{fullName, firm {legalName}, addresses{street}}}#)->from(M2MMapping1, getRuntimeWithModelQueryConnection(Person, $binding, $data))->externalize($binding, checked(#{TargetPerson{fullName, firm {legalName}, addresses{street}}}#, defaultDefectTree()))};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe", "firm": {"legalName": "Firm A"}}'));

  assertEquals('{"defects":[],"value":{"fullName":"John Doe","firm":{"legalName":"Firm A"},"addresses":[]}}', $result);

  let resultWithDefcts = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John"}'));

  assertEquals('{"defects":[{"id":null,"externalId":null,"message":"No Input Available","enforcementLevel":"Critical","ruleType":"NoInput","ruleDefinerPath":"meta::external::format::json::executionPlan::test::simple::TargetPerson","path":[]}],"value":null}', $resultWithDefcts);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testMultiLevelM2MChainingWithJson(): Boolean[1]
{
  let binding = getTestBinding();
  let runtime = ^Runtime(connectionStores = ^ConnectionStore(element=^meta::external::store::model::ModelStore(), connection=^meta::external::store::model::ModelChainConnection(mappings = M2MMapping1)));
  let query   = {data:String[1]| RefinedPerson.all()->graphFetch(#{RefinedPerson{fullName, firm {legalName}, addresses{street}}}#)->from(M2MMapping2, mergeRuntimes([$runtime, getRuntimeWithModelQueryConnection(Person, 'application/json', $data)]))->externalize($binding, #{RefinedPerson{fullName, firm {legalName}, addresses{street}}}#)};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe", "firm": {"legalName": "Firm A"}}'));

  assertEquals('{"fullName":"John Doe refined","firm":{"legalName":"Firm A refined"},"addresses":[]}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testMultiLevelM2MChainingWithJsonAndChecked(): Boolean[1]
{
  let binding = getTestBinding();
  let runtime = ^Runtime(connectionStores = ^ConnectionStore(element=^meta::external::store::model::ModelStore(), connection=^meta::external::store::model::ModelChainConnection(mappings = M2MMapping1)));
  let query   = {data:String[1]| RefinedPerson.all()->graphFetchChecked(#{RefinedPerson{fullName, firm {legalName}, addresses{street}}}#)->from(M2MMapping2, mergeRuntimes([$runtime, getRuntimeWithModelQueryConnection(Person, 'application/json', $data)]))->externalize($binding, checked(#{RefinedPerson{fullName, firm {legalName}, addresses{street}}}#, defaultDefectTree()))};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '{"firstName": "John", "lastName":"Doe", "firm": {"legalName": "Firm A"}}'));

  assertEquals('{"defects":[],"value":{"fullName":"John Doe refined","firm":{"legalName":"Firm A refined"},"addresses":[]}}', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testBindingAndM2MChainedWithQualifiedProperty(): Boolean[1]
{
  let binding = getTestBinding();
  let tree    = #{TargetPerson{fullName, firm {legalName}, addresses {street, decoratedStreet}}}#;
  let query   = {data:String[1]| TargetPerson.all()->graphFetch($tree)->from(M2MMapping1, getRuntimeWithModelQueryConnection(Person, $binding, $data))->externalize($binding, $tree);};

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, pair('data', '[{"firstName":"John", "lastName":"Doe", "firm":{"legalName":"Firm A"}, "addresses": {"street": "Street A"}}, {"firstName":"John", "lastName":"Doe2", "firm":{"legalName":"Firm B"}, "addresses": [{"street": "Street A"}, {"street": "Street B"}]}, {"firstName":"John", "lastName":"Doe3", "firm":{"legalName":"Firm C"}}]'));

  assertEquals('[{"fullName":"John Doe","firm":{"legalName":"Firm A"},"addresses":[{"street":"Street A","decoratedStreet()":"Street:Street A"}]},{"fullName":"John Doe2","firm":{"legalName":"Firm B"},"addresses":[{"street":"Street A","decoratedStreet()":"Street:Street A"},{"street":"Street B","decoratedStreet()":"Street:Street B"}]},{"fullName":"John Doe3","firm":{"legalName":"Firm C"},"addresses":[]}]', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testBindingAndM2MChainedWithXStore(): Boolean[1]
{
  let binding = getTradeProductTestBinding();
  let tree    = #{Trade {
                    tradeId,
                    trader {
                      kerberos,
                      firstName,
                      lastName
                    },
                    product {
                      productId,
                      productName,
                      description,
                      synonyms {
                        name,
                        type
                      }
                    }
                  }
                }#;
  let query   = {tradeData:String[1], productData:String[1]| Trade.all()->graphFetch($tree)->from(M2MCrossStoreMapping, mergeRuntimes([getRuntimeWithModelQueryConnection(S_Trade, $binding, $tradeData), getRuntimeWithModelQueryConnection(S_Product, $binding, $productData)]))->externalize($binding, $tree);};
  let vars    = [pair('tradeData', '[{"s_tradeId": 1, "s_tradeDetails": "30:100", "s_traderDetails": "abc:F_Name_1:L_Name_1"},{"s_tradeId": 2, "s_tradeDetails": "31:200", "s_traderDetails": "abc:F_Name_1:L_Name_1"},{"s_tradeId": 3, "s_tradeDetails": "30:300", "s_traderDetails": "xyz:F_Name_2:L_Name_2"},{"s_tradeId": 4, "s_tradeDetails": "31:400", "s_traderDetails": "xyz:F_Name_2:L_Name_2"}]'),
                 pair('productData', '[{"s_productId": "30", "s_productName": "Product 30", "s_description": "Product 30 description", "s_synonyms": [{"s_name":"product 30 synonym 1", "s_type":"isin"},{"s_name":"product 30 synonym 2", "s_type":"cusip"}]},{"s_productId": "31", "s_productName": "Product 31", "s_description": "Product 31 description", "s_synonyms": [{"s_name":"product 31 synonym 1", "s_type":"isin"}, {"s_name":"product 31 synonym 2", "s_type":"cusip"}]}]')];

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, $vars);

  assertEquals('[{"tradeId":1,"trader":{"kerberos":"abc","firstName":"F_Name_1","lastName":"L_Name_1"},"product":{"productId":"30","productName":"Product 30","description":"Product 30 description","synonyms":[{"name":"product 30 synonym 1","type":"ISIN"},{"name":"product 30 synonym 2","type":"CUSIP"}]}},{"tradeId":2,"trader":{"kerberos":"abc","firstName":"F_Name_1","lastName":"L_Name_1"},"product":{"productId":"31","productName":"Product 31","description":"Product 31 description","synonyms":[{"name":"product 31 synonym 1","type":"ISIN"},{"name":"product 31 synonym 2","type":"CUSIP"}]}},{"tradeId":3,"trader":{"kerberos":"xyz","firstName":"F_Name_2","lastName":"L_Name_2"},"product":{"productId":"30","productName":"Product 30","description":"Product 30 description","synonyms":[{"name":"product 30 synonym 1","type":"ISIN"},{"name":"product 30 synonym 2","type":"CUSIP"}]}},{"tradeId":4,"trader":{"kerberos":"xyz","firstName":"F_Name_2","lastName":"L_Name_2"},"product":{"productId":"31","productName":"Product 31","description":"Product 31 description","synonyms":[{"name":"product 31 synonym 1","type":"ISIN"},{"name":"product 31 synonym 2","type":"CUSIP"}]}}]', $result);
}

function <<meta::pure::profiles::test.Test, meta::pure::profiles::test.AlloyOnly>> meta::external::format::json::executionPlan::test::simple::testBindingAndM2MChainedWithUnion(): Boolean[1]
{
  let binding = getTradeProductTestBinding();
  let tree    = #{Trade {
                    tradeId,
                    trader {
                      kerberos,
                      firstName,
                      lastName
                    }
                  }
                }#;
  let query   = {tradeData1:String[1], tradeData2:String[1]| Trade.all()->graphFetch($tree)->from(M2MUnionMapping, mergeRuntimes([getRuntimeWithModelQueryConnection(S_Trade1, $binding, $tradeData1), getRuntimeWithModelQueryConnection(S_Trade2, $binding, $tradeData2)]))->externalize($binding, $tree);};
  let vars    = [pair('tradeData1', '[{"s_tradeId": 1, "s_tradeDetails": "30:100", "s_traderDetails": "abc:F_Name_1:L_Name_1"},{"s_tradeId": 2, "s_tradeDetails": "31:200", "s_traderDetails": "abc:F_Name_1:L_Name_1"},{"s_tradeId": 3, "s_tradeDetails": "30:300", "s_traderDetails": "xyz:F_Name_2:L_Name_2"},{"s_tradeId": 4, "s_tradeDetails": "31:400", "s_traderDetails": "xyz:F_Name_2:L_Name_2"}]'),
                 pair('tradeData2', '[{"s_tradeId": 5, "s_tradeDetails": "30:100", "s_traderDetails": "abc:F_Name_1:L_Name_1"},{"s_tradeId": 6, "s_tradeDetails": "31:200", "s_traderDetails": "abc:F_Name_1:L_Name_1"},{"s_tradeId": 7, "s_tradeDetails": "30:300", "s_traderDetails": "xyz:F_Name_2:L_Name_2"},{"s_tradeId": 8, "s_tradeDetails": "31:400", "s_traderDetails": "xyz:F_Name_2:L_Name_2"}]')];

  let result  = meta::external::format::json::executionPlan::test::executeJsonSchemaBindingQuery($query, $vars);

  assertEquals('[{"tradeId":1,"trader":{"kerberos":"abc","firstName":"F_Name_1","lastName":"L_Name_1"}},{"tradeId":2,"trader":{"kerberos":"abc","firstName":"F_Name_1","lastName":"L_Name_1"}},{"tradeId":3,"trader":{"kerberos":"xyz","firstName":"F_Name_2","lastName":"L_Name_2"}},{"tradeId":4,"trader":{"kerberos":"xyz","firstName":"F_Name_2","lastName":"L_Name_2"}},{"tradeId":5,"trader":{"kerberos":"abc","firstName":"F_Name_1","lastName":"L_Name_1"}},{"tradeId":6,"trader":{"kerberos":"abc","firstName":"F_Name_1","lastName":"L_Name_1"}},{"tradeId":7,"trader":{"kerberos":"xyz","firstName":"F_Name_2","lastName":"L_Name_2"}},{"tradeId":8,"trader":{"kerberos":"xyz","firstName":"F_Name_2","lastName":"L_Name_2"}}]', $result);
}

// =========================================================================================================
// Models
// =========================================================================================================

###Pure
import meta::legend::*;
import meta::external::format::shared::binding::*;
import meta::external::format::json::executionPlan::test::simple::*;

Class meta::external::format::json::executionPlan::test::simple::RefinedPerson
{
  fullName  : String[1];
  firm      : Firm[1];
  addresses : Address[*];
}

Class meta::external::format::json::executionPlan::test::simple::TargetPerson
{
  fullName  : String[1];
  firm      : Firm[1];
  addresses : Address[*];
}

Class meta::external::format::json::executionPlan::test::simple::Person
{
  firstName : String[1];
  lastName  : String[1];
  firm      : Firm[1];
  addresses : Address[*];
}

Class meta::external::format::json::executionPlan::test::simple::Firm
{
  legalName : String[1];
}

Class meta::external::format::json::executionPlan::test::simple::Address
{
  street : String[1];

  decoratedStreet()
  {
    'Street:' + $this.street
  }:String[1];
}

function meta::external::format::json::executionPlan::test::simple::getTestBinding():Binding[1]
{
  let schema =
    '###ExternalFormat\n' +
    'Binding meta::external::format::json::executionPlan::test::simple::TestBinding\n' +
    '{\n' +
    '  contentType: \'application/json\';\n' +
    '  modelIncludes: [\n' +
    '    meta::external::format::json::executionPlan::test::simple::RefinedPerson,\n' +
    '    meta::external::format::json::executionPlan::test::simple::TargetPerson,\n' +
    '    meta::external::format::json::executionPlan::test::simple::Person,\n' +
    '    meta::external::format::json::executionPlan::test::simple::Firm,\n' +
    '    meta::external::format::json::executionPlan::test::simple::Address\n' +
    '  ];\n' +
    '}\n';

  compileLegendGrammar($schema)->filter(ele | $ele->instanceOf(Binding))->cast(@Binding)->toOne();
}

Enum meta::external::format::json::executionPlan::test::simple::SynonymType
{
  CUSIP,
  ISIN
}

Class meta::external::format::json::executionPlan::test::simple::Product
{
  productId: String[1];
  productName: String[1];
  description: String[1];
}

Class meta::external::format::json::executionPlan::test::simple::ProductExtended extends meta::external::format::json::executionPlan::test::simple::Product
{
}

Class meta::external::format::json::executionPlan::test::simple::Target
{
  targetProductId: String[1];
}

Class meta::external::format::json::executionPlan::test::simple::Source
{
  child: meta::external::format::json::executionPlan::test::simple::Product[1];
}

Class meta::external::format::json::executionPlan::test::simple::Synonym
{
  name: String[1];
  type: SynonymType[1];
}

Class meta::external::format::json::executionPlan::test::simple::Trade
{
  tradeId: Integer[1];
  traderKerb: String[0..1];
  quantity: Integer[1];
  productName() {$this.product.productName}: String[0..1];
  justProduct() {$this.product}: meta::external::format::json::executionPlan::test::simple::Product[0..1];
}

Class meta::external::format::json::executionPlan::test::simple::Trader
{
  kerberos: String[1];
  firstName: String[1];
  lastName: String[1];
}

Class meta::external::format::json::executionPlan::test::simple::S_Trade
{
  s_tradeId: Integer[1];
  s_traderDetails: String[1];
  s_tradeDetails: String[1];
}

Class meta::external::format::json::executionPlan::test::simple::S_Trade1
{
  s_tradeId: Integer[1];
  s_traderDetails: String[1];
  s_tradeDetails: String[1];
}

Class meta::external::format::json::executionPlan::test::simple::S_Trade2
{
  s_tradeId: Integer[1];
  s_traderDetails: String[1];
  s_tradeDetails: String[1];
}


Class meta::external::format::json::executionPlan::test::simple::S_Product
{
  s_productId: String[1];
  s_productName: String[1];
  s_description: String[1];
  s_synonyms: meta::external::format::json::executionPlan::test::simple::S_Synonym[*];
}

Class meta::external::format::json::executionPlan::test::simple::S_Synonym
{
  s_name: String[1];
  s_type: String[1];
}

Association meta::external::format::json::executionPlan::test::simple::Product_Synonym
{
  product: meta::external::format::json::executionPlan::test::simple::Product[1];
  synonyms: meta::external::format::json::executionPlan::test::simple::Synonym[*];
}

Association meta::external::format::json::executionPlan::test::simple::Trade_Product
{
  product: meta::external::format::json::executionPlan::test::simple::Product[1];
  trades: meta::external::format::json::executionPlan::test::simple::Trade[*];
}

Association meta::external::format::json::executionPlan::test::simple::Trade_Trader
{
  trader: meta::external::format::json::executionPlan::test::simple::Trader[1];
  trades: meta::external::format::json::executionPlan::test::simple::Trade[*];
}


function meta::external::format::json::executionPlan::test::simple::getTradeProductTestBinding():Binding[1]
{
  let schema =
    '###ExternalFormat\n' +
    'Binding meta::external::format::json::executionPlan::test::simple::TradeProductTestBinding\n' +
    '{\n' +
    '  contentType: \'application/json\';\n' +
    '  modelIncludes: [\n' +
    '    meta::external::format::json::executionPlan::test::simple::S_Trade,\n' +
    '    meta::external::format::json::executionPlan::test::simple::S_Trade1,\n' +
    '    meta::external::format::json::executionPlan::test::simple::S_Trade2,\n' +
    '    meta::external::format::json::executionPlan::test::simple::S_Product,\n' +
    '    meta::external::format::json::executionPlan::test::simple::S_Synonym\n' +
    '  ];\n' +
    '}\n';

  compileLegendGrammar($schema)->filter(ele | $ele->instanceOf(Binding))->cast(@Binding)->toOne();
}


###Mapping
Mapping meta::external::format::json::executionPlan::test::simple::M2MMapping1
(
  meta::external::format::json::executionPlan::test::simple::TargetPerson: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::Person

    fullName : $src.firstName + ' ' + $src.lastName,
    firm : $src.firm,
    addresses : $src.addresses
  }

  meta::external::format::json::executionPlan::test::simple::Firm: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::Firm

    legalName : $src.legalName
  }

  meta::external::format::json::executionPlan::test::simple::Address: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::Address

    street : $src.street
  }
)

Mapping meta::external::format::json::executionPlan::test::simple::M2MMapping2
(
  meta::external::format::json::executionPlan::test::simple::RefinedPerson: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::TargetPerson

    fullName : $src.fullName + ' refined',
    firm : $src.firm,
    addresses : $src.addresses
  }

  meta::external::format::json::executionPlan::test::simple::Firm: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::Firm

    legalName : $src.legalName + ' refined'
  }

  meta::external::format::json::executionPlan::test::simple::Address: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::Address

    street : $src.street + ' refined'
  }
)

Mapping meta::external::format::json::executionPlan::test::simple::M2MMappingWithChild
(
  meta::external::format::json::executionPlan::test::simple::Target: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::Source
    targetProductId: $src.child.productId
  }
)

Mapping meta::external::format::json::executionPlan::test::simple::M2MCrossStoreMapping
(
  meta::external::format::json::executionPlan::test::simple::Trade[trade_set]: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::S_Trade
    tradeId: $src.s_tradeId,
    +prodId: String[1]: $src.s_tradeDetails->split(':')->at(0),
    quantity: $src.s_tradeDetails->split(':')->at(1)->parseInteger(),
    trader[trader_set]: $src
  }
  meta::external::format::json::executionPlan::test::simple::Trader[trader_set]: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::S_Trade
    kerberos: $src.s_traderDetails->split(':')->at(0),
    firstName: $src.s_traderDetails->split(':')->at(1),
    lastName: $src.s_traderDetails->split(':')->at(2)
  }
  meta::external::format::json::executionPlan::test::simple::Product[prod_set]: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::S_Product
    productId: $src.s_productId,
    productName: $src.s_productName,
    description: $src.s_description,
    synonyms[synonym_set]: $src.s_synonyms
  }
  meta::external::format::json::executionPlan::test::simple::Synonym[synonym_set]: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::S_Synonym
    name: $src.s_name,
    type: EnumerationMapping SynonymTypeMapping: $src.s_type
  }

  meta::external::format::json::executionPlan::test::simple::Trade_Product: XStore
  {
    product[trade_set, prod_set]: $this.prodId == $that.productId,
    trades[prod_set, trade_set]: $this.productId == $that.prodId
  }

  meta::external::format::json::executionPlan::test::simple::SynonymType: EnumerationMapping SynonymTypeMapping
  {
    CUSIP: ['cusip', 'CUSIP'],
    ISIN: ['isin', 'ISIN']
  }
)

Mapping meta::external::format::json::executionPlan::test::simple::M2MUnionMapping
(
  meta::external::format::json::executionPlan::test::simple::Trade[trade_set1]: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::S_Trade1
    tradeId: $src.s_tradeId,
    quantity: $src.s_tradeDetails->split(':')->at(1)->parseInteger(),
    trader[trader_set1]: $src
  }
  *meta::external::format::json::executionPlan::test::simple::Trader[trader_set1]: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::S_Trade1
    kerberos: $src.s_traderDetails->split(':')->at(0),
    firstName: $src.s_traderDetails->split(':')->at(1),
    lastName: $src.s_traderDetails->split(':')->at(2)
  }

  meta::external::format::json::executionPlan::test::simple::Trade[trade_set2]: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::S_Trade2
    tradeId: $src.s_tradeId,
    quantity: $src.s_tradeDetails->split(':')->at(1)->parseInteger(),
    trader[trader_set2]: $src
  }
  meta::external::format::json::executionPlan::test::simple::Trader[trader_set2]: Pure
  {
    ~src meta::external::format::json::executionPlan::test::simple::S_Trade2
    kerberos: $src.s_traderDetails->split(':')->at(0),
    firstName: $src.s_traderDetails->split(':')->at(1),
    lastName: $src.s_traderDetails->split(':')->at(2)
  }

  *meta::external::format::json::executionPlan::test::simple::Trade: Operation
  {
    meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(trade_set1,trade_set2)
  }
)
