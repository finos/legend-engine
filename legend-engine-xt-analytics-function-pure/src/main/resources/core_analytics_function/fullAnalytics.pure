// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::executionPlan::*;
import meta::pure::runtime::*;
import meta::pure::lineage::scanRelations::*;
import meta::pure::mapping::modelToModel::*;
import meta::pure::lineage::scanProject::*;
import meta::pure::lineage::scanColumns::*;
import meta::pure::lineage::scanMapping::*;
import meta::analytics::function::flowClass::*;
import meta::pure::lineage::scanProperties::*;
import meta::analytics::function::flowDatabase::*;
import meta::pure::lineage::scanExecutes::*;
import meta::pure::lineage::scanProperties::propertyTree::*;
import meta::analytics::function::*;
import meta::pure::mapping::*;
import meta::relational::metamodel::relation::*;
import meta::relational::mapping::*;
import meta::relational::metamodel::*;
import meta::analytics::function::graph::*;
import meta::analytics::function::flow::*;
import meta::relational::runtime::*;

Class meta::analytics::function::FunctionAnalytics
{
   databaseLineage : Graph[1];
   relationTree : RelationTree[1];
   classLineage : Graph[1];
   functionTrees : PropertyPathTree[*];
   reportLineage : ReportLineage[1];
}

Class meta::analytics::function::ReportLineage
{
   columns : ReportColumn[*];
}

Class meta::analytics::function::ReportColumn
{
   name : String[1];
   propertyTree : PropertyPathTree[1];
   columns : ColumnWithContext[*];
}

Class meta::analytics::function::PropertyLineage
{
   propertyTransforms : PropertyTransform[*];
}

Class meta::analytics::function::PropertyTransform
{
   targetProperty: PropertyElement[1];
   propertyTree : PropertyPathTree[1];
   srcProperties: PropertyElement[*];
   targetPropertyTransforms: PropertyTransform[*];
}

Class meta::analytics::function::PropertyLineageState
{
   processed:Map<String, PropertyLineage>[1];
}

Class meta::analytics::function::PropertyElement
{
   <<equality.Key>> class : String[1];
   <<equality.Key>> name : String[1];
   type : String[0..1];
}

function meta::analytics::function::computeLineage(f:FunctionDefinition<Any>[1], m:Mapping[1], r:Runtime[0..1], extensions:meta::pure::extension::Extension[*]):FunctionAnalytics[1]
{
   let mappings = if($r->isEmpty(), |$m, |$m->concatenate(getMappingsFromRuntime($r->toOne())));
   let modelToModelMappings = $mappings->init();
   let sourceMapping = $mappings->last()->toOne();
   let funcBody = $f.expressionSequence->at(0)->evaluateAndDeactivate();
   let updatedFuncBody = $funcBody->meta::pure::lineage::analytics::inlineQualifiedProperties(newMap([]->cast(@Pair<VariableExpression, ValueSpecification>), VariableExpression->classPropertyByName('name')->cast(@Property<VariableExpression,String|1>)), $f->openVariableValues(), $extensions);
   let propertyTrees = $updatedFuncBody->buildMultiLevelPropertyTrees($modelToModelMappings, $extensions);

   let reprocessedFuncBody = if($modelToModelMappings->isEmpty(),
                                |$updatedFuncBody,
                                |$updatedFuncBody->cast(@FunctionExpression)->meta::pure::mapping::modelToModel::chain::allReprocess([], $modelToModelMappings, $extensions, noDebug()).res);

   let vars = $f->functionType().parameters->evaluateAndDeactivate()->map(p| pair($p.name, ^List<PlanVarPlaceHolder>(values = ^PlanVarPlaceHolder(name=$p.name, type = $p.genericType.rawType->toOne(), multiplicity=$p.multiplicity))));
   let relationTree = if($f->functionReturnType().rawType->toOne()->_subTypeOf(TabularDataSet) && $r->isNotEmpty() && $modelToModelMappings->isEmpty(),
                            | scanRelations(^LambdaFunction<{->Any[*]}>(expressionSequence = $funcBody), $sourceMapping, $r->toOne(), $vars, noDebug(), $extensions),
                            | scanRelations($propertyTrees->last()->toOne(), $sourceMapping));

   ^FunctionAnalytics
   (
      databaseLineage = $f->toFlowDatabase($sourceMapping, $propertyTrees->last()->toOne(), $r)->toGraph(),
      classLineage = $f->toFlowClass($propertyTrees->at(0), $modelToModelMappings)->toGraph(),
      functionTrees = $propertyTrees,
      relationTree = $relationTree,
      reportLineage = buildReportLineage($reprocessedFuncBody, $sourceMapping)
   );
}

function meta::analytics::function::computeLineage(f:FunctionDefinition<Any>[1], m:Mapping[1], extensions:meta::pure::extension::Extension[*]):FunctionAnalytics[1]
{
   computeLineage($f, $m, [], $extensions);
}

function meta::analytics::function::buildReportLineage(e:Execute[1]):ReportLineage[1]
{
   let project = $e.funcEntryPoint->evaluateAndDeactivate();
   let mapping = $e.mappingEntryPoint->scanMapping()->at(0);
   buildReportLineage($e.funcEntryPoint, $mapping);
}

Class meta::analytics::function::ReportColumnsWithState
{
   columns: ReportColumn[*];
   classToSets: Map<Class<Any>, List<InstanceSetImplementation>>[1];
   idToSet: Map<String, List<SetImplementation>>[1];
}


function meta::analytics::function::buildReportLineage(funcBody:ValueSpecification[1], mapping:Mapping[1]):ReportLineage[1]
{
   let project = $funcBody->meta::pure::lineage::scanProject::scanProject();
   let groupedProject = $project.columns->groupBy(c| $c.first);

   let colPropertyTreePair = $groupedProject->keys()->map(gp|let propertiesPaths = $groupedProject->get($gp).values->map(c| $c.second.expressionSequence->at(0)->scanProperties(^List<PropertyPathNode>(), [], [], noDebug()))->removeDuplicates();
                                                pair($gp, $propertiesPaths.result->buildPropertyTree()););

   let result = $colPropertyTreePair->fold({p,state|
                                            let res= $p.second->scanColumns($mapping, $state.classToSets, $state.idToSet);
                                            ^ReportColumnsWithState(columns=$state.columns->concatenate(^ReportColumn(name = $p.first, propertyTree = $p.second, columns = $res.colRes.columns->removeDuplicates())),
                                                         idToSet = $res.idToSet->map(n|$n->keyValues())->newMap(),
                                                         classToSets = $res.classToSets->map(n|$n->keyValues())->newMap());},
                                            ^ReportColumnsWithState(idToSet=^Map<String, List<SetImplementation>>(), classToSets=^Map<Class<Any>, List<InstanceSetImplementation>>()));

   ^ReportLineage
   (
      columns = $result.columns
   );
}

function meta::analytics::function::flowDatabase::toFlowDatabase(f:ConcreteFunctionDefinition<Any>[1]):Flow[1]
{
   let executes = $f->scanExecutes();
   let propertyTree = $executes->buildPropertyTree();
   $f->toFlowDatabase($executes->map(e|$e.mappingEntryPoint->scanMapping()), $propertyTree);
}

function meta::analytics::function::flowDatabase::toFlowDatabase(f:FunctionDefinition<Any>[1], mappings:Mapping[*], propertyTree:PropertyPathTree[1]):Flow[1]
{
   meta::analytics::function::flowDatabase::toFlowDatabase($f, $mappings, $propertyTree, []);
}

function meta::analytics::function::flowDatabase::toFlowDatabase(f:FunctionDefinition<Any>[1], mappings:Mapping[*], propertyTree:PropertyPathTree[1], runtime:Runtime[0..1]):Flow[1]
{
   let databaseConnection = if($runtime->isNotEmpty(),
                          | let connections = $runtime->toOne().connections->filter(c | $c->instanceOf(DatabaseConnection));
                            if($connections->size() == 1,
                               | $connections->toOne()->cast(@DatabaseConnection),
                               | []);,
                          | []);

   $mappings->map(m|
         let tables = $propertyTree->toFlowDatabase($m, [], false, [])->cast(@NamedRelation);
         let dbs = $tables->map(r|$r->schema()).database->removeDuplicates();
         let maturityTests = maturityTests();
         ^Flow(
            functions = $f,
            databases = $dbs,
            tables = $tables->cast(@NamedRelation),
            links = $tables->map(t|let db = $t->map(r|$r->schema()).database->toOne();
                                   let tbNode = ^NamedRelationNode(relation=$t->cast(@NamedRelation));
                                   let fNode = ^FunctionNode(func=$f);
                                   let dbNode = ^DatabaseNode(db=$db);
                                   [
                                     ^FlowEdge(source=$tbNode, target=$fNode, lineageMaturity=maturity($tbNode, $fNode, $maturityTests)),
                                     ^FlowEdge(source=$dbNode, target=$tbNode, lineageMaturity=maturity($dbNode, $tbNode, $maturityTests))
                                   ];
                           )
         );
   )->merge();
}

function meta::analytics::function::flowDatabase::toFlowDatabase(p:PropertyPathTree[1], m:Mapping[1], sets:SetImplementation[*], disregardClass:Boolean[1], extraChildren:PropertyPathTree[*]):NamedRelation[*]
{
    $p.value->match([
                     pr:PropertyPathNode[1]|
                          let possiblePropertyTargetClasses = $p.children.value->map(vv|$vv->match([
                             v:PropertyPathNode[1]|$v.class,
                             o:Any[1]|[];
                          ]))->removeDuplicates();
                          let wsets = $sets->filter(s|$s->instanceOf(PropertyMappingsImplementation))->cast(@PropertyMappingsImplementation);
                          $pr.property->match([
                             sp:Property<Nil,Any|*>[1]|let propertyMappings = $wsets->map(s|$s.propertyMappingsByPropertyName($pr.property.name->toOne()););
                                                       let isDataTypeProperty = !$pr.property.genericType.rawType->isEmpty() && $pr.property.genericType.rawType->toOne()->instanceOf(DataType);
                                                       if ($isDataTypeProperty,
                                                         | $propertyMappings->cast(@RelationalPropertyMapping)->map(pm|$pm->meta::analytics::function::flowDatabase::getTables());,
                                                         | $propertyMappings->map(pm|processNonDataTypeProperty($p, $pm, $possiblePropertyTargetClasses, $m, $extraChildren))
                                                       );,
                             q:QualifiedProperty<Any>[1]|if($q->meta::pure::milestoning::hasGeneratedMilestoningPropertyStereotype(),
                                                            | let propertyMappings = $wsets->map(s|$s.propertyMappingsByPropertyName($pr.property.functionName->toOne()+'AllVersions'));
                                                              $propertyMappings->map(pm|processNonDataTypeProperty($p, $pm, $possiblePropertyTargetClasses, $m, $extraChildren));,
                                                            | $p.qualifierSubTree->toOne()->toFlowDatabase($m, $sets, true, $p.children));
                          ]);
                          ,
                     cl: Class<Any>[1]|if($disregardClass,
                                             |meta::analytics::function::flowDatabase::manageQualifiers($p.children, $extraChildren)->map(c|$c->toFlowDatabase($m, $sets, false, $extraChildren)),
                                             |meta::analytics::function::flowDatabase::manageQualifiers($p.children, $extraChildren)->map(c|$c->toFlowDatabase($m, $m.rootClassMappingByClass($cl)->last()->meta::pure::router::routing::resolveOperation($m), false, $extraChildren));
                                       );,
                     a :Any[1]|meta::analytics::function::flowDatabase::manageQualifiers($p.children, $extraChildren)->map(c|$c->toFlowDatabase($m, $sets, $disregardClass, $extraChildren))
                   ]);
}

function <<access.private>> meta::analytics::function::flowDatabase::processNonDataTypeProperty(p:PropertyPathTree[1], pm: PropertyMapping[1], possiblePropertyTargetClasses: Class<Any>[*], m:Mapping[1], extraChildren:PropertyPathTree[*]): NamedRelation[*]
{
   let targetSetImplementationId = $pm->match([
      i: InlineEmbeddedRelationalInstanceSetImplementation[1]|
         $m->meta::analytics::function::flowDatabase::allSubSetImplementationIds($i.inlineSetImplementationId)->removeDuplicates(),
      p:PropertyMapping[1]|
         let targetSiId = $p.targetSetImplementationId;
         let targetClass = $m.classMappingById($targetSiId).class;
         if ($targetClass->isNotEmpty() && $possiblePropertyTargetClasses->isNotEmpty() && !$possiblePropertyTargetClasses->exists(c|$targetClass->toOne()->_subTypeOf($c)),
            | [],
            | $targetSiId);
   ]);

   let potentialTablesFromJoin = $pm->match([
      r:RelationalPropertyMapping[1]|
         if($targetSetImplementationId->contains($r.targetSetImplementationId),
            | $r->meta::analytics::function::flowDatabase::getTables(),
            | []),
      a:Any[1]|[]
   ]);

   let tablesFromChildren = meta::analytics::function::flowDatabase::manageQualifiers($p.children, $extraChildren)
   ->map(c|$c->toFlowDatabase($m, $targetSetImplementationId->map(id|$m.classMappingById($id)), false, $extraChildren));

   $potentialTablesFromJoin->concatenate($tablesFromChildren);
}

function meta::analytics::function::flowClass::toFlowClass(f:FunctionDefinition<Any>[1], propertyTree:PropertyPathTree[1]):Flow[1]
{
   $f->toFlowClass($propertyTree, []);
}

function meta::analytics::function::flowClass::toFlowClass(f:FunctionDefinition<Any>[1], propertyTree:PropertyPathTree[1], mappings:Mapping[*]):Flow[1]
{
   let sourceLinks = $propertyTree->toFlowClassOne($f, maturityTests());
   let endPointClasses = $sourceLinks->map(l|[$l.source, $l.target])->filter(n|$n->instanceOf(ClassNode))->cast(@ClassNode).class->removeDuplicates();
   let mappingLinks = $endPointClasses->getClassLinksFromMappings($mappings);
   let links = $sourceLinks->concatenate($mappingLinks);
   let nodes = $links->map(l|[$l.source, $l.target]);

   ^Flow(
      functions = $f,
      packages = $nodes->filter(n|$n->instanceOf(PackageNode))->cast(@PackageNode).package->removeDuplicates(),
      classes = $nodes->filter(n|$n->instanceOf(ClassNode))->cast(@ClassNode).class->removeDuplicates(),
      links = $links->removeDuplicates()
   );
}

function meta::analytics::function::getExecutionTables::getExecutionTables(func:FunctionDefinition<Any>[1]):String[*]
{
   let executes = $func->scanExecutes();
   $executes->map( e |  let propertyTree = $e->buildPropertyTree();
                        let mappings = $e.mappingEntryPoint->toOne()->scanMapping();
                        $mappings->map(m| $propertyTree->toFlowDatabase($m, [], false, [])->map(nr|let table = $nr->match([t:Table[1]|$t, v:View[1]|$v.mainTable]); $table.schema.name+'.'+$table.name;));)->removeDuplicates();
}

function <<access.private>> meta::analytics::function::flowDatabase::getTables(r:RelationalPropertyMapping[1]):NamedRelation[*]
{
   $r.relationalOperationElement->meta::analytics::function::flowDatabase::getTables();
}

function <<access.private>> meta::analytics::function::flowDatabase::getTables(r:RelationalOperationElement[*]):NamedRelation[*]
{
   $r->meta::relational::functions::pureToSqlQuery::extractTableAliasColumns().alias.relationalElement->cast(@NamedRelation)->map(nr|$nr->match([
      v:View[1]|$v.mainTable
                  ->concatenate($v.filter.joinTreeNode.join.operation->meta::analytics::function::flowDatabase::getTables())
                  ->concatenate($v.filter.filter.operation->meta::analytics::function::flowDatabase::getTables())
                  ->concatenate($v.groupBy.columns->meta::analytics::function::flowDatabase::getTables())
                  ->concatenate($v.columnMappings.relationalOperationElement->meta::analytics::function::flowDatabase::getTables()),
      nr:NamedRelation[1]|$nr
   ]));
}

function meta::analytics::function::flowDatabase::allSubSetImplementationIds(m:Mapping[1], ids: String[*]):String[*]
{
   if($ids->isEmpty(), |[], |
   $ids->concatenate($m->meta::analytics::function::flowDatabase::allSubSetImplementationIds($m.classMappings()->filter(si|!$si.superSetImplementationId->isEmpty()&& $ids->contains($si.superSetImplementationId->toOne())).id)));
}

function <<access.private>> meta::analytics::function::flowDatabase::manageQualifiers(children:PropertyPathTree[*], extraChildren:PropertyPathTree[*]):PropertyPathTree[*]
{
   if ($children->isEmpty() ||
       ($children->size()==1 &&
        $children->at(0).value->instanceOf(PropertyPathNode) &&
        $children->at(0).value->cast(@PropertyPathNode).property.name == 'businessDate') , |$extraChildren->concatenate($children), |$children);
}

function <<access.private>> meta::analytics::function::flowClass::toFlowClassOne(p:PropertyPathTree[1], f:FunctionDefinition<Any>[1], maturityTests:Pair<Function<{FlowNode[1],FlowNode[1]->Boolean[1]}>,LineageMaturity>[*]) : FlowEdge[*]
{
   $p.value->match([
                     p:PropertyPathNode[1]|
                        let propertyNode = ^PropertyNode(property=$p.property);
                        let classNode = ^ClassNode(class=$p.class);
                        let functionNode = ^FunctionNode(func=$f);
                        let packageNode = ^PackageNode(package=$p.class.package->toOne());
                        [
                           ^FlowEdge(source=$classNode, target=$functionNode, lineageMaturity=maturity($classNode, $functionNode, $maturityTests)),
                           ^FlowEdge(source=$packageNode, target=$classNode, lineageMaturity=maturity($packageNode, $classNode, $maturityTests))
                        ];,
                     a :Any[1]|[]
                   ])->concatenate($p.children->map(c|$c->toFlowClassOne($f, $maturityTests)));
}

function <<access.private>> meta::analytics::function::flowClass::getClassLinksFromMapping(endPointClasses: Class<Any>[*], mapping:Mapping[1], maturityTests:Pair<Function<{FlowNode[1],FlowNode[1]->Boolean[1]}>,LineageMaturity>[*]) : Pair<List<Class<Any>>, List<FlowEdge>>[1]
{
   $endPointClasses->fold({a,b | if($mapping.classMappingByClass($a)->isEmpty(),
                                    |^$b(first=^List<Class<Any>>(values=$b.first.values->concatenate($a)));,
                                    |let srcClasses = $mapping.classMappingByClass($a)->filter(si | $si->instanceOf(PureInstanceSetImplementation))->map(psi | $psi->cast(@PureInstanceSetImplementation).srcClass->cast(@Class<Any>))->removeDuplicates();
                                     let srcClassNodes = $srcClasses->map(sc |^ClassNode(class=$sc));
                                     let targetClassNode = ^ClassNode(class=$a);
                                     let srcClassPackageNodes = $srcClasses->map(sc | ^PackageNode(package=$sc.package->toOne()));
                                     let newEdges = $srcClassNodes->map(scn | ^FlowEdge(source=$scn, target=$targetClassNode, lineageMaturity=maturity($scn, $targetClassNode, $maturityTests)))
                                                                  ->concatenate($srcClassPackageNodes->zip($srcClassNodes)->map(sc | ^FlowEdge(source=$sc.first, target=$sc.second, lineageMaturity=maturity($sc.first, $sc.second, $maturityTests))));
                                     ^$b(first=^List<Class<Any>>(values=$b.first.values->concatenate($srcClasses)), second=^List<FlowEdge>(values=$b.second.values->concatenate($newEdges)));)},
                          ^Pair<List<Class<Any>>, List<FlowEdge>>(first=^List<Class<Any>>(values=[]), second=^List<FlowEdge>(values=[])))
}

function <<access.private>> meta::analytics::function::flowClass::getClassLinksFromMappings(endPointClasses: Class<Any>[*], mappings:Mapping[*]) : FlowEdge[*]
{
   if($mappings->isEmpty(),
      |[],
      |$mappings->fold({a,b | let res = getClassLinksFromMapping($b.first.values, $a, maturityTests());
                              ^$b(first = $res.first, second=^List<FlowEdge>(values=$b.second.values->concatenate($res.second.values)));}, ^Pair<List<Class<Any>>, List<FlowEdge>>(first=^List<Class<Any>>(values=$endPointClasses), second=^List<FlowEdge>(values=[]))).second.values;

   );
}

