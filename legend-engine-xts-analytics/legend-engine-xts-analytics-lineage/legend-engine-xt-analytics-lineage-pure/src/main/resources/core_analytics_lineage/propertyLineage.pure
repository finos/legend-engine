// Copyright 2025 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::extension::*;
import meta::external::store::model::*;
import meta::pure::lineage::scanProject::*;
import meta::pure::lineage::scanProperties::*;
import meta::analytics::lineage::property::relation::scanRelations::*;
import meta::relational::mapping::*;
import meta::pure::lineage::scanProperties::propertyTree::*;
import meta::pure::mapping::*;
import meta::relational::metamodel::*;
import meta::analytics::lineage::*;
import meta::relational::metamodel::relation::*;
import meta::pure::lineage::relation::scanRelations::*;
import meta::pure::extension::*;
import meta::pure::metamodel::relation::*;
import meta::analytics::lineage::property::*;
import meta::analytics::lineage::property::scanner::*;
  
Class meta::analytics::lineage::property::PropertyLineageReport
{
 propertyOwner:meta::analytics::lineage::property::PropertyLineageNode[*];
 ownerLink:meta::analytics::lineage::property::OwnerLink[*];
}

Class meta::analytics::lineage::property::PropertyLineageNode //nodes in the graph that dont have direct properies (E.g. a store)
{
   <<equality.Key>> id:String[1];
  name:String[1];

}


Class meta::analytics::lineage::property::StorePropertyLineageNode extends PropertyLineageNode //nodes that is a parent of  property owners e.g. Store holds a collection of tables
{
}


Class meta::analytics::lineage::property::PropertyOwnerNode  extends PropertyLineageNode 
{
  properties:meta::analytics::lineage::property::LineageProperty[*];
  
}
Class meta::analytics::lineage::property::RootQuery  extends PropertyOwnerNode 
{
}

Class meta::analytics::lineage::property::Query  extends PropertyOwnerNode 
{
}


Class meta::analytics::lineage::property::RelationalPropertyOwner  extends PropertyOwnerNode 
{
    relationType:String[1]; 
    relationName:String[1];
    schemaName:String[1];
    relationOwnerPath:String[1]; 
    relationOwnerName:String[1]; 

}



Class meta::analytics::lineage::property::MappedSetOwner extends PropertyOwnerNode
{
  setImplementationID:String[1];
}


Class meta::analytics::lineage::property::MappedClassOwner  extends PropertyOwnerNode 
{
    mapping:String[0..1];
    setImplementationID:String[0..1];
    _class:String[1];

}



Class meta::analytics::lineage::property::OwnerLink  
{
  <<equality.Key>> source:String[1];  //change these to references 
  <<equality.Key>> target:String[1];  

}


Enum meta::analytics::lineage::property::PropertyType
{
  RELATIONAL,
  RELATION,
  MODEL,
  MAPPING


}

Class meta::analytics::lineage::property::LineageProperty
{
   <<equality.Key>> name:String[1];
    dataType:String[1];
    sourceInfo:SourceInformation[0..1]; 
    scope:String[0..1];
    propertyType:meta::analytics::lineage::property::PropertyType[1];  //Relational/ Model/ Relation
  <<equality.Key>>  ownerID:String[1];
    sourceProperties:meta::analytics::lineage::property::LineageProperty[*];
    annotations:Annotation[*];
}

Class meta::analytics::lineage::property::LineageModelProperty extends  meta::analytics::lineage::property::LineageProperty
{
    propertyTree:PropertyPathTree[1];

}


Class meta::analytics::lineage::property::PropertyLink   
{
  source:meta::analytics::lineage::property::LineageProperty[1];
  target:meta::analytics::lineage::property::LineageProperty[1];  
}


Class meta::analytics::lineage::property::scanner::ScannerState
{
  //current owners for buildings links across levels of the tree
  currentOwner:PropertyOwnerNode[*]; 
  lineageColumn: LineageProperty[*];
  vars:Map<String, List<Any>>[1] ;
  currentFunction : FunctionExpression[0..1];
  visitedFunctions: String[*];
  inReprocess:Boolean[1]=false;
  //global set for the final report
  propertyOwner:meta::analytics::lineage::property::PropertyLineageNode[*];
  propertyLink:  meta::analytics::lineage::property::PropertyLink[*];
  ownerLink:meta::analytics::lineage::property::OwnerLink[*];
  extensions:Extension[*];

  mapping:Mapping[0..1];
}




function meta::analytics::lineage::property::scanBuildPropertyLineage(vs: Any[1], state:ScannerState[1], extension:LineageExtension[*]):ScannerState[1]
{  
  let extended = $extension.buildPropertyReport->map(r|$r->eval($state,$extension));
  $vs->match($extended->concatenate(
              [
              f:FunctionDefinition<Any>[1]  | $f.expressionSequence->evaluateAndDeactivate()->fold({a,b|$a->scanBuildPropertyLineage($b,$extension)}, $state);,
              fe:FunctionExpression[1]      | let funcPath = $fe.func->elementToPath();
                                              let dispatch = [pair( 'meta::pure::functions::relation::join_Relation_1__Relation_1__JoinKind_1__Function_1__Relation_1_',
                                                                   {|

                                                                     let states = concatenate($fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension),
                                                                                              $fe.parametersValues->at(1)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension));
                                                                     ^$state(currentOwner=$states.currentOwner, ownerLink= $states.ownerLink->distinct(), propertyOwner= $states.propertyOwner->distinct(),  lineageColumn=$states.lineageColumn);
                                                                   }
                                                                    ),
                                                               pair( 'meta::pure::functions::relation::asOfJoin_Relation_1__Relation_1__Function_1__Function_1__Relation_1_',
                                                                   {|

                                                                     let states = concatenate($fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension),
                                                                                  $fe.parametersValues->at(1)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension));
                                                                     ^$state(currentOwner=$states.currentOwner, ownerLink= $states.ownerLink->distinct(), propertyOwner= $states.propertyOwner->distinct(),  lineageColumn=$states.lineageColumn);
                                                                   }
                                                                    ),
                                                         pair( 'meta::pure::functions::relation::asOfJoin_Relation_1__Relation_1__Function_1__Relation_1_',
                                                                   {|

                                                                     let states = concatenate($fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension),
                                                                                  $fe.parametersValues->at(1)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension));
                                                                     ^$state(currentOwner=$states.currentOwner, ownerLink= $states.ownerLink->distinct(), propertyOwner= $states.propertyOwner->distinct(),  lineageColumn=$states.lineageColumn);
                                                                   }
                                                                    ),

                                                          pair( 'meta::pure::functions::relation::concatenate_Relation_1__Relation_1__Relation_1_',
                                                                   {|

                                                                     let set1 =$fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                                     let set2 = $fe.parametersValues->at(1)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                                     let set2Columns= $set2.lineageColumn->groupBy(c|$c.name);
                                                                     let combined =   $set1.lineageColumn->map( s |   ^$s(sourceProperties+= $set2Columns->get($s.name).values->at(0).sourceProperties));

                                                                     ^$set1(propertyOwner+=$set2.propertyOwner->distinct(), ownerLink= $set2.ownerLink->distinct(),    currentOwner=$set1.currentOwner->concatenate($set2.currentOwner)->distinct() ,lineageColumn=$combined    );  //TODO::FIX THIS for current owner
                                                                   }
                                                                    ),

                                                             pair('meta::pure::functions::relation::rename_Relation_1__ColSpec_1__ColSpec_1__Relation_1_',
                                                                  {|let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                                    let oldName = $fe.parametersValues->at(1)->extractColSpecColumns($incomingState.vars)->toOne();
                                                                    let newName = $fe.parametersValues->at(2)->extractColSpecColumns($incomingState.vars)->toOne();
                                                                    let newColumns = $incomingState.lineageColumn->map( c|  if( $c.name==$oldName,| ^$c(name=$newName),|$c));
                                                                    ^$incomingState(lineageColumn = $newColumns);
                                                                  }
                                                             ),

                                                            pair('meta::pure::functions::relation::select_Relation_1__ColSpecArray_1__Relation_1_',
                                                                  {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension); // this should have the right columns and accessors
                                                                      let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                                     ^$incomingState(lineageColumn=$colSpec);
                                                                  }),
                                                         pair('meta::pure::functions::relation::select_Relation_1__ColSpec_1__Relation_1_',
                                                                  {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension); // this should have the right columns and accessors
                                                                     let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                                    ^$incomingState(lineageColumn=$colSpec);
                                                                  }),
                                                           pair('meta::pure::functions::relation::extend_Relation_1__FuncColSpec_1__Relation_1_',
                                                        {|
                                                        let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                        let cols = extractQueryColumnsAtParam($fe,1,$incomingState,$state);
                                                        ^$incomingState(lineageColumn+=$cols);
                                                        }
                                                      ),

                                                      pair('meta::pure::functions::relation::extend_Relation_1__FuncColSpecArray_1__Relation_1_',
                                                        {|
                                                        let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                        let cols = extractQueryColumnsAtParam($fe,1,$incomingState,$state);
                                                        ^$incomingState( lineageColumn+=$cols);
                                                        }),

                                                    pair('meta::pure::functions::relation::project_Relation_1__FuncColSpecArray_1__Relation_1_',
                                                         {|  let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let cols = extractQueryColumnsAtParam($fe,1,$incomingState,$state);
                                                           ^$incomingState( lineageColumn=$cols); 
                                                        }),
                                                    pair('meta::pure::functions::relation::project_Relation_1__FuncColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let cols = extractQueryColumnsAtParam($fe,1,$incomingState,$state);
                                                           ^$incomingState( lineageColumn=$cols);
                                                        }),
                                                    pair('meta::pure::functions::relation::groupBy_Relation_1__ColSpec_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                            let updatedColumns = $colSpec->concatenate($agColumns);
                                                           ^$incomingState(lineageColumn=$updatedColumns);
                                                        }),
                                                pair('meta::pure::functions::relation::groupBy_Relation_1__ColSpec_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                            let updatedColumns = $colSpec->concatenate($agColumns);
                                                           ^$incomingState(lineageColumn=$updatedColumns);
                                                        }),

                                                pair('meta::pure::functions::relation::groupBy_Relation_1__ColSpecArray_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                            let updatedColumns = $colSpec->concatenate($agColumns);
                                                           ^$incomingState(lineageColumn=$updatedColumns);
                                                        }),

                                                pair('meta::pure::functions::relation::groupBy_Relation_1__ColSpecArray_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                            let updatedColumns = $colSpec->concatenate($agColumns);
                                                           ^$incomingState(lineageColumn=$updatedColumns);
                                                        })   ,
                                               pair('meta::pure::functions::relation::extend_Relation_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(1,$incomingState,$state);
                                                           ^$incomingState(lineageColumn+=$agColumns);
                                                        }),
                                                pair('meta::pure::functions::relation::extend_Relation_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(1,$incomingState,$state);
                                                           ^$incomingState(lineageColumn+=$agColumns);
                                                        }),
                                                pair('meta::pure::functions::relation::extend_Relation_1___Window_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                           ^$incomingState(lineageColumn+=$agColumns);
                                                        }),
                                                 pair('meta::pure::functions::relation::extend_Relation_1___Window_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                           ^$incomingState( lineageColumn+=$agColumns);
                                                        })    ,

                                                pair('meta::pure::functions::relation::pivot_Relation_1__ColSpecArray_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                           pivotLineageColumns($fe,$incomingState);
                                                        }),

                                              pair('meta::pure::functions::relation::pivot_Relation_1__ColSpecArray_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                           pivotLineageColumns($fe,$incomingState);
                                                        }) ,
                                              pair('meta::pure::functions::relation::pivot_Relation_1__ColSpec_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                           pivotLineageColumns($fe,$incomingState);
                                                        })  ,
                                               pair('meta::pure::functions::relation::pivot_Relation_1__ColSpec_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                           pivotLineageColumns($fe,$incomingState);
                                                        }),
                                                pair('meta::pure::tds::project_T_MANY__ColumnSpecification_MANY__TabularDataSet_1_',
                                                           |
                                                         let classPath = $fe.parametersValues->at(0).genericType.rawType->toOne()->elementToPath()->toOne();
                                                         let cols = $fe.parametersValues->at(1)->evaluateAndDeactivate();
                                                         let columns =  $cols->map(c|$c->meta::pure::lineage::scanProject::extractCol($state.vars));
                                                         print($columns);
                                                         let namedTransforms = $columns->map(c|^NamedTransform(name=$c.name,function=$c.func->cast(@FunctionDefinition<Any>)));
                                                          buildNamedTransforms($fe,$classPath,$namedTransforms,$state,$extension);
                                                      ), 
                                               pair('meta::pure::tds::project_K_MANY__Function_MANY__String_MANY__TabularDataSet_1_',
                                                           |
                                                            let classPath = $fe.parametersValues->at(0).genericType.rawType->toOne()->elementToPath()->toOne();
                                                            let funcs = $fe.parametersValues->at(1)->match([s:InstanceValue[1]|$s.values, a:Any[*]|[]]);
                                                            let names = $fe.parametersValues->at(2)->match([s:InstanceValue[1]|$s.values, a:Any[*]|[]]);
                                                            let cols = $funcs->zip($names);
                                                            print($cols);
                                                            let namedTransforms = $cols->map(c|^NamedTransform(name=$c.second->cast(@String),function=$c.first->cast(@FunctionDefinition<Any>)));
                                                             buildNamedTransforms($fe,$classPath,$namedTransforms,$state,$extension);
                                                           
                                                      ),       
                                                       
                                                pair('meta::pure::functions::relation::project_C_MANY__FuncColSpecArray_1__Relation_1_',
                                                         {|
                                                             let propfns = $fe.parametersValues->at(1)->meta::analytics::lineage::property::relation::scanRelations::extractTransforms($state.vars);
                                                             //print($propfns);
                                                             let classPath = $fe.parametersValues->at(0).genericType.rawType->toOne()->elementToPath()->toOne();
                                                             //print($fe.parametersValues.genericType.rawType);
                                                             buildNamedTransforms($fe,$classPath,$propfns,$state,$extension);

                                                        })
                                                           ]->newMap();
                                                   let fn = $dispatch->get($funcPath);
                                                   if($fn->isNotEmpty(),
                                                         |$fn->toOne()->eval();,
                                                         | if($fe.parametersValues->evaluateAndDeactivate()->size()>0 && $funcPath->startsWith('meta::') , 
                                                                   |$fe.parametersValues->evaluateAndDeactivate()->at(0)->scanBuildPropertyLineage($state,$extension);
                                                                   ,| if(!$funcPath->in($state.visitedFunctions),
                                                                            |$fe.func->scanBuildPropertyLineage(^$state(visitedFunctions+=$funcPath),$extension),     
                                                                            |$state)
                                                                   );
                                                        );,  
              i:InstanceValue[1]              |     if($i.values->size()>1,
                                                                  |  $i.values->evaluateAndDeactivate()->fold({a,b|$a->scanBuildPropertyLineage($b,$extension)}, $state);, 
                                                                  |  $i.values->evaluateAndDeactivate()->at(0)->scanBuildPropertyLineage($state,$extension)
                                                                       ),
              r:RelationElementAccessor<Any>[1] | $r->meta::analytics::lineage::property::buildAccessorPropertyNode($state, $extension);,
              s:meta::external::query::sql::expression::SQLExpression<Any>[1] |  $s.pureFunction->scanBuildPropertyLineage($state,$extension),
              a:Any[*]                                 |  $state;
            ])->toOneMany())->toOne();
}



function meta::analytics::lineage::property::buildNamedTransforms(fe:FunctionExpression[1],classPath: String[1],transforms:NamedTransform[*], state:ScannerState[1],  extension:LineageExtension[*]): ScannerState[1]
{
    let mappingPath= if($state.mapping->isNotEmpty(),|$state.mapping->toOne()->elementToPath(),|[]);
    let name = $classPath+ if( $mappingPath->isNotEmpty(),|'.'+$mappingPath->toOne(),|'');
    let ownerNode = ^MappedClassOwner(name =$name, id= 'MappedClassOwner_' + $name,  _class=  $classPath, mapping=$mappingPath);
    //print($transforms.classifierGenericType.rawType);
    let props =  $transforms->map(transform|let propertiesPaths = $transform.function->cast(@FunctionDefinition<Any>).expressionSequence->at(0)->evaluateAndDeactivate()->scanProperties(^List<PropertyPathNode>(), [], [], noDebug())->removeDuplicates();
                                  let tree = $propertiesPaths.result->buildPropertyTree();   
                                  let trees =  $propertiesPaths.result->map(p|$p->buildPropertyTree());
                                  //print($trees.children.children);
                                  let modelProps = $trees->map( t | ^LineageModelProperty(propertyType=PropertyType.MODEL, dataType=$transform.function->cast(@FunctionDefinition<Any>)->functionReturnType().rawType.name->toOne(), name=$t->propertyTreetoName(), ownerID = $ownerNode.id, propertyTree=$t));
                                  //print($modelProps);
                                  pair($transform.name,list($modelProps));
                                  );
    //print($props.second); 
    //Gather included mappings (mapping includes) if present
    let includeMappings = if($state.mapping->isEmpty(), | [], | $state.mapping->toOne().includes.included);
    //print($includeMappings);
    
    let includedClassMap =
    if($includeMappings->isEmpty(),
       | [],
       |
       $includeMappings->map(inc |let incPath = $inc->elementToPath();
           meta::pure::mapping::classMappings($inc)->filter(cm | $cm.class->isNotEmpty())->map(cm | pair($cm.class->toOne()->elementToPath()->toOne(), $incPath));)->concatenate([]);
    );
    let rootIncPaths = $includedClassMap->filter(pc | $pc.first == $classPath)->map(pc | $pc.second);
    let rootMapping  = if($state.mapping->isEmpty(), | [], | [$state.mapping->toOne()] );
    let parentClassMap = if($rootMapping->isEmpty(),
    |[],
    |meta::pure::mapping::classMappings($rootMapping->toOne())->filter(cm | $cm.class->isNotEmpty())
                ->map(cm | pair($cm.class->toOne()->elementToPath()->toOne(), $rootMapping->toOne()->elementToPath()))
    );
    let mutatedPropsPairs =meta::analytics::lineage::property::buildMutatedPropsPairs($props, $includedClassMap, $parentClassMap, $classPath);
    let updatedNode = $ownerNode->mutateAdd('properties',$props.second.values);
    let updatedState = ^$state(currentFunction=$fe);
    let incomingState= $updatedNode->meta::analytics::lineage::property::scanMappedNode($updatedState,$extension);
    //Group properties per class referenced in the query
    //let includeState =
    //if($mutatedPropsPairs ->isEmpty(),
    //   | $incomingState,
    //   | meta::analytics::lineage::property::attachRelationalIncludeOwnerLinks($incomingState, $updatedNode, $mutatedPropsPairs , $extension)
    //);
    //print($incomingState);
    if($state.inReprocess,
    | $incomingState;,
    | let queryProps = $props->map( p |   let sourceCol = $incomingState.lineageColumn->filter(c|$c.name->in($p.second.values.name));
                                          let prop =  ^LineageProperty(ownerID='query',dataType=$sourceCol.dataType->at(0), propertyType=PropertyType.MODEL, name=$p.first, scope= 'IDENTITY',sourceProperties=$sourceCol);
                                          );

      let rootNode = ^meta::analytics::lineage::property::Query(name = $fe.func.name->toOne(), id='Query_'+$fe.func.name->toOne(),properties=$queryProps);  //TODO Add id# so we get unique ids for these
      let links =  $incomingState.currentOwner->map(o| ^OwnerLink(source=$o.id, target = $rootNode.id ));
      ^$incomingState(currentOwner=$rootNode,
                propertyOwner+= $rootNode, 
                ownerLink += $links,
                lineageColumn=$queryProps   ););
}

function meta::analytics::lineage::property::buildMutatedPropsPairs(props:Pair<String,List<LineageModelProperty>>[*],includedClassMap:Pair<String,String>[*],parentClassMap:Pair<String,String>[*],rootClassPath:String[1]):Pair<String,List<LineageModelProperty>>[*]
{
  //Filter classes used other than root class
  let referencedClasses =$props.second.values->cast(@LineageModelProperty)->map(mp |$mp.propertyTree->propertyTreeProperties()->map(pp | $pp.owner->elementToPath()))
  ->concatenate([])->removeDuplicates()->filter(c | $c != $rootClassPath);
  if($referencedClasses->isEmpty(),
     |[],
     |$props->map(propPair | let mutated=$propPair.second.values->cast(@LineageModelProperty)->map(mp | let treeClasses=$mp.propertyTree->propertyTreeProperties()
     ->map(pp | $pp.owner->elementToPath())->removeDuplicates();
            // Restrict to classes that are actually referenced elsewhere in the projection
            let matched = $treeClasses->filter(c | $c->in($referencedClasses));
            if($matched->isEmpty(),
            |[],
            | $matched->removeDuplicates()->map(chosenClass |
              // Resolve mapping path precedence: included mapping first, then parent
              let incMappingPath =$includedClassMap->filter(pc | $pc.first == $chosenClass)->map(pc | $pc.second);
              let parentMappingPath = $parentClassMap->filter(pc | $pc.first == $chosenClass)->map(pc | $pc.second);
              let mappingPath   = if($incMappingPath->isNotEmpty(), | $incMappingPath, | $parentMappingPath);
              // Skip if mapping cannot be resolved (no include or parent match)
              if($mappingPath->isEmpty(),| [],|
              let mappingSuffix = '.' + $mappingPath->at(0);
              let newOwnerName = $chosenClass + $mappingSuffix;
              let newOwnerId   = 'MappedClassOwner_' + $newOwnerName;
              // Create a LineageModelProperty pointing to the future per-class owner
              ^LineageModelProperty(
                      propertyType = $mp.propertyType,
                      dataType     = $mp.dataType,
                      name         = $mp.name,
                      ownerID      = $newOwnerId,
                      propertyTree = $mp.propertyTree
            );
          );
        );
      );
     )->concatenate([]);
     // Group and dedupe properties (same ownerID + name + propertyTree based filter)
     if($mutated->isEmpty(),
            | [],
            | [ pair($propPair.first, list($mutated->groupBy(p | pair($p.ownerID + '|' + $p.name + '|' + $p.propertyTree->propertyTreetoName(), $p))->keyValues()
            ->map(g | $g.second.values->at(0)))) ]
         );
       )->concatenate([]);
  );
}



function meta::analytics::lineage::property::propertyTreetoName(t:PropertyPathTree[1]):String[1]
{
   $t.value->match([c:Class<Any>[1]|$c.name->toOne(),
                            a:String[1]|'',
                            p:PropertyPathNode[1]|'.'+$p.property.name->toOne()+if($p.nestedQualifier->isEmpty(),|'',|'.'+$p.nestedQualifier->buildPropertyTree()->propertyTreetoName());
                          ])+
   $t.children->sort({a,b| if($a.value->instanceOf(PropertyPathNode) && $b.value->instanceOf(PropertyPathNode),
                             |let c = $a.value->cast(@PropertyPathNode);
                              let d = $b.value->cast(@PropertyPathNode);
                              let e = $c.class.name->toOne()+'.'+$c.property.name->toOne();
                              let f = $d.class.name->toOne()+'.'+$d.property.name->toOne();
                              $e->compare($f);,
                             |0
                          );
                     })
              ->map(c|$c->propertyTreetoName())->joinStrings('');
}


function meta::analytics::lineage::property::propertyTreeProperties(t:PropertyPathTree[1]):meta::pure::metamodel::function::property::AbstractProperty<meta::pure::metamodel::type::Any>[*]
{
   $t.value->match([ p:PropertyPathNode[1]|$p.property->concatenate(if($p.nestedQualifier->isEmpty(),|[],|$p.nestedQualifier->buildPropertyTree()->propertyTreeProperties()));,
                    a:Any[*]|[]
                          ])->concatenate( $t.children->map(c|$c->propertyTreeProperties()));
}

function  meta::analytics::lineage::property::lineagePropertyToString(p:LineageProperty[1], pretty:Boolean[1], Iindent:String[1], extensions:LineageExtension[*]):String[1]
{
    let indent = if($pretty && $Iindent =='',|'\n\t',|'');
    $p.ownerID+'.'+ $p.name 
      + if( $p.sourceProperties->isNotEmpty(),| '->'+$indent+ $p.sourceProperties->map(s|$s->lineagePropertyToString($pretty,$indent+'\t',$extensions))->joinStrings('[',','+$indent,']' ),|'');

}


function  meta::analytics::lineage::property::buildPropertyLineageReport(element:Any[1] ,ownerID:String[1], state:ScannerState[1], extensions:LineageExtension[*]):ScannerState[1]
{
  //print($state);
  $element->match([v:ValueSpecification[1] |$v->buildVSLineagePropertyNode($ownerID,$state,$extensions)

              ] );
}



function meta::pure::lineage::relation::scanRelations::accessorToLineageProperty(r :RelationElementAccessor<Any>[1], column:meta::pure::metamodel::relation::Column<Nil,Any|*>[1], extension:LineageExtension[*] ): LineageProperty[*]
{
    $r->match( $extension.accessorToLineageProperty->map(a|$a->eval($column,$extension))->concatenate(
              rea:RelationElementAccessor<Any>[*]| $rea.sourceElement->cast(@Table).columns->cast(@meta::relational::metamodel::Column)->filter(rac|$rac.name==$column.name)->map(c|$c->lineagePropertyColumn().second))->toOneMany());
                                                    //needs to work with Views
  } 

function  meta::analytics::lineage::property::buildAccessorPropertyNode(accessor:RelationElementAccessor<Any>[1], state:ScannerState[1], extensions:LineageExtension[*] ):ScannerState[1]
{
  

    let columns =  $accessor.classifierGenericType.typeArguments.rawType->cast(@RelationType<Any>).columns; 

    $accessor->match(  [r:meta::pure::store::RelationStoreAccessor<Any>[1] |  
                                                                              let lineageColumns  = $columns->map(c| accessorToLineageProperty($r,$c,$extensions));
                                                                              let store = $r.sourceElement->cast(@NamedRelation)->schema().database;
                                                                              let ownerNode = $r.sourceElement->cast(@NamedRelation)->namedRelationToOwner($lineageColumns);
                                                                              let storeNode = ^StorePropertyLineageNode(name=$store.name->toOne(), id= $store->elementToPath());
                                                                              let link = ^OwnerLink(source=$storeNode.id,target=$ownerNode.id);
                                                                                                                                                            
                                                                              ^$state(currentOwner= $ownerNode,
                                                                                       lineageColumn=$lineageColumns,
                                                                                      propertyOwner+=$ownerNode->concatenate($storeNode),
                                                                                      ownerLink+=$link);

                        ]            );
  

}

function  meta::analytics::lineage::property::scannerToPropertyReport(state:ScannerState[1]):PropertyLineageReport[1]
{

    ^PropertyLineageReport(propertyOwner=$state.propertyOwner,
                           ownerLink=$state.ownerLink);
}

function  meta::analytics::lineage::property::buildVSLineagePropertyNode(funcBody:ValueSpecification[1],ownerID:String[1], state:ScannerState[1],  extensions:LineageExtension[*]):ScannerState[1]
{
    //TODO  match on different FN types for different query flows
    let rootFunctionNode =  ^RootQuery(name=$ownerID,id=$ownerID);
    let updatedState = ^$state(currentOwner=$rootFunctionNode);
    let relationScan  = $funcBody->scanBuildPropertyLineage($updatedState,$extensions);
   let node = ^RootQuery(name= $ownerID, id=$ownerID,properties=$relationScan.lineageColumn);
   let ownerLink = $relationScan.currentOwner->map(o|  ^OwnerLink(source=$o.id,target=$node.id));

    let propertyLink =  $relationScan.lineageColumn->map( c | $c.sourceProperties->map( source |     ^PropertyLink(target=$c, source= $source )));
   ^PropertyLineageReport(propertyOwner=$node->concatenate($relationScan.propertyOwner),
                          ownerLink=$ownerLink->concatenate($relationScan.ownerLink));

  ^$state( propertyOwner+=$node->concatenate($relationScan.propertyOwner),
            propertyLink +=$propertyLink->concatenate($relationScan.propertyLink),
            ownerLink+=$ownerLink->concatenate($relationScan.ownerLink));

}
/*
function meta::analytics::lineage::property::attachRelationalIncludeOwnerLinks(state:meta::analytics::lineage::property::scanner::ScannerState[1], ownerNode: MappedClassOwner[1], props:Pair<String,List<LineageModelProperty>>[*],extensions:LineageExtension[*]):meta::analytics::lineage::property::scanner::ScannerState[1]
{
  let rootMapping = $state.mapping->toOne();
  let includes = $rootMapping.includes.included;
  // Build (classPath -> setImplementation) pairs for parent and included mappings
  let parentClassMappings = meta::pure::mapping::classMappings($rootMapping)->filter(cm | $cm.class->isNotEmpty())->map(cm | pair($cm.class->toOne()->elementToPath()->toOne(),$cm));
  let includedClassMappings =$includes->map(inc |let incPath = $inc->elementToPath();meta::pure::mapping::classMappings($inc)->filter(cm | $cm.class->isNotEmpty())
                                      ->map(cm | pair($cm.class->toOne()->elementToPath()->toOne(), $cm));)->concatenate([]);
  let includedClassPaths = $includedClassMappings.first->removeDuplicates();
  let parentPaths   = $parentClassMappings.first->removeDuplicates();
  let parentClassPaths = $parentPaths->filter(pp | !$includedClassPaths->contains($pp));
  // Gather all classes referenced in the property trees for the current owner (excluding the owner itself) 
  let referencedClassesRaw =$props.second.values->cast(@LineageModelProperty)->map(lp | $lp.propertyTree->propertyTreeProperties()->map(pp | $pp.owner->elementToPath()))->concatenate([])->removeDuplicates();
  let referencedClasses =$referencedClassesRaw->filter(c | $c != $ownerNode._class)->removeDuplicates();
  let chosenClassPathCandidates =$referencedClasses->filter(rc | $includedClassPaths->exists(p | $p == $rc) || $parentClassPaths->exists(icp | $icp == $rc));
  if($chosenClassPathCandidates->isEmpty(),
   |$state,
   |
    let existingMappedOwners= $state.propertyOwner->filter(o | $o->instanceOf(meta::analytics::lineage::property::MappedClassOwner))->cast( @meta::analytics::lineage::property::MappedClassOwner);
    // Build new MappedClassOwner nodes for candidate classes not already present
    let newOwner= $chosenClassPathCandidates->map(chosenClassPath | let chosenCM =$includedClassMappings->filter(p | $p.first == $chosenClassPath) // Resolve the chosen class's set implementation, prefer included mapping, else parent
                                            ->map(p | $p.second)->defaultIfEmpty($parentClassMappings->filter(p | $p.first == $chosenClassPath)->map(p | $p.second)->at(0));
    // Skip if an owner with same resolved setImplementation already exists
    let already = $existingMappedOwners->exists(o|$o.setImplementationID->isNotEmpty() && $o.setImplementationID->toOne() == $chosenCM.id);
    if($already,
       |[],
       |let incMappingPath =if($includes->filter(inc |meta::pure::mapping::classMappings($inc)->exists(cm | $cm.id == $chosenCM.id))->exists(x | true),
       |[$includes->toOne()->elementToPath()],|[]);
        let parentMappingPath = if($rootMapping->meta::pure::mapping::classMappings()->exists(cm | $cm.id == $chosenCM.id)->exists(x | true),
        | [$rootMapping->toOne()->elementToPath()], | []);
        let mappingPath = if($incMappingPath->isNotEmpty(), | $incMappingPath, | if($parentMappingPath->isNotEmpty(), | $parentMappingPath, |[]));
        let name = $chosenClassPath + if( $incMappingPath->isNotEmpty(),|'.'+$incMappingPath->toOne(),| '.' + $mappingPath->toOne());
        [ ^meta::analytics::lineage::property::MappedClassOwner(
                 id='MappedClassOwner_'+$name,
                 _class=$chosenClassPath,
                  name=$name,
                  mapping=$mappingPath
        )];);)->concatenate([])->removeDuplicates();
    // If no new owners were created, lineage state is unchanged
    if($newOwner->isEmpty(),
      |$state,
      |
       // Attach the correct subset of mutated properties to each new owner
       let ownersWithProps = $newOwner->map(no | let propsForOwner =  $props.second.values->cast(@LineageModelProperty)->filter(p | $p.ownerID == $no.id);
           $no->mutateAdd('properties', $propsForOwner););
       // Enrich each owner's properties via column scanning (relational lineage);
       let ownersEnriched = $ownersWithProps->map(updatedNode |
          let columnFold = $updatedNode.properties ->cast(@LineageModelProperty)
          ->fold(
             { p, colState |
              let scanRes = $p.propertyTree->meta::pure::lineage::scanColumns::scanColumns($rootMapping, $colState.classToSets, $colState.idToSet);
              let cols    = $scanRes.colRes.columns;
              if($cols->isEmpty(),
               | ^$colState(),  // no enrichment; keep state as-is
               |
                // Build enriched lineage model property with upstream column sources
                let sourceProps = $cols->map(c | $c.column->lineagePropertyColumn());
                let enrichedProp = ^$p(ownerID = $updatedNode.id, sourceProperties = $sourceProps.second);
                ^$colState(
                   owners       += $sourceProps.first,
                   properties   += $enrichedProp,
                   link         += ^PropertyLink(target = $p, source = $enrichedProp),
                   idToSet        = $scanRes.idToSet->map(n | $n->keyValues())->newMap(),
                   classToSets    = $scanRes.classToSets->map(n | $n->keyValues())->newMap()
                 ););},
              ^LineagePropertyColumnScanner(idToSet     = ^Map<String, List<SetImplementation>>(),classToSets = ^Map<Class<Any>, List<InstanceSetImplementation>>()));
      // Resolve to relational or pure set;
      let set =$rootMapping->meta::pure::mapping::rootClassMappingByClass($updatedNode._class->pathToElement()->cast(@Class<Any>))->last()->meta::pure::router::routing::resolveOperation($rootMapping);
      let mappedNode =$set->match([
          r:RootRelationalInstanceSetImplementation[1] |
          ^$updatedNode(name              = $r.parent->toOne()->elementToPath(),
                        id                = 'MappedClassOwner_' + $r.id,
                        setImplementationID = $r.id,
                        properties        = $columnFold.properties),
          p:PureInstanceSetImplementation[1] | $updatedNode,
          a:Any[*] | $updatedNode]);
      pair($mappedNode, $columnFold);
    );
    // Reuse relational owners by finding only tables touched by included class mappings as rootclass containes all the referenced prop details
    let includeOwnerTablesKeys = $ownersEnriched.first.mapping->toOne()->pathToElement()->cast(@Mapping)->map(inc | meta::pure::mapping::classMappings($inc)
    ->filter(cm | $cm->instanceOf(RootRelationalInstanceSetImplementation))->cast(@RootRelationalInstanceSetImplementation)
       ->map(r | $r.propertyMappings->filter(pm | $pm->instanceOf(RelationalPropertyMapping))->cast(@RelationalPropertyMapping)
       ->map(rpm | $rpm.relationalOperationElement->meta::analytics::lineage::flowDatabase::getTables())->concatenate([]);)->concatenate([]);
    )->concatenate([])->removeDuplicates();
    // Filter relational property owners to those actually referenced by included owners' tables
    let includeTableKeys = $includeOwnerTablesKeys->filter(t | $t->instanceOf(Table))->cast(@Table)->map(tbl | $tbl.schema.database->elementToPath()+ '.' + $tbl.schema.name+ '.' + $tbl.name)->removeDuplicates();
    let includeRelOwners = $ownersEnriched.second.owners->concatenate([])->filter(ro | $ro->instanceOf(RelationalPropertyOwner))->cast(@RelationalPropertyOwner)->filter(ro | $includeTableKeys->contains($ro.name))->distinct();
    let includePropertyLinks = $ownersEnriched.second.link->concatenate([])->distinct();
    // Determine which relational owners are new
    let existingRelOwnerIds = $state.propertyOwner->filter(o | $o->instanceOf(RelationalPropertyOwner))->cast(@RelationalPropertyOwner)->map(r | $r.id)->removeDuplicates();
    let newRelOwners = $includeRelOwners->filter(ro | !$existingRelOwnerIds->contains($ro.id));
    // Edges: relational owner -> each new mapped class owner
    let mappingToRelationalLink = $includeRelOwners->map(rel |$ownersEnriched.first->map(incOwner | ^OwnerLink(target = $incOwner.id, source = $rel.id)))->concatenate([])->distinct();
    // Parent-child edges: new included owners -> existing mapped owners for root mapping
    let includeEdges = $ownersEnriched.first->map(no | $existingMappedOwners->filter(o | $o.mapping->isNotEmpty() && $o.mapping->toOne() == $rootMapping->elementToPath()->toOne())->map(po | ^OwnerLink(source = $no.id, target = $po.id)))->concatenate([]);
    let incomingLinks = $state.ownerLink;
    let ownerIds      = $includeRelOwners.id->removeDuplicates();
    let includeLinks  = $state.ownerLink->filter(li | $ownerIds->contains($li.source));
    let mergedLinks = $incomingLinks->concatenate($mappingToRelationalLink)->concatenate($includeEdges)->distinct();
    // Merge owners (mapped class owners + any new relational owners), remove duplicates by id
    let mergedOwners =$ownersEnriched.first->concatenate($newRelOwners)->groupBy(n | pair($n.id, $n))->keyValues()->map(g | $g.second.values->at(0));
    ^$state(
      propertyOwner += $mergedOwners,
      ownerLink = $mergedLinks,
      propertyLink +=$includePropertyLinks,
      currentOwner = $state.currentOwner,
      lineageColumn = $state.lineageColumn
    );););
}

function meta::analytics::lineage::property::ownerForSet(sid: String[1],state: meta::analytics::lineage::property::scanner::ScannerState[1]): meta::analytics::lineage::property::MappedClassOwner[1]
{
  // reuse if already built in state
  let existing = $state.propertyOwner
    ->filter(o | $o->instanceOf(meta::analytics::lineage::property::MappedClassOwner))
    ->cast(@meta::analytics::lineage::property::MappedClassOwner)
    ->filter(mo | $mo.setImplementationID->isNotEmpty() && $mo.setImplementationID->toOne() == $sid);

  if($existing->isNotEmpty(),
    | $existing->toOne(),
    | let raw = $state.mapping->toOne()->classMappings()->filter(cm | $cm.id == $sid);
      let resolved = if($raw->isEmpty(), | [], | [$raw->toOne()->meta::pure::router::routing::resolveOperation($state.mapping->toOne())])->toOne();

      $resolved->match([
        rr: RootRelationalInstanceSetImplementation[1] |
          ^meta::analytics::lineage::property::MappedClassOwner(
            name = $rr.parent->elementToPath(),
            id   = 'MappedClassOwner_' + $rr.id,
            setImplementationID = $rr.id,
            _class = $rr.class->elementToPath(),
            mapping = [$rr.parent->elementToPath()]
          ),
        pi: PureInstanceSetImplementation[1] |
          ^meta::analytics::lineage::property::MappedClassOwner(
            name = $pi.parent->elementToPath(),
            id   = 'MappedClassOwner_' + $pi.id,
            setImplementationID = $pi.id,
            _class = $pi.class->elementToPath(),
            mapping = [$pi.parent->elementToPath()]
          ),
        a: Any[1] |
          ^meta::analytics::lineage::property::MappedClassOwner(
            name = 'MappedClassOwner_' + $sid,
            id   = 'MappedClassOwner_' + $sid,
            setImplementationID = $sid,
            _class = '',
            mapping = []
          )
      ]);
  );
}
*/

function  meta::analytics::lineage::property::scanMappedNode(m:MappedClassOwner[1],state:meta::analytics::lineage::property::scanner::ScannerState[1], extensions:LineageExtension[*]):ScannerState[1]
{  
   if($m.mapping->isEmpty(),
      |$state,
      |let mapping = $m.mapping->toOne()->pathToElement()->cast(@Mapping);
        let set =$state.mapping->toOne()->meta::pure::mapping::rootClassMappingByClass($m._class->pathToElement()->cast(@Class<Any>))->last()->meta::pure::router::routing::resolveOperation($mapping);
        //let sets =$state.mapping->toOne()->meta::pure::router::routing::resolveOperation($m.mapping->toOne()->pathToElement()->cast(@Mapping));
        //print($set);
        //print($sets.propertyMappings.targetSetImplementationId);
          //TODO: add extensions for other mapping types 
          //print($set);
      let mappedNode = $set->match( [r:RootRelationalInstanceSetImplementation[1]|  
                                                                                    let owner = ^$m(name=  $r.parent->elementToPath(),id ='MappedClassOwner_' + $r.id, setImplementationID=$r.id,mapping = $r.parent->elementToPath());
                                                                                    let props = $m.properties->cast(@LineageModelProperty)->fold({p,columnState|  let res= $p.propertyTree->meta::pure::lineage::scanColumns::scanColumns($state.mapping->toOne(), $columnState.classToSets, $columnState.idToSet);
                                                                                                            //print($res.colRes.columns);
                                                                                                            let sourceProps = $res.colRes.columns->map(c|$c.column->lineagePropertyColumn());
                                                                                                            //print($sourceProps);
                                                                                                            //print($state);
                                                                                                            //print($p);
                                                                                                            let Owners = $p.propertyTree->propertyTreeProperties()->map(pp | $pp.owner->elementToPath());
                                                                                                            let ClassPaths = if($Owners->isNotEmpty(), | $Owners->last(), | $m._class);
                                                                                                            let participatingSets = $res.colRes.sets->cast(@SetImplementation);
                                                                                                            let participatingSet = $set->cast(@SetImplementation);
                                                                                                            //print($participatingSet);
                                                                                                            let setOwnerIds =  $participatingSets->filter(si | $si.class->isNotEmpty() && $si.class->toOne()->elementToPath()->toOne() == $ClassPaths->toOne())->map(si |
                                                                                                                                let classPath   = $si.class->toOne()->elementToPath()->toOne();
                                                                                                                                let mappingPath = $si.parent->toOne()->elementToPath()->toOne();
                                                                                                                                'MappedClassOwner_' + $classPath + '.' + $mappingPath;
                                                                                                            );
                                                                                                            //print($setOwnerIds);
                                                                                                            let setOwnerI =  $set->filter(si | $si.class->isNotEmpty() && $si.class->toOne()->elementToPath()->toOne() == $ClassPaths->toOne())->map(si |
                                                                                                                                let classPath   = $si.class->toOne()->elementToPath()->toOne();
                                                                                                                                let mappingPath = $si.parent->toOne()->elementToPath()->toOne();
                                                                                                                                'MappedClassOwner_' + $classPath + '.' + $mappingPath;
                                                                                                            );
                                                                                                            //print($setOwnerI);
                                                                                                            let ownerIdsForSets = $participatingSets->map(si |
                                                                                                                  let classPath   = $si.class->toOne()->elementToPath()->toOne();
                                                                                                                  ^Pair<String, String>(first = 'MappedClassOwner_' + $si.id, second = $classPath);
                                                                                                            );
                                                                                                            //print($ownerIdsForSets);
                                                                                                            let ownerIdToSetIdPairs = $participatingSets->map(si |
                                                                                                               ^Pair<String, String>(first = 'MappedClassOwner_' + $si.id, second = $si.id);
                                                                                                            );
                                                                                                            //print($os);
                                                                                                            let ownerIdToMappingPathPairs = $participatingSets->map(si |
                                                                                                                let mappingPath = $si.parent->toOne()->elementToPath()->toOne();
                                                                                                                ^Pair<String, String>(first = 'MappedClassOwner_' + $si.id, second = $mappingPath);
                                                                                                            );
                                                                                                            let rootClass = ($ClassPaths == $m._class);
                                                                                                            //print($rootClass);
                                                                                                            let rootOwnerId =$p.ownerID;
                                                                                                            //print($rootOwnerId);
                                                                                                            let setOwnerId = if($rootClass || $setOwnerIds->isEmpty(),| $p,|^$p(ownerID  = $setOwnerIds->toOne()));
                                                                                                            //print($setOwnerId);
                                                                                                            //print($p.ownerID);
                                                                                                            let attachToRoot = ($p.ownerID == $setOwnerId.ownerID);
                                                                                                            //let proForRoot = if($attachToRoot,|  ^$p(ownerID = $owner.id, sourceProperties = $sourceProps.second) ,| []);
                                                                                                            //print($proForRoot);
                                                                                                            
                                                                                                            let propForRoot = if($attachToRoot,|  
                                                                                                               //$setOwnerId->filter(oid | $oid == $p.ownerID)
                                                                                                               ^$p(ownerID = $owner.id, sourceProperties = $sourceProps.second) ,| []);
                                                                                                            //print($propForRoot);
                                                                                                            let propForNonRoot = if($attachToRoot,
                                                                                                                 | [],
                                                                                                                 | $ownerIdsForSets->filter(oid | $oid.second == $ClassPaths->toOne())->map(oid | 
                                                                                                                  ^$p(ownerID = $oid.first, sourceProperties = $sourceProps.second));
                                                                                                            );
                                                                                                            //print($propForNonRoot);
                                                                                                            let linksForRootProps =if($rootClass && !$propForRoot->isEmpty(),| $propForRoot->map(rp | ^PropertyLink(target = $p, source = $rp)),| []);
                                                                                                            //print($linksForRootProps);
                                                                                                            let linksForNonRootProps =if(!$rootClass && !$propForNonRoot->isEmpty(),| $propForNonRoot->map(nrp | ^PropertyLink(target = $setOwnerId, source = $nrp)),| []);
                                                                                                            //print($linksForNonRootProps);
                                                                                                            ^$columnState(owners+=$sourceProps.first,
                                                                                                                          properties+=$propForRoot->concatenate($propForNonRoot),
                                                                                                                          link +=$linksForRootProps->concatenate($linksForNonRootProps)->distinct(),
                                                                                                                          idToSet = $res.idToSet->map(n|$n->keyValues())->newMap(),
                                                                                                                          classToSets = $res.classToSets->map(n|$n->keyValues())->newMap(),
                                                                                                                          ownerIdToSetId       = $columnState.ownerIdToSetId->concatenate($ownerIdToSetIdPairs),
                                                                                                                          ownerIdToMappingPath = $columnState.ownerIdToMappingPath->concatenate($ownerIdToMappingPathPairs)
                                                                                                              );
                                                                                                            },
                                                                                                        ^LineagePropertyColumnScanner(idToSet=^Map<String, List<SetImplementation>>(), classToSets=^Map<Class<Any>, List<InstanceSetImplementation>>(), ownerIdToSetId = [],ownerIdToMappingPath = []));
                                                                                  let ownerWithProps =  ^$owner(properties = $props.properties->removeDuplicates()->filter(lp | $lp.ownerID == $owner.id));
                                                                                  //print($ownerWithProps);
                                                                                  let ownerIdToSetIdIndex =$props.ownerIdToSetId->groupBy(p | $p.first)->keyValues()->map(e | ^Pair<String, String>(first = $e.first, second = $e.second.values->at(0).second))->newMap();
                                                                                  let nonRootGroups = $props.properties->filter(lp | $lp.ownerID != $owner.id)->groupBy(lp | $lp.ownerID)->keyValues();
                                                                                  let existingOwnersIndex = $state.propertyOwner->groupBy(o | $o.id)->keyValues()->map(e | ^Pair<String, Any>(first = $e.first, second = $e.second.values->at(0)));
                                                                                  let ownerIdToMappingIndex =$props.ownerIdToMappingPath->groupBy(p | $p.first)->keyValues()->map(e | ^Pair<String, String>(first = $e.first, second = $e.second.values->at(0).second))->newMap();
                                                                                  let nonRootOwners = $nonRootGroups->map(g|
                                                                                      let ownerId  = $g.first;
                                                                                      let propsFor = $g.second.values;
                                                                                      let existing = $existingOwnersIndex->find(e | $e.first == $ownerId)->map(e | $e.second);
                                                                                      if($existing->isNotEmpty(),
                                                                                       | $existing->toOne()->mutateAdd('properties', $propsFor),
                                                                                       | let firstProp      = $propsFor->cast(@LineageModelProperty)->at(0);
                                                                                         let Owners     = $firstProp.propertyTree->propertyTreeProperties()->map(pp | $pp.owner->elementToPath());
                                                                                         let ClassPaths  = if($Owners->isNotEmpty(), | $Owners->last(), | $m._class);
                                                                                         let setId       = $ownerIdToSetIdIndex->get($ownerId)->map(v | $v)->toOne();
                                                                                         let mappingPath = $ownerIdToMappingIndex->get($ownerId)->map(v | $v)->toOne();
                                                                                         ^meta::analytics::lineage::property::MappedClassOwner(
                                                                                                     name                = $mappingPath->toOne(),
                                                                                                     id                  = 'MappedClassOwner_' + $setId,
                                                                                                     _class              = $ClassPaths->toOne(),
                                                                                                     setImplementationID = $setId,
                                                                                                     mapping = $mappingPath->toOne() 
                                                                                            )->mutateAdd('properties', $propsFor);
                                                                                      );
                                                                                   );
                                                                                  let relationalOwners = $props.owners->distinct();
                                                                                  let rootMapping = $m.mapping->toOne()->pathToElement()->cast(@Mapping);
                                                                                  let relSets = $rootMapping->classMappings()->filter(cm | $cm->instanceOf(RootRelationalInstanceSetImplementation))->cast(@RootRelationalInstanceSetImplementation);
                                                                                  let rootSet = $relSets->find(rs | $rs.id == $ownerWithProps.setImplementationID->toOne());
                                                                                  let childToRootLinks =$nonRootOwners->cast(@meta::analytics::lineage::property::MappedClassOwner)->map(no | ^OwnerLink(source = $no.id, target = $ownerWithProps.id));
                                                                                  let nonRootsToRelationalLink =  $nonRootOwners->cast(@meta::analytics::lineage::property::MappedClassOwner)->map(no |
                                                                                            let setForOwner = $relSets->filter(rs | $rs.id == $no.setImplementationID->toOne());
                                                                                            //print($setForOwner);
                                                                                            if($setForOwner->isEmpty(),| [],| let ownerTables = $no.properties->map(lp | let leafNodes = $lp->cast(@LineageModelProperty).propertyTree->propertyTreeProperties();
                                                                                                                              let leafPropName = if($leafNodes->isEmpty(),  | $lp.name, | $leafNodes->last().name;);
                                                                                               $setForOwner->toOne().propertyMappings->filter(pm | $pm->instanceOf(RelationalPropertyMapping))->cast(@RelationalPropertyMapping)->filter(rpm | $rpm.property.name == $leafPropName)
                                                                                                                          ->map(rpm | $rpm.relationalOperationElement->meta::analytics::lineage::flowDatabase::getTables())->concatenate([])->filter(t | $t->instanceOf(Table))
                                                                                                                           ->cast(@Table)->map(tbl | $tbl.schema.database->elementToPath() + '.' + $tbl.schema.name + '.' + $tbl.name)->removeDuplicates();
                                                                                            )->removeDuplicates();
                                                                                             $relationalOwners->filter(ro | $ro->instanceOf(RelationalPropertyOwner))->cast(@RelationalPropertyOwner)->filter(ro | $ownerTables->contains($ro.name))->map(rel | ^OwnerLink(target = $no.id, source = $rel.id));
                                                                                           );
                                                                                  )->removeDuplicates();
                                                                                  let storenodes = $relationalOwners->filter(o|$o->instanceOf(RelationalPropertyOwner))->cast(@RelationalPropertyOwner)->groupBy(n|pair($n.relationOwnerPath,$n.relationOwnerName));
                                                                                  let newNodeLink = $storenodes->keyValues()->map(s|let storeNode =   ^StorePropertyLineageNode(name=$s.first.second, id= $s.first.first);
                                                                                                                                    let links =  $s.second.values->map(v|  ^OwnerLink(source=$storeNode.id,target=$v.id));
                                                                                                                                    pair($storeNode,list($links));
                                                                                   
                                                                                  );
                                                                                  let rootToRelationalLink = $relationalOwners->map(rel| ^OwnerLink(target=$ownerWithProps.id, source=$rel.id) );
                                                                                  let mappingToRelationalLink = $rootToRelationalLink->concatenate($nonRootsToRelationalLink)->removeDuplicates();
                                                                                ^$state(currentOwner=$ownerWithProps,
                                                                                       propertyLink +=$props.link,
                                                                                      ownerLink += $mappingToRelationalLink->concatenate($newNodeLink.second.values)->concatenate($childToRootLinks),
                                                                                      propertyOwner += $ownerWithProps->concatenate($nonRootOwners)->cast(@PropertyLineageNode)->concatenate($relationalOwners)->concatenate($newNodeLink.first),
                                                                                      lineageColumn=$props.properties);,
                                                    p:PureInstanceSetImplementation[1] | let reProcess =   $state.currentFunction->evaluateAndDeactivate()->toOne()->meta::pure::mapping::modelToModel::chain::allReprocess([], $state.mapping, $state.extensions, true, noDebug()) ;
                                                                                         let id =  'MappedClassOwner_' +$p.id;
                                                                                         let owner = ^$m(name=  $p.parent->elementToPath(), id=$id, setImplementationID=$p.id);  
                                                                                         let  sourceNode =  $reProcess.res-> scanBuildPropertyLineage(^$state(inReprocess=true),$extensions); 
                                                                                         let sourceNodeProp = $sourceNode.lineageColumn->cast(@LineageModelProperty)->map(l|pair($l, list($l.propertyTree->propertyTreeProperties())));
                                                                                         let updatedprops = $m.properties->map(lc|  let modelProperties = $lc->cast(@LineageModelProperty).propertyTree->map(p|$p->propertyTreeProperties()); 
                                                                                                                                      let processedFns = $reProcess.propertyFunctions->filter(p|$p.first ->in($modelProperties));
                                                                                                                                      let sourceTrees =  $processedFns.second->evaluateAndDeactivate()->map(p|$p->scanProperties(^List<PropertyPathNode>(), [], [], noDebug())).result->buildPropertyTree()->map(p|$p->propertyTreeProperties());
                                                                                                                                      let upstreamProperties = $sourceNodeProp->filter( p|  $p.second.values->containsAll($sourceTrees));
                                                                                                                                      ^$lc(ownerID=$owner.id, sourceProperties = $upstreamProperties.first);); 

                                                                                          let updatedOwner =     ^$owner(properties=$updatedprops);                   
                                                                                          let ownerLink = [^OwnerLink(source=$sourceNode.currentOwner.id->toOne(),target=$updatedOwner.id)];      
                                                                                            ^$sourceNode( inReprocess=false,
                                                                                                          currentOwner= $updatedOwner,
                                                                                                          lineageColumn=$updatedprops,
                                                                                                          propertyOwner+=$updatedOwner,
                                                                                                          ownerLink+=$ownerLink);,                                                                                
                                                     a:Any[*]|         $state;                                                                
                                     ]););
}

/*
function  meta::analytics::lineage::property::scanMappedNode(m:MappedClassOwner[1],state:meta::analytics::lineage::property::scanner::ScannerState[1], extensions:LineageExtension[*]):ScannerState[1]

{  
   if($m.mapping->isEmpty(),
      |$state,
      |let mapping = $m.mapping->toOne()->pathToElement()->cast(@Mapping);
        let set =$state.mapping->toOne()->meta::pure::mapping::rootClassMappingByClass($m._class->pathToElement()->cast(@Class<Any>))->last()->meta::pure::router::routing::resolveOperation($mapping);
          //TODO: add extensions for other mapping types 
      let mappedNode = $set->match( [r:RootRelationalInstanceSetImplementation[1]|  
                                                                                    let owner = ^$m(name=  $r.parent->elementToPath(),id ='MappedClassOwner_' + $r.id, setImplementationID=$r.id); 
                                                                                   let props = $m.properties->cast(@LineageModelProperty)->fold({p,columnState|  let res= $p.propertyTree->meta::pure::lineage::scanColumns::scanColumns($state.mapping->toOne(), $columnState.classToSets, $columnState.idToSet);
                                                                                                            let sourceProps = $res.colRes.columns->map(c|$c.column->lineagePropertyColumn());
                                                                                                            let newProp = ^$p(ownerID=$owner.id,  sourceProperties = $sourceProps.second);
                                                                                                            ^$columnState(owners+=$sourceProps.first,
                                                                                                                          properties+=$newProp,
                                                                                                                          link +=^PropertyLink(target=$p,source=$newProp),
                                                                                                                          idToSet = $res.idToSet->map(n|$n->keyValues())->newMap(),
                                                                                                                          classToSets = $res.classToSets->map(n|$n->keyValues())->newMap());
                                                                                                                                              },
                                                                                                        ^LineagePropertyColumnScanner(idToSet=^Map<String, List<SetImplementation>>(), classToSets=^Map<Class<Any>, List<InstanceSetImplementation>>()));
                                                                                  let ownerWithProps =  $owner->mutateAdd('properties',$props.properties);


                                                                                   let relationalOwners = $props.owners->distinct();
                                                                                   let storenodes = $relationalOwners->filter(o|$o->instanceOf(RelationalPropertyOwner))->cast(@RelationalPropertyOwner)->groupBy(n|pair($n.relationOwnerPath,$n.relationOwnerName));
                                                                                   let newNodeLink = $storenodes->keyValues()->map(s|let storeNode =   ^StorePropertyLineageNode(name=$s.first.second, id= $s.first.first);
                                                                                                                                    let links =  $s.second.values->map(v|  ^OwnerLink(source=$storeNode.id,target=$v.id));
                                                                                                                                    pair($storeNode,list($links));
                                                                                   
                                                                                   );
                                                                                   
                                                                                  let mappingToRelationalLink = $relationalOwners->map(rel| ^OwnerLink(target=$ownerWithProps.id, source=$rel.id)  );    
                                                                                ^$state(currentOwner=$ownerWithProps,
                                                                                       propertyLink +=$props.link,
                                                                                      ownerLink += $mappingToRelationalLink->concatenate($newNodeLink.second.values),
                                                                                      propertyOwner += $ownerWithProps->concatenate($relationalOwners)->concatenate($newNodeLink.first),
                                                                                      lineageColumn=$props.properties);,
                                                    p:PureInstanceSetImplementation[1] | let reProcess =   $state.currentFunction->evaluateAndDeactivate()->toOne()->meta::pure::mapping::modelToModel::chain::allReprocess([], $state.mapping, $state.extensions, true, noDebug()) ;
                                                                                         let id =  'MappedClassOwner_' +$p.id;
                                                                                         let owner = ^$m(name=  $p.parent->elementToPath(), id=$id, setImplementationID=$p.id);  
                                                                                         let  sourceNode =  $reProcess.res-> scanBuildPropertyLineage(^$state(inReprocess=true),$extensions); 
                                                                                         let sourceNodeProp = $sourceNode.lineageColumn->cast(@LineageModelProperty)->map(l|pair($l, list($l.propertyTree->propertyTreeProperties())));
                                                                                         let updatedprops = $m.properties->map(lc|  let modelProperties = $lc->cast(@LineageModelProperty).propertyTree->map(p|$p->propertyTreeProperties()); 
                                                                                                                                      let processedFns = $reProcess.propertyFunctions->filter(p|$p.first ->in($modelProperties));
                                                                                                                                      let sourceTrees =  $processedFns.second->evaluateAndDeactivate()->map(p|$p->scanProperties(^List<PropertyPathNode>(), [], [], noDebug())).result->buildPropertyTree()->map(p|$p->propertyTreeProperties());
                                                                                                                                      let upstreamProperties = $sourceNodeProp->filter( p|  $p.second.values->containsAll($sourceTrees));
                                                                                                                                      ^$lc(ownerID=$owner.id, sourceProperties = $upstreamProperties.first);); 

                                                                                          let updatedOwner =     ^$owner(properties=$updatedprops);                   
                                                                                          let ownerLink = [^OwnerLink(source=$sourceNode.currentOwner.id->toOne(),target=$updatedOwner.id)];      
                                                                                            ^$sourceNode( inReprocess=false,
                                                                                                          currentOwner= $updatedOwner,
                                                                                                          lineageColumn=$updatedprops,
                                                                                                          propertyOwner+=$updatedOwner,
                                                                                                          ownerLink+=$ownerLink);,
                                                                                 
                                                     a:Any[*]|         $state;       
                                                           

                                     ]););


}

*/
function   meta::analytics::lineage::property::extractPropertyFuncion(v:Pair<Property<Nil,Any|*>, ValueSpecification>[1]):Any[*]
{
    if($v.second->instanceOf(SimpleFunctionExpression) && $v.second->cast(@SimpleFunctionExpression).func==eval_Function_1__T_n__V_m_,
          |let fn = $v.second->cast(@SimpleFunctionExpression);
          
           let sourcePorperty = $fn.parametersValues->at(0)->cast(@InstanceValue).values;
        let sourcePropertyTree = $v.second->scanProperties(^List<PropertyPathNode>(), [], [], noDebug()).result;//  _Firm.employees
            $fn.propertyName ; // the target name
           ,|[]);
}

function   meta::analytics::lineage::property::buildMultiLevelPropertyTrees(vs:ValueSpecification[1], mappings:Mapping[*], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):PropertyPathTree[*]
{
   let res = ^Pair<ValueSpecification, List<PropertyPathTree>>(first=$vs, second=^List<PropertyPathTree>(values=[$vs->scanProperties( $debug).result->buildPropertyTree()]));

   $mappings->fold({a, b| let reprocessedQuery = $b.first->cast(@FunctionExpression)->meta::pure::mapping::modelToModel::chain::allReprocess([], $a, $extensions, $debug).res;
                          let newPropertyTree = $reprocessedQuery->scanProperties($debug).result->buildPropertyTree();
                          ^$b(first = $reprocessedQuery,
                              second = ^List<PropertyPathTree>(values=$b.second.values->concatenate($newPropertyTree)));
                       },
                   $res).second.values;
}



function  meta::analytics::lineage::property::extractNamedProperties(n:NamedTransform[1],ownerID:String[1]):LineageModelProperty[*]
{

    
   let path =  $n.function->evaluateAndDeactivate().expressionSequence->at(0)->scanProperties(^List<PropertyPathNode>(), [], [], noDebug());
   ^LineageModelProperty(propertyType=PropertyType.MODEL, dataType=$n.function->functionReturnType().rawType.name->toOne(), name=$n.name, ownerID = $ownerID, propertyTree=$path.result->buildPropertyTree());


}


function  meta::analytics::lineage::property::getLeafSourceProperties(p:LineageProperty[1]):LineageProperty[*]
{
  if($p.sourceProperties->isEmpty(),
      |$p,
      |$p.sourceProperties->map(s|$s->getLeafSourceProperties())
  );

}

Class meta::analytics::lineage::property::LineagePropertyColumnScanner
{
   classToSets: Map<Class<Any>, List<InstanceSetImplementation>>[1];
   idToSet: Map<String, List<SetImplementation>>[1];
   properties:LineageProperty[*];
   link:PropertyLink[*];
   owners:PropertyOwnerNode[*];
   ownerIdToSetId: Pair<String, String>[*];
   ownerIdToMappingPath: Pair<String, String>[*];
}
    



###Pure
import meta::relational::metamodel::relation::*;
import meta::pure::lineage::graph::*;
import meta::analytics::lineage::property::*;
import meta::analytics::lineage::*;
import meta::analytics::lineage::property::scanner::*;

function <<access.private>> meta::analytics::lineage::property::findUltimateSource(link:OwnerLink[1], removeIds:String[*], allLinks:OwnerLink[*]):String[*]
{
  let sourceId = $link.source;
  if($removeIds->contains($sourceId),
    |let incomingLinks = $allLinks->filter(l|$l.target == $sourceId);
     if($incomingLinks->isEmpty(), 
       |[], 
       |$incomingLinks->map(l|$l->findUltimateSource($removeIds, $allLinks));
     );,
    |[$link.source]
  );
}

function  <<access.private>> meta::analytics::lineage::property::findUltimateTargets(link:OwnerLink[1], removeIds:String[*], allLinks:OwnerLink[*]):String[*]
{
  let targetId = $link.target;
  if($removeIds->contains($targetId),
    |let outgoingLinks = $allLinks->filter(l|$l.source == $targetId);
     if($outgoingLinks->isEmpty(), 
       |[], 
       |$outgoingLinks->map(l|$l->findUltimateTargets($removeIds, $allLinks));
     );,
    |[$link.target]
  );
}

function meta::analytics::lineage::property::toGraphFromPropertyLineage(state:ScannerState[1], function:FunctionDefinition<Any>[1], extension:LineageExtension[*]):Graph[1]
{
  let nodesToRemove = $state.propertyOwner->filter(o|
    $o->instanceOf(meta::analytics::lineage::property::Query) ||
    $o->instanceOf(meta::analytics::lineage::property::MappedClassOwner)
  );

  let removeIds = $nodesToRemove.id;
  let filteredLinksInit = $state.ownerLink->filter(l| $removeIds->contains($l.source) || $removeIds->contains($l.target));
  let bypassLinks = $filteredLinksInit->map(link |
    let sources = $link->findUltimateSource($removeIds, $state.ownerLink);
    let targets = $link->findUltimateTargets($removeIds, $state.ownerLink);
    $sources->map(src | $targets->map(tgt |  if($src!= $tgt,
                                                | ^OwnerLink(source=$src, target=$tgt),
                                              | [] 
                                              );
                                ));)->distinct();

  let filteredLinks = $state.ownerLink->filter(l|
    !$removeIds->contains($l.source) && !$removeIds->contains($l.target)
  );

  let allLinks = $filteredLinks->concatenate($bypassLinks)->cast(@OwnerLink);
  let filteredNodes = $state.propertyOwner->filter(o|!$removeIds->contains($o.id));

  let nodes = $filteredNodes->map(o|pair($o.id,$o->match($extension.propertyReportToGraphNode->map(a|$a->eval())->concatenate(
    [s:StorePropertyLineageNode[1] | ^NodeData(id=$s->toGraphID(), type=$s->type().name->toOne(), text=$s.name),
     r:RelationalPropertyOwner[1]| ^NodeData(id=$r->toGraphID(), type=$r->type().name->toOne(), text=$r.relationName);,
     r:RootQuery[1] | ^NodeData(id=$r->toGraphID(), text='LAMBDA', type=$r->type().name->toOne()),
     r:MappedSetOwner[1] | ^NodeData(id=$r.id, type=$r->type().name->toOne(), text=$r.id)
    ])->toOneMany())));

  let nodesById = $nodes->groupBy(c|$c.first);

  ^Graph(
    nodes = $nodes.second->map(n| ^meta::pure::lineage::graph::Node(data=$n)),
    edges = $allLinks->map(l|
      ^Edge(data=^EdgeData(
        id='x',
        text='txt',
        type='',
        source= ^meta::pure::lineage::graph::Node(data=$nodesById->get($l.source)->toOne().values->at(0).second),
        target= ^meta::pure::lineage::graph::Node(data=$nodesById->get($l.target)->toOne().values->at(0).second)
      ))
    )
  );
}

function <<access.private>> meta::analytics::lineage::property::toGraphID(p:PropertyLineageNode[1]):String[1]
{
  $p->match([  s:StorePropertyLineageNode[1] | 'db_'+$s.name->toOne(),
                r:RelationalPropertyOwner[1]| 
                                              'tb_'+$r.relationOwnerName->toOne()+$r.schemaName+$r.relationName;,
               r:RootQuery[1] |'Lambda',
              p:PropertyLineageNode[1] |$p.name
            
  ]);

}




