// Copyright 2025 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::extension::*;
import meta::external::store::model::*;
import meta::pure::lineage::scanProject::*;
import meta::pure::lineage::scanProperties::*;
import meta::analytics::lineage::property::relation::scanRelations::*;
import meta::relational::mapping::*;
import meta::pure::lineage::scanProperties::propertyTree::*;
import meta::pure::mapping::*;
import meta::relational::metamodel::*;
import meta::analytics::lineage::*;
import meta::relational::metamodel::relation::*;
import meta::pure::lineage::relation::scanRelations::*;
import meta::pure::extension::*;
import meta::pure::metamodel::relation::*;
import meta::analytics::lineage::property::*;
import meta::analytics::lineage::property::scanner::*;
  
Class meta::analytics::lineage::property::PropertyLineageReport
{
 propertyOwner:meta::analytics::lineage::property::PropertyLineageNode[*];
 ownerLink:meta::analytics::lineage::property::OwnerLink[*];
}

Class meta::analytics::lineage::property::PropertyLineageNode //nodes in the graph that dont have direct properies (E.g. a store)
{
   <<equality.Key>> id:String[1];
  name:String[1];

}


Class meta::analytics::lineage::property::StorePropertyLineageNode extends PropertyLineageNode //nodes that is a parent of  property owners e.g. Store holds a collection of tables
{
}


Class meta::analytics::lineage::property::PropertyOwnerNode  extends PropertyLineageNode 
{
  properties:meta::analytics::lineage::property::LineageProperty[*];
  
}
Class meta::analytics::lineage::property::RootQuery  extends PropertyOwnerNode 
{
}

Class meta::analytics::lineage::property::Query  extends PropertyOwnerNode 
{
}


Class meta::analytics::lineage::property::RelationalPropertyOwner  extends PropertyOwnerNode 
{
    relationType:String[1]; 
    relationName:String[1];
    schemaName:String[1];
    relationOwnerPath:String[1]; 
    relationOwnerName:String[1]; 

}



Class meta::analytics::lineage::property::MappedSetOwner extends PropertyOwnerNode
{
  setImplementationID:String[1];
}


Class meta::analytics::lineage::property::MappedClassOwner  extends PropertyOwnerNode 
{
    mapping:String[0..1];
    setImplementationID:String[0..1];
    _class:String[1];

}



Class meta::analytics::lineage::property::OwnerLink  
{
  <<equality.Key>> source:String[1];  //change these to references 
  <<equality.Key>> target:String[1];  

}


Enum meta::analytics::lineage::property::PropertyType
{
  RELATIONAL,
  RELATION,
  MODEL,
  MAPPING


}

Class meta::analytics::lineage::property::LineageProperty
{
   <<equality.Key>> name:String[1];
    dataType:String[1];
    sourceInfo:SourceInformation[0..1]; 
    scope:String[0..1];
    propertyType:meta::analytics::lineage::property::PropertyType[1];  //Relational/ Model/ Relation
  <<equality.Key>>  ownerID:String[1];
    sourceProperties:meta::analytics::lineage::property::LineageProperty[*];
    annotations:Annotation[*];
}

Class meta::analytics::lineage::property::LineageModelProperty extends  meta::analytics::lineage::property::LineageProperty
{
    propertyTree:PropertyPathTree[1];

}


Class meta::analytics::lineage::property::PropertyLink   
{
  source:meta::analytics::lineage::property::LineageProperty[1];
  target:meta::analytics::lineage::property::LineageProperty[1];  
}


Class meta::analytics::lineage::property::scanner::ScannerState
{
  //current owners for buildings links across levels of the tree
  currentOwner:PropertyOwnerNode[*]; 
  lineageColumn: LineageProperty[*];
  vars:Map<String, List<Any>>[1] ;
  currentFunction : FunctionExpression[0..1];
  visitedFunctions: String[*];
  inReprocess:Boolean[1]=false;
  //global set for the final report
  propertyOwner:meta::analytics::lineage::property::PropertyLineageNode[*];
  propertyLink:  meta::analytics::lineage::property::PropertyLink[*];
  ownerLink:meta::analytics::lineage::property::OwnerLink[*];
  extensions:Extension[*];

  mapping:Mapping[0..1];
}




function meta::analytics::lineage::property::scanBuildPropertyLineage(vs: Any[1], state:ScannerState[1], extension:LineageExtension[*]):ScannerState[1]
{  
  let extended = $extension.buildPropertyReport->map(r|$r->eval($state,$extension));
  $vs->match($extended->concatenate(
              [
              f:FunctionDefinition<Any>[1]  | $f.expressionSequence->evaluateAndDeactivate()->fold({a,b|$a->scanBuildPropertyLineage($b,$extension)}, $state);,
              fe:FunctionExpression[1]      | let funcPath = $fe.func->elementToPath();
                                              let dispatch = [pair( 'meta::pure::functions::relation::join_Relation_1__Relation_1__JoinKind_1__Function_1__Relation_1_',
                                                                   {|

                                                                     let states = concatenate($fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension),
                                                                                              $fe.parametersValues->at(1)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension));
                                                                     ^$state(currentOwner=$states.currentOwner, ownerLink= $states.ownerLink->distinct(), propertyOwner= $states.propertyOwner->distinct(),  lineageColumn=$states.lineageColumn);
                                                                   }
                                                                    ),
                                                               pair( 'meta::pure::functions::relation::asOfJoin_Relation_1__Relation_1__Function_1__Function_1__Relation_1_',
                                                                   {|

                                                                     let states = concatenate($fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension),
                                                                                  $fe.parametersValues->at(1)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension));
                                                                     ^$state(currentOwner=$states.currentOwner, ownerLink= $states.ownerLink->distinct(), propertyOwner= $states.propertyOwner->distinct(),  lineageColumn=$states.lineageColumn);
                                                                   }
                                                                    ),
                                                         pair( 'meta::pure::functions::relation::asOfJoin_Relation_1__Relation_1__Function_1__Relation_1_',
                                                                   {|

                                                                     let states = concatenate($fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension),
                                                                                  $fe.parametersValues->at(1)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension));
                                                                     ^$state(currentOwner=$states.currentOwner, ownerLink= $states.ownerLink->distinct(), propertyOwner= $states.propertyOwner->distinct(),  lineageColumn=$states.lineageColumn);
                                                                   }
                                                                    ),

                                                          pair( 'meta::pure::functions::relation::concatenate_Relation_1__Relation_1__Relation_1_',
                                                                   {|

                                                                     let set1 =$fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                                     let set2 = $fe.parametersValues->at(1)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                                     let set2Columns= $set2.lineageColumn->groupBy(c|$c.name);
                                                                     let combined =   $set1.lineageColumn->map( s |   ^$s(sourceProperties+= $set2Columns->get($s.name).values->at(0).sourceProperties));

                                                                     ^$set1(propertyOwner+=$set2.propertyOwner->distinct(), ownerLink= $set2.ownerLink->distinct(),    currentOwner=$set1.currentOwner->concatenate($set2.currentOwner)->distinct() ,lineageColumn=$combined    );  //TODO::FIX THIS for current owner
                                                                   }
                                                                    ),

                                                             pair('meta::pure::functions::relation::rename_Relation_1__ColSpec_1__ColSpec_1__Relation_1_',
                                                                  {|let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                                    let oldName = $fe.parametersValues->at(1)->extractColSpecColumns($incomingState.vars)->toOne();
                                                                    let newName = $fe.parametersValues->at(2)->extractColSpecColumns($incomingState.vars)->toOne();
                                                                    let newColumns = $incomingState.lineageColumn->map( c|  if( $c.name==$oldName,| ^$c(name=$newName),|$c));
                                                                    ^$incomingState(lineageColumn = $newColumns);
                                                                  }
                                                             ),

                                                            pair('meta::pure::functions::relation::select_Relation_1__ColSpecArray_1__Relation_1_',
                                                                  {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension); // this should have the right columns and accessors
                                                                      let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                                     ^$incomingState(lineageColumn=$colSpec);
                                                                  }),
                                                         pair('meta::pure::functions::relation::select_Relation_1__ColSpec_1__Relation_1_',
                                                                  {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension); // this should have the right columns and accessors
                                                                     let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                                    ^$incomingState(lineageColumn=$colSpec);
                                                                  }),
                                                           pair('meta::pure::functions::relation::extend_Relation_1__FuncColSpec_1__Relation_1_',
                                                        {|
                                                        let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                        let cols = extractQueryColumnsAtParam($fe,1,$incomingState,$state);
                                                        ^$incomingState(lineageColumn+=$cols);
                                                        }
                                                      ),

                                                      pair('meta::pure::functions::relation::extend_Relation_1__FuncColSpecArray_1__Relation_1_',
                                                        {|
                                                        let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                        let cols = extractQueryColumnsAtParam($fe,1,$incomingState,$state);
                                                        ^$incomingState( lineageColumn+=$cols);
                                                        }),

                                                    pair('meta::pure::functions::relation::project_Relation_1__FuncColSpecArray_1__Relation_1_',
                                                         {|  let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let cols = extractQueryColumnsAtParam($fe,1,$incomingState,$state);
                                                           ^$incomingState( lineageColumn=$cols); 
                                                        }),
                                                    pair('meta::pure::functions::relation::project_Relation_1__FuncColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let cols = extractQueryColumnsAtParam($fe,1,$incomingState,$state);
                                                           ^$incomingState( lineageColumn=$cols);
                                                        }),
                                                    pair('meta::pure::functions::relation::groupBy_Relation_1__ColSpec_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                            let updatedColumns = $colSpec->concatenate($agColumns);
                                                           ^$incomingState(lineageColumn=$updatedColumns);
                                                        }),
                                                pair('meta::pure::functions::relation::groupBy_Relation_1__ColSpec_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                            let updatedColumns = $colSpec->concatenate($agColumns);
                                                           ^$incomingState(lineageColumn=$updatedColumns);
                                                        }),

                                                pair('meta::pure::functions::relation::groupBy_Relation_1__ColSpecArray_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                            let updatedColumns = $colSpec->concatenate($agColumns);
                                                           ^$incomingState(lineageColumn=$updatedColumns);
                                                        }),

                                                pair('meta::pure::functions::relation::groupBy_Relation_1__ColSpecArray_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let colSpec = $fe->colSpecQueryColumnsAtParameter(1,$incomingState);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                            let updatedColumns = $colSpec->concatenate($agColumns);
                                                           ^$incomingState(lineageColumn=$updatedColumns);
                                                        })   ,
                                               pair('meta::pure::functions::relation::extend_Relation_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(1,$incomingState,$state);
                                                           ^$incomingState(lineageColumn+=$agColumns);
                                                        }),
                                                pair('meta::pure::functions::relation::extend_Relation_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(1,$incomingState,$state);
                                                           ^$incomingState(lineageColumn+=$agColumns);
                                                        }),
                                                pair('meta::pure::functions::relation::extend_Relation_1___Window_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                           ^$incomingState(lineageColumn+=$agColumns);
                                                        }),
                                                 pair('meta::pure::functions::relation::extend_Relation_1___Window_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                            let agColumns = $fe->extractQueryColumnsAtParam(2,$incomingState,$state);
                                                           ^$incomingState( lineageColumn+=$agColumns);
                                                        })    ,

                                                pair('meta::pure::functions::relation::pivot_Relation_1__ColSpecArray_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                           pivotLineageColumns($fe,$incomingState);
                                                        }),

                                              pair('meta::pure::functions::relation::pivot_Relation_1__ColSpecArray_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                           pivotLineageColumns($fe,$incomingState);
                                                        }) ,
                                              pair('meta::pure::functions::relation::pivot_Relation_1__ColSpec_1__AggColSpecArray_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                           pivotLineageColumns($fe,$incomingState);
                                                        })  ,
                                               pair('meta::pure::functions::relation::pivot_Relation_1__ColSpec_1__AggColSpec_1__Relation_1_',
                                                         {| let incomingState = $fe.parametersValues->at(0)->evaluateAndDeactivate()->scanBuildPropertyLineage($state,$extension);
                                                           pivotLineageColumns($fe,$incomingState);
                                                        }),
                                                pair('meta::pure::tds::project_T_MANY__ColumnSpecification_MANY__TabularDataSet_1_',
                                                           |
                                                         let classPath = $fe.parametersValues->at(0).genericType.rawType->toOne()->elementToPath()->toOne();
                                                         let cols = $fe.parametersValues->at(1)->evaluateAndDeactivate();
                                                         let columns =  $cols->map(c|$c->meta::pure::lineage::scanProject::extractCol($state.vars));
                                                         let namedTransforms = $columns->map(c|^NamedTransform(name=$c.name,function=$c.func->cast(@FunctionDefinition<Any>)));
                                                          buildNamedTransforms($fe,$classPath,$namedTransforms,$state,$extension);
                                                      ), 
                                               pair('meta::pure::tds::project_K_MANY__Function_MANY__String_MANY__TabularDataSet_1_',
                                                           |
                                                            let classPath = $fe.parametersValues->at(0).genericType.rawType->toOne()->elementToPath()->toOne();
                                                            let funcs = $fe.parametersValues->at(1)->match([s:InstanceValue[1]|$s.values, a:Any[*]|[]]);
                                                            let names = $fe.parametersValues->at(2)->match([s:InstanceValue[1]|$s.values, a:Any[*]|[]]);
                                                            let cols = $funcs->zip($names);
                                                            let namedTransforms = $cols->map(c|^NamedTransform(name=$c.second->cast(@String),function=$c.first->cast(@FunctionDefinition<Any>)));
                                                             buildNamedTransforms($fe,$classPath,$namedTransforms,$state,$extension);
                                                           
                                                      ),       
                                                       
                                                pair('meta::pure::functions::relation::project_C_MANY__FuncColSpecArray_1__Relation_1_',
                                                         {|
                                                             let propfns = $fe.parametersValues->at(1)->meta::analytics::lineage::property::relation::scanRelations::extractTransforms($state.vars);
                                                             let classPath = $fe.parametersValues->at(0).genericType.rawType->toOne()->elementToPath()->toOne();
                                                             buildNamedTransforms($fe,$classPath,$propfns,$state,$extension);

                                                        })
                                                           ]->newMap();
                                                   let fn = $dispatch->get($funcPath);
                                                   if($fn->isNotEmpty(),
                                                         |$fn->toOne()->eval();,
                                                         | if($fe.parametersValues->evaluateAndDeactivate()->size()>0 && $funcPath->startsWith('meta::') , 
                                                                   |$fe.parametersValues->evaluateAndDeactivate()->at(0)->scanBuildPropertyLineage($state,$extension);
                                                                   ,| if(!$funcPath->in($state.visitedFunctions),
                                                                            |$fe.func->scanBuildPropertyLineage(^$state(visitedFunctions+=$funcPath),$extension),     
                                                                            |$state)
                                                                   );
                                                        );,  
              i:InstanceValue[1]              |     if($i.values->size()>1,
                                                                  |  $i.values->evaluateAndDeactivate()->fold({a,b|$a->scanBuildPropertyLineage($b,$extension)}, $state);, 
                                                                  |  $i.values->evaluateAndDeactivate()->at(0)->scanBuildPropertyLineage($state,$extension)
                                                                       ),
              r:RelationElementAccessor<Any>[1] | $r->meta::analytics::lineage::property::buildAccessorPropertyNode($state, $extension);,
              a:Any[*]                                 |  $state;
            ])->toOneMany())->toOne();
}



function meta::analytics::lineage::property::buildNamedTransforms(fe:FunctionExpression[1],classPath: String[1],transforms:NamedTransform[*], state:ScannerState[1],  extension:LineageExtension[*]): ScannerState[1]
{
    let mappingPath= if($state.mapping->isNotEmpty(),|$state.mapping->toOne()->elementToPath(),|[]);
    let name = $classPath+ if( $mappingPath->isNotEmpty(),|'.'+$mappingPath->toOne(),|'') ;
    let ownerNode = ^MappedClassOwner(name =$name, id= 'MappedClassOwner_' + $name,  _class=  $classPath, mapping=$mappingPath);
    let props =  $transforms->map(transform|let propertiesPaths = $transform.function->cast(@FunctionDefinition<Any>).expressionSequence->at(0)->evaluateAndDeactivate()->scanProperties(^List<PropertyPathNode>(), [], [], noDebug())->removeDuplicates();
                                  let tree = $propertiesPaths.result->buildPropertyTree();   
                                  let trees =  $propertiesPaths.result->map(p|$p->buildPropertyTree());
                                  let modelProps = $trees->map( t | ^LineageModelProperty(propertyType=PropertyType.MODEL, dataType=$transform.function->cast(@FunctionDefinition<Any>)->functionReturnType().rawType.name->toOne(), name=$t->propertyTreetoName(), ownerID = $ownerNode.id, propertyTree=$t));
                                  pair($transform.name,list($modelProps));
                                  ); 
                                  
    let updatedNode = $ownerNode->mutateAdd('properties',$props.second.values);
    let updatedState = ^$state(currentFunction=$fe);
    let incomingState= $updatedNode->meta::analytics::lineage::property::scanMappedNode($updatedState,$extension);


    if($state.inReprocess,
    | $incomingState;,
    | let queryProps = $props->map( p |   let sourceCol = $incomingState.lineageColumn->filter(c|$c.name->in($p.second.values.name));
                                          let prop =  ^LineageProperty(ownerID='query',dataType=$sourceCol.dataType->at(0), propertyType=PropertyType.MODEL, name=$p.first, scope= 'IDENTITY',sourceProperties=$sourceCol);
                                          );

      let rootNode = ^meta::analytics::lineage::property::Query(name = $fe.func.name->toOne(), id='Query_'+$fe.func.name->toOne(),properties=$queryProps);  //TODO Add id# so we get unique ids for these
      let links =  $incomingState.currentOwner->map(o| ^OwnerLink(source=$o.id, target = $rootNode.id ));
      ^$incomingState(currentOwner=$rootNode,
                propertyOwner+= $rootNode, 
                ownerLink += $links,
                lineageColumn=$queryProps   ););
}



function meta::analytics::lineage::property::propertyTreetoName(t:PropertyPathTree[1]):String[1]
{
   $t.value->match([c:Class<Any>[1]|$c.name->toOne(),
                            a:String[1]|'',
                            p:PropertyPathNode[1]|'.'+$p.property.name->toOne()+if($p.nestedQualifier->isEmpty(),|'',|'.'+$p.nestedQualifier->buildPropertyTree()->propertyTreetoName());
                          ])+
   $t.children->sort({a,b| if($a.value->instanceOf(PropertyPathNode) && $b.value->instanceOf(PropertyPathNode),
                             |let c = $a.value->cast(@PropertyPathNode);
                              let d = $b.value->cast(@PropertyPathNode);
                              let e = $c.class.name->toOne()+'.'+$c.property.name->toOne();
                              let f = $d.class.name->toOne()+'.'+$d.property.name->toOne();
                              $e->compare($f);,
                             |0
                          );
                     })
              ->map(c|$c->propertyTreetoName())->joinStrings('');
}


function meta::analytics::lineage::property::propertyTreeProperties(t:PropertyPathTree[1]):meta::pure::metamodel::function::property::AbstractProperty<meta::pure::metamodel::type::Any>[*]
{
   $t.value->match([ p:PropertyPathNode[1]|$p.property->concatenate(if($p.nestedQualifier->isEmpty(),|[],|$p.nestedQualifier->buildPropertyTree()->propertyTreeProperties()));,
                    a:Any[*]|[]
                          ])->concatenate( $t.children->map(c|$c->propertyTreeProperties()));
}

function  meta::analytics::lineage::property::lineagePropertyToString(p:LineageProperty[1], pretty:Boolean[1], Iindent:String[1], extensions:LineageExtension[*]):String[1]
{
    let indent = if($pretty && $Iindent =='',|'\n\t',|'');
    $p.ownerID+'.'+ $p.name 
      + if( $p.sourceProperties->isNotEmpty(),| '->'+$indent+ $p.sourceProperties->map(s|$s->lineagePropertyToString($pretty,$indent+'\t',$extensions))->joinStrings('[',','+$indent,']' ),|'');

}


function  meta::analytics::lineage::property::buildPropertyLineageReport(element:Any[1] ,ownerID:String[1], state:ScannerState[1], extensions:LineageExtension[*]):ScannerState[1]
{
  $element->match([v:ValueSpecification[1] |$v->buildVSLineagePropertyNode($ownerID,$state,$extensions)

              ] );


}



function meta::pure::lineage::relation::scanRelations::accessorToLineageProperty(r :RelationElementAccessor<Any>[1], column:meta::pure::metamodel::relation::Column<Nil,Any|*>[1], extension:LineageExtension[*] ): LineageProperty[*]
{
    $r->match( $extension.accessorToLineageProperty->map(a|$a->eval($column,$extension))->concatenate(
              rea:RelationElementAccessor<Any>[*]| $rea.sourceElement->cast(@Table).columns->cast(@meta::relational::metamodel::Column)->filter(rac|$rac.name==$column.name)->map(c|$c->lineagePropertyColumn().second))->toOneMany());
                                                    //needs to work with Views
  } 

function  meta::analytics::lineage::property::buildAccessorPropertyNode(accessor:RelationElementAccessor<Any>[1], state:ScannerState[1], extensions:LineageExtension[*] ):ScannerState[1]
{
  

    let columns =  $accessor.classifierGenericType.typeArguments.rawType->cast(@RelationType<Any>).columns; 

    $accessor->match(  [r:meta::pure::store::RelationStoreAccessor<Any>[1] |  
                                                                              let lineageColumns  = $columns->map(c| accessorToLineageProperty($r,$c,$extensions));
                                                                              let store = $r.sourceElement->cast(@NamedRelation)->schema().database;
                                                                              let ownerNode = $r.sourceElement->cast(@NamedRelation)->namedRelationToOwner($lineageColumns);
                                                                              let storeNode = ^StorePropertyLineageNode(name=$store.name->toOne(), id= $store->elementToPath());
                                                                              let link = ^OwnerLink(source=$storeNode.id,target=$ownerNode.id);
                                                                                                                                                            
                                                                              ^$state(currentOwner= $ownerNode,
                                                                                       lineageColumn=$lineageColumns,
                                                                                      propertyOwner+=$ownerNode->concatenate($storeNode),
                                                                                      ownerLink+=$link);

                        ]            );
  

}

function  meta::analytics::lineage::property::scannerToPropertyReport(state:ScannerState[1]):PropertyLineageReport[1]
{

    ^PropertyLineageReport(propertyOwner=$state.propertyOwner,
                           ownerLink=$state.ownerLink);
}

function  meta::analytics::lineage::property::buildVSLineagePropertyNode(funcBody:ValueSpecification[1],ownerID:String[1], state:ScannerState[1],  extensions:LineageExtension[*]):ScannerState[1]
{
    //TODO  match on different FN types for different query flows
    let rootFunctionNode =  ^RootQuery(name=$ownerID,id=$ownerID);
    let updatedState = ^$state(currentOwner=$rootFunctionNode);
    let relationScan  = $funcBody->scanBuildPropertyLineage($updatedState,$extensions);
   let node = ^RootQuery(name= $ownerID, id=$ownerID,properties=$relationScan.lineageColumn);
   let ownerLink = $relationScan.currentOwner->map(o|  ^OwnerLink(source=$o.id,target=$node.id));

    let propertyLink =  $relationScan.lineageColumn->map( c | $c.sourceProperties->map( source |     ^PropertyLink(target=$c, source= $source )));
   ^PropertyLineageReport(propertyOwner=$node->concatenate($relationScan.propertyOwner),
                          ownerLink=$ownerLink->concatenate($relationScan.ownerLink));

  ^$state( propertyOwner+=$node->concatenate($relationScan.propertyOwner),
            propertyLink +=$propertyLink->concatenate($relationScan.propertyLink),
            ownerLink+=$ownerLink->concatenate($relationScan.ownerLink));

}



function  meta::analytics::lineage::property::scanMappedNode(m:MappedClassOwner[1],state:meta::analytics::lineage::property::scanner::ScannerState[1], extensions:LineageExtension[*]):ScannerState[1]

{  
   if($m.mapping->isEmpty(),
      |$state,
      |let mapping = $m.mapping->toOne()->pathToElement()->cast(@Mapping);
        let set =$state.mapping->toOne()->meta::pure::mapping::rootClassMappingByClass($m._class->pathToElement()->cast(@Class<Any>))->last()->meta::pure::router::routing::resolveOperation($mapping);
          //TODO: add extensions for other mapping types 
      let mappedNode = $set->match( [r:RootRelationalInstanceSetImplementation[1]|  
                                                                                    let owner = ^$m(name=  $r.parent->elementToPath(),id ='MappedClassOwner_' + $r.id, setImplementationID=$r.id); 
                                                                                   let props = $m.properties->cast(@LineageModelProperty)->fold({p,columnState|  let res= $p.propertyTree->meta::pure::lineage::scanColumns::scanColumns($state.mapping->toOne(), $columnState.classToSets, $columnState.idToSet);
                                                                                                            let sourceProps = $res.colRes.columns->map(c|$c.column->lineagePropertyColumn());
                                                                                                            let newProp = ^$p(ownerID=$owner.id,  sourceProperties = $sourceProps.second);
                                                                                                            ^$columnState(owners+=$sourceProps.first,
                                                                                                                          properties+=$newProp,
                                                                                                                          link +=^PropertyLink(target=$p,source=$newProp),
                                                                                                                          idToSet = $res.idToSet->map(n|$n->keyValues())->newMap(),
                                                                                                                          classToSets = $res.classToSets->map(n|$n->keyValues())->newMap());
                                                                                                                                              },
                                                                                                        ^LineagePropertyColumnScanner(idToSet=^Map<String, List<SetImplementation>>(), classToSets=^Map<Class<Any>, List<InstanceSetImplementation>>()));
                                                                                  let ownerWithProps =  $owner->mutateAdd('properties',$props.properties);


                                                                                   let relationalOwners = $props.owners->distinct();
                                                                                   let storenodes = $relationalOwners->filter(o|$o->instanceOf(RelationalPropertyOwner))->cast(@RelationalPropertyOwner)->groupBy(n|pair($n.relationOwnerPath,$n.relationOwnerName));
                                                                                   let newNodeLink = $storenodes->keyValues()->map(s|let storeNode =   ^StorePropertyLineageNode(name=$s.first.second, id= $s.first.first);
                                                                                                                                    let links =  $s.second.values->map(v|  ^OwnerLink(source=$storeNode.id,target=$v.id));
                                                                                                                                    pair($storeNode,list($links));
                                                                                   
                                                                                   );
                                                                                   
                                                                                  let mappingToRelationalLink = $relationalOwners->map(rel| ^OwnerLink(target=$ownerWithProps.id, source=$rel.id)  );    
                                                                                ^$state(currentOwner=$ownerWithProps,
                                                                                       propertyLink +=$props.link,
                                                                                      ownerLink += $mappingToRelationalLink->concatenate($newNodeLink.second.values),
                                                                                      propertyOwner += $ownerWithProps->concatenate($relationalOwners)->concatenate($newNodeLink.first),
                                                                                      lineageColumn=$props.properties);,
                                                    p:PureInstanceSetImplementation[1] | let reProcess =   $state.currentFunction->evaluateAndDeactivate()->toOne()->meta::pure::mapping::modelToModel::chain::allReprocess([], $state.mapping, $state.extensions, true, noDebug()) ;
                                                                                         let id =  'MappedClassOwner_' +$p.id;
                                                                                         let owner = ^$m(name=  $p.parent->elementToPath(), id=$id, setImplementationID=$p.id);  
                                                                                         let  sourceNode =  $reProcess.res-> scanBuildPropertyLineage(^$state(inReprocess=true),$extensions); 
                                                                                         let sourceNodeProp = $sourceNode.lineageColumn->cast(@LineageModelProperty)->map(l|pair($l, list($l.propertyTree->propertyTreeProperties())));
                                                                                         let updatedprops = $m.properties->map(lc|  let modelProperties = $lc->cast(@LineageModelProperty).propertyTree->map(p|$p->propertyTreeProperties()); 
                                                                                                                                      let processedFns = $reProcess.propertyFunctions->filter(p|$p.first ->in($modelProperties));
                                                                                                                                      let sourceTrees =  $processedFns.second->evaluateAndDeactivate()->map(p|$p->scanProperties(^List<PropertyPathNode>(), [], [], noDebug())).result->buildPropertyTree()->map(p|$p->propertyTreeProperties());
                                                                                                                                      let upstreamProperties = $sourceNodeProp->filter( p|  $p.second.values->containsAll($sourceTrees));
                                                                                                                                      ^$lc(ownerID=$owner.id, sourceProperties = $upstreamProperties.first);); 

                                                                                          let updatedOwner =     ^$owner(properties=$updatedprops);                   
                                                                                          let ownerLink = [^OwnerLink(source=$sourceNode.currentOwner.id->toOne(),target=$updatedOwner.id)];      
                                                                                            ^$sourceNode( inReprocess=false,
                                                                                                          currentOwner= $updatedOwner,
                                                                                                          lineageColumn=$updatedprops,
                                                                                                          propertyOwner+=$updatedOwner,
                                                                                                          ownerLink+=$ownerLink);,
                                                                                 
                                                     a:Any[*]|         $state;       
                                                           

                                     ]););


}
function   meta::analytics::lineage::property::extractPropertyFuncion(v:Pair<Property<Nil,Any|*>, ValueSpecification>[1]):Any[*]
{
    if($v.second->instanceOf(SimpleFunctionExpression) && $v.second->cast(@SimpleFunctionExpression).func==eval_Function_1__T_n__V_m_,
          |let fn = $v.second->cast(@SimpleFunctionExpression);
          
           let sourcePorperty = $fn.parametersValues->at(0)->cast(@InstanceValue).values;
        let sourcePropertyTree = $v.second->scanProperties(^List<PropertyPathNode>(), [], [], noDebug()).result;//  _Firm.employees
            $fn.propertyName ; // the target name
           ,|[]);
}

function   meta::analytics::lineage::property::buildMultiLevelPropertyTrees(vs:ValueSpecification[1], mappings:Mapping[*], extensions:meta::pure::extension::Extension[*], debug:DebugContext[1]):PropertyPathTree[*]
{
   let res = ^Pair<ValueSpecification, List<PropertyPathTree>>(first=$vs, second=^List<PropertyPathTree>(values=[$vs->scanProperties( $debug).result->buildPropertyTree()]));

   $mappings->fold({a, b| let reprocessedQuery = $b.first->cast(@FunctionExpression)->meta::pure::mapping::modelToModel::chain::allReprocess([], $a, $extensions, $debug).res;
                          let newPropertyTree = $reprocessedQuery->scanProperties($debug).result->buildPropertyTree();
                          ^$b(first = $reprocessedQuery,
                              second = ^List<PropertyPathTree>(values=$b.second.values->concatenate($newPropertyTree)));
                       },
                   $res).second.values;
}



function  meta::analytics::lineage::property::extractNamedProperties(n:NamedTransform[1],ownerID:String[1]):LineageModelProperty[*]
{

    
   let path =  $n.function->evaluateAndDeactivate().expressionSequence->at(0)->scanProperties(^List<PropertyPathNode>(), [], [], noDebug());
   ^LineageModelProperty(propertyType=PropertyType.MODEL, dataType=$n.function->functionReturnType().rawType.name->toOne(), name=$n.name, ownerID = $ownerID, propertyTree=$path.result->buildPropertyTree());


}


function  meta::analytics::lineage::property::getLeafSourceProperties(p:LineageProperty[1]):LineageProperty[*]
{
  if($p.sourceProperties->isEmpty(),
      |$p,
      |$p.sourceProperties->map(s|$s->getLeafSourceProperties())
  );

}

Class meta::analytics::lineage::property::LineagePropertyColumnScanner
{
   classToSets: Map<Class<Any>, List<InstanceSetImplementation>>[1];
   idToSet: Map<String, List<SetImplementation>>[1];
   properties:LineageProperty[*];
   link:PropertyLink[*];
   owners:PropertyOwnerNode[*];
}
    



###Pure
import meta::relational::metamodel::relation::*;
import meta::pure::lineage::graph::*;
import meta::analytics::lineage::property::*;
import meta::analytics::lineage::*;
import meta::analytics::lineage::property::scanner::*;

function <<access.private>> meta::analytics::lineage::property::findUltimateSource(link:OwnerLink[1], removeIds:String[*], allLinks:OwnerLink[*]):String[*]
{
  let sourceId = $link.source;
  if($removeIds->contains($sourceId),
    |let incomingLinks = $allLinks->filter(l|$l.target == $sourceId);
     if($incomingLinks->isEmpty(), 
       |[], 
       |$incomingLinks->map(l|$l->findUltimateSource($removeIds, $allLinks));
     );,
    |[$link.source]
  );
}

function  <<access.private>> meta::analytics::lineage::property::findUltimateTargets(link:OwnerLink[1], removeIds:String[*], allLinks:OwnerLink[*]):String[*]
{
  let targetId = $link.target;
  if($removeIds->contains($targetId),
    |let outgoingLinks = $allLinks->filter(l|$l.source == $targetId);
     if($outgoingLinks->isEmpty(), 
       |[], 
       |$outgoingLinks->map(l|$l->findUltimateTargets($removeIds, $allLinks));
     );,
    |[$link.target]
  );
}

function meta::analytics::lineage::property::toGraphFromPropertyLineage(state:ScannerState[1], function:FunctionDefinition<Any>[1], extension:LineageExtension[*]):Graph[1]
{
  let nodesToRemove = $state.propertyOwner->filter(o|
    $o->instanceOf(meta::analytics::lineage::property::Query) ||
    $o->instanceOf(meta::analytics::lineage::property::MappedClassOwner)
  );

  let removeIds = $nodesToRemove.id;
  let filteredLinksInit = $state.ownerLink->filter(l| $removeIds->contains($l.source) || $removeIds->contains($l.target));
  let bypassLinks = $filteredLinksInit->map(link |
    let sources = $link->findUltimateSource($removeIds, $state.ownerLink);
    let targets = $link->findUltimateTargets($removeIds, $state.ownerLink);
    $sources->map(src | $targets->map(tgt |  if($src!= $tgt,
                                                | ^OwnerLink(source=$src, target=$tgt),
                                              | [] 
                                              );
                                ));)->distinct();

  let filteredLinks = $state.ownerLink->filter(l|
    !$removeIds->contains($l.source) && !$removeIds->contains($l.target)
  );

  let allLinks = $filteredLinks->concatenate($bypassLinks)->cast(@OwnerLink);
  let filteredNodes = $state.propertyOwner->filter(o|!$removeIds->contains($o.id));

  let nodes = $filteredNodes->map(o|pair($o.id,$o->match($extension.propertyReportToGraphNode->map(a|$a->eval())->concatenate(
    [s:StorePropertyLineageNode[1] | ^NodeData(id=$s->toGraphID(), type=$s->type().name->toOne(), text=$s.name),
     r:RelationalPropertyOwner[1]| ^NodeData(id=$r->toGraphID(), type=$r->type().name->toOne(), text=$r.relationName);,
     r:RootQuery[1] | ^NodeData(id=$r->toGraphID(), text='LAMBDA', type=$r->type().name->toOne()),
     r:MappedSetOwner[1] | ^NodeData(id=$r.id, type=$r->type().name->toOne(), text=$r.id)
    ])->toOneMany())));

  let nodesById = $nodes->groupBy(c|$c.first);

  ^Graph(
    nodes = $nodes.second->map(n| ^meta::pure::lineage::graph::Node(data=$n)),
    edges = $allLinks->map(l|
      ^Edge(data=^EdgeData(
        id='x',
        text='txt',
        type='',
        source= ^meta::pure::lineage::graph::Node(data=$nodesById->get($l.source)->toOne().values->at(0).second),
        target= ^meta::pure::lineage::graph::Node(data=$nodesById->get($l.target)->toOne().values->at(0).second)
      ))
    )
  );
}

function <<access.private>> meta::analytics::lineage::property::toGraphID(p:PropertyLineageNode[1]):String[1]
{
  $p->match([  s:StorePropertyLineageNode[1] | 'db_'+$s.name->toOne(),
                r:RelationalPropertyOwner[1]| 
                                              'tb_'+$r.relationOwnerName->toOne()+$r.schemaName+$r.relationName;,
               r:RootQuery[1] |'Lambda',
              p:PropertyLineageNode[1] |$p.name
            
  ]);

}




