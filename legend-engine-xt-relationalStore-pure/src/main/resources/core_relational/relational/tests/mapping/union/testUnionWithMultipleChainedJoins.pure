// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

###Pure
import meta::relational::functions::asserts::*;
import meta::relational::tests::mapping::union::multipleChainedJoins::mapping::*;
import meta::relational::tests::mapping::union::multipleChainedJoins::model::*;
import meta::relational::tests::*;

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionWithChainedJoinsAcross2SetsV1():Boolean[1]
{
   let result = execute(|X.all(%2018-1-1)->project([x|$x.pk, x|$x.y.pk, x|$x.y.z.pk],['x_pk', 'y_pk', 'z_pk']), multipleChainedJoinsMappingWithUnionAcross2SetsV1, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase"."X0pk_X1pk" as "x_pk", "unionalias_1"."Y0pk_Y1pk" as "y_pk", "unionalias_3"."Z0pk_Z1pk" as "z_pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".pk as "pk_0_0", null as "pk_0_1", "root".pk as "X0pk_X1pk", "root".fk as fk_0, null as fk_1 from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "pk_0_0", "root".pk as "pk_0_1", "root".pk as "X0pk_X1pk", null as fk_0, "root".fk as fk_1 from X1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionBase" left outer join A as "a_0" on ("unionBase".fk_1 = "a_0".fk0 and "a_0".from_z <= \'2018-01-01\' and "a_0".thru_z > \'2018-01-01\') left outer join (select "unionalias_2".fk_1 as fk_1, "unionalias_2".fk_0 as fk_0, "unionalias_2"."Y0pk_Y1pk" as "Y0pk_Y1pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".fk as fk_0, null as fk_1, "root".pk as "Y0pk_Y1pk" from Y0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as fk_0, "root".fk as fk_1, "root".pk as "Y0pk_Y1pk" from Y1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_2" where (coalesce("unionalias_2"."from_z_0", "unionalias_2"."from_z_1") <= \'2018-01-01\' and coalesce("unionalias_2"."thru_z_0", "unionalias_2"."thru_z_1") > \'2018-01-01\') or coalesce("unionalias_2"."from_z_0", "unionalias_2"."from_z_1", "unionalias_2"."thru_z_0", "unionalias_2"."thru_z_1") is null) as "unionalias_1" on ("a_0".fk1 = "unionalias_1".fk_1 or "unionBase".fk_0 = "unionalias_1".fk_0) left outer join (select "g_1".fk0 as fk0, "g_1".fk1 from G as "g_1" where "g_1".from_z <= \'2018-01-01\' and "g_1".thru_z > \'2018-01-01\') as "g_0" on ("unionalias_1".fk_1 = "g_0".fk0) left outer join (select "unionalias_4".fk_1 as fk_1, "unionalias_4".fk_0 as fk_0, "unionalias_4"."Z0pk_Z1pk" as "Z0pk_Z1pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".fk as fk_0, null as fk_1, "root".pk as "Z0pk_Z1pk" from Z0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as fk_0, "root".fk as fk_1, "root".pk as "Z0pk_Z1pk" from Z1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_4" where (coalesce("unionalias_4"."from_z_0", "unionalias_4"."from_z_1") <= \'2018-01-01\' and coalesce("unionalias_4"."thru_z_0", "unionalias_4"."thru_z_1") > \'2018-01-01\') or coalesce("unionalias_4"."from_z_0", "unionalias_4"."from_z_1", "unionalias_4"."thru_z_0", "unionalias_4"."thru_z_1") is null) as "unionalias_3" on ("g_0".fk1 = "unionalias_3".fk_1 or "unionalias_1".fk_0 = "unionalias_3".fk_0)', $result);
   assertEquals([10, 11], $result.values.rows.get('x_pk'));
   assertEquals([20, 21], $result.values.rows.get('y_pk'));
   assertEquals([30, 31], $result.values.rows.get('z_pk'));
}

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionWithChainedJoinsAcross3SetsV1():Boolean[1]
{
   let result = execute(|X.all(%2018-1-1)->project([x|$x.pk, x|$x.y.pk, x|$x.y.z.pk],['x_pk', 'y_pk', 'z_pk']), multipleChainedJoinsMappingWithUnionAcross3SetsV1, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase"."X0pk_X1pk_X2pk" as "x_pk", "unionalias_1"."Y0pk_Y1pk_Y2pk" as "y_pk", "unionalias_2"."Z0pk_Z1pk_Z2pk" as "z_pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".pk as "pk_0_0", null as "pk_0_1", null as "pk_0_2", "root".pk as "X0pk_X1pk_X2pk", "root".fk as fk_0, null as fk_1, null as fk_2, null as fk1_1, null as fk1_2 from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "pk_0_0", "root".pk as "pk_0_1", null as "pk_0_2", "root".pk as "X0pk_X1pk_X2pk", null as fk_0, "root".fk as fk_1, null as fk_2, "a_0".fk1 as fk1_1, null as fk1_2 from X1 as "root" left outer join A as "a_0" on ("root".fk = "a_0".fk0 and "a_0".from_z <= \'2018-01-01\' and "a_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as "pk_0_0", null as "pk_0_1", "root".pk as "pk_0_2", "root".pk as "X0pk_X1pk_X2pk", null as fk_0, null as fk_1, "root".fk as fk_2, null as fk1_1, "c_0".fk1 as fk1_2 from X2 as "root" left outer join B as "b_0" on ("root".fk = "b_0".fk0 and "b_0".from_z <= \'2018-01-01\' and "b_0".thru_z > \'2018-01-01\') left outer join (select "c_1".fk1 as fk1, "c_1".fk0 as fk0 from C as "c_1" where "c_1".from_z <= \'2018-01-01\' and "c_1".thru_z > \'2018-01-01\') as "c_0" on ("b_0".fk1 = "c_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionBase" left outer join (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".fk as fk_0, null as fk_1, null as fk_2, "root".pk as "Y0pk_Y1pk_Y2pk", null as fk1_1, null as fk1_2 from Y0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as fk_0, "root".fk as fk_1, null as fk_2, "root".pk as "Y0pk_Y1pk_Y2pk", "g_0".fk1 as fk1_1, null as fk1_2 from Y1 as "root" left outer join G as "g_0" on ("root".fk = "g_0".fk0 and "g_0".from_z <= \'2018-01-01\' and "g_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as fk_0, null as fk_1, "root".fk as fk_2, "root".pk as "Y0pk_Y1pk_Y2pk", null as fk1_1, "i_0".fk1 as fk1_2 from Y2 as "root" left outer join H as "h_0" on ("root".fk = "h_0".fk0 and "h_0".from_z <= \'2018-01-01\' and "h_0".thru_z > \'2018-01-01\') left outer join (select "i_1".fk1 as fk1, "i_1".fk0 as fk0 from I as "i_1" where "i_1".from_z <= \'2018-01-01\' and "i_1".thru_z > \'2018-01-01\') as "i_0" on ("h_0".fk1 = "i_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_1" on (("unionBase".fk_0 = "unionalias_1".fk_0 or "unionBase".fk1_1 = "unionalias_1".fk_1 or "unionBase".fk1_2 = "unionalias_1".fk_2) and ((coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1", "unionalias_1"."from_z_2") <= \'2018-01-01\' and coalesce("unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1", "unionalias_1"."thru_z_2") > \'2018-01-01\') or coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1", "unionalias_1"."from_z_2", "unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1", "unionalias_1"."thru_z_2") is null)) left outer join (select "unionalias_3".fk_0 as fk_0, "unionalias_3".fk_1 as fk_1, "unionalias_3".fk_2 as fk_2, "unionalias_3"."Z0pk_Z1pk_Z2pk" as "Z0pk_Z1pk_Z2pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".fk as fk_0, null as fk_1, null as fk_2, "root".pk as "Z0pk_Z1pk_Z2pk" from Z0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as fk_0, "root".fk as fk_1, null as fk_2, "root".pk as "Z0pk_Z1pk_Z2pk" from Z1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as fk_0, null as fk_1, "root".fk as fk_2, "root".pk as "Z0pk_Z1pk_Z2pk" from Z2 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_3" where (coalesce("unionalias_3"."from_z_0", "unionalias_3"."from_z_1", "unionalias_3"."from_z_2") <= \'2018-01-01\' and coalesce("unionalias_3"."thru_z_0", "unionalias_3"."thru_z_1", "unionalias_3"."thru_z_2") > \'2018-01-01\') or coalesce("unionalias_3"."from_z_0", "unionalias_3"."from_z_1", "unionalias_3"."from_z_2", "unionalias_3"."thru_z_0", "unionalias_3"."thru_z_1", "unionalias_3"."thru_z_2") is null) as "unionalias_2" on ("unionalias_1".fk_0 = "unionalias_2".fk_0 or "unionalias_1".fk1_1 = "unionalias_2".fk_1 or "unionalias_1".fk1_2 = "unionalias_2".fk_2)', $result);
   assertEquals([10, 11, 12], $result.values.rows.get('x_pk'));
   assertEquals([20, 21, 22], $result.values.rows.get('y_pk'));
   assertEquals([30, 31, 32], $result.values.rows.get('z_pk'));
}

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionWithChainedJoinsAcross4SetsV1():Boolean[1]
{
   let result = execute(|X.all(%2018-1-1)->project([x|$x.pk, x|$x.y.pk, x|$x.y.z.pk],['x_pk', 'y_pk', 'z_pk']), multipleChainedJoinsMappingWithUnionAcross4SetsV1, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase"."X0pk_X1pk_X2pk_X3pk" as "x_pk", "unionalias_1"."Y0pk_Y1pk_Y2pk_Y3pk" as "y_pk", "unionalias_2"."Z0pk_Z1pk_Z2pk_Z3pk" as "z_pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", "root".pk as "pk_0_0", null as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", "root".fk as fk_0, null as fk_1, null as fk_2, null as fk_3, null as fk1_1, null as fk1_2, null as fk1_3 from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as "pk_0_0", "root".pk as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", null as fk_0, "root".fk as fk_1, null as fk_2, null as fk_3, "a_0".fk1 as fk1_1, null as fk1_2, null as fk1_3 from X1 as "root" left outer join A as "a_0" on ("root".fk = "a_0".fk0 and "a_0".from_z <= \'2018-01-01\' and "a_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as "pk_0_0", null as "pk_0_1", "root".pk as "pk_0_2", null as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", null as fk_0, null as fk_1, "root".fk as fk_2, null as fk_3, null as fk1_1, "c_0".fk1 as fk1_2, null as fk1_3 from X2 as "root" left outer join B as "b_0" on ("root".fk = "b_0".fk0 and "b_0".from_z <= \'2018-01-01\' and "b_0".thru_z > \'2018-01-01\') left outer join (select "c_1".fk1 as fk1, "c_1".fk0 as fk0 from C as "c_1" where "c_1".from_z <= \'2018-01-01\' and "c_1".thru_z > \'2018-01-01\') as "c_0" on ("b_0".fk1 = "c_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".from_z as "from_z_3", "root".thru_z as "thru_z_3", null as "pk_0_0", null as "pk_0_1", null as "pk_0_2", "root".pk as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", null as fk_0, null as fk_1, null as fk_2, "root".fk as fk_3, null as fk1_1, null as fk1_2, "f_0".fk1 as fk1_3 from X3 as "root" left outer join D as "d_0" on ("root".fk = "d_0".fk0 and "d_0".from_z <= \'2018-01-01\' and "d_0".thru_z > \'2018-01-01\') left outer join (select "e_1".fk0 as fk0, "e_1".fk1 from E as "e_1" where "e_1".from_z <= \'2018-01-01\' and "e_1".thru_z > \'2018-01-01\') as "e_0" on ("d_0".fk1 = "e_0".fk0) left outer join (select "f_1".fk1 as fk1, "f_1".fk0 as fk0 from F as "f_1" where "f_1".from_z <= \'2018-01-01\' and "f_1".thru_z > \'2018-01-01\') as "f_0" on ("e_0".fk1 = "f_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionBase" left outer join (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", "root".fk as fk_0, null as fk_1, null as fk_2, null as fk_3, "root".pk as "Y0pk_Y1pk_Y2pk_Y3pk", null as fk1_1, null as fk1_2, null as fk1_3 from Y0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as fk_0, "root".fk as fk_1, null as fk_2, null as fk_3, "root".pk as "Y0pk_Y1pk_Y2pk_Y3pk", "g_0".fk1 as fk1_1, null as fk1_2, null as fk1_3 from Y1 as "root" left outer join G as "g_0" on ("root".fk = "g_0".fk0 and "g_0".from_z <= \'2018-01-01\' and "g_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as fk_0, null as fk_1, "root".fk as fk_2, null as fk_3, "root".pk as "Y0pk_Y1pk_Y2pk_Y3pk", null as fk1_1, "i_0".fk1 as fk1_2, null as fk1_3 from Y2 as "root" left outer join H as "h_0" on ("root".fk = "h_0".fk0 and "h_0".from_z <= \'2018-01-01\' and "h_0".thru_z > \'2018-01-01\') left outer join (select "i_1".fk1 as fk1, "i_1".fk0 as fk0 from I as "i_1" where "i_1".from_z <= \'2018-01-01\' and "i_1".thru_z > \'2018-01-01\') as "i_0" on ("h_0".fk1 = "i_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".from_z as "from_z_3", "root".thru_z as "thru_z_3", null as fk_0, null as fk_1, null as fk_2, "root".fk as fk_3, "root".pk as "Y0pk_Y1pk_Y2pk_Y3pk", null as fk1_1, null as fk1_2, "l_0".fk1 as fk1_3 from Y3 as "root" left outer join J as "j_0" on ("root".fk = "j_0".fk0 and "j_0".from_z <= \'2018-01-01\' and "j_0".thru_z > \'2018-01-01\') left outer join (select "k_1".fk0 as fk0, "k_1".fk1 from K as "k_1" where "k_1".from_z <= \'2018-01-01\' and "k_1".thru_z > \'2018-01-01\') as "k_0" on ("j_0".fk1 = "k_0".fk0) left outer join (select "l_1".fk1 as fk1, "l_1".fk0 as fk0 from L as "l_1" where "l_1".from_z <= \'2018-01-01\' and "l_1".thru_z > \'2018-01-01\') as "l_0" on ("k_0".fk1 = "l_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_1" on (("unionBase".fk_0 = "unionalias_1".fk_0 or "unionBase".fk1_1 = "unionalias_1".fk_1 or "unionBase".fk1_2 = "unionalias_1".fk_2 or "unionBase".fk1_3 = "unionalias_1".fk_3) and ((coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1", "unionalias_1"."from_z_2", "unionalias_1"."from_z_3") <= \'2018-01-01\' and coalesce("unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1", "unionalias_1"."thru_z_2", "unionalias_1"."thru_z_3") > \'2018-01-01\') or coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1", "unionalias_1"."from_z_2", "unionalias_1"."from_z_3", "unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1", "unionalias_1"."thru_z_2", "unionalias_1"."thru_z_3") is null)) left outer join (select "unionalias_3".fk_0 as fk_0, "unionalias_3".fk_1 as fk_1, "unionalias_3".fk_2 as fk_2, "unionalias_3".fk_3 as fk_3, "unionalias_3"."Z0pk_Z1pk_Z2pk_Z3pk" as "Z0pk_Z1pk_Z2pk_Z3pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", "root".fk as fk_0, null as fk_1, null as fk_2, null as fk_3, "root".pk as "Z0pk_Z1pk_Z2pk_Z3pk" from Z0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as fk_0, "root".fk as fk_1, null as fk_2, null as fk_3, "root".pk as "Z0pk_Z1pk_Z2pk_Z3pk" from Z1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as fk_0, null as fk_1, "root".fk as fk_2, null as fk_3, "root".pk as "Z0pk_Z1pk_Z2pk_Z3pk" from Z2 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".from_z as "from_z_3", "root".thru_z as "thru_z_3", null as fk_0, null as fk_1, null as fk_2, "root".fk as fk_3, "root".pk as "Z0pk_Z1pk_Z2pk_Z3pk" from Z3 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_3" where (coalesce("unionalias_3"."from_z_0", "unionalias_3"."from_z_1", "unionalias_3"."from_z_2", "unionalias_3"."from_z_3") <= \'2018-01-01\' and coalesce("unionalias_3"."thru_z_0", "unionalias_3"."thru_z_1", "unionalias_3"."thru_z_2", "unionalias_3"."thru_z_3") > \'2018-01-01\') or coalesce("unionalias_3"."from_z_0", "unionalias_3"."from_z_1", "unionalias_3"."from_z_2", "unionalias_3"."from_z_3", "unionalias_3"."thru_z_0", "unionalias_3"."thru_z_1", "unionalias_3"."thru_z_2", "unionalias_3"."thru_z_3") is null) as "unionalias_2" on ("unionalias_1".fk_0 = "unionalias_2".fk_0 or "unionalias_1".fk1_1 = "unionalias_2".fk_1 or "unionalias_1".fk1_2 = "unionalias_2".fk_2 or "unionalias_1".fk1_3 = "unionalias_2".fk_3)', $result);
   assertEquals([10, 11, 12, 13], $result.values.rows.get('x_pk'));
   assertEquals([20, 21, 22, 23], $result.values.rows.get('y_pk'));
   assertEquals([30, 31, 32, 33], $result.values.rows.get('z_pk'));
}

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionWithChainedJoinsAcross2SetsV2():Boolean[1]
{
   let result = execute(|X.all(%2018-1-1)->project([x|$x.pk, x|$x.y.pk, x|$x.y.z.pk],['x_pk', 'y_pk', 'z_pk']), multipleChainedJoinsMappingWithUnionAcross2SetsV2, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase"."X0pk_X1pk" as "x_pk", "unionalias_1"."Y0pk_Y1pk" as "y_pk", "z0_0".pk as "z_pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".pk as "pk_0_0", null as "pk_0_1", "root".pk as "X0pk_X1pk", "root".fk as fk_0, null as fk_1 from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "pk_0_0", "root".pk as "pk_0_1", "root".pk as "X0pk_X1pk", null as fk_0, "root".fk as fk_1 from X1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionBase" left outer join A as "a_0" on ("unionBase".fk_1 = "a_0".fk0 and "a_0".from_z <= \'2018-01-01\' and "a_0".thru_z > \'2018-01-01\') left outer join (select "unionalias_2".fk_1 as fk_1, "unionalias_2".fk_0 as fk_0, "unionalias_2"."Y0pk_Y1pk" as "Y0pk_Y1pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".fk as fk_0, null as fk_1, "root".pk as "Y0pk_Y1pk" from Y0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as fk_0, "root".fk as fk_1, "root".pk as "Y0pk_Y1pk" from Y1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_2" where (coalesce("unionalias_2"."from_z_0", "unionalias_2"."from_z_1") <= \'2018-01-01\' and coalesce("unionalias_2"."thru_z_0", "unionalias_2"."thru_z_1") > \'2018-01-01\') or coalesce("unionalias_2"."from_z_0", "unionalias_2"."from_z_1", "unionalias_2"."thru_z_0", "unionalias_2"."thru_z_1") is null) as "unionalias_1" on ("a_0".fk1 = "unionalias_1".fk_1 or "unionBase".fk_0 = "unionalias_1".fk_0) left outer join (select "g_1".fk0 as fk0, "g_1".fk1 from G as "g_1" where "g_1".from_z <= \'2018-01-01\' and "g_1".thru_z > \'2018-01-01\') as "g_0" on ("unionalias_1".fk_1 = "g_0".fk0) left outer join (select "z0_1".fk as fk, "z0_1".pk as pk from Z0 as "z0_1" where "z0_1".from_z <= \'2018-01-01\' and "z0_1".thru_z > \'2018-01-01\') as "z0_0" on ("g_0".fk1 = "z0_0".fk or "unionalias_1".fk_0 = "z0_0".fk)', $result);
   assertEquals([10, 11], $result.values.rows.get('x_pk'));
   assertEquals([20, 21], $result.values.rows.get('y_pk'));
   assertEquals([30, 30], $result.values.rows.get('z_pk'));
}

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionWithChainedJoinsAcross3SetsV2():Boolean[1]
{
   let result = execute(|X.all(%2018-1-1)->project([x|$x.pk, x|$x.y.pk, x|$x.y.z.pk],['x_pk', 'y_pk', 'z_pk']), multipleChainedJoinsMappingWithUnionAcross3SetsV2, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase"."X0pk_X1pk_X2pk" as "x_pk", "unionalias_1"."Y0pk_Y1pk_Y2pk" as "y_pk", "z0_0".pk as "z_pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".pk as "pk_0_0", null as "pk_0_1", null as "pk_0_2", "root".pk as "X0pk_X1pk_X2pk", "root".fk as fk_0, null as fk_1, null as fk_2, null as fk1_1, null as fk1_2 from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "pk_0_0", "root".pk as "pk_0_1", null as "pk_0_2", "root".pk as "X0pk_X1pk_X2pk", null as fk_0, "root".fk as fk_1, null as fk_2, "a_0".fk1 as fk1_1, null as fk1_2 from X1 as "root" left outer join A as "a_0" on ("root".fk = "a_0".fk0 and "a_0".from_z <= \'2018-01-01\' and "a_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as "pk_0_0", null as "pk_0_1", "root".pk as "pk_0_2", "root".pk as "X0pk_X1pk_X2pk", null as fk_0, null as fk_1, "root".fk as fk_2, null as fk1_1, "c_0".fk1 as fk1_2 from X2 as "root" left outer join B as "b_0" on ("root".fk = "b_0".fk0 and "b_0".from_z <= \'2018-01-01\' and "b_0".thru_z > \'2018-01-01\') left outer join (select "c_1".fk1 as fk1, "c_1".fk0 as fk0 from C as "c_1" where "c_1".from_z <= \'2018-01-01\' and "c_1".thru_z > \'2018-01-01\') as "c_0" on ("b_0".fk1 = "c_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionBase" left outer join (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".fk as fk_0, null as fk_1, null as fk_2, "root".pk as "Y0pk_Y1pk_Y2pk", null as fk1_1, null as fk1_2 from Y0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as fk_0, "root".fk as fk_1, null as fk_2, "root".pk as "Y0pk_Y1pk_Y2pk", "g_0".fk1 as fk1_1, null as fk1_2 from Y1 as "root" left outer join G as "g_0" on ("root".fk = "g_0".fk0 and "g_0".from_z <= \'2018-01-01\' and "g_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as fk_0, null as fk_1, "root".fk as fk_2, "root".pk as "Y0pk_Y1pk_Y2pk", null as fk1_1, "i_0".fk1 as fk1_2 from Y2 as "root" left outer join H as "h_0" on ("root".fk = "h_0".fk0 and "h_0".from_z <= \'2018-01-01\' and "h_0".thru_z > \'2018-01-01\') left outer join (select "i_1".fk1 as fk1, "i_1".fk0 as fk0 from I as "i_1" where "i_1".from_z <= \'2018-01-01\' and "i_1".thru_z > \'2018-01-01\') as "i_0" on ("h_0".fk1 = "i_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_1" on (("unionBase".fk_0 = "unionalias_1".fk_0 or "unionBase".fk1_1 = "unionalias_1".fk_1 or "unionBase".fk1_2 = "unionalias_1".fk_2) and ((coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1", "unionalias_1"."from_z_2") <= \'2018-01-01\' and coalesce("unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1", "unionalias_1"."thru_z_2") > \'2018-01-01\') or coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1", "unionalias_1"."from_z_2", "unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1", "unionalias_1"."thru_z_2") is null)) left outer join (select "z0_1".fk as fk, "z0_1".pk as pk from Z0 as "z0_1" where "z0_1".from_z <= \'2018-01-01\' and "z0_1".thru_z > \'2018-01-01\') as "z0_0" on ("unionalias_1".fk_0 = "z0_0".fk or "unionalias_1".fk1_1 = "z0_0".fk or "unionalias_1".fk1_2 = "z0_0".fk)', $result);
   assertEquals([10, 11, 12], $result.values.rows.get('x_pk'));
   assertEquals([20, 21, 22], $result.values.rows.get('y_pk'));
   assertEquals([30, 30, 30], $result.values.rows.get('z_pk'));
}

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionWithChainedJoinsAcross4SetsV2():Boolean[1]
{
   let result = execute(|X.all(%2018-1-1)->project([x|$x.pk, x|$x.y.pk, x|$x.y.z.pk],['x_pk', 'y_pk', 'z_pk']), multipleChainedJoinsMappingWithUnionAcross4SetsV2, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase"."X0pk_X1pk_X2pk_X3pk" as "x_pk", "unionalias_1"."Y0pk_Y1pk_Y2pk_Y3pk" as "y_pk", "z0_0".pk as "z_pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", "root".pk as "pk_0_0", null as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", "root".fk as fk_0, null as fk_1, null as fk_2, null as fk_3, null as fk1_1, null as fk1_2, null as fk1_3 from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as "pk_0_0", "root".pk as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", null as fk_0, "root".fk as fk_1, null as fk_2, null as fk_3, "a_0".fk1 as fk1_1, null as fk1_2, null as fk1_3 from X1 as "root" left outer join A as "a_0" on ("root".fk = "a_0".fk0 and "a_0".from_z <= \'2018-01-01\' and "a_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as "pk_0_0", null as "pk_0_1", "root".pk as "pk_0_2", null as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", null as fk_0, null as fk_1, "root".fk as fk_2, null as fk_3, null as fk1_1, "c_0".fk1 as fk1_2, null as fk1_3 from X2 as "root" left outer join B as "b_0" on ("root".fk = "b_0".fk0 and "b_0".from_z <= \'2018-01-01\' and "b_0".thru_z > \'2018-01-01\') left outer join (select "c_1".fk1 as fk1, "c_1".fk0 as fk0 from C as "c_1" where "c_1".from_z <= \'2018-01-01\' and "c_1".thru_z > \'2018-01-01\') as "c_0" on ("b_0".fk1 = "c_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".from_z as "from_z_3", "root".thru_z as "thru_z_3", null as "pk_0_0", null as "pk_0_1", null as "pk_0_2", "root".pk as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", null as fk_0, null as fk_1, null as fk_2, "root".fk as fk_3, null as fk1_1, null as fk1_2, "f_0".fk1 as fk1_3 from X3 as "root" left outer join D as "d_0" on ("root".fk = "d_0".fk0 and "d_0".from_z <= \'2018-01-01\' and "d_0".thru_z > \'2018-01-01\') left outer join (select "e_1".fk0 as fk0, "e_1".fk1 from E as "e_1" where "e_1".from_z <= \'2018-01-01\' and "e_1".thru_z > \'2018-01-01\') as "e_0" on ("d_0".fk1 = "e_0".fk0) left outer join (select "f_1".fk1 as fk1, "f_1".fk0 as fk0 from F as "f_1" where "f_1".from_z <= \'2018-01-01\' and "f_1".thru_z > \'2018-01-01\') as "f_0" on ("e_0".fk1 = "f_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionBase" left outer join (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", "root".fk as fk_0, null as fk_1, null as fk_2, null as fk_3, "root".pk as "Y0pk_Y1pk_Y2pk_Y3pk", null as fk1_1, null as fk1_2, null as fk1_3 from Y0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as fk_0, "root".fk as fk_1, null as fk_2, null as fk_3, "root".pk as "Y0pk_Y1pk_Y2pk_Y3pk", "g_0".fk1 as fk1_1, null as fk1_2, null as fk1_3 from Y1 as "root" left outer join G as "g_0" on ("root".fk = "g_0".fk0 and "g_0".from_z <= \'2018-01-01\' and "g_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as fk_0, null as fk_1, "root".fk as fk_2, null as fk_3, "root".pk as "Y0pk_Y1pk_Y2pk_Y3pk", null as fk1_1, "i_0".fk1 as fk1_2, null as fk1_3 from Y2 as "root" left outer join H as "h_0" on ("root".fk = "h_0".fk0 and "h_0".from_z <= \'2018-01-01\' and "h_0".thru_z > \'2018-01-01\') left outer join (select "i_1".fk1 as fk1, "i_1".fk0 as fk0 from I as "i_1" where "i_1".from_z <= \'2018-01-01\' and "i_1".thru_z > \'2018-01-01\') as "i_0" on ("h_0".fk1 = "i_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".from_z as "from_z_3", "root".thru_z as "thru_z_3", null as fk_0, null as fk_1, null as fk_2, "root".fk as fk_3, "root".pk as "Y0pk_Y1pk_Y2pk_Y3pk", null as fk1_1, null as fk1_2, "l_0".fk1 as fk1_3 from Y3 as "root" left outer join J as "j_0" on ("root".fk = "j_0".fk0 and "j_0".from_z <= \'2018-01-01\' and "j_0".thru_z > \'2018-01-01\') left outer join (select "k_1".fk0 as fk0, "k_1".fk1 from K as "k_1" where "k_1".from_z <= \'2018-01-01\' and "k_1".thru_z > \'2018-01-01\') as "k_0" on ("j_0".fk1 = "k_0".fk0) left outer join (select "l_1".fk1 as fk1, "l_1".fk0 as fk0 from L as "l_1" where "l_1".from_z <= \'2018-01-01\' and "l_1".thru_z > \'2018-01-01\') as "l_0" on ("k_0".fk1 = "l_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_1" on (("unionBase".fk_0 = "unionalias_1".fk_0 or "unionBase".fk1_1 = "unionalias_1".fk_1 or "unionBase".fk1_2 = "unionalias_1".fk_2 or "unionBase".fk1_3 = "unionalias_1".fk_3) and ((coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1", "unionalias_1"."from_z_2", "unionalias_1"."from_z_3") <= \'2018-01-01\' and coalesce("unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1", "unionalias_1"."thru_z_2", "unionalias_1"."thru_z_3") > \'2018-01-01\') or coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1", "unionalias_1"."from_z_2", "unionalias_1"."from_z_3", "unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1", "unionalias_1"."thru_z_2", "unionalias_1"."thru_z_3") is null)) left outer join (select "z0_1".fk as fk, "z0_1".pk as pk from Z0 as "z0_1" where "z0_1".from_z <= \'2018-01-01\' and "z0_1".thru_z > \'2018-01-01\') as "z0_0" on ("unionalias_1".fk_0 = "z0_0".fk or "unionalias_1".fk1_1 = "z0_0".fk or "unionalias_1".fk1_2 = "z0_0".fk or "unionalias_1".fk1_3 = "z0_0".fk)', $result);
   assertEquals([10, 11, 12, 13], $result.values.rows.get('x_pk'));
   assertEquals([20, 21, 22, 23], $result.values.rows.get('y_pk'));
   assertEquals([30, 30, 30, 30], $result.values.rows.get('z_pk'));
}

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionWithChainedJoinsAcross2SetsV3():Boolean[1]
{
   let result = execute(|X.all(%2018-1-1)->project([x|$x.pk, x|$x.y.pk, x|$x.y.z.pk],['x_pk', 'y_pk', 'z_pk']), multipleChainedJoinsMappingWithUnionAcross2SetsV3, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase"."X0pk_X1pk" as "x_pk", "y0_0".pk as "y_pk", "z0_0".pk as "z_pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".pk as "pk_0_0", null as "pk_0_1", "root".pk as "X0pk_X1pk", "root".fk as fk_0, null as fk_1 from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "pk_0_0", "root".pk as "pk_0_1", "root".pk as "X0pk_X1pk", null as fk_0, "root".fk as fk_1 from X1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionBase" left outer join A as "a_0" on ("unionBase".fk_1 = "a_0".fk0 and "a_0".from_z <= \'2018-01-01\' and "a_0".thru_z > \'2018-01-01\') left outer join (select "y0_1".fk as fk, "y0_1".pk as pk from Y0 as "y0_1" where "y0_1".from_z <= \'2018-01-01\' and "y0_1".thru_z > \'2018-01-01\') as "y0_0" on ("a_0".fk1 = "y0_0".fk or "unionBase".fk_0 = "y0_0".fk) left outer join (select "z0_1".fk as fk, "z0_1".pk as pk from Z0 as "z0_1" where "z0_1".from_z <= \'2018-01-01\' and "z0_1".thru_z > \'2018-01-01\') as "z0_0" on ("y0_0".fk = "z0_0".fk)', $result);
   assertEquals([10, 11], $result.values.rows.get('x_pk'));
   assertEquals([20, 20], $result.values.rows.get('y_pk'));
   assertEquals([30, 30], $result.values.rows.get('z_pk'));
}

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionWithChainedJoinsAcross3SetsV3():Boolean[1]
{
   let result = execute(|X.all(%2018-1-1)->project([x|$x.pk, x|$x.y.pk, x|$x.y.z.pk],['x_pk', 'y_pk', 'z_pk']), multipleChainedJoinsMappingWithUnionAcross3SetsV3, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase"."X0pk_X1pk_X2pk" as "x_pk", "y0_0".pk as "y_pk", "z0_0".pk as "z_pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".pk as "pk_0_0", null as "pk_0_1", null as "pk_0_2", "root".pk as "X0pk_X1pk_X2pk", "root".fk as fk_0, null as fk_1, null as fk_2, null as fk1_1, null as fk1_2 from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "pk_0_0", "root".pk as "pk_0_1", null as "pk_0_2", "root".pk as "X0pk_X1pk_X2pk", null as fk_0, "root".fk as fk_1, null as fk_2, "a_0".fk1 as fk1_1, null as fk1_2 from X1 as "root" left outer join A as "a_0" on ("root".fk = "a_0".fk0 and "a_0".from_z <= \'2018-01-01\' and "a_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as "pk_0_0", null as "pk_0_1", "root".pk as "pk_0_2", "root".pk as "X0pk_X1pk_X2pk", null as fk_0, null as fk_1, "root".fk as fk_2, null as fk1_1, "c_0".fk1 as fk1_2 from X2 as "root" left outer join B as "b_0" on ("root".fk = "b_0".fk0 and "b_0".from_z <= \'2018-01-01\' and "b_0".thru_z > \'2018-01-01\') left outer join (select "c_1".fk1 as fk1, "c_1".fk0 as fk0 from C as "c_1" where "c_1".from_z <= \'2018-01-01\' and "c_1".thru_z > \'2018-01-01\') as "c_0" on ("b_0".fk1 = "c_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionBase" left outer join Y0 as "y0_0" on (("unionBase".fk_0 = "y0_0".fk or "unionBase".fk1_1 = "y0_0".fk or "unionBase".fk1_2 = "y0_0".fk) and "y0_0".from_z <= \'2018-01-01\' and "y0_0".thru_z > \'2018-01-01\') left outer join (select "z0_1".fk as fk, "z0_1".pk as pk from Z0 as "z0_1" where "z0_1".from_z <= \'2018-01-01\' and "z0_1".thru_z > \'2018-01-01\') as "z0_0" on ("y0_0".fk = "z0_0".fk)', $result);
   assertEquals([10, 11, 12], $result.values.rows.get('x_pk'));
   assertEquals([20, 20, 20], $result.values.rows.get('y_pk'));
   assertEquals([30, 30, 30], $result.values.rows.get('z_pk'));
}

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionWithChainedJoinsAcross4SetsV3():Boolean[1]
{
   let result = execute(|X.all(%2018-1-1)->project([x|$x.pk, x|$x.y.pk, x|$x.y.z.pk],['x_pk', 'y_pk', 'z_pk']), multipleChainedJoinsMappingWithUnionAcross4SetsV3, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase"."X0pk_X1pk_X2pk_X3pk" as "x_pk", "y0_0".pk as "y_pk", "z0_0".pk as "z_pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", "root".pk as "pk_0_0", null as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", "root".fk as fk_0, null as fk_1, null as fk_2, null as fk_3, null as fk1_1, null as fk1_2, null as fk1_3 from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", null as "from_z_2", null as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as "pk_0_0", "root".pk as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", null as fk_0, "root".fk as fk_1, null as fk_2, null as fk_3, "a_0".fk1 as fk1_1, null as fk1_2, null as fk1_3 from X1 as "root" left outer join A as "a_0" on ("root".fk = "a_0".fk0 and "a_0".from_z <= \'2018-01-01\' and "a_0".thru_z > \'2018-01-01\') where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".from_z as "from_z_2", "root".thru_z as "thru_z_2", null as "from_z_3", null as "thru_z_3", null as "pk_0_0", null as "pk_0_1", "root".pk as "pk_0_2", null as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", null as fk_0, null as fk_1, "root".fk as fk_2, null as fk_3, null as fk1_1, "c_0".fk1 as fk1_2, null as fk1_3 from X2 as "root" left outer join B as "b_0" on ("root".fk = "b_0".fk0 and "b_0".from_z <= \'2018-01-01\' and "b_0".thru_z > \'2018-01-01\') left outer join (select "c_1".fk1 as fk1, "c_1".fk0 as fk0 from C as "c_1" where "c_1".from_z <= \'2018-01-01\' and "c_1".thru_z > \'2018-01-01\') as "c_0" on ("b_0".fk1 = "c_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "from_z_1", null as "thru_z_1", null as "from_z_2", null as "thru_z_2", "root".from_z as "from_z_3", "root".thru_z as "thru_z_3", null as "pk_0_0", null as "pk_0_1", null as "pk_0_2", "root".pk as "pk_0_3", "root".pk as "X0pk_X1pk_X2pk_X3pk", null as fk_0, null as fk_1, null as fk_2, "root".fk as fk_3, null as fk1_1, null as fk1_2, "f_0".fk1 as fk1_3 from X3 as "root" left outer join D as "d_0" on ("root".fk = "d_0".fk0 and "d_0".from_z <= \'2018-01-01\' and "d_0".thru_z > \'2018-01-01\') left outer join (select "e_1".fk0 as fk0, "e_1".fk1 from E as "e_1" where "e_1".from_z <= \'2018-01-01\' and "e_1".thru_z > \'2018-01-01\') as "e_0" on ("d_0".fk1 = "e_0".fk0) left outer join (select "f_1".fk1 as fk1, "f_1".fk0 as fk0 from F as "f_1" where "f_1".from_z <= \'2018-01-01\' and "f_1".thru_z > \'2018-01-01\') as "f_0" on ("e_0".fk1 = "f_0".fk0) where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionBase" left outer join Y0 as "y0_0" on (("unionBase".fk_0 = "y0_0".fk or "unionBase".fk1_1 = "y0_0".fk or "unionBase".fk1_2 = "y0_0".fk or "unionBase".fk1_3 = "y0_0".fk) and "y0_0".from_z <= \'2018-01-01\' and "y0_0".thru_z > \'2018-01-01\') left outer join (select "z0_1".fk as fk, "z0_1".pk as pk from Z0 as "z0_1" where "z0_1".from_z <= \'2018-01-01\' and "z0_1".thru_z > \'2018-01-01\') as "z0_0" on ("y0_0".fk = "z0_0".fk)', $result);
   assertEquals([10, 11, 12, 13], $result.values.rows.get('x_pk'));
   assertEquals([20, 20, 20, 20], $result.values.rows.get('y_pk'));
   assertEquals([30, 30, 30, 30], $result.values.rows.get('z_pk'));
}


function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testViewToViewToUnion():Boolean[1]
{
   let result = execute(|Y.all(%2018-1-1)->project(y|$y.z.pk,'z'), viewToViewToUnion, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."Z1pk_Z2pk" as "z" from (select "root".pk as pk, "root".fk as fk, \'2018-01-01\' as "k_businessDate" from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "root" left outer join (select "root".pk as pk, "root".fk as fk, \'2018-01-01\' as "k_businessDate" from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "vx2_0" on ("root".fk = "vx2_0".pk) left outer join (select "unionalias_1".pk as pk, "unionalias_1"."Z1pk_Z2pk" as "Z1pk_Z2pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".pk as pk, "root".pk as "Z1pk_Z2pk" from Z1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", "root".pk as pk, "root".pk as "Z1pk_Z2pk" from Z2 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_1" where (coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1") <= \'2018-01-01\' and coalesce("unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1") > \'2018-01-01\') or coalesce("unionalias_1"."from_z_0", "unionalias_1"."from_z_1", "unionalias_1"."thru_z_0", "unionalias_1"."thru_z_1") is null) as "unionalias_0" on ("vx2_0".fk = "unionalias_0".pk)', $result);
}

function <<test.Test>> meta::relational::tests::mapping::union::multipleChainedJoins::testUnionedViewsToViewToUnion():Boolean[1]
{
   let result = execute(|Y.all(%2018-1-1)->project(y|$y.z.pk,'z'), unionOfViewsToViewToUnion, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_1"."Z1pk_Z2pk" as "z" from (select "root".pk as "pk_0_0", null as "pk_0_1", "root".fk as fk_0, null as fk_1 from (select "root".pk as pk, "root".fk as fk, \'2018-01-01\' as "k_businessDate" from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "root" UNION ALL select null as "pk_0_0", "root".pk as "pk_0_1", null as fk_0, "root".fk as fk_1 from (select "root".pk as pk, "root".fk as fk, \'2018-01-01\' as "k_businessDate" from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "root") as "unionBase" left outer join (select "root".pk as pk, "root".fk as fk, \'2018-01-01\' as "k_businessDate" from X0 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "vx2_0" on ("unionBase".fk_0 = "vx2_0".pk or "unionBase".fk_1 = "vx2_0".pk) left outer join (select "unionalias_2".pk as pk, "unionalias_2"."Z1pk_Z2pk" as "Z1pk_Z2pk" from (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "from_z_1", null as "thru_z_1", "root".pk as pk, "root".pk as "Z1pk_Z2pk" from Z1 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".from_z as "from_z_1", "root".thru_z as "thru_z_1", "root".pk as pk, "root".pk as "Z1pk_Z2pk" from Z2 as "root" where "root".from_z <= \'2018-01-01\' and "root".thru_z > \'2018-01-01\') as "unionalias_2" where (coalesce("unionalias_2"."from_z_0", "unionalias_2"."from_z_1") <= \'2018-01-01\' and coalesce("unionalias_2"."thru_z_0", "unionalias_2"."thru_z_1") > \'2018-01-01\') or coalesce("unionalias_2"."from_z_0", "unionalias_2"."from_z_1", "unionalias_2"."thru_z_0", "unionalias_2"."thru_z_1") is null) as "unionalias_1" on ("vx2_0".fk = "unionalias_1".pk)', $result);   
}

###Pure
import meta::relational::tests::mapping::union::multipleChainedJoins::model::*;

Class <<temporal.businesstemporal>> meta::relational::tests::mapping::union::multipleChainedJoins::model::X
{
   pk : Integer[1];
}

Class <<temporal.businesstemporal>> meta::relational::tests::mapping::union::multipleChainedJoins::model::Y
{
   pk : Integer[1];
}

Class <<temporal.businesstemporal>> meta::relational::tests::mapping::union::multipleChainedJoins::model::Z
{
   pk : Integer[1];
}

Association meta::relational::tests::mapping::union::multipleChainedJoins::model::XY
{
   x : X[*];
   y : Y[*];
}

Association meta::relational::tests::mapping::union::multipleChainedJoins::model::YZ
{
   y : Y[*];
   z : Z[*];
}

###Relational
Database meta::relational::tests::mapping::union::multipleChainedJoins::store::multipleChainedJoinsDB
(
   Table X0(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table X1(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table X2(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table X3(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table Y0(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table Y1(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table Y2(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table Y3(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table Z0(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table Z1(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table Z2(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table Z3(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      pk INTEGER PRIMARY KEY, fk INTEGER, from_z DATE, thru_z DATE
   )
   
   Table A(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table B(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table C(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table D(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table E(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table F(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table G(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table H(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table I(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table J(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table K(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )

   Table L(
      milestoning(
         business(BUS_FROM = from_z, BUS_THRU = thru_z)
      )
      fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE
   )
   
   View VX1(
      pk: X0.pk PRIMARY KEY,
      fk: X0.fk
   )
   
   View VX1B(
      pk: X0.pk PRIMARY KEY,
      fk: X0.fk
   )
   
   View VX2(
      pk: X0.pk PRIMARY KEY,
      fk: X0.fk
   )   
   
   Join X0_Y0(X0.fk = Y0.fk)
   Join X0_A(X0.fk = A.fk0)
   Join X0_B(X0.fk = B.fk0)
   Join X0_D(X0.fk = D.fk0)
   Join X1_A(X1.fk = A.fk0)
   Join X2_B(X2.fk = B.fk0)
   Join X3_D(X3.fk = D.fk0) 
   Join A_Y0(A.fk1 = Y0.fk)
   Join A_Y1(A.fk1 = Y1.fk)
   Join C_Y0(C.fk1 = Y0.fk)
   Join C_Y2(C.fk1 = Y2.fk)
   Join F_Y0(F.fk1 = Y0.fk)
   Join F_Y3(F.fk1 = Y3.fk)
   Join Y0_Z0(Y0.fk = Z0.fk)
   Join Y0_G(Y0.fk = G.fk0)
   Join Y0_H(Y0.fk = H.fk0)
   Join Y0_J(Y0.fk = J.fk0)
   Join Y1_G(Y1.fk = G.fk0) 
   Join Y2_H(Y2.fk = H.fk0)
   Join Y3_J(Y3.fk = J.fk0)
   Join G_Z0(G.fk1 = Z0.fk)
   Join G_Z1(G.fk1 = Z1.fk)
   Join I_Z0(I.fk1 = Z0.fk)
   Join I_Z2(I.fk1 = Z2.fk)
   Join L_Z0(L.fk1 = Z0.fk)
   Join L_Z3(L.fk1 = Z3.fk)
   Join B_C(B.fk1 = C.fk0)
   Join D_E(D.fk1 = E.fk0)
   Join E_F(E.fk1 = F.fk0)
   Join H_I(H.fk1 = I.fk0)
   Join J_K(J.fk1 = K.fk0) 
   Join K_L(K.fk1 = L.fk0)
   Join VX1_VX2(VX1.fk = VX2.pk)
   Join VX1B_VX2(VX1B.fk = VX2.pk)
   Join VX2_Z1(VX2.fk = Z1.pk)
   Join VX2_Z2(VX2.fk = Z2.pk)
)

###Mapping
import meta::relational::tests::mapping::union::multipleChainedJoins::model::*;
import meta::relational::tests::mapping::union::multipleChainedJoins::store::*;

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::viewToViewToUnion
(
   
   Y[y] : Relational
   {
      pk : [multipleChainedJoinsDB]VX1.pk
   }
   
   *Z : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(z1, z2)
   }
   
   Z[z1] : Relational
   {
      pk : [multipleChainedJoinsDB]Z1.pk
   }
   
   Z[z2] : Relational
   {
      pk : [multipleChainedJoinsDB]Z2.pk
   }
      
   YZ : Relational
   {
      AssociationMapping
      (
         z[y, z1] : [multipleChainedJoinsDB]@VX1_VX2 > @VX2_Z1,
         z[y, z2] : [multipleChainedJoinsDB]@VX1_VX2 > @VX2_Z2
      )
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::unionOfViewsToViewToUnion
(
   
   Y[y1] : Relational
   {
      pk : [multipleChainedJoinsDB]VX1.pk
   }
   
   Y[y2] : Relational
   {
      pk : [multipleChainedJoinsDB]VX1B.pk
   }   
   
   *Y : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(y1, y2)
   }   
   
   *Z : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(z1, z2)
   }
   
   Z[z1] : Relational
   {
      pk : [multipleChainedJoinsDB]Z1.pk
   }
   
   Z[z2] : Relational
   {
      pk : [multipleChainedJoinsDB]Z2.pk
   }
      
   YZ : Relational
   {
      AssociationMapping
      (
         z[y1, z1] : [multipleChainedJoinsDB]@VX1_VX2 > @VX2_Z1,
         z[y1, z2] : [multipleChainedJoinsDB]@VX1_VX2 > @VX2_Z2,
         
         z[y2, z1] : [multipleChainedJoinsDB]@VX1B_VX2 > @VX2_Z1,
         z[y2, z2] : [multipleChainedJoinsDB]@VX1B_VX2 > @VX2_Z2
      )
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsMappingWithUnionAcross2SetsV1
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV1
   
   *X : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(x0, x1)
   }
   
   *Y : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(y0, y1)
   }
   
   *Z : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(z0, z1)
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsMappingWithUnionAcross2SetsV2
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV2

   *X : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(x0, x1)
   }

   *Y : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(y0, y1)
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsMappingWithUnionAcross2SetsV3
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV3

   *X : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(x0, x1)
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsMappingWithUnionAcross3SetsV1
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV1
   
   *X : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(x0, x1, x2)
   }
   
   *Y : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(y0, y1, y2)
   }
   
   *Z : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(z0, z1, z2)
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsMappingWithUnionAcross3SetsV2
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV2

   *X : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(x0, x1, x2)
   }

   *Y : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(y0, y1, y2)
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsMappingWithUnionAcross3SetsV3
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV3

   *X : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(x0, x1, x2)
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsMappingWithUnionAcross4SetsV1
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV1
   
   *X : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(x0, x1, x2, x3)
   }
   
   *Y : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(y0, y1, y2, y3)
   }
   
   *Z : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(z0, z1, z2, z3)
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsMappingWithUnionAcross4SetsV2
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV2

   *X : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(x0, x1, x2, x3)
   }

   *Y : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(y0, y1, y2, y3)
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsMappingWithUnionAcross4SetsV3
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV3

   *X : Operation
   {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(x0, x1, x2, x3)
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV1
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsClassMapping

   XY : Relational
   {
      AssociationMapping
      (
         x[y0, x0] : [multipleChainedJoinsDB]@X0_Y0,
         y[x0, y0] : [multipleChainedJoinsDB]@X0_Y0,

         x[y1, x1] : [multipleChainedJoinsDB]@A_Y1 > @X1_A,
         y[x1, y1] : [multipleChainedJoinsDB]@X1_A > @A_Y1,

         x[y2, x2] : [multipleChainedJoinsDB]@C_Y2 > @B_C > @X2_B,
         y[x2, y2] : [multipleChainedJoinsDB]@X2_B > @B_C > @C_Y2,

         x[y3, x3] : [multipleChainedJoinsDB]@F_Y3 > @E_F > @D_E > @X3_D,
         y[x3, y3] : [multipleChainedJoinsDB]@X3_D > @D_E > @E_F > @F_Y3
      )
   }

   YZ : Relational
   {
      AssociationMapping
      (
         y[z0, y0] : [multipleChainedJoinsDB]@Y0_Z0,
         z[y0, z0] : [multipleChainedJoinsDB]@Y0_Z0,

         y[z1, y1] : [multipleChainedJoinsDB]@G_Z1 > @Y1_G,
         z[y1, z1] : [multipleChainedJoinsDB]@Y1_G > @G_Z1,

         y[z2, y2] : [multipleChainedJoinsDB]@I_Z2 > @H_I > @Y2_H,
         z[y2, z2] : [multipleChainedJoinsDB]@Y2_H > @H_I > @I_Z2,

         y[z3, y3] : [multipleChainedJoinsDB]@L_Z3 > @K_L > @J_K > @Y3_J,
         z[y3, z3] : [multipleChainedJoinsDB]@Y3_J > @J_K > @K_L > @L_Z3
      )
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV2
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsClassMapping

   XY : Relational
   {
      AssociationMapping
      (
         x[y0, x0] : [multipleChainedJoinsDB]@X0_Y0,
         y[x0, y0] : [multipleChainedJoinsDB]@X0_Y0,

         x[y1, x1] : [multipleChainedJoinsDB]@A_Y1 > @X1_A,
         y[x1, y1] : [multipleChainedJoinsDB]@X1_A > @A_Y1,

         x[y2, x2] : [multipleChainedJoinsDB]@C_Y2 > @B_C > @X2_B,
         y[x2, y2] : [multipleChainedJoinsDB]@X2_B > @B_C > @C_Y2,

         x[y3, x3] : [multipleChainedJoinsDB]@F_Y3 > @E_F > @D_E > @X3_D,
         y[x3, y3] : [multipleChainedJoinsDB]@X3_D > @D_E > @E_F > @F_Y3
      )
   }

   YZ : Relational
   {
      AssociationMapping
      (
         y[z0, y0] : [multipleChainedJoinsDB]@Y0_Z0,
         z[y0, z0] : [multipleChainedJoinsDB]@Y0_Z0,

         y[z0, y1] : [multipleChainedJoinsDB]@G_Z0 > @Y1_G,
         z[y1, z0] : [multipleChainedJoinsDB]@Y1_G > @G_Z0,

         y[z0, y2] : [multipleChainedJoinsDB]@I_Z0 > @H_I > @Y2_H,
         z[y2, z0] : [multipleChainedJoinsDB]@Y2_H > @H_I > @I_Z0,

         y[z0, y3] : [multipleChainedJoinsDB]@L_Z0 > @K_L > @J_K > @Y3_J,
         z[y3, z0] : [multipleChainedJoinsDB]@Y3_J > @J_K > @K_L > @L_Z0
      )
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsAssociationMappingV3
(
   include meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsClassMapping

   XY : Relational
   {
      AssociationMapping
      (
         x[y0, x0] : [multipleChainedJoinsDB]@X0_Y0,
         y[x0, y0] : [multipleChainedJoinsDB]@X0_Y0,

         x[y0, x1] : [multipleChainedJoinsDB]@A_Y0 > @X1_A,
         y[x1, y0] : [multipleChainedJoinsDB]@X1_A > @A_Y0,

         x[y0, x2] : [multipleChainedJoinsDB]@C_Y0 > @B_C > @X2_B,
         y[x2, y0] : [multipleChainedJoinsDB]@X2_B > @B_C > @C_Y0,

         x[y0, x3] : [multipleChainedJoinsDB]@F_Y0 > @E_F > @D_E > @X3_D,
         y[x3, y0] : [multipleChainedJoinsDB]@X3_D > @D_E > @E_F > @F_Y0
      )
   }

   YZ : Relational
   {
      AssociationMapping
      (
         y[z0, y0] : [multipleChainedJoinsDB]@Y0_Z0,
         z[y0, z0] : [multipleChainedJoinsDB]@Y0_Z0
      )
   }
)

Mapping meta::relational::tests::mapping::union::multipleChainedJoins::mapping::multipleChainedJoinsClassMapping
(     
   *X[x0] : Relational
   {
      pk : [multipleChainedJoinsDB]X0.pk
   }
   
   X[x1] : Relational
   {
      pk : [multipleChainedJoinsDB]X1.pk
   }
   
   X[x2] : Relational
   {
      pk : [multipleChainedJoinsDB]X2.pk
   }
   
   X[x3] : Relational
   {
      pk : [multipleChainedJoinsDB]X3.pk
   }
      
   *Y[y0] : Relational
   {
      pk : [multipleChainedJoinsDB]Y0.pk
   }      
   
   Y[y1] : Relational
   {
      pk : [multipleChainedJoinsDB]Y1.pk
   }
   
   Y[y2] : Relational
   {
      pk : [multipleChainedJoinsDB]Y2.pk
   }
   
   Y[y3] : Relational
   {
      pk : [multipleChainedJoinsDB]Y3.pk
   }
   
   *Z[z0] : Relational
   {
      pk : [multipleChainedJoinsDB]Z0.pk
   }   
      
   Z[z1] : Relational
   {
      pk : [multipleChainedJoinsDB]Z1.pk
   }
   
   Z[z2] : Relational
   {
      pk : [multipleChainedJoinsDB]Z2.pk
   }
   
   Z[z3] : Relational
   {
      pk : [multipleChainedJoinsDB]Z3.pk
   }
)

###Pure
import meta::relational::metamodel::execute::*;
import meta::relational::tests::mapping::union::multipleChainedJoins::store::*;
import meta::relational::runtime::*;
import meta::pure::runtime::*;

function <<test.BeforePackage>> meta::relational::tests::mapping::union::multipleChainedJoins::setup():Runtime[1]
{
   let connection = meta::relational::tests::testRuntime(multipleChainedJoinsDB).connections->toOne()->cast(@TestDatabaseConnection);
  
   executeInDb('drop table if exists X0;', $connection);
   executeInDb('create table X0 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into X0 values(10, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into X0 values(10, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists X1;', $connection);
   executeInDb('create table X1 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into X1 values(11, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into X1 values(11, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists X2;', $connection);
   executeInDb('create table X2 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into X2 values(12, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into X2 values(12, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists X3;', $connection);
   executeInDb('create table X3 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into X3 values(13, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into X3 values(13, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists Y0;', $connection);
   executeInDb('create table Y0 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into Y0 values(20, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into Y0 values(20, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists Y1;', $connection);
   executeInDb('create table Y1 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into Y1 values(21, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into Y1 values(21, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists Y2;', $connection);
   executeInDb('create table Y2 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into Y2 values(22, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into Y2 values(22, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists Y3;', $connection);
   executeInDb('create table Y3 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into Y3 values(23, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into Y3 values(23, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists Z0;', $connection);
   executeInDb('create table Z0 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into Z0 values(30, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into Z0 values(30, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists Z1;', $connection);
   executeInDb('create table Z1 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into Z1 values(31, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into Z1 values(31, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists Z2;', $connection);
   executeInDb('create table Z2 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into Z2 values(32, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into Z2 values(32, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists Z3;', $connection);
   executeInDb('create table Z3 (pk INTEGER, fk INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into Z3 values(33, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into Z3 values(33, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists A;',$connection);
   executeInDb('create table A(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into A values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into A values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists B;',$connection);
   executeInDb('create table B(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into B values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into B values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists C;',$connection);
   executeInDb('create table C(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into C values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into C values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists D;',$connection);
   executeInDb('create table D(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into D values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into D values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists E;',$connection);
   executeInDb('create table E(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into E values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into E values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists F;',$connection);
   executeInDb('create table F(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into F values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into F values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists G;',$connection);
   executeInDb('create table G(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into G values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into G values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists H;',$connection);
   executeInDb('create table H(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into H values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into H values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists I;',$connection);
   executeInDb('create table I(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into I values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into I values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists J;',$connection);
   executeInDb('create table J(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into J values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into J values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists K;',$connection);
   executeInDb('create table K(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into K values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into K values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   executeInDb('drop table if exists L;',$connection);
   executeInDb('create table L(fk0 INTEGER, fk1 INTEGER, from_z DATE, thru_z DATE)', $connection);
   executeInDb('insert into L values(111, 111, \'2015-1-1\', \'2017-1-1\');', $connection);
   executeInDb('insert into L values(111, 111, \'2017-1-1\', \'9999-12-31\');', $connection);
   
   ^Runtime(connections = $connection);
}
