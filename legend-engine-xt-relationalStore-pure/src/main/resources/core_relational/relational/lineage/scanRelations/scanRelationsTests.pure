// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::lineage::scanRelations::*;
import meta::pure::router::extension::*;
import meta::relational::metamodel::join::*;
import meta::relational::functions::database::*;
import meta::pure::graphFetch::execution::*;
import meta::relational::tests::model::simple::*;

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTree_Inheritance_1():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> project([f|$f.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).owner.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Bicycle).owner.name],
                                                                          ['Person','Car Owner','Bicycle Owner'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [b_PersonID]\n' +
                  '    ------> (t) Car(PersonCar) [ID, c_PersonID]\n' +
                  '      ------> (t) Owner(CarOwner) [VEHICLE_ID, name]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions())-> toOne();

   let expected1 = 'root\n' +
                   '  ------> (t) Person [ID, name]\n' +
                   '    ------> (t) Bicycle(equal_PersonID_Bicycleb_PersonID) [b_PersonID]\n' +
                   '    ------> (t) Car(equal_PersonID_Carc_PersonID) [ID, c_PersonID]\n' +
                   '      ------> (t) Owner(equal_CarID_OwnerVEHICLE_ID) [VEHICLE_ID, name]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTree_Inheritance_2():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> project([f|$f.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).engineType,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Bicycle).person.name],
                                                                          ['Person','Engine Type','Bicycle Person'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();

   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [b_PersonID]\n' +
                  '      ------> (t) Person(PersonBicycle) [ID, name]\n' +
                  '    ------> (t) Car(PersonCar) [c_PersonID, engineType]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) Person [ID, name]\n' +
                   '    ------> (t) Bicycle(equal_PersonID_Bicycleb_PersonID) [b_PersonID]\n' +
                   '      ------> (t) Person(equal_PersonID_Bicycleb_PersonID) [ID, name]\n' +
                   '    ------> (t) Car(equal_PersonID_Carc_PersonID) [c_PersonID, engineType]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeMultiJoin():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> project([f|$f.name, f|$f.vehicles.description], ['Person','Description'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [b_Description, b_PersonID]\n' +
                  '    ------> (t) Car(PersonCar) [c_Description, c_PersonID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions())-> toOne();
   let expected1 =  'root\n' +
                    '  ------> (t) Person [ID, name]\n' +
                    '    ------> (t) Bicycle(or_equal_PersonID_s(Bicycleb_PersonID_SQLNull_Bicycleb_Description,Bicycle,)s(SQLNull_Carc_PersonID_Carc_Description,Car,)b_PersonID_0_equal_PersonID_SQLNull) [b_Description, b_PersonID]\n' +
                    '    ------> (t) Car(or_equal_PersonID_SQLNull_equal_PersonID_s(Bicycleb_PersonID_SQLNull_Bicycleb_Description,Bicycle,)s(SQLNull_Carc_PersonID_Carc_Description,Car,)c_PersonID_1) [c_Description, c_PersonID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testConstant():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> project([f|'constant'], ['col'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions())-> toOne();

   let expected = 'root\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let expectedWithJustTable =  'root\n' +
                                '  ------> (t) Person []\n';
   assertEquals($expectedWithJustTable, $relationTreeFromPureToSQL-> relationTreeAsString());
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSelectOnLeftSide():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> filter(p|$p.name == 'ok' && $p.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).owner.name == 'test').name};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());

   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [b_PersonID]\n' +
                  '    ------> (t) Car(PersonCar) [ID, c_PersonID]\n' +
                  '      ------> (t) Owner(CarOwner) [VEHICLE_ID, name]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let expected2 = 'root\n' +
                   '  ------> (t) Person [ID, name]\n' +
                   '    ------> (t) Car(equal_PersonID_Carc_PersonID) [ID, c_PersonID]\n' +
                   '      ------> (t) Owner(equal_CarID_OwnerVEHICLE_ID) [VEHICLE_ID, name]\n';
   assertEquals($expected2, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeTwoFilters():Boolean[1]
{
   let query = {|meta::relational::tests::model::inheritance::Person.all()-> filter(x|$x.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).owner.name != 'x')
                                                                -> filter(x|$x.bicycles.id != 'okok')
                                                                -> project([f|$f.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Car).owner.name,
                                                                           f|$f.vehicles-> subType(@meta::relational::tests::model::inheritance::Bicycle).owner.name],
                                                                          ['Person','Car Owner','Bicycle Owner'])};
   let mapping = meta::relational::tests::mapping::inheritance::relational::inheritanceMappingDB;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) Person [ID, name]\n' +
                  '    ------> (t) Bicycle(PersonBicycle) [ID, b_PersonID]\n' +
                  '    ------> (t) Car(PersonCar) [ID, c_PersonID]\n' +
                  '      ------> (t) Owner(CarOwner) [VEHICLE_ID, name]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) Person [ID, name]\n' +
                   '    ------> (t) Bicycle(equal_PersonID_Bicycleb_PersonID) [ID, b_PersonID]\n' +
                   '    ------> (t) Car(equal_PersonID_Carc_PersonID) [ID, c_PersonID]\n' +
                   '      ------> (t) Owner(equal_CarID_OwnerVEHICLE_ID) [VEHICLE_ID, name]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeQualifier():Boolean[1]
{
   let query = {|Trade.all()-> project([t|$t.product.name, t|$t.product->toOne().synonymByType(ProductSynonymType.CUSIP).name],['prodName', 'synName'])};
   let mapping = meta::relational::tests::simpleRelationalMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) tradeTable [prodId]\n' +
                  '    ------> (t) productTable(Trade_Product) [ID, NAME]\n' +
                  '      ------> (t) synonymTable(Product_Synonym) [NAME, PRODID, TYPE]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) tradeTable [prodId]\n' +
                   '    ------> (t) productTable(equal_tradeTableprodId_productTableID) [ID, NAME]\n' +
                   '      ------> (t) synonymTable(equal_s(synonymTablePRODID_synonymTableNAME,synonymTable,equal_synonymTableTYPE_CUSIP)PRODID_productTableID) [NAME, PRODID, TYPE]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeWithMappingFilter():Boolean[1]
{
   let query = {|Person.all()-> project([p|$p.firstName], ['c1'])};
   let mapping = meta::relational::tests::mapping::filter::filterMappingWithJoinInFilterAndProperty;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) personTable [FIRMID, FIRSTNAME]\n' +
                  '    ------> (t) firmTable(Firm_Person) [ID, LEGALNAME]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions())-> toOne();
   let expected1 = 'root\n' +
                   '  ------> (t) personTable [FIRMID, FIRSTNAME]\n' +
                   '    ------> (t) firmTable(equal_firmTableID_personTableFIRMID) [ID, LEGALNAME]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeMilestoning():Boolean[1]
{
   let query = {|meta::relational::tests::milestoning::Order.all()-> project(o|$o.biTemporalProduct(%2017-6-10, %2017-6-9).biTemporalClassification(%2017-6-11, %2017-6-10).type, 'type')};
   let mapping = meta::relational::tests::milestoning::latestbitemporalmap;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) OrderTable [prodFk]\n' +
                  '    ------> (t) BiTemporalProductTableWithLatest(Order_BiTemporalProductWithLatest) [id, type]\n' +
                  '      ------> (t) BiTemporalProductClassificationTableWithLatest(BiTemporalProductWithLatest_BiTemporalClassificationWithLatest) [type]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) OrderTable [prodFk]\n' +
                   '    ------> (t) BiTemporalProductTableWithLatest(equal_OrderTableprodFk_BiTemporalProductTableWithLatestid) [from_z, id, in_z, out_z, thru_z, type]\n' +
                   '      ------> (t) BiTemporalProductClassificationTableWithLatest(equal_BiTemporalProductTableWithLatesttype_s(BiTemporalProductClassificationTableWithLatesttype,BiTemporalProductClassificationTableWithLatest,group_and_and_lessThanEqual_BiTemporalProductClassificationTableWithLatestin_z_2017-06-11_greaterThan_BiTemporalProductClassificationTableWithLatestout_z_2017-06-11_and_lessThanEqual_BiTemporalProductClassificationTableWithLatestfrom_z_2017-06-10_greaterThan_BiTemporalProductClassificationTableWithLatestthru_z_2017-06-10)type) [from_z, in_z, out_z, thru_z, type]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeMilestoning_ChainJoins():Boolean[1]
{
   let query = {|meta::relational::tests::milestoning::Order.all()-> project([o|$o.biTemporalProduct(%2017-6-10, %2017-6-9).biTemporalClassification(%2017-6-11, %2017-6-10).type, o|$o.systemADescription(%2017-6-10).description], ['type', 'description'])};
   let mapping = meta::relational::tests::milestoning::milestoningmap;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
      '  ------> (t) OrderTable [id, prodFk]\n' +
      '    ------> (t) BiTemporalProductTable(Order_BiTemporalProduct) [id, type]\n' +
      '      ------> (t) BiTemporalProductClassificationTable(BiTemporalProduct_BiTemporalClassification) [type]\n' +
      '    ------> (t) OrderToSystemADescriptions(Order_OrderToSystemADescriptions) [orderId, systemADescriptionId]\n' +
      '      ------> (t) SystemAOrderDescriptionTable(OrderToSystemADescriptions_SystemAOrderDescriptionTable) [description, descriptionId]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) OrderTable [id, prodFk]\n' +
                   '    ------> (t) BiTemporalProductTable(equal_OrderTableprodFk_BiTemporalProductTableid) [from_z, id, in_z, out_z, thru_z, type]\n' +
                   '      ------> (t) BiTemporalProductClassificationTable(equal_BiTemporalProductTabletype_s(BiTemporalProductClassificationTabletype,BiTemporalProductClassificationTable,group_and_and_lessThanEqual_BiTemporalProductClassificationTablein_z_2017-06-11_greaterThan_BiTemporalProductClassificationTableout_z_2017-06-11_and_lessThanEqual_BiTemporalProductClassificationTablefrom_z_2017-06-10_greaterThan_BiTemporalProductClassificationTablethru_z_2017-06-10)type) [from_z, in_z, out_z, thru_z, type]\n' +
                   '    ------> (t) OrderToSystemADescriptions(equal_OrderTableid_OrderToSystemADescriptionsorderId) [from_z, orderId, systemADescriptionId, thru_z]\n' +
                   '      ------> (t) SystemAOrderDescriptionTable(equal_OrderToSystemADescriptionssystemADescriptionId_SystemAOrderDescriptionTabledescriptionId) [description, descriptionId]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableTreeMilestoningWithLet():Boolean[1]
{
   let query = {|let date1 = %2017-6-10;
                 let date2 = %2017-6-9;
                 meta::relational::tests::milestoning::Order.all()-> project(o|$o.biTemporalProduct($date1, $date2).biTemporalClassification(%2017-6-11, $date1).type, 'type');};
   let mapping = meta::relational::tests::milestoning::latestbitemporalmap;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) OrderTable [prodFk]\n' +
                  '    ------> (t) BiTemporalProductTableWithLatest(Order_BiTemporalProductWithLatest) [id, type]\n' +
                  '      ------> (t) BiTemporalProductClassificationTableWithLatest(BiTemporalProductWithLatest_BiTemporalClassificationWithLatest) [type]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (t) OrderTable [prodFk]\n' +
                   '    ------> (t) BiTemporalProductTableWithLatest(equal_OrderTableprodFk_BiTemporalProductTableWithLatestid) [from_z, id, in_z, out_z, thru_z, type]\n' +
                   '      ------> (t) BiTemporalProductClassificationTableWithLatest(equal_BiTemporalProductTableWithLatesttype_s(BiTemporalProductClassificationTableWithLatesttype,BiTemporalProductClassificationTableWithLatest,group_and_and_lessThanEqual_BiTemporalProductClassificationTableWithLatestin_z_2017-06-11_greaterThan_BiTemporalProductClassificationTableWithLatestout_z_2017-06-11_and_lessThanEqual_BiTemporalProductClassificationTableWithLatestfrom_z_2017-06-10_greaterThan_BiTemporalProductClassificationTableWithLatestthru_z_2017-06-10)type) [from_z, in_z, out_z, thru_z, type]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnion():Boolean[1]
{
   let query = {|Firm.all()-> project([p|$p.legalName, p|$p.employees.name], ['Firm','Employee'])};
   let mapping = meta::relational::tests::mapping::union::unionMappingWithSameJoinInPropertyInBothUnions;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonMaster(PersonMasterFirmSet1) [FirmID, firstName, lastName]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n' +
                  '    ------> (t) PersonMaster(PersonMasterFirmSet2) [FirmID, firstName, lastName]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonMaster [FirmID, ID, firstName, lastName]\n' +
                  '    ------> (t) PersonMaster [FirmID, ID, firstName, lastName]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n' +
                  '    ------> (t) PersonMaster [FirmID, ID, firstName, lastName]\n' +
                  '    ------> (t) PersonMaster [FirmID, ID, firstName, lastName]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionWithJoinToOneTable():Boolean[1]
{
   let query = {|Firm.all()-> project([p|$p.legalName, p|$p.employees.name], ['Firm','EmployeeName'])};
   let mapping = meta::relational::tests::mapping::union::unionToUnionMapping3;

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonSet1 [FirmID, firstName_s1, lastName_s1]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionToUnion():Boolean[1]
{
   let query = {|Firm.all()-> project([p|$p.legalName, p|$p.bridge.employees.name], ['Firm','Employee'])};
   let mapping = meta::relational::tests::mapping::union::unionMappingWithEmbeddedProperty2;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonSet1(PersonSet1FirmSet1) [FirmID, firstName_s1, lastName_s1]\n' +
                  '    ------> (t) PersonSet2(PersonSet2FirmSet1) [FirmID, firstName_s2, lastName_s2]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n' +
                  '    ------> (t) PersonSet1(PersonSet1FirmSet2) [FirmID, firstName_s1, lastName_s1]\n' +
                  '    ------> (t) PersonSet2(PersonSet2FirmSet2) [FirmID, firstName_s2, lastName_s2]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) PersonSet1 [FirmID, ID, firstName_s1, lastName_s1]\n' +
                  '    ------> (t) PersonSet2 [FirmID, ID, firstName_s2, lastName_s2]\n' +
                  '  ------> (t) FirmSet2 [ID, name]\n' +
                  '    ------> (t) PersonSet1 [FirmID, ID, firstName_s1, lastName_s1]\n' +
                  '    ------> (t) PersonSet2 [FirmID, ID, firstName_s2, lastName_s2]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionToUnionMultiple():Boolean[1]
{
   let query = {|Person.all()-> project([p|$p.lastName, p|$p.firm.legalName, p|$p.address.name], ['Person','Firm', 'Employee'])};
   let mapping = meta::relational::tests::mapping::union::unionToUnionMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '    ------> (t) AddressSet1(PersonSet1AddressSet1) [ID, name]\n' +
                  '    ------> (t) AddressSet2(PersonSet1AddressSet2) [ID, name]\n' +
                  '    ------> (t) FirmSet1(PersonSet1FirmSet1) [ID, name]\n' +
                  '    ------> (t) FirmSet2(PersonSet1FirmSet2) [ID, name]\n' +
                  '  ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '    ------> (t) AddressSet1(PersonSet2AddressSet1) [ID, name]\n' +
                  '    ------> (t) AddressSet2(PersonSet2AddressSet2) [ID, name]\n' +
                  '    ------> (t) FirmSet1(PersonSet2FirmSet1) [ID, name]\n' +
                  '    ------> (t) FirmSet2(PersonSet2FirmSet2) [ID, name]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) PersonSet1 [FirmID, ID, lastName_s1]\n' +
                  '    ------> (t) AddressSet1 [ID, name]\n' +
                  '    ------> (t) AddressSet2 [ID, name]\n' +
                  '    ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) FirmSet2 [ID, name]\n' +
                  '  ------> (t) PersonSet2 [FirmID, ID, lastName_s2]\n' +
                  '    ------> (t) AddressSet1 [ID, name]\n' +
                  '    ------> (t) AddressSet2 [ID, name]\n' +
                  '    ------> (t) FirmSet1 [ID, name]\n' +
                  '    ------> (t) FirmSet2 [ID, name]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionToUnionMultipleLevels():Boolean[1]
{
   let query = {|Person.all()-> project([p|$p.lastName, p|$p.firm.legalName, p|$p.firm.employees.lastName, p|$p.address.name], ['Person','Firm','Colleague','Employee'])};
   let mapping = meta::relational::tests::mapping::union::unionToUnionMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '    ------> (t) AddressSet1(PersonSet1AddressSet1) [ID, name]\n' +
                  '    ------> (t) AddressSet2(PersonSet1AddressSet2) [ID, name]\n' +
                  '    ------> (t) FirmSet1(PersonSet1FirmSet1) [ID, name]\n' +
                  '      ------> (t) PersonSet1(PersonSet1FirmSet1) [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2(PersonSet2FirmSet1) [FirmID, lastName_s2]\n' +
                  '    ------> (t) FirmSet2(PersonSet1FirmSet2) [ID, name]\n' +
                  '      ------> (t) PersonSet1(PersonSet1FirmSet2) [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2(PersonSet2FirmSet2) [FirmID, lastName_s2]\n' +
                  '  ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '    ------> (t) AddressSet1(PersonSet2AddressSet1) [ID, name]\n' +
                  '    ------> (t) AddressSet2(PersonSet2AddressSet2) [ID, name]\n' +
                  '    ------> (t) FirmSet1(PersonSet2FirmSet1) [ID, name]\n' +
                  '      ------> (t) PersonSet1(PersonSet1FirmSet1) [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2(PersonSet2FirmSet1) [FirmID, lastName_s2]\n' +
                  '    ------> (t) FirmSet2(PersonSet2FirmSet2) [ID, name]\n' +
                  '      ------> (t) PersonSet1(PersonSet1FirmSet2) [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2(PersonSet2FirmSet2) [FirmID, lastName_s2]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) PersonSet1 [FirmID, ID, lastName_s1]\n' +
                  '    ------> (t) AddressSet1 [ID, name]\n' +
                  '    ------> (t) AddressSet2 [ID, name]\n' +
                  '    ------> (t) FirmSet1 [ID, name]\n' +
                  '      ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '    ------> (t) FirmSet2 [ID, name]\n' +
                  '      ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '  ------> (t) PersonSet2 [FirmID, ID, lastName_s2]\n' +
                  '    ------> (t) AddressSet1 [ID, name]\n' +
                  '    ------> (t) AddressSet2 [ID, name]\n' +
                  '    ------> (t) FirmSet1 [ID, name]\n' +
                  '      ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2 [FirmID, lastName_s2]\n' +
                  '    ------> (t) FirmSet2 [ID, name]\n' +
                  '      ------> (t) PersonSet1 [FirmID, lastName_s1]\n' +
                  '      ------> (t) PersonSet2 [FirmID, lastName_s2]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionToSameTableWithDiffKeys():Boolean[1]
{
   let query = {|Firm.all()-> project([f|$f.legalName, f|$f.employees.firstName], ['legalName','employee_firstname'])};
   let mapping = meta::relational::tests::mapping::union::unionToUnionMappingWithJoinToSameTableWithDiffKeys;

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) Firm [ID, name]\n' +
                  '    ------> (t) PersonSet4(equal_s(PersonSet4FirmID_1_PersonSet4firstName_s1,PersonSet4,)s(PersonSet4FirmID_2_PersonSet4firstName_s1,PersonSet4,)firmId_FirmID) [FirmID_1, firstName_s1]\n' +
                  '    ------> (t) PersonSet4(equal_s(PersonSet4FirmID_1_PersonSet4firstName_s1,PersonSet4,)s(PersonSet4FirmID_2_PersonSet4firstName_s1,PersonSet4,)firmId_FirmID) [FirmID_2, firstName_s1]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString(true));
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSimpleViewRoot():Boolean[1]
{

   let query = {|OrderPnl.all()->project(#/OrderPnl/pnl#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (v) orderPnlView [pnl]\n' +
                  '    root\n' +
                  '      ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '        ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '          ------> (t) accountTable(Order_Account) [ID]\n' +
                  '          ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (v) orderPnlView [pnl]\n' +
                   '    root\n' +
                   '      ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                   '        ------> (t) orderTable(equal_orderPnlTableORDER_ID_orderTableID) [ID, accountID]\n' +
                   '          ------> (t) accountTable(equal_orderTableaccountID_accountTableID) [ID]\n' +
                   '          ------> (t) salesPersonTable(equal_orderTableaccountID_salesPersonTableACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSimpleViewRootToJoin():Boolean[1]
{

   let query = {|OrderPnl.all()->project([#/OrderPnl/pnl#, #/OrderPnl/order/settlementDateTime#])};
   let mapping = meta::relational::tests::simpleRelationalMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (v) orderPnlView [ORDER_ID, pnl]\n' +
                  '    ------> (t) orderTable(OrderPnlView_Order) [ID, settlementDateTime]\n' +
                  '    root\n' +
                  '      ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '        ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '          ------> (t) accountTable(Order_Account) [ID]\n' +
                  '          ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 = 'root\n' +
                   '  ------> (v) orderPnlView [ORDER_ID, pnl]\n' +
                   '    ------> (t) orderTable(equal_orderPnlViewORDER_ID_orderTableID) [ID, settlementDateTime]\n' +
                   '    root\n' +
                   '      ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                   '        ------> (t) orderTable(equal_orderPnlTableORDER_ID_orderTableID) [ID, accountID]\n' +
                   '          ------> (t) accountTable(equal_orderTableaccountID_accountTableID) [ID]\n' +
                   '          ------> (t) salesPersonTable(equal_orderTableaccountID_salesPersonTableACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}


function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSimpleTableToViewJoin():Boolean[1]
{

   let query = {|Order.all()->project([o|$o.id, o|$o.pnl], ['ID', 'PNL'])};
   let mapping = meta::relational::tests::simpleRelationalMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) orderTable [ID]\n' +
                  '    ------> (v) orderPnlView(OrderPnlView_Order) [ORDER_ID, pnl]\n' +
                  '      root\n' +
                  '        ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '          ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '            ------> (t) accountTable(Order_Account) [ID]\n' +
                  '            ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) orderTable [ID]\n' +
                  '    ------> (v) orderPnlView(equal_orderPnlViewORDER_ID_orderTableID) [ORDER_ID, pnl]\n' +
                  '      root\n' +
                  '        ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '          ------> (t) orderTable(equal_orderPnlTableORDER_ID_orderTableID) [ID, accountID]\n' +
                  '            ------> (t) accountTable(equal_orderTableaccountID_accountTableID) [ID]\n' +
                  '            ------> (t) salesPersonTable(equal_orderTableaccountID_salesPersonTableACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testUnionViewOnView():Boolean[1]
{

   let query = {|OrderPnl.all()->project([#/OrderPnl/pnl#, #/OrderPnl/order/settlementDateTime#])};
   let mapping = meta::relational::tests::projection::view::unionOnViewOnViewMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (v) orderNegativePnlViewOnView [ORDER_ID, pnl]\n' +
                  '    ------> (t) orderTable(OrderNegativePnlViewOnView_Order) [ID, settlementDateTime]\n' +
                  '    root\n' +
                  '      ------> (v) orderNegativePnlView [ORDER_ID, pnl]\n' +
                  '        root\n' +
                  '          ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '            ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '              ------> (t) accountTable(Order_Account) [ID]\n' +
                  '              ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n' +
                  '  ------> (v) orderPnlViewOnView [ORDER_ID, pnl]\n' +
                  '    ------> (t) orderTable(OrderPnlViewOnView_Order) [ID, settlementDateTime]\n' +
                  '    root\n' +
                  '      ------> (v) orderPnlView [ORDER_ID, pnl]\n' +
                  '        root\n' +
                  '          ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '            ------> (t) orderTable(OrderPnlTable_Order) [ID, accountID]\n' +
                  '              ------> (t) accountTable(Order_Account) [ID]\n' +
                  '              ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (v) orderNegativePnlViewOnView [ORDER_ID, pnl]\n' +
                  '    ------> (t) orderTable(or_equal_SQLNull_orderTableID_equal_s(orderPnlViewOnViewORDER_ID_SQLNull_orderPnlViewOnViewpnl,orderPnlViewOnView,)s(SQLNull_orderNegativePnlViewOnViewORDER_ID_orderNegativePnlViewOnViewpnl,orderNegativePnlViewOnView,)ORDER_ID_1_orderTableID) [ID, settlementDateTime]\n' +
                  '    root\n' +
                  '      ------> (v) orderNegativePnlView [ORDER_ID, pnl]\n' +
                  '        root\n' +
                  '          ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '            ------> (t) orderTable(equal_orderPnlTableORDER_ID_orderTableID) [ID, accountID]\n' +
                  '              ------> (t) accountTable(equal_orderTableaccountID_accountTableID) [ID]\n' +
                  '              ------> (t) salesPersonTable(equal_orderTableaccountID_salesPersonTableACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n' +
                  '  ------> (v) orderPnlViewOnView [ORDER_ID, pnl]\n' +
                  '    ------> (t) orderTable(or_equal_s(orderPnlViewOnViewORDER_ID_SQLNull_orderPnlViewOnViewpnl,orderPnlViewOnView,)s(SQLNull_orderNegativePnlViewOnViewORDER_ID_orderNegativePnlViewOnViewpnl,orderNegativePnlViewOnView,)ORDER_ID_0_orderTableID_equal_SQLNull_orderTableID) [ID, settlementDateTime]\n' +
                  '    root\n' +
                  '      ------> (v) orderPnlView [ORDER_ID, pnl]\n' +
                  '        root\n' +
                  '          ------> (t) orderPnlTable [ORDER_ID, pnl]\n' +
                  '            ------> (t) orderTable(equal_orderPnlTableORDER_ID_orderTableID) [ID, accountID]\n' +
                  '              ------> (t) accountTable(equal_orderTableaccountID_accountTableID) [ID]\n' +
                  '              ------> (t) salesPersonTable(equal_orderTableaccountID_salesPersonTableACCOUNT_ID) [ACCOUNT_ID, NAME, PERSON_ID]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testViewEmbeddedInChainedJoin():Boolean[1]
{

   let query = {|Order.all()->project([o|$o.id, o|$o.pnlContact.firm.legalName], ['ID', 'PNL'])};
   let mapping = meta::relational::tests::MappingWithInnerJoinAndEmbeddedMapping;

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   let expected = 'root\n' +
                  '  ------> (t) orderTable [ID, accountID]\n' +
                  '    ------> (t) salesPersonTable(Order_SalesPerson) [ACCOUNT_ID, PERSON_ID]\n' +
                  '      ------> (v) PersonFirmView(SalesPerson_PersonView) [PERSON_ID, firm_name]\n' +
                  '        root\n' +
                  '          ------> (t) personTable [FIRMID, ID, LASTNAME]\n' +
                  '            ------> (t) firmTable(Firm_Person) [ID, LEGALNAME]\n';
   assertEquals($expected, $relationTree-> relationTreeAsString());

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected1 ='root\n' +
                  '  ------> (t) orderTable [ID, accountID]\n' +
                  '    ------> (t) salesPersonTable(equal_orderTableaccountID_s(salesPersonTableACCOUNT_ID_PersonFirmViewfirm_name,salesPersonTable_SalesPerson_PersonView,)ACCOUNT_ID) [ACCOUNT_ID, PERSON_ID]\n' +
                  '      ------> (v) PersonFirmView(equal_salesPersonTablePERSON_ID_PersonFirmViewPERSON_ID) [PERSON_ID, firm_name]\n' +
                  '        root\n' +
                  '          ------> (t) personTable [FIRMID, ID, LASTNAME]\n' +
                  '            ------> (t) firmTable(equal_firmTableID_personTableFIRMID) [ID, LEGALNAME]\n';
   assertEquals($expected1, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testSameRelationsAtSameLevel():Boolean[1]
{
   let query = {|meta::relational::tests::mapping::union::sqlQueryMerging::model::A.all()->filter(a|$a.p3 == 'A')->project([a|$a.pk, a|$a.p1, a|$a.p2], ['a_pk', 'a_p1', 'a_p3'])};
   let mapping = meta::relational::tests::mapping::union::sqlQueryMerging::mapping::unionMapping;

   let relationTreeFromPureToSQL = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, meta::relational::tests::testRuntime(), defaultRelationalExtensions());
   let expected = 'root\n'+
                  '  ------> (t) aTable1 [fk, pk]\n'+
                  '    ------> (t) bTable1(equal_aTable1fk_s(bTable1fk_cTable1c1,bTable1_B1C1_1,)fk) [fk]\n'+
                  '      ------> (t) cTable1(and_equal_bTable1fk_cTable1fk_equal_cTable1fk_8) [c1, fk]\n'+
                  '    ------> (t) bTable1(equal_aTable1fk_s(bTable1fk_cTable1c2,bTable1_B1C1_2,)fk) [fk]\n'+
                  '      ------> (t) cTable1(and_equal_bTable1fk_cTable1fk_equal_cTable1fk_9) [c2, fk]\n'+
                  '    ------> (t) bTable1(equal_aTable1fk_s(bTable1fk_dTable1pk,bTable1_B1C1_2_C1D1,)fk) [fk]\n'+
                  '      ------> (t) cTable1(and_equal_bTable1fk_cTable1fk_equal_cTable1fk_9) [fk]\n'+
                  '        ------> (t) dTable1(equal_cTable1fk_dTable1fk) [fk, pk]\n'+
                  '  ------> (t) aTable2 [fk, pk]\n'+
                  '    ------> (t) bTable2(equal_aTable2fk_s(bTable2fk_cTable2c1,bTable2_B2C2_1,)fk) [fk]\n'+
                  '      ------> (t) cTable2(and_equal_bTable2fk_cTable2fk_equal_cTable2fk_8) [c1, fk]\n'+
                  '    ------> (t) bTable2(equal_aTable2fk_s(bTable2fk_cTable2c2,bTable2_B2C2_2,)fk) [fk]\n'+
                  '      ------> (t) cTable2(and_equal_bTable2fk_cTable2fk_equal_cTable2fk_9) [c2, fk]\n'+
                  '    ------> (t) bTable2(equal_aTable2fk_s(bTable2fk_dTable2pk,bTable2_B2C2_2_C2D2,)fk) [fk]\n'+
                  '      ------> (t) cTable2(and_equal_bTable2fk_cTable2fk_equal_cTable2fk_9) [fk]\n'+
                  '        ------> (t) dTable2(equal_cTable2fk_dTable2fk) [fk, pk]\n';
   assertEquals($expected, $relationTreeFromPureToSQL-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testFunctionWithGraphFetch():Boolean[1]
{

   let query = {|Trade.all()->graphFetch(#{
      Trade {
         id,
         product {
            name,
            synonymByType(ProductSynonymType.CUSIP) {
               typeAsString,
               name
            }
         }
      }
   }#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   assertEquals(
      'root\n'+
      '  ------> (t) tradeTable [ID, prodId]\n'+
      '    ------> (t) productTable(Trade_Product) [ID, NAME]\n'+
      '      ------> (t) synonymTable(Product_Synonym) [NAME, PRODID, TYPE]\n', $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testFunctionWithGraphFetchNoDefaults():Boolean[1]
{

   let query = {|Trade.all()->graphFetch(#{
      Trade {
         id,
         product {
            name,
            synonymByType(ProductSynonymType.CUSIP) {
               type
            }
         }
      }
   }#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   assertEquals(
      'root\n'+
      '  ------> (t) tradeTable [ID, prodId]\n'+
      '    ------> (t) productTable(Trade_Product) [ID, NAME]\n'+
      '      ------> (t) synonymTable(Product_Synonym) [PRODID, TYPE]\n', $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableInQualifiedPropertiesInGraphFetchTree():Boolean[1]
{

   let query = {|Firm.all()->graphFetch(#{
      Firm {
         legalName,
         averageEmployeesAge
      }
   }#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   assertEquals(
      'root\n'+
      '  ------> (t) firmTable [ID, LEGALNAME]\n'+
      '    ------> (t) personTable(Firm_Person) [AGE, FIRMID]\n', $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testMultipleTablesInQualifiedPropertiesInGraphFetchTree():Boolean[1]
{

   let query = {|Firm.all()->graphFetch(#{
      Firm {
         legalName,
         averageEmployeesAge,
         employeesByCityOrManagerAndLastName('', '', '') {
            lastName
         }
      }
   }#)};
   let mapping = meta::relational::tests::simpleRelationalMapping;
   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, defaultRelationalExtensions())-> toOne();
   assertEquals(
      'root\n'+
      '  ------> (t) firmTable [ID, LEGALNAME]\n'+
      '    ------> (t) personTable(Firm_Person) [ADDRESSID, AGE, FIRMID, ID, LASTNAME, MANAGERID]\n'+
      '      ------> (t) addressTable(Address_Person) [ID, NAME]\n'+
      '      ------> (t) personTable(Person_Manager) [FIRSTNAME, ID, LASTNAME, MANAGERID]\n', $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsSimple():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithProject():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                          ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'first_name'), col(r:TDSRow[1]|$r.getString('LASTNAME'), 'last_name')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME, LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithDuplicateProjectColumns():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                          ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'first_name'), col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name_again')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithRestrict():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->restrict(['FIRSTNAME', 'AGE'])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [AGE, FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithFilter():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->meta::pure::tds::filter({r:TDSRow[1] | $r.getString('FIRSTNAME') == 'John'})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithFilterAndProject():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->meta::pure::tds::filter({r:TDSRow[1] | $r.getString('FIRSTNAME') == 'John'})
                        ->project([col(r:TDSRow[1]|$r.getString('LASTNAME'), 'name')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME, LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithFilterAndProjectOperatingOnSameColumns():Boolean[1]
{
   let query   = {| tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->meta::pure::tds::filter({r:TDSRow[1] | $r.getString('FIRSTNAME') == 'John'})
                        ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithExtend():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'firstName')])
                        ->extend([col({r:TDSRow[1]|'Hello'}, 'hello')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithDistinctAndTake():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name')])->distinct()->take(2)};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithSort():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->sort('LASTNAME')->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name')])};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME, LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithGroupBy():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                         ->groupBy(['FIRSTNAME'], agg('cnt', x|$x.getString('LASTNAME'), y| $y->count()))};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME, LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithConcatenate():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::dbInc,'default','personTable'))
                        ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'firstName')])
                        ->concatenate(Person.all()->project([col(p|$p.lastName, 'lastName')]))};

   let mapping = meta::relational::tests::simpleRelationalMappingInc;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n'+
                      '  ------> (t) personTable [LASTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithConcatenateUsingDifferentTables():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::dbInc,'default','personTable'))
                        ->project([col(r:TDSRow[1]|$r.getString('FIRSTNAME'), 'name')])
                        ->concatenate(tableToTDS(tableReference(meta::relational::tests::dbInc,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('LEGALNAME'), 'name')]))};

   let mapping = meta::relational::tests::simpleRelationalMappingInc;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) firmTable [LEGALNAME]\n'+
                      '  ------> (t) personTable [FIRSTNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithJoin():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))->project([col(r:TDSRow[1]|$r.getInteger('ID'), 'eID')])
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable')), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('ID');})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ID]\n'+
                      '    ------> (t) firmTable(equal_s(personTableID,personTable,)"eID"_s(firmTableID_firmTableLEGALNAME_firmTableADDRESSID_firmTableCEOID,firmTable,)"ID") [ADDRESSID, CEOID, ID, LEGALNAME]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithJoinAndUnion():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                        ->project([col(r:TDSRow[1]|$r.getString('ID'), 'eID')])
                        ->concatenate(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'eID')]))
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','addressTable')), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('ID');})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) firmTable [ID]\n'+
                      '    ------> (t) addressTable [COMMENTS, ID, NAME, STREET, TYPE]\n'+
                      '  ------> (t) personTable [ID]\n'+
                      '    ------> (t) addressTable [COMMENTS, ID, NAME, STREET, TYPE]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithMultipleJoin():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'personID')])
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'firmID'), col(r:TDSRow[1]|$r.getString('CEOID'), 'ceoID')]), JoinType.INNER, {a,b|$a.getInteger('personID') == $b.getInteger('firmID');})
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','addressTable')), JoinType.LEFT_OUTER, {a,b|$a.getInteger('ceoID') == $b.getInteger('ID');})
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','locationTable'))->project([col(r:TDSRow[1]|$r.getInteger('PERSONID'), 'locationPersonID')]), JoinType.LEFT_OUTER, {a,b|$a.getInteger('personID') == $b.getInteger('locationPersonID');})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ID]\n'+
                      '    ------> (t) firmTable [CEOID, ID]\n'+
                      '      ------> (t) addressTable [COMMENTS, ID, NAME, STREET, TYPE]\n'+
                      '    ------> (t) locationTable [PERSONID]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString(false));
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithJoinToSameTable():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'personID')])
                        ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','personTable')), JoinType.INNER, {a,b|$a.getInteger('personID') == $b.getInteger('ID');})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ID]\n'+
                      '    ------> (t) personTable(equal_s(personTableID,personTable,)"personID"_s(personTableID_personTableFIRSTNAME_personTableLASTNAME_personTableAGE_personTableADDRESSID_personTableFIRMID_personTableMANAGERID,personTable,)"ID") [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n';
   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithOLAPGroupBy():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                     ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'firmID'), col(r:TDSRow[1]|$r.getString('CEOID'), 'ceoID')]), JoinType.INNER, {a,b|$a.getInteger('ID') == $b.getInteger('firmID');})
                     ->groupBy(['FIRSTNAME','LASTNAME'], agg('cnt', x|$x.getInteger('AGE'), y| $y->sum()))
                     ->olapGroupBy('FIRSTNAME',asc('LASTNAME'),func('cnt',y|$y->sum()),'testCol1')};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n' +
                      '    ------> (t) firmTable(equal_s(personTableID_personTableFIRSTNAME_personTableLASTNAME_personTableAGE_personTableADDRESSID_personTableFIRMID_personTableMANAGERID,personTable,)"ID"_s(firmTableID_firmTableCEOID,firmTable,)"firmID") [CEOID, ID]\n';

   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}

function <<meta::pure::profiles::test.Test>> meta::pure::lineage::scanRelations::test::testTableToTdsWithCrossJoin():Boolean[1]
{
   let query   = {|tableToTDS(tableReference(meta::relational::tests::db,'default','personTable'))
                     ->join(tableToTDS(tableReference(meta::relational::tests::db,'default','firmTable'))->project([col(r:TDSRow[1]|$r.getString('ID'), 'firmID'), col(r:TDSRow[1]|$r.getString('CEOID'), 'ceoID')]), JoinType.INNER, {a,b| true})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let relationTree = meta::pure::lineage::scanRelations::scanRelations($query, $mapping, $runtime, defaultRelationalExtensions());

   let expectedTree = 'root\n'+
                      '  ------> (t) personTable [ADDRESSID, AGE, FIRMID, FIRSTNAME, ID, LASTNAME, MANAGERID]\n' +
                      '    ------> (t) firmTable(tdsJoin) [CEOID, ID]\n';

   assertEquals($expectedTree, $relationTree-> relationTreeAsString());
}