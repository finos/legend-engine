// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import meta::relational::metamodel::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::functions::sqlQueryToString::default::*;

Class <<typemodifiers.abstract>> meta::pure::alloy::connections::alloy::isolation::TempTableIsolationStrategy
{  
}

Class meta::pure::alloy::connections::alloy::isolation::DefaultIsolationStrategy extends meta::pure::alloy::connections::alloy::isolation::TempTableIsolationStrategy
{
  updateNodes(u: meta::relational::commands::UpdateSQLQueryCommands[1], e: DbExtension[1], dbConfig: meta::relational::functions::sqlQueryToString::DbConfig[1])
  {
    let createTempTable = $e.createTableSQLQueryProcessor->toOne()->eval($u.createTempTable, $dbConfig)->sqlStringToUpdateNode();
    let loadTable = $e.loadTableSQLQueryProcessor->toOne()->eval($u.loadTable, $dbConfig)->sqlStringToUpdateNode();
    [$createTempTable, $loadTable];
  }: meta::relational::executionPlan::UpdateSqlExecutionNode[*];

  finallyNode(u: meta::relational::commands::UpdateSQLQueryCommands[1], e: DbExtension[1])
  {
    $e.dropTableSQLQueryProcessor->toOne()->eval($u.dropTable)->sqlStringToUpdateNode()->updateNodeToFinallyNode()
  }: meta::relational::executionPlan::FinallyExecutionNode[1];

  generateTempTablePath(t: meta::relational::metamodel::relation::Table[1]){$t.name->toOne()}: String[1];

  createSchema(){^Schema (name = 'default', database = ^Database(name= 'TempTableDb'))}:Schema[1];
}

Class meta::pure::alloy::connections::alloy::isolation::IsolateByAuthId extends meta::pure::alloy::connections::alloy::isolation::TempTableIsolationStrategy
{  
  updateNodes(u: meta::relational::commands::UpdateSQLQueryCommands[1], e: DbExtension[1], dbConfig:DbConfig[1])
  {
    
    let createSchema = $e.createSchemaSQLQueryProcessor->toOne()->eval($u.createSchema)->sqlStringToUpdateNode();
    let useDbCommand = $e.useDbSQLQueryProcessor->toOne()->eval($u.useDb->toOne())->sqlStringToUpdateNode();
    let createTempTable = $e.createTableSQLQueryProcessor->toOne()->eval($u.createTempTable, $dbConfig)->sqlStringToUpdateNode();
    let loadTable = $e.loadTableSQLQueryProcessor->toOne()->eval($u.loadTable, $dbConfig)->sqlStringToUpdateNode();
    [$createSchema, $useDbCommand->toOne(), $createTempTable, $loadTable];
  }: meta::relational::executionPlan::UpdateSqlExecutionNode[*];

  finallyNode(u: meta::relational::commands::UpdateSQLQueryCommands[1], e: DbExtension[1])
  {
    $e.dropSchemaSQLQueryProcessor->toOne()->eval($u.dropSchema)->sqlStringToUpdateNode()->meta::relational::functions::sqlQueryToString::default::updateNodeToFinallyNode()
  }: meta::relational::executionPlan::FinallyExecutionNode[1];

  generateTempTablePath(t: meta::relational::metamodel::relation::Table[1]){$t.schema.database.name->toOne() + '.' + $t.schema.name->toOne() + '.' + $t.name->toOne()}: String[1];

  createSchema(requestIdVarPlaceHolder: String[1])
  {
    let authIdVarPlaceHolder = stringToPlaceHolder('auth_id');
    ^Schema (name = $authIdVarPlaceHolder+'_schema_'+$requestIdVarPlaceHolder, database = ^Database(name= $authIdVarPlaceHolder+'_db'));
  }:Schema[1];
}