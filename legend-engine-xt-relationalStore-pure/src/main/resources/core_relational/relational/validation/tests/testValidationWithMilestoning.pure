// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::functions::asserts::*;
import meta::pure::runtime::*;
import meta::relational::validation::tests::milestoning::*;
import meta::relational::validation::*;

Class <<temporal.businesstemporal>> meta::relational::validation::tests::milestoning::Product extends meta::relational::tests::milestoning::Product
[
   idNotNegative : $this.id > 0,
   classificationTypeStrNotEMpty : $this.classificationTypeStr != ''
   
]
{
   
}

Class <<temporal.businesstemporal>> meta::relational::validation::tests::milestoning::ProductClassification extends meta::relational::tests::milestoning::ProductClassification
[
   joinStringsConstraint: sum([$this.type->length(), $this.description->length()]) >10
]
{

}

Class  meta::relational::validation::tests::milestoning::OrderWithAggregationConstraint extends meta::relational::tests::milestoning::Order
[
   aggConstraint: abs( ($this.product(%2018-09-09)->filter(p|$p.id>100 || $p.id==-1)->map(p|$p.id)->sum() - $this.product(%2018-09-09)->filter(p|$p.id<100 || $p.id==-10)->map(p|$p.id)->sum()))>1,
   aggConstraint2: $this.product(%2018-09-09)->count() >1
]
{
}

function <<test.BeforePackage>> meta::relational::validation::tests::milestoning::setUp():Runtime[1]
{
   meta::relational::tests::milestoning::snapshot::setUp();
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testAggregationOnRootClass():Boolean[1]
{
   let validation = validate({|meta::relational::validation::tests::milestoning::ProductClassification.all(%2019-09-09)},MilestoneMappingWithDynaFunction,meta::relational::tests::testRuntime(),['joinStringsConstraint'], meta::relational::extension::relationalExtensions());
   assertSameSQL('select \'joinStringsConstraint\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".type as "type" from ProductClassificationTableWithBusinessSnapshotMilestoning as "root" where not (char_length("root".type) + char_length("root".type_description)) > 10 and "root".snapshotDate = \'2019-09-09\'', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryWithMilestoningAndAggregationAll():Boolean[1]
{
   let validation = validate({|OrderWithAggregationConstraint.all()}, MilestoneMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."CONSTRAINT_ID" as "CONSTRAINT_ID", "unionalias_0"."ENFORCEMENT_LEVEL" as "ENFORCEMENT_LEVEL", "unionalias_0"."MESSAGE" as "MESSAGE", "unionalias_0"."id" as "id" from (select \'aggConstraint\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from OrderTable as "root" left outer join (select "ordertable_2".id as id, sum("producttablewithbusinesssnapshotmilestoning_0".id) as aggCol from OrderTable as "ordertable_2" left outer join ProductTableWithBusinessSnapshotMilestoning as "producttablewithbusinesssnapshotmilestoning_0" on ("ordertable_2".prodFk = "producttablewithbusinesssnapshotmilestoning_0".id and "producttablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2018-09-09\' and ("producttablewithbusinesssnapshotmilestoning_0".id > 100 or "producttablewithbusinesssnapshotmilestoning_0".id = -1)) group by "ordertable_2".id) as "ordertable_1" on ("root".id = "ordertable_1".id) left outer join (select "ordertable_4".id as id, sum("producttablewithbusinesssnapshotmilestoning_1".id) as aggCol from OrderTable as "ordertable_4" left outer join ProductTableWithBusinessSnapshotMilestoning as "producttablewithbusinesssnapshotmilestoning_1" on ("ordertable_4".prodFk = "producttablewithbusinesssnapshotmilestoning_1".id and "producttablewithbusinesssnapshotmilestoning_1".snapshotDate = \'2018-09-09\' and ("producttablewithbusinesssnapshotmilestoning_1".id < 100 or "producttablewithbusinesssnapshotmilestoning_1".id = -10)) group by "ordertable_4".id) as "ordertable_3" on ("root".id = "ordertable_3".id) where not abs(("ordertable_1".aggCol - "ordertable_3".aggCol)) > 1 UNION ALL select \'aggConstraint2\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from OrderTable as "root" left outer join (select "ordertable_6".id as id, count(*) as aggCol from OrderTable as "ordertable_6" left outer join ProductTableWithBusinessSnapshotMilestoning as "producttablewithbusinesssnapshotmilestoning_2" on ("ordertable_6".prodFk = "producttablewithbusinesssnapshotmilestoning_2".id and "producttablewithbusinesssnapshotmilestoning_2".snapshotDate = \'2018-09-09\') group by "ordertable_6".id) as "ordertable_5" on ("root".id = "ordertable_5".id) where not "ordertable_5".aggCol > 1) as "unionalias_0"', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryWithMilestoningAndAggregationSingle():Boolean[1]
{
   let validation = validate({|OrderWithAggregationConstraint.all()}, MilestoneMapping, meta::relational::tests::testRuntime(),['aggConstraint'], meta::relational::extension::relationalExtensions());
   assertSameSQL('select \'aggConstraint\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from OrderTable as "root" left outer join (select "ordertable_2".id as id, sum("producttablewithbusinesssnapshotmilestoning_0".id) as aggCol from OrderTable as "ordertable_2" left outer join ProductTableWithBusinessSnapshotMilestoning as "producttablewithbusinesssnapshotmilestoning_0" on ("ordertable_2".prodFk = "producttablewithbusinesssnapshotmilestoning_0".id and "producttablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2018-09-09\' and ("producttablewithbusinesssnapshotmilestoning_0".id > 100 or "producttablewithbusinesssnapshotmilestoning_0".id = -1)) group by "ordertable_2".id) as "ordertable_1" on ("root".id = "ordertable_1".id) left outer join (select "ordertable_4".id as id, sum("producttablewithbusinesssnapshotmilestoning_1".id) as aggCol from OrderTable as "ordertable_4" left outer join ProductTableWithBusinessSnapshotMilestoning as "producttablewithbusinesssnapshotmilestoning_1" on ("ordertable_4".prodFk = "producttablewithbusinesssnapshotmilestoning_1".id and "producttablewithbusinesssnapshotmilestoning_1".snapshotDate = \'2018-09-09\' and ("producttablewithbusinesssnapshotmilestoning_1".id < 100 or "producttablewithbusinesssnapshotmilestoning_1".id = -10)) group by "ordertable_4".id) as "ordertable_3" on ("root".id = "ordertable_3".id) where not abs(("ordertable_1".aggCol - "ordertable_3".aggCol)) > 1', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryWithMilestoningAndAggregationSingleAndNestedDynaFunction():Boolean[1]
{
   let validation = validate({|OrderWithAggregationConstraint.all()}, MilestoneMappingWithDynaFunction, meta::relational::tests::testRuntime(),['aggConstraint'], meta::relational::extension::relationalExtensions());
   assertSameSQL('select \'aggConstraint\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from OrderTable as "root" left outer join (select "ordertable_2".id as id, sum(("producttablewithbusinesssnapshotmilestoning_0".id + "producttablewithbusinesssnapshotmilestoning_0".id)) as aggCol from OrderTable as "ordertable_2" left outer join ProductTableWithBusinessSnapshotMilestoning as "producttablewithbusinesssnapshotmilestoning_0" on ("ordertable_2".prodFk = "producttablewithbusinesssnapshotmilestoning_0".id and "producttablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2018-09-09\' and (("producttablewithbusinesssnapshotmilestoning_0".id + "producttablewithbusinesssnapshotmilestoning_0".id) > 100 or ("producttablewithbusinesssnapshotmilestoning_0".id + "producttablewithbusinesssnapshotmilestoning_0".id) = -1)) group by "ordertable_2".id) as "ordertable_1" on ("root".id = "ordertable_1".id) left outer join (select "ordertable_4".id as id, sum(("producttablewithbusinesssnapshotmilestoning_1".id + "producttablewithbusinesssnapshotmilestoning_1".id)) as aggCol from OrderTable as "ordertable_4" left outer join ProductTableWithBusinessSnapshotMilestoning as "producttablewithbusinesssnapshotmilestoning_1" on ("ordertable_4".prodFk = "producttablewithbusinesssnapshotmilestoning_1".id and "producttablewithbusinesssnapshotmilestoning_1".snapshotDate = \'2018-09-09\' and (("producttablewithbusinesssnapshotmilestoning_1".id + "producttablewithbusinesssnapshotmilestoning_1".id) < 100 or ("producttablewithbusinesssnapshotmilestoning_1".id + "producttablewithbusinesssnapshotmilestoning_1".id) = -10)) group by "ordertable_4".id) as "ordertable_3" on ("root".id = "ordertable_3".id) where not abs(("ordertable_1".aggCol - "ordertable_3".aggCol)) > 1', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryWithMilestoning():Boolean[1]
{
   let validation = validate({|Product.all(%2010-10-10)}, MilestoneMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."CONSTRAINT_ID" as "CONSTRAINT_ID", "unionalias_0"."ENFORCEMENT_LEVEL" as "ENFORCEMENT_LEVEL", "unionalias_0"."MESSAGE" as "MESSAGE", "unionalias_0"."id" as "id" from (select \'idNotNegative\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" where not "root".id > 0 and "root".snapshotDate = \'2010-10-10\' UNION ALL select \'classificationTypeStrNotEMpty\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_0" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_0".type) where "productclassificationtablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2010-10-10\' and "productclassificationtablewithbusinesssnapshotmilestoning_0".type = \'\' and "root".snapshotDate = \'2010-10-10\') as "unionalias_0"', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryWithMilestoningWithVariable():Boolean[1]
{
   let date = %2010-10-10;
   let validation = validate({|Product.all($date)}, MilestoneMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."CONSTRAINT_ID" as "CONSTRAINT_ID", "unionalias_0"."ENFORCEMENT_LEVEL" as "ENFORCEMENT_LEVEL", "unionalias_0"."MESSAGE" as "MESSAGE", "unionalias_0"."id" as "id" from (select \'idNotNegative\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" where not "root".id > 0 and "root".snapshotDate = \'2010-10-10\' UNION ALL select \'classificationTypeStrNotEMpty\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_0" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_0".type) where "productclassificationtablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2010-10-10\' and "productclassificationtablewithbusinesssnapshotmilestoning_0".type = \'\' and "root".snapshotDate = \'2010-10-10\') as "unionalias_0"', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryWithMilestoningWithMultipleVariables():Boolean[1]
{
   let date = %2010-10-10;
   let id = 45;
   let validation = validate({|Product.all($date)->filter(i | $i.id == $id)}, MilestoneMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."CONSTRAINT_ID" as "CONSTRAINT_ID", "unionalias_0"."ENFORCEMENT_LEVEL" as "ENFORCEMENT_LEVEL", "unionalias_0"."MESSAGE" as "MESSAGE", "unionalias_0"."id" as "id" from (select \'idNotNegative\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" where "root".id = 45 and "root".snapshotDate = \'2010-10-10\' and not "root".id > 0 UNION ALL select \'classificationTypeStrNotEMpty\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_0" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_0".type) where "productclassificationtablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2010-10-10\' and "root".id = 45 and "root".snapshotDate = \'2010-10-10\' and "productclassificationtablewithbusinesssnapshotmilestoning_0".type = \'\') as "unionalias_0"', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryOpenVariableInCol():Boolean[1]
{
   let date = %2010-10-10;
   let batch = 1;
   let validation = validate({|Product.all($date)}, [col(x|$x.id, 'id')], {t|$t->extend(col(x:TDSRow[1] | $batch->toOne(), 'Batch_ID'))}, MilestoneMapping, meta::relational::tests::testRuntime(), ^meta::relational::runtime::RelationalExecutionContext(), [], [], meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."CONSTRAINT_ID" as "CONSTRAINT_ID", "unionalias_0"."ENFORCEMENT_LEVEL" as "ENFORCEMENT_LEVEL", "unionalias_0"."MESSAGE" as "MESSAGE", "unionalias_0"."id" as "id", 1 as "Batch_ID" from (select \'idNotNegative\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" where not "root".id > 0 and "root".snapshotDate = \'2010-10-10\' UNION ALL select \'classificationTypeStrNotEMpty\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_0" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_0".type) where "productclassificationtablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2010-10-10\' and "productclassificationtablewithbusinesssnapshotmilestoning_0".type = \'\' and "root".snapshotDate = \'2010-10-10\') as "unionalias_0"', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryOpenVariableInKeyExpression():Boolean[1]
{
   let date = %2010-10-10;
   let batch = 1;
   let validation = validate({|Product.all($date)}, [col(x|$x.id, 'id')], {t|$t->extend(^BasicColumnSpecification<TDSRow>(func=x:TDSRow[1] | $batch->toOne(), name='Batch_ID'))}, MilestoneMapping, meta::relational::tests::testRuntime(), ^meta::relational::runtime::RelationalExecutionContext(), [], [], meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."CONSTRAINT_ID" as "CONSTRAINT_ID", "unionalias_0"."ENFORCEMENT_LEVEL" as "ENFORCEMENT_LEVEL", "unionalias_0"."MESSAGE" as "MESSAGE", "unionalias_0"."id" as "id", 1 as "Batch_ID" from (select \'idNotNegative\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" where not "root".id > 0 and "root".snapshotDate = \'2010-10-10\' UNION ALL select \'classificationTypeStrNotEMpty\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_0" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_0".type) where "productclassificationtablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2010-10-10\' and "productclassificationtablewithbusinesssnapshotmilestoning_0".type = \'\' and "root".snapshotDate = \'2010-10-10\') as "unionalias_0"', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryOpenVariableInAgg():Boolean[1]
{
   let date = %2010-10-10;
   let count = 3;
   let validation = validate({|Product.all($date)}, [col(x|$x.id, 'id')], {t|$t->groupBy(['CONSTRAINT_ID'], agg('Sum', x|$x.getInteger('id') + $count, y|$y->sum()))}, MilestoneMapping, meta::relational::tests::testRuntime(), ^meta::relational::runtime::RelationalExecutionContext(), [], [], meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."CONSTRAINT_ID" as "CONSTRAINT_ID", sum(("unionalias_0"."id" + 3)) as "Sum" from (select \'idNotNegative\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" where not "root".id > 0 and "root".snapshotDate = \'2010-10-10\' UNION ALL select \'classificationTypeStrNotEMpty\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_0" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_0".type) where "productclassificationtablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2010-10-10\' and "productclassificationtablewithbusinesssnapshotmilestoning_0".type = \'\' and "root".snapshotDate = \'2010-10-10\') as "unionalias_0" group by "CONSTRAINT_ID"', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryOpenVariableInColAndAgg():Boolean[1]
{
   let date = %2010-10-10;
   let batch = 1;
   let count = 3;
   let validation = validate({|Product.all($date)}, [col(x|$x.id, 'id')], {t|$t->extend(col(x:TDSRow[1] | $batch->toOne() + $batch->toOne(), 'Batch_ID'))->groupBy(['CONSTRAINT_ID', 'Batch_ID'], agg('Sum', x|$x.getInteger('id') + $count, y|$y->sum()))}, MilestoneMapping, meta::relational::tests::testRuntime(), ^meta::relational::runtime::RelationalExecutionContext(), [], [], meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."CONSTRAINT_ID" as "CONSTRAINT_ID", (1 + 1) as "Batch_ID", sum(("unionalias_0"."id" + 3)) as "Sum" from (select \'idNotNegative\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" where not "root".id > 0 and "root".snapshotDate = \'2010-10-10\' UNION ALL select \'classificationTypeStrNotEMpty\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id" from ProductTableWithBusinessSnapshotMilestoning as "root" left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_0" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_0".type) where "productclassificationtablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2010-10-10\' and "productclassificationtablewithbusinesssnapshotmilestoning_0".type = \'\' and "root".snapshotDate = \'2010-10-10\') as "unionalias_0" group by "CONSTRAINT_ID","Batch_ID"', $validation);
}


function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryOpenVariableInColAndExtraProjection():Boolean[1]
{
   let date = %2010-10-10;
   let date2 = %2010-10-11;
   let batch = 1;
   let validation = validate({|Product.all($date)}, [col(x|$x.id, 'id'), col(x|$x.classification($date2).type, 'class')], {t|$t->extend(col(x:TDSRow[1] | $batch->toOne(), 'Batch_ID'))}, MilestoneMapping, meta::relational::tests::testRuntime(), ^meta::relational::runtime::RelationalExecutionContext(), [], [], meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionalias_0"."CONSTRAINT_ID" as "CONSTRAINT_ID", "unionalias_0"."ENFORCEMENT_LEVEL" as "ENFORCEMENT_LEVEL", "unionalias_0"."MESSAGE" as "MESSAGE", "unionalias_0"."id" as "id", "unionalias_0"."class" as "class", 1 as "Batch_ID" from (select \'idNotNegative\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id", "productclassificationtablewithbusinesssnapshotmilestoning_0".type as "class" from ProductTableWithBusinessSnapshotMilestoning as "root" left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_0" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_0".type and "productclassificationtablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2010-10-11\') where not "root".id > 0 and "root".snapshotDate = \'2010-10-10\' UNION ALL select \'classificationTypeStrNotEMpty\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "root".id as "id", "productclassificationtablewithbusinesssnapshotmilestoning_0".type as "class" from ProductTableWithBusinessSnapshotMilestoning as "root" left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_1" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_1".type) left outer join ProductClassificationTableWithBusinessSnapshotMilestoning as "productclassificationtablewithbusinesssnapshotmilestoning_0" on ("root".type = "productclassificationtablewithbusinesssnapshotmilestoning_0".type and "productclassificationtablewithbusinesssnapshotmilestoning_0".snapshotDate = \'2010-10-11\') where "productclassificationtablewithbusinesssnapshotmilestoning_1".snapshotDate = \'2010-10-10\' and "productclassificationtablewithbusinesssnapshotmilestoning_1".type = \'\' and "root".snapshotDate = \'2010-10-10\') as "unionalias_0"', $validation);
}

function <<test.Test>> meta::relational::validation::tests::milestoning::testValidateQueryWithUnion():Boolean[1]
{
   let date = %2010-10-10;
   let date2 = %2010-10-11;
   let batch = 1;
   let validation = validate({|Product.all($date)}, [col(x|$x.id, 'id')], {t|$t->extend(col(x:TDSRow[1] | $batch->toOne(), 'Batch_ID'))}, MilestoneUnionMapping, meta::relational::tests::testRuntime(), ^meta::relational::runtime::RelationalExecutionContext(), ['idNotNegative'], [], meta::relational::extension::relationalExtensions());
   assertSameSQL('select \'idNotNegative\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'\' as "MESSAGE", "unionBase"."ProductTableWithBusinessSnapshotMilestoningid_ProductTableWithBusinessSnapshotMilestoningid" as "id", 1 as "Batch_ID" from (select "root".snapshotDate as "snapshotDate_0", null as "snapshotDate_1", "root".id as "ProductTableWithBusinessSnapshotMilestoningid_ProductTableWithBusinessSnapshotMilestoningid", "root".id as "pk_0_0", null as "pk_0_1" from ProductTableWithBusinessSnapshotMilestoning as "root" where "root".snapshotDate = \'2010-10-10\' UNION ALL select null as "snapshotDate_0", "root".snapshotDate as "snapshotDate_1", "root".id as "ProductTableWithBusinessSnapshotMilestoningid_ProductTableWithBusinessSnapshotMilestoningid", null as "pk_0_0", "root".id as "pk_0_1" from ProductTableWithBusinessSnapshotMilestoning as "root" where "root".snapshotDate = \'2010-10-10\') as "unionBase" where not "unionBase"."ProductTableWithBusinessSnapshotMilestoningid_ProductTableWithBusinessSnapshotMilestoningid" > 0', $validation);
}

###Mapping
import meta::relational::tests::milestoning::dbmeta::relational::tests::milestoning::*;

Mapping meta::relational::validation::tests::milestoning::MilestoneMappingWithDynaFunction
(
   include meta::relational::tests::milestoning::businessSnapshotMilestoningMapWithDynaFunction

   meta::relational::validation::tests::milestoning::Product extends [p] : Relational {

   }

   meta::relational::validation::tests::milestoning::OrderWithAggregationConstraint[o1] extends [o] : Relational {

   }

    meta::relational::validation::tests::milestoning::ProductClassification[c2] extends [c] : Relational {

   }
)

Mapping meta::relational::validation::tests::milestoning::MilestoneMapping
(
   include meta::relational::tests::milestoning::businessSnapshotMilestoningMap

   meta::relational::validation::tests::milestoning::Product extends [p] : Relational {

   }

   meta::relational::validation::tests::milestoning::OrderWithAggregationConstraint[o1] extends [o] : Relational {

   }
)

###Mapping
Mapping meta::relational::validation::tests::milestoning::MilestoneUnionMapping
(
   include meta::relational::tests::milestoning::businessSnapshotMilestoningMap
   
   
   *meta::relational::validation::tests::milestoning::Product : Operation {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(p1, p2)
   }
   
   meta::relational::validation::tests::milestoning::Product[p1] extends [p] : Relational {
      classification[c1] : [meta::relational::tests::milestoning::db]@ProductWithBusinessSnapshotMilestoning_ClassificationWithBusinessSnapshotMilestoning
   }
   
   meta::relational::validation::tests::milestoning::Product[p2] extends [p] : Relational {
      classification[c2] : [meta::relational::tests::milestoning::db]@ProductWithBusinessSnapshotMilestoning_ClassificationWithBusinessSnapshotMilestoning
   }
   
   *meta::relational::validation::tests::milestoning::ProductClassification : Operation {
      meta::pure::router::operations::union_OperationSetImplementation_1__SetImplementation_MANY_(c1, c2)
   }
   
   meta::relational::validation::tests::milestoning::ProductClassification[c1] extends [c] : Relational {

   }
   
   meta::relational::validation::tests::milestoning::ProductClassification[c2] extends [c] : Relational {

   }
)