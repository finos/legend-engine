// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::functions::database::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::pure::executionPlan::*;
import meta::pure::functions::meta::*;
import meta::pure::mapping::*;
import meta::pure::milestoning::*;
import meta::relational::functions::pureToSqlQuery::*;
import meta::relational::functions::pureToSqlQuery::metamodel::*;
import meta::relational::mapping::*;
import meta::relational::metamodel::*;
import meta::relational::metamodel::execute::*;
import meta::relational::metamodel::join::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::operation::*;
import meta::relational::milestoning::*;
import meta::pure::router::metamodel::*;

Enum meta::relational::milestoning::MilestoningProcessingState{
   MILESTONED_ALL_FUNC,
   MILESTONED_CLASS_PROPERTY,
   MILESTONED_CLASS_PROPERTY_NO_ARG,
   NON_MILESTONED_CLASS_PROPERTY,
   DATATYPE_PROPERTY,
   ALL_VERSIONS,
   ALL_VERSIONS_IN_RANGE,
   ALL_FOR_EACH_DATE
}

Class meta::relational::milestoning::TemporalMilestoningThisContext
{
   processingDate:Any[0..1];
   businessDate:Any[0..1];
}
   
Class meta::relational::milestoning::TemporalMilestoningContext
{
   processingDate: RelationalOperationElement[0..1];
   businessDate: RelationalOperationElement[0..1];

   toTemporalMilestoningThisContext()
   {
      let toDate = {r:RelationalOperationElement[1]|$r->toOne()->match([l:Literal[1]| $l.value, 
                                                                        r:RelationalOperationElement[1]| fail('$this.');[];])}; //need to figure this out
   
      let processingDate = if($this.processingDate->isNotEmpty(),|$toDate->eval($this.processingDate),|[]);
      let businessDate = if($this.businessDate->isNotEmpty(),|$toDate->eval($this.businessDate),|[]);

      ^TemporalMilestoningThisContext(processingDate=$processingDate, businessDate=$businessDate);
      
   }:TemporalMilestoningThisContext[0..1];
   
   currentMilestoningStrategy: TemporalStrategy[1];
   currentProcessingState : MilestoningProcessingState[0..1];
   
   startDate : RelationalOperationElement[0..1];
   endDate : RelationalOperationElement[0..1];

   isAllVersions(){
      $this.currentProcessingState ==  MilestoningProcessingState.ALL_VERSIONS
   }: Boolean[1];

   isAllVersionsInRange(){
      $this.currentProcessingState ==  MilestoningProcessingState.ALL_VERSIONS_IN_RANGE
   }: Boolean[1];

   isAllForEachDate(){
      $this.currentProcessingState ==  MilestoningProcessingState.ALL_FOR_EACH_DATE
   }: Boolean[1];

   currentProcessingStateIsMilestonedClassProperty(){$this.currentProcessingState != [] && ($this.currentProcessingState == MilestoningProcessingState.MILESTONED_CLASS_PROPERTY || $this.currentProcessingState == MilestoningProcessingState.MILESTONED_CLASS_PROPERTY_NO_ARG || $this.isAllVersionsInRange())}:Boolean[1];

   columns(r:Relation[1]) {
      $this.currentMilestoningStrategy->expandToSingleTemporalStrategies()->map(temporalStrategy | $temporalStrategy->getTemporalDateAlias($this, $r))->reverse();
   }: Alias[*];
}

function meta::relational::milestoning::getTemporalDateAlias(temporalStrategy:SingleDateTemporalStrategy[1], milestoningContext:TemporalMilestoningContext[1], r:Relation[1]):Alias[0..1]
{
   let temporalDate = $temporalStrategy->temporalDate($milestoningContext);
   let temporalDateRelationalElement = if ($milestoningContext.isAllVersions() || $milestoningContext.isAllVersionsInRange() || $milestoningContext.isAllForEachDate(),
                                           | $temporalDate,
                                           | if($temporalDate->toOne()->isLatestDate() && $temporalStrategy->relationalElementCanSupportStrategy($r) && $temporalStrategy->getInfinityDate($r)->isNotEmpty(),| ^Literal(value=$temporalStrategy->getInfinityDate($r)->toString())
                                                                                                                                                                                                            ,| if($temporalDate->toOne()->isLatestDate() ,| [] 
                                                                                                                                                                                                                                                         ,| $temporalDate->match([l:Literal[1]| $l.value->match([d:Date[1]|^Literal(value=$d->toString()), v:VarPlaceHolder[1]|$l]), 
                                                                                                                                                                                                                                                                                  d:DynaFunction[1] | $d])));
                                          );
   if ($temporalDateRelationalElement->isNotEmpty(),| ^Alias(name = '\"'+temporalColumnAliasProperties($temporalStrategy).second+'\"', relationalElement = $temporalDateRelationalElement->toOne()),| []);
}

function meta::relational::milestoning::applyMilestoningFilters(e:RelationalOperationElement[1], tableToFilterOp: meta::pure::metamodel::function::Function<{TableAlias[1]->Operation[0..1]}>[1],tableToTable : meta::pure::metamodel::function::Function<{Table[1]->Table[1]}>[1], shouldProcessViewSubSelect:Boolean[1], extensions:Extension[*]):RelationalOperationElement[1]
{
    $e->match([     v: VarSetPlaceHolder[1] | $v,
                    pl: VarPlaceHolder[1]|$pl,
                    s:SelectSQLQuery[1] | let rootTable = $s.data.alias;
                                          let sourceFilterOp = $s.filteringOperation->map(f|$f->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions));
                                          let tableFilterOp = $tableToFilterOp->eval($rootTable);
                                          let sourceFilterContainTableFilter = $sourceFilterOp->buildUniqueName(true, $extensions)->contains($tableFilterOp->buildUniqueName(true, $extensions));
                                          let newSourceFilterOp = if(!$sourceFilterContainTableFilter,|
                                                                        if ($sourceFilterOp != [],
                                                                               | $tableFilterOp->concatenate($sourceFilterOp)->andFilters($extensions),
                                                                               | $tableFilterOp);
                                                                        ,|$sourceFilterOp);
                                          let newRoot = $s.data->toOne()->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)->cast(@RootJoinTreeNode);
                                          let aliasRemap = $newRoot->getAllNodes()->cast(@RelationalTreeNode)->map(n | ^OldAliasToNewAlias(first = $n.alias.name, second = $n.alias));
                                          ^$s(columns=$s.columns->map(c|$c->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions))->reprocessAliases($aliasRemap),
                                              filteringOperation=$newSourceFilterOp->reprocessAliases($aliasRemap),
                                              data=$newRoot,
                                              leftSideOfFilter = if($s.leftSideOfFilter->isEmpty(),|[],|$s.leftSideOfFilter->toOne()->findOneNode($s.data->toOne(), $newRoot))
                                           );,
                    a:Alias[1] | ^$a(relationalElement=$a.relationalElement->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)),
                    u:Union[1] | ^$u(queries=$u.queries->map(q|$q->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)->cast(@SelectSQLQuery))),
                    v:ViewSelectSQLQuery[1] | if($shouldProcessViewSubSelect,|^$v(selectSQLQuery=$v.selectSQLQuery->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)->cast(@SelectSQLQuery)),|$v),
                    t:Table[1] | $tableToTable->eval($t),
                    d:DynaFunction[1] | ^$d(parameters=$d.parameters->map(p|$p->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions))),
                    f:FreeMarkerOperationHolder[1]| $f,
                    c:TableAliasColumn[1] | $c,
                    wc: WindowColumn[1] | ^$wc(window = $wc.window , func = $wc.func),
                    w: meta::relational::metamodel::Window[1]| ^$w(partition = $w.partition, sortBy = $w.sortBy),
                    cn:ColumnName[1] | $cn ,
                    j:JoinStrings[1] | ^$j(strings=$j.strings->map(p|$p->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)),prefix=if($j.prefix!=[],| $j.prefix->toOne()->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions),|$j.prefix),separator=if($j.separator!=[],| $j.separator->toOne()->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions),|$j.separator),suffix=if($j.suffix!=[],| $j.suffix->toOne()->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions),|$j.suffix)),
                    l:Literal[1] | $l,
                    ll:LiteralList[1] | $ll,
                    op:UnaryOperation[1] | ^$op(nested=$op.nested->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)),
                    op:BinaryOperation[1] | ^$op(left=$op.left->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions),right=$op.right->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)),
                    op:VariableArityOperation[1] | ^$op(args=$op.args->map(a|$a->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions))),
                    s:SemiStructuredPropertyAccess[1] | ^$s(operand = $s.operand->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions), property = $s.property->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions), index = $s.index->map(i | $i->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions))),
                    s:SemiStructuredArrayElementAccess[1] | ^$s(operand = $s.operand->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions), index = $s.index->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)),
                    s:SemiStructuredArrayFlatten[1] | ^$s(navigation = $s.navigation->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)),
                    s:SemiStructuredArrayFlattenOutput[1] | ^$s(tableAliasColumn = $s.tableAliasColumn->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)->cast(@TableAliasColumn))     
                  ]);
}

function meta::relational::milestoning::applyMilestoningFilters(j:RelationalTreeNode[1], tableToFilterOp: meta::pure::metamodel::function::Function<{TableAlias[1]->Operation[0..1]}>[1],tableToTable : meta::pure::metamodel::function::Function<{Table[1]->Table[1]}>[1], shouldProcessViewSubSelect:Boolean[1], extensions:Extension[*]):RelationalTreeNode[1]
{
    $j->match([
               jtn:JoinTreeNode[1] | let join = $jtn.join;
                                     let targetTable = $jtn.alias;
                                     let newJoin = $targetTable.relationalElement->match([
                                           t:Table[1] | let tableFilter = $tableToFilterOp->eval($targetTable->toOne());
                                                        let sourceFilterContainTableFilter = $join.operation->buildUniqueName(true, $extensions)->contains($tableFilter->buildUniqueName(true, $extensions));
                                                        let newJoinOperation = if(!$sourceFilterContainTableFilter && $tableFilter!=[],|newAndOrDynaFunctionRelaxedBrackets('and', [$join.operation, $tableFilter->toOne()]);,
                                                                                                   |$join.operation);
                                                        let newJoin = ^$join(operation=$newJoinOperation);,
                                           u:Union[1] | $join,
                                           s:SelectSQLQuery[1] | $join
                                     ]);
                                     let newAlias = $j.alias->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)->cast(@TableAlias);
                                     let joinWithAliasProcessed = reprocessJoin($newJoin, ^OldAliasToNewAlias(first=$j.alias.name, second=$newAlias), []);
                                     ^$jtn(join=$joinWithAliasProcessed, alias=$newAlias, childrenData=$j.childrenData->map(c|$c->cast(@JoinTreeNode)->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)));,
               rtn:RelationalTreeNode[1] |^$rtn(alias=$j.alias->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)->cast(@TableAlias), childrenData=$j.childrenData->map(c|$c->cast(@JoinTreeNode)->applyMilestoningFilters($tableToFilterOp, $tableToTable, $shouldProcessViewSubSelect, $extensions)))
              ]);
}

function meta::relational::milestoning::temporalpostprocessor::dateEqualityTemporalMilestoningProcessor(dbs:Database[*], thruDateColumnName : String[1], latestDate : Date[1], extensions:Extension[*]):meta::pure::metamodel::function::Function<{SelectSQLQuery[1]->meta::pure::mapping::Result<SelectSQLQuery|1>[1]}>[1]
{
   let tablesInScope = $dbs->map(db|$db->findTablesInDbHierarchy([],true));
   {s:SelectSQLQuery[1] | let ff = {ta:TableAlias[1]| let table = $ta.relationalElement->cast(@Table);
                                                      if($tablesInScope->contains($table) ,| ^DynaFunction(name='equal', parameters=[^TableAliasColumn(alias=$ta, column=^Column(name=$thruDateColumnName, type=^meta::relational::metamodel::datatype::Date(), nullable=false)), ^Literal(value=$latestDate)]);
                                                                                          ,| []);};
                          let s2 = applyMilestoningFilters($s, $ff, getTableToTableIdentifyFunction(), true, $extensions)->cast(@SelectSQLQuery);
                          ^meta::pure::mapping::Result<SelectSQLQuery|1>(values=$s2);
   };
}

function meta::relational::milestoning::getTableToTableIdentifyFunction():meta::pure::metamodel::function::Function<{Table[1]->Table[1]}>[1]
{
   {t:Table[1] |$t}
}

function meta::relational::milestoning::getProcessingDateAliasLiteral():String[1]
{
   'k_processingDate';
}

function meta::relational::milestoning::getBusinessDateAliasLiteral():String[1]
{
   'k_businessDate';
}

function meta::relational::milestoning::isBiTemporalMilestoningTopLevelAnd(milestoningContext:TemporalMilestoningContext[1], func:meta::pure::metamodel::function::Function<Any>[1]):Boolean[1]
{
   $milestoningContext->isNotEmpty() && $milestoningContext.currentProcessingStateIsMilestonedClassProperty() && ($func->id() == 'and_Boolean_1__Boolean_1__Boolean_1_')
}

function meta::relational::milestoning::getAllMilestonedTableFilter( t:TemporalStrategy[1], query:SelectSQLQuery[1], milestoningContext:TemporalMilestoningContext[1] , inScopeVars:Map<String, List<Any>>[1], extensions:Extension[*]):meta::pure::metamodel::function::Function<{TableAlias[1]->Operation[0..1]}>[1]
{
   {ta:TableAlias[1]| let isMilestonedTable = $ta.relationalElement->relationalElementIsMilestoned();
                      if ($isMilestonedTable,
                          | $t->expandToSingleTemporalStrategies()->map(s| if ($s->relationalElementCanSupportStrategy($ta.relationalElement),
                                                                               | if ($milestoningContext.isAllVersionsInRange(),
                                                                                     | getTemporalMilestoneTableRangeFilter($ta.relationalElement->cast(@Table), $ta, $s, $milestoningContext->temporalRangeDates()),
                                                                                     | getTemporalTableFilter($ta.relationalElement->cast(@Table), $s, $ta, $s->temporalDate($milestoningContext)->at(0))),
                                                                               | []))->andFilters($extensions)->cast(@Operation);,
                          | []);
   };
}

function meta::relational::milestoning::getEqualityMilestonedFiltering(t:TemporalStrategy[1], sourceSelect: SelectSQLQuery[1], eqLhs:ValueSpecification[1], tableAlias :TableAlias[1], milestoningContext:TemporalMilestoningContext[1], processMilestoningParams:meta::pure::metamodel::function::Function<{->SelectSQLQuery[1]}>[1], state:State[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   if($t->instanceOf(BiTemporal),| let internalMilestoningProperty = $eqLhs->byPassRouterInfo()->cast(@FunctionExpression).func->cast(@Property<Nil,Any|*>);
                                   let biTemporalSubStrategy = if($internalMilestoningProperty.name->toOne() == 'processingDate',| ^ProcessingTemporal(),| if($internalMilestoningProperty.name->toOne() == 'businessDate',| ^BusinessTemporal() ,|[]))->toOne();
                                   $biTemporalSubStrategy->getEqualityMilestonedFilteringSelect($sourceSelect, $tableAlias, $milestoningContext, $processMilestoningParams, $state, $extensions);
                                ,| $t->getEqualityMilestonedFilteringSelect($sourceSelect, $tableAlias, $milestoningContext, $processMilestoningParams, $state, $extensions));
}

function meta::relational::milestoning::getEqualityMilestonedFilteringSelect(t:TemporalStrategy[1], sourceSelect : SelectSQLQuery[1], tableAlias :TableAlias[1], milestoningContext:TemporalMilestoningContext[1], processMilestoningParams:meta::pure::metamodel::function::Function<{->SelectSQLQuery[1]}>[1], state:State[0..1], extensions:Extension[*]):SelectSQLQuery[1]
{
    assert($t->instanceOf(ProcessingTemporal) || $t->instanceOf(BusinessTemporal),| 'temporal equality processing should only consider single temporal strategies, found:'+$t->type().name->toOne());
    $t->map(s| if ($s->relationalElementCanSupportStrategy($tableAlias.relationalElement),
                   | if ($milestoningContext.isAllVersionsInRange(),
                         | let temporalRangeDates = $milestoningContext->temporalRangeDates();
                           let milestonedFilteringOp =  getTemporalMilestoneTableRangeFilter($tableAlias.relationalElement->cast(@Table), $tableAlias, $s, $temporalRangeDates);
                           let newFilteringOp = $sourceSelect.filteringOperation->concatenate($milestonedFilteringOp)->andFilters($extensions);
                           ^$sourceSelect(filteringOperation=$newFilteringOp);,
                         | let temporalDate = $s->temporalDate($milestoningContext);
                           let selectDateFilterPair = if ($temporalDate->isNotEmpty(),
                                                          | pair($sourceSelect, $temporalDate->toOne()),
                                                          | let right = $processMilestoningParams->eval();
                                                            let rightVal = $state->toOne().inFilter->if(|$right.filteringOperation->at(0),|$right.columns->at(0));
                                                            let propagatedTemporalRlnOpElement = ^Alias( name=$s->temporalPropagatedColumnAliasProperties(), relationalElement=$rightVal);
                                                            pair(^$right(columns=$propagatedTemporalRlnOpElement), $rightVal);
                                                      )->toOne()->cast(@Pair<SelectSQLQuery, RelationalOperationElement>);
                           let milestonedFilteringOp = $tableAlias.relationalElement->match([t: Table[1] | getTemporalTableFilter($t, $s, $tableAlias, $selectDateFilterPair.second),
                                                                                             u: Union[1] | getTemporalUnionFilter($u, $s, $tableAlias, $selectDateFilterPair.second)]);
                           let newFilteringOp = $sourceSelect.filteringOperation->concatenate($milestonedFilteringOp)->andFilters($extensions);
                           let newSelect = $selectDateFilterPair.first;
                           ^$newSelect(filteringOperation=$newFilteringOp);),
                   | $sourceSelect))->toOne();
}

function meta::relational::milestoning::updateMilestoningContextWithPropagatedColumns(select:SelectSQLQuery[1], mc:TemporalMilestoningContext[0..1]):TemporalMilestoningContext[0..1]
{
   let updatedMilestoningContext = if($mc->isNotEmpty(),| let mcToOne=$mc->toOne();
                                                          temporalPropagatedColumnAliasProperties($mcToOne, $select.columns);
                                                       ,|$mc);

}

function <<access.private>> meta::relational::milestoning::temporalPropagatedColumnAliasProperties(t:TemporalStrategy[1]):String[1]
{
     $t->match([ p:ProcessingTemporal[1]| 'p_processingDate',
                 b:BusinessTemporal[1]| 'p_businessDate' ]);
}

function <<access.private>> meta::relational::milestoning::temporalPropagatedColumnAliasProperties(mc:TemporalMilestoningContext[1], columns:RelationalOperationElement[*]):TemporalMilestoningContext[1]
{
     let newMc = $columns->fold({c,mca| $c->match([ a:Alias[1] | if($a.name=='p_processingDate',|^$mca(processingDate=$a.relationalElement),| if($a.name=='p_businessDate',|^$mca(businessDate=$a.relationalElement),|$mca)),
                                                    r:RelationalOperationElement[1] | $mca]) }, $mc);
}

function meta::relational::milestoning::getMilestonedFilteringOperation(t:TemporalStrategy[1], tableAlias :TableAlias[1], milestoningContext:TemporalMilestoningContext[1]):Operation[*]
{
    $t->expandToSingleTemporalStrategies()->map(s| if($s->relationalElementCanSupportStrategy($tableAlias.relationalElement),
                                                      | if ($milestoningContext.isAllVersionsInRange(),
                                                            | let temporalRangeDates = $milestoningContext->temporalRangeDates();
                                                              $tableAlias.relationalElement->match([t: Table[1] | getTemporalMilestoneTableRangeFilter($t, $tableAlias, $s, $temporalRangeDates),
                                                                                                    u: Union[1] | []]);,
                                                            | let temporalDate = $s->temporalDate($milestoningContext)->at(0);
                                                              $tableAlias.relationalElement->match([t: Table[1] | getTemporalTableFilter($t, $s, $tableAlias, $temporalDate),
                                                                                                    u: Union[1] | getTemporalUnionFilter($u, $s, $tableAlias, $temporalDate)]);),
                                                      |[]));
}

function meta::relational::milestoning::getTemporalTableFilter(table:Table[1], milestoningStrategy:TemporalStrategy[1], tableAlias:TableAlias[1], temporalDate: RelationalOperationElement[1]):Operation[1]
{
   if ($milestoningStrategy->instanceOf(BusinessTemporal) && $table->hasMilestoning(BusinessSnapshotMilestoning),
       | $table->getBusinessSnapshotMilestoneTableFilter($tableAlias, $milestoningStrategy, $temporalDate),
       | $table->getTemporalMilestoneTableFilter($tableAlias, $milestoningStrategy, $temporalDate)
   );
}

function meta::relational::milestoning::getBusinessSnapshotMilestoneTableFilter(table:Table[1], tableAlias:TableAlias[1], milestoningStrategy:TemporalStrategy[1], temporalDate: RelationalOperationElement[1]):Operation[1]
{
   let snapshotDateColumn = $tableAlias.relationalElement->cast(@Table)->getSnapshotDateColumn()->toOne();
   let snapshotDate = ^TableAliasColumn(alias=$tableAlias, column=$snapshotDateColumn);
   getBusinessSnapshotMilestoneFilter($snapshotDate, $temporalDate);
}

function meta::relational::milestoning::getTemporalMilestoneTableFilter(table:Table[1], tableAlias:TableAlias[1], milestoningStrategy:TemporalStrategy[1], temporalDate: RelationalOperationElement[1]):Operation[1]
{
   let milestoneColumns = $tableAlias->getTemporalMilestoneColumns($milestoningStrategy);
   let inclusive = $milestoningStrategy->getInclusive($table);
   getTemporalMilestoneFilter($table, $milestoningStrategy, $milestoneColumns->at(0), $milestoneColumns->at(1), $temporalDate, $inclusive);
}

function meta::relational::milestoning::getTemporalMilestoneTableRangeFilter(table:Table[1], tableAlias:TableAlias[1], milestoningStrategy:TemporalStrategy[1], dateRange: RelationalOperationElement[*]):Operation[1]
{
   if($milestoningStrategy->instanceOf(BusinessTemporal) && $table->hasMilestoning(BusinessSnapshotMilestoning),
      | getTemporalMilestoneRangeFilterForBusinessSnapshotMilestoning($tableAlias, $milestoningStrategy, $dateRange->at(0), $dateRange->at(1));,
      | let milestoneColumns = $tableAlias->getTemporalMilestoneColumns($milestoningStrategy);
        let inclusive = $milestoningStrategy->getInclusive($table);
        getTemporalMilestoneRangeFilter($table, $milestoningStrategy, $milestoneColumns->at(0), $milestoneColumns->at(1), $dateRange->at(0), $dateRange->at(1), $inclusive);
      );
}

function meta::relational::milestoning::getTemporalMilestoneColumns(tableAlias:TableAlias[1], milestoningStrategy:TemporalStrategy[1]):RelationalOperationElement[2]
{
   let table = $tableAlias.relationalElement->cast(@Table);
   let lowerUpperColumns = $milestoningStrategy->getLowerUpperMilestonedColumns($table);
   let from = ^TableAliasColumn(alias=$tableAlias, column=$lowerUpperColumns->toOne().first);
   let thru = ^TableAliasColumn(alias=$tableAlias, column=$lowerUpperColumns->toOne().second);
   [$from,$thru];
}

function meta::relational::milestoning::getTemporalUnionFilter(union:Union[1], milestoningStrategy:TemporalStrategy[1], tableAlias:TableAlias[1], temporalDate: RelationalOperationElement[1]):Operation[1]
{
   let colAliases=$union.queries.columns->filter(c| $c->cast(@Alias).relationalElement->instanceOf(TableAliasColumn))->cast(@Alias);
   let tables = $colAliases.relationalElement->cast(@TableAliasColumn).alias.relationalElement->cast(@Table);

   let isColMilestoned = { c:Alias[1], storeMilestonedCols: Column[*] | $storeMilestonedCols->contains($c->cast(@Alias).relationalElement->cast(@TableAliasColumn).column)};
   let toUnionAlias = { c:Alias[1] | let tac=$c.relationalElement->cast(@TableAliasColumn); let col=$tac.column; ^$tac(alias=$tableAlias, column=^$col(name=$c.name));};
   let transformCols = { c: Alias[*], storeMilestonedCols: Column[*] | $c->filter(c|$isColMilestoned->eval($c,$storeMilestonedCols))->map(c|$toUnionAlias->eval($c))};

   $milestoningStrategy->match([ b : BusinessTemporal[1]   | getBusinessMilestoneUnionFilter($tables, $union, $milestoningStrategy, $temporalDate, $colAliases, $transformCols, $isColMilestoned, $toUnionAlias),
                                 p : ProcessingTemporal[1] | getTemporalMilestoneUnionFilter($tables, $union, $milestoningStrategy, $temporalDate, $colAliases, $transformCols, $isColMilestoned, $toUnionAlias)]);
}

function meta::relational::milestoning::getBusinessMilestoneUnionFilter(tables:Table[*], union:Union[1], milestoningStrategy:TemporalStrategy[1], temporalDate: RelationalOperationElement[1], colAliases:Alias[*], transformCols:LambdaFunction<{Alias[*], Column[*]->TableAliasColumn[*]}>[1], isColMilestoned:LambdaFunction<{Alias[1], Column[*]->Boolean[1]}>[1], toUnionAlias:LambdaFunction<{Alias[1]->TableAliasColumn[1]}>[1]):Operation[1]
{
   let tablesWithBusinessMilestoning = $tables->filter(table|$table->hasMilestoning(BusinessMilestoning));
   let tablesWithBusinessSnapshotMilestoning = $tables->filter(table|$table->hasMilestoning(BusinessSnapshotMilestoning));

   let businessMilestoningFilter = if($tablesWithBusinessMilestoning->isEmpty(),| [],| getTemporalMilestoneUnionFilter($tablesWithBusinessMilestoning, $union, $milestoningStrategy, $temporalDate, $colAliases, $transformCols, $isColMilestoned, $toUnionAlias));
   let businessSnapshotMilestoningFilter = if($tablesWithBusinessSnapshotMilestoning->isEmpty(),| [],| getBusinessSnapshotMilestoneUnionFilter($tablesWithBusinessSnapshotMilestoning, $union, $milestoningStrategy, $temporalDate, $colAliases, $transformCols, $isColMilestoned, $toUnionAlias));

   $businessMilestoningFilter->concatenate($businessSnapshotMilestoningFilter)->match([o1 : Operation[1] | $o1, o2 : Operation[2] | newAndOrDynaFunctionRelaxedBrackets('and',[$o2->at(0),$o2->at(1)])]);
}

function meta::relational::milestoning::getTemporalMilestoneUnionFilter(tables:Table[*], union:Union[1], milestoningStrategy:TemporalStrategy[1], temporalDate: RelationalOperationElement[1], colAliases:Alias[*], transformCols:LambdaFunction<{Alias[*], Column[*]->TableAliasColumn[*]}>[1], isColMilestoned:LambdaFunction<{Alias[1], Column[*]->Boolean[1]}>[1], toUnionAlias:LambdaFunction<{Alias[1]->TableAliasColumn[1]}>[1]):Operation[1]
{
   let lowerUpperColumns = $milestoningStrategy->getLowerUpperMilestonedColumns($tables);
   let fromTableAliasColumns=$transformCols->eval($colAliases,$lowerUpperColumns.first);
   let thruTableAliasColumns=$transformCols->eval($colAliases,$lowerUpperColumns.second);
   let from = $fromTableAliasColumns->getCoalesceForUnion();
   let thru = $thruTableAliasColumns->getCoalesceForUnion();
   let inclusive = $milestoningStrategy->getInclusive($tables);
   let includeNonMilestonedSubTypes = ^DynaFunction(name = 'isNull', parameters=$fromTableAliasColumns->concatenate($thruTableAliasColumns)->getCoalesceForUnion());

   newAndOrDynaFunctionRelaxedBrackets('or', [getTemporalMilestoneFilter($union, $milestoningStrategy, $from, $thru, $temporalDate, $inclusive), $includeNonMilestonedSubTypes]);
}

function meta::relational::milestoning::getBusinessSnapshotMilestoneUnionFilter(tables:Table[*], union:Union[1], milestoningStrategy:TemporalStrategy[1], temporalDate: RelationalOperationElement[1], colAliases:Alias[*], transformCols:LambdaFunction<{Alias[*], Column[*]->TableAliasColumn[*]}>[1], isColMilestoned:LambdaFunction<{Alias[1], Column[*]->Boolean[1]}>[1], toUnionAlias:LambdaFunction<{Alias[1]->TableAliasColumn[1]}>[1]):Operation[1]
{
   let snapshotDateColumns = $tables->getSnapshotDateColumns();
   let snapshotDateTableAliasColumns = $transformCols->eval($colAliases,$snapshotDateColumns);
   let snapshotDate = $snapshotDateTableAliasColumns->getCoalesceForUnion();
   let includeNonMilestonedSubTypesFilter = ^DynaFunction(name = 'isNull', parameters=$snapshotDate);
   newAndOrDynaFunctionRelaxedBrackets('or', [getBusinessSnapshotMilestoneFilter($snapshotDate, $temporalDate), $includeNonMilestonedSubTypesFilter]);
}

function meta::relational::milestoning::getCoalesceForUnion(tableAliasColumns:TableAliasColumn[*]):RelationalOperationElement[1]
{
   if($tableAliasColumns->size() == 1,| $tableAliasColumns->toOne(),| ^DynaFunction(name='coalesce', parameters=$tableAliasColumns));
}

function meta::relational::milestoning::getBusinessSnapshotMilestoneFilter(snapshotDate: RelationalOperationElement[1], date: RelationalOperationElement[1]):Operation[1]
{
   assert(!$date->isLatestDate(), '%latest not a valid businessDate for BusinessSnapshotMilestoning');
   ^DynaFunction(name = 'equal', parameters=[$snapshotDate, $date]);
}

function meta::relational::milestoning::getTemporalMilestoneFilter(r:Relation[1], m:TemporalStrategy[1], from: RelationalOperationElement[1], thru: RelationalOperationElement[1],  date: RelationalOperationElement[1], inclusive : Boolean[1]):Operation[1]
{
   if($date->isLatestDate(),| let tableLatestDate = $m->getInfinityDate($r);
                              ^DynaFunction(name = 'equal', parameters=[$thru, ^Literal(value=$tableLatestDate)]);
                           ,| let businessFrom = if($inclusive,| ^DynaFunction(name = 'lessThan', parameters=[$from, $date]),| ^DynaFunction(name = 'lessThanEqual', parameters=[$from, $date]));
                              let businessThru = if($inclusive,| ^DynaFunction(name = 'greaterThanEqual', parameters=[$thru, $date]),| ^DynaFunction(name = 'greaterThan', parameters=[$thru, $date]));
                              newAndOrDynaFunctionRelaxedBrackets('and', [$businessFrom,$businessThru]);)
}

function meta::relational::milestoning::getTemporalMilestoneRangeFilter(r:Relation[1], m:TemporalStrategy[1], from: RelationalOperationElement[1], thru: RelationalOperationElement[1], start: RelationalOperationElement[1], end: RelationalOperationElement[1], inclusive : Boolean[1]):Operation[1]
{
   assert(!$start->isLatestDate() && !$end->isLatestDate(), '%latest not a valid parameter for allVersionsInRange');
   let fromFilter = if ($inclusive,| ^DynaFunction(name = 'lessThan', parameters=[$from, $end]),| ^DynaFunction(name = 'lessThanEqual', parameters=[$from, $end]));
   let thruFilter = if ($inclusive,| ^DynaFunction(name = 'greaterThanEqual', parameters=[$thru, $start]),| ^DynaFunction(name = 'greaterThan', parameters=[$thru, $start]));
   newAndOrDynaFunctionRelaxedBrackets('and', [$fromFilter, $thruFilter]);
}

function meta::relational::milestoning::getTemporalMilestoneRangeFilterForBusinessSnapshotMilestoning(tableAlias:TableAlias[1], milestoningStrategy:TemporalStrategy[1], start: RelationalOperationElement[1], end: RelationalOperationElement[1]):Operation[1]
{
   assert(!$start->isLatestDate() && !$end->isLatestDate(), '%latest not a valid parameter for allVersionsInRange');
   let snapshotDateColumn = $tableAlias.relationalElement->cast(@Table)->getSnapshotDateColumn()->toOne();
   let snapshotDate = ^TableAliasColumn(alias=$tableAlias, column=$snapshotDateColumn);
  
   let lessThanFilter = ^DynaFunction(name = 'lessThanEqual', parameters=[$snapshotDate, $end]);
   let greaterThanFilter = ^DynaFunction(name = 'greaterThanEqual', parameters=[$snapshotDate, $start]);
   newAndOrDynaFunctionRelaxedBrackets('and', [$greaterThanFilter, $lessThanFilter]);
}

function meta::relational::milestoning::hasMilestoning(table:Table[1], milestoningType:Class<Milestoning>[1]):Boolean[1]
{
   $table.milestoning->exists(m|$m->instanceOf($milestoningType));
}

function meta::relational::milestoning::getLowerUpperMilestonedColumns(t:TemporalStrategy[1], tables:Table[*]):Pair<Column, Column>[*]
{
   $tables->map(table|$t->getLowerUpperMilestonedColumns($table))
}

function <<access.private>> meta::relational::milestoning::getLowerUpperMilestonedColumns(t:TemporalStrategy[1], table:Table[1]):Pair<Column, Column>[0..1]
{
   let tableMilestoning = $table.milestoning->filter(m|$m->milestoningCanSupportTemporalStrategy($t));
   if($tableMilestoning->isNotEmpty(),|$tableMilestoning->toOne()->cast(@TemporalMilestoning)->columns(),|[]);
}

function meta::relational::milestoning::getSnapshotDateColumns(tables:Table[*]):Column[*]
{
   $tables->map(table|$table->getSnapshotDateColumn());
}

function <<access.private>> meta::relational::milestoning::getSnapshotDateColumn(table:Table[1]):Column[0..1]
{
   $table.milestoning->filter(m|$m->instanceOf(BusinessSnapshotMilestoning))->cast(@BusinessSnapshotMilestoning).snapshotDate->first();
}

function meta::relational::milestoning::getInclusive(milestoningStrategy:TemporalStrategy[1], tables:Table[*]):Boolean[1]
{
   let inclusive = $tables.milestoning->filter(m|$m->milestoningCanSupportTemporalStrategy($milestoningStrategy))->match([p : ProcessingMilestoning[*] | $p.outIsInclusive, b : BusinessMilestoning[*] | $b.thruIsInclusive])->removeDuplicates();
   assert($inclusive->size() == 1, | 'Inclusive criteria not consistent across tables : ' + $tables->removeDuplicates().name->joinStrings('[', ',', ']') + ' in union operation.');
   $inclusive->toOne();
}

function meta::relational::milestoning::getMilestoneFilters(milestoningStrategy:TemporalStrategy[1], tables:TableAlias[*], milestoningContext:TemporalMilestoningContext[1]):Operation[*]
{
    let milestonedTables = $tables->filter(q|$milestoningStrategy->relationalElementCanSupportStrategy($q.relationalElement));
    $milestonedTables->map(q| getMilestonedFilteringOperation($milestoningStrategy, $q, $milestoningContext););
}

function meta::relational::milestoning::getMilestoningContextForPropertyPathQualifiedProperty(qp : QualifiedProperty<Any>[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1]):TemporalMilestoningContext[0..1]
{
   if($qp->hasGeneratedMilestoningPropertyStereotype(),| let qpParamCount = $qp.classifierGenericType.typeArguments.rawType->cast(@FunctionType).parameters->tail()->size();

                                                         let qpReturnType = $qp.genericType.rawType->toOne()->match([c:Class<Any>[1]|$c, a:Any[1]|[]]);
                                                         let milestoningStrategy = getTemporalMilestoningStrategy($qpReturnType->toOne())->toOne();
                                                         let expectedDateParamCount = $milestoningStrategy->dateParamCount();
                                                         assert($qpParamCount == $expectedDateParamCount, | 'property: ' + $qp.name->toOne()+' is '+$milestoningStrategy->class().name->toOne()+' expected ' + $expectedDateParamCount->toString() +' parameters, found ' + $qpParamCount->toString() + ' parameters');
                                                         let milestoningGeneratedEquals = $qp.expressionSequence->at(0)->findExpressionsForFunctionInValueSpecification([eq_Any_1__Any_1__Boolean_1_]);
                                                         let resolvedDateParams = $milestoningGeneratedEquals->map(e|let expectedDateVarExpr = $e.parametersValues->at(1);
                                                                                                                     let res = $expectedDateVarExpr->resolveInstanceValuesAtParameter($qp, $vars, $state.inScopeVars);
                                                                                                                     let date = $res->match([ d:Date[1]|$d,
                                                                                                                                              i:InstanceValue[1]|$i->resolveInstanceValuesAtParameter($qp, $vars, $state.inScopeVars)]);
                                                                                                                  );
                                                         assert($resolvedDateParams->size() == $expectedDateParamCount && $resolvedDateParams->fold({p,a|$p->instanceOf(Date) && $a}, true) ,| 'Unable to determine milestoned date parameter for property: ' + $qp.name->toOne());
                                                         $milestoningStrategy->newTemporalMilestoningContext($resolvedDateParams->cast(@Date)->map(d|^DateWrapper(date=^Literal(value=$d))), [], MilestoningProcessingState.MILESTONED_CLASS_PROPERTY);
                                                      ,|[]);
}

function meta::relational::milestoning::getQueryTableAliases(el: Any[*] ):TableAlias[*]{
   $el->getQueryTableRelationalOperationElements()->cast(@TableAlias)
}

function meta::relational::milestoning::getQueryTableRelationalOperationElements(el: Any[*] ):RelationalOperationElement[*]{
   $el->match([
     u : Union[1] | $u.queries->getQueryTableRelationalOperationElements(),
     s : SelectSQLQuery[1]|getQueryTableAliases($s.data)->concatenate(getQueryTableAliases($s.filteringOperation)),
     s : ViewSelectSQLQuery[1]|getQueryTableAliases($s.selectSQLQuery),
     a : RootJoinTreeNode[1]|getQueryTableAliases($a.alias)->concatenate(getQueryTableAliases($a->children())),
     b : JoinTreeNode[1]|getQueryTableAliases($b.alias)->concatenate(getQueryTableAliases($b.join.target))->concatenate(getQueryTableAliases($b->children())),
     t : TableAlias[1]| if ($t.relationalElement->instanceOf(Table) && !$t.relationalElement->instanceOf(ViewSelectSQLQuery),| $t,| getQueryTableAliases($t.relationalElement)),
     a:  Alias[1] | getQueryTableAliases($a.relationalElement),
     op: UnaryOperation[1] | getQueryTableAliases($op.nested),
     op: BinaryOperation[1] | getQueryTableAliases($op.left)->concatenate(getQueryTableAliases($op.right)),
     va : VariableArityOperation[1] | getQueryTableAliases($va.args),
     d : DynaFunction[1] | getQueryTableAliases($d.parameters),
     a : Any[1] | [],
     e : Any[*]| $e->map(el | $el->getQueryTableAliases())
   ])
}

function meta::relational::milestoning::getAppliedJoinMilestoningFilters(milestoningContext: TemporalMilestoningContext[0..1], joinTreeNode:JoinTreeNode[1], appliedJoinTreeNode:JoinTreeNode[1], state:State[1]) : Pair<JoinTreeNode, Operation>[*]{

   let milestoningContextIsAvailable = !$milestoningContext->isEmpty();
   let inUnionChainedJoin = {|$state.inUnionChainedJoin == true};
   let inIntermediateJoinForClassProperty = {|($milestoningContext->toOne().currentProcessingStateIsMilestonedClassProperty()->toOne() || $milestoningContext.currentProcessingState == MilestoningProcessingState.NON_MILESTONED_CLASS_PROPERTY) && !$joinTreeNode->children()->isEmpty()};
   let inDataTypeProperty = {|$milestoningContext.currentProcessingState == MilestoningProcessingState.DATATYPE_PROPERTY };

   if($milestoningContextIsAvailable && ($inUnionChainedJoin->eval() || $inIntermediateJoinForClassProperty->eval() || $inDataTypeProperty->eval()) ,| $milestoningContext.currentMilestoningStrategy->toOne()->getMilestoneFilters([$appliedJoinTreeNode.alias],$milestoningContext->toOne())->map(f|pair($appliedJoinTreeNode, $f)),|[]);
}

function meta::relational::milestoning::manageMilestoningContextPropogationForQualifiedProperties(op: OperationWithParentPropertyMapping[1], milestoningContext : TemporalMilestoningContext[0..1]): OperationWithParentPropertyMapping[1]{
   let swc = $op.element->cast(@SelectWithCursor);
   let updatedSwc = if($milestoningContext->isEmpty(),|^$swc(milestoningContext=[]),|let c=$milestoningContext->toOne(); ^$swc(milestoningContext=^$c(currentProcessingState=[])););
   ^$op(element=$updatedSwc);
}

function meta::relational::milestoning::manageMilestoningContextPropogationForProperties(swc: SelectWithCursor[1]): SelectWithCursor[1]{
   let milestoningContext=$swc.milestoningContext;
   if(!$milestoningContext->isEmpty() && !$milestoningContext->toOne().currentProcessingStateIsMilestonedClassProperty(),|^$swc(milestoningContext=[]),|$swc);
}

function meta::relational::milestoning::updateMilestoningContextProcessingStateForProperties(swc: SelectWithCursor[1], milestoningProcessingState: MilestoningProcessingState[0..1]): SelectWithCursor[1]{
    let milestoningContext=$swc.milestoningContext;
    if(!$milestoningContext->isEmpty() && !$milestoningContext->toOne().currentProcessingStateIsMilestonedClassProperty(),|
                                             let milestoningContextToOne = $milestoningContext->toOne();
                                             let milestoningContextUpdated=^$milestoningContextToOne(currentProcessingState=$milestoningProcessingState);
                                             ^$swc(milestoningContext=$milestoningContextUpdated);
                                       ,| $swc);
}

function meta::relational::milestoning::unknownDefaultBusinessDate():Date[1]{
   %9999-12-31
}

function <<access.private>> meta::relational::milestoning::getRelationalMilestoningType(t:TemporalStrategy[1]):Class<Milestoning>[*]
{
   $t->match([ p:ProcessingTemporal[1]| ProcessingMilestoning,
               b:BusinessTemporal[1]| BusinessMilestoning->concatenate(BusinessSnapshotMilestoning)])
}

function <<access.private>> meta::relational::milestoning::temporalRangeDates(mc:TemporalMilestoningContext[1]):RelationalOperationElement[*]
{
   $mc.startDate->concatenate($mc.endDate)
}

function <<access.private>> meta::relational::milestoning::temporalDate(t:TemporalStrategy[1], mc:TemporalMilestoningContext[1]):RelationalOperationElement[0..1]
{
   $t->match([ p:ProcessingTemporal[1]| $mc.processingDate,
               b:BusinessTemporal[1]| $mc.businessDate])
}

function <<access.private>> meta::relational::milestoning::tableMilestoning(t:TemporalStrategy[1], table:Table[1]):TemporalMilestoning[0..1]
{
  let tableMilestoning = $table.milestoning->filter(m|$m->milestoningCanSupportTemporalStrategy($t));
  $tableMilestoning->cast(@TemporalMilestoning)->first();
}

function <<access.private>> meta::relational::milestoning::columns(t:TemporalMilestoning[1]):Pair<Column, Column>[1]
{
    $t->match([ p:ProcessingMilestoning[1]| pair($p.in, $p.out),
                b:BusinessMilestoning[1]| pair($b.from, $b.thru)])
}

function meta::relational::milestoning::temporalColumnAliasProperties(t:TemporalStrategy[1]):Pair<String, String>[1]
{
     $t->match([ p:ProcessingTemporal[1]| pair('processingDate', getProcessingDateAliasLiteral()),
                 b:BusinessTemporal[1]| pair('businessDate', getBusinessDateAliasLiteral()) ]);
}

function <<access.private>> meta::relational::milestoning::getInfinityDate(t:TemporalStrategy[1], r:Relation[1]):Date[1]
{
     $r->match([table:Table[1] | let infinityDate = $t->getInfinityDate($table);
                                 assertNotEmpty($infinityDate,| '%latest usage for temporal parameter: '+$t->temporalColumnAliasProperties().first+' Table: '+$table.schema.name+'.'+$table.name+' requires it to specify a milestoning \'INFINITY_DATE\'');
                                 $infinityDate->toOne();,
                     u:Union[1]| let tables = $u.queries.data.alias.relationalElement->cast(@Table);
                                 let infinityDates = $tables->map(table|$t->getInfinityDate($table))->distinct();
                                 assert($infinityDates->size() == 1,| '%latest usage for Union requires all Unioned tables to specify a milestoning \'INFINITY_DATE\' which must be the same across all tables');
                                 $infinityDates->at(0);]);
}

function <<access.private>> meta::relational::milestoning::getInfinityDate(t:TemporalStrategy[1], table:Table[1]):Date[0..1]
{
   $t->tableMilestoning($table).infinityDate;
}

function <<access.private>> meta::relational::milestoning::isLatestDate(r:RelationalOperationElement[1]):Boolean[1]
{
   $r->instanceOf(Literal) && $r->cast(@Literal).value->instanceOf(Date) && $r->cast(@Literal).value->cast(@Date)->isLatestDate()
}

function meta::relational::milestoning::getKeyValueBuildClasses(t:TemporalStrategy[1], row : Row[1]):KeyValue[*]
{
   $t->expandToSingleTemporalStrategies()->map(s| let temporalColumnAliasProperties = $s->temporalColumnAliasProperties();
                                                  if($row.parent.columnNames->contains($temporalColumnAliasProperties.second),| ^KeyValue(key=$temporalColumnAliasProperties.first, value=parseDate($row.value($temporalColumnAliasProperties.second)->toString()))
                                                                                                                             ,| []);)
}

Class meta::relational::milestoning::DateWrapper
{
   date : RelationalOperationElement[0..1];
}

function <<access.private>> meta::relational::milestoning::resolveMilestoningDateParams(temporalStrategy: TemporalStrategy[1], milestoneDateParams : ValueSpecification[*], currentMilestoningContext : TemporalMilestoningContext[0..1], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):DateWrapper[*]
{
   let inScopeVars = $state.inScopeVars;
   let newState = ^$state(inFilter=false, qualifierBase=[]);
                                                                                                                                                                                                                                     
   let milestoningStrategies = if($temporalStrategy->instanceOf(SingleDateTemporalStrategy) && $milestoneDateParams->size() == 2,|$temporalStrategy->cast(@SingleDateTemporalStrategy)->repeat(2)                                        //handle the range case where two dates are supplied
                                                                                                                                ,|$temporalStrategy->expandToSingleTemporalStrategies()->reverse());
   
   let singleTemporalStrategyAndParam = $milestoningStrategies->zip($milestoneDateParams);
   $singleTemporalStrategyAndParam->map(dp | let d = $dp.second;
                                            $d->byPassRouterInfo()->match([ v: VariableExpression[1] | let resolvedVar = $inScopeVars->get($v.name).values->at(0);
                                                                                            let dateRoe = $resolvedVar->match([d:Date[1]|^Literal(value=$d),
                                                                                                                               p:PlanVarPlaceHolder[1]|^Literal(value=^VarPlaceHolder(name=$p.name,type = $p.type));]);
                                                                                            ^DateWrapper(date=$dateRoe);,
                                                                 i: InstanceValue[1] | $i.values->at(0)->match([
                                                                                          d: Date[1]               | ^DateWrapper(date=^Literal(value=$d));,
                                                                                          p: PlanVarPlaceHolder[1] | ^DateWrapper(date=^Literal(value=^VarPlaceHolder(name=$p.name,type=$p.type))),
                                                                                          a: Any[*]                | resolveMilestoningDateParams($temporalStrategy, $i.values->cast(@ValueSpecification), $currentMilestoningContext, $state, $vars, $context, $extensions)
                                                                                       ]),
                                                                 f: FunctionExpression[1] | let singleTemporalStrategy = $dp.first;
                                                                                            let isThisMilestonedGeneratedDateProperty = $f->isThisMilestonedGeneratedDateProperty($singleTemporalStrategy);
                                                                                            if($isThisMilestonedGeneratedDateProperty && $currentMilestoningContext->isNotEmpty(),| let tp = TemporalMilestoningContext.properties->filter(p|$p.name->toOne() == $f.func.name)->toOne();
                                                                                                                                                                                    $tp->eval($currentMilestoningContext)->map(d|^DateWrapper(date=$d->cast(@RelationalOperationElement)));
                                                                                                                                                                                 ,|if($f->isNonThisRootVariableExpression(),| 
                                                                                                                                                                                          if($state.functionExpressionStack->last()->evaluateAndDeactivate().func->in([
                                                                                                                                                                                              getAll_Class_1__Date_1__Date_1__T_MANY_, 
                                                                                                                                                                                              getAll_Class_1__Date_1__T_MANY_, 
                                                                                                                                                                                              getAllVersionsInRange_Class_1__Date_1__Date_1__T_MANY_
                                                                                                                                                                                              ]), 
                                                                                                                                                                                             | ^DateWrapper(date = processFunctionExpression($f, [], ^SelectWithCursor(select=^SelectSQLQuery()), $vars, ^$state(functionExpressionStack+=$f), JoinType.LEFT_OUTER, '', ^List<ColumnGroup>(values = []), $context, $extensions).element->cast(@SelectWithCursor).select.columns->first()), 
                                                                                                                                                                                             | ^DateWrapper() //change this so we look at the state + add test for range
                                                                                                                                                                                          )
                                                                                                                                                                                                                           ,| if($f->referencesVariableExpression()
                                                                                                                                                                                                                                 ,|  let new = newThisMilestonedPropertyExpression($singleTemporalStrategy);
                                                                                                                                                                                                                                     let nf = $f->replaceThisMilestoningPropertyVariableExpression($new, $singleTemporalStrategy)->cast(@FunctionExpression);
                                                                                                                                                                                                                                     let updatedInScopeVars = $inScopeVars->put('this', ^List<Any>(values=$currentMilestoningContext->toOne().toTemporalMilestoningThisContext()));
                                                                                                                                                                                                                                     let res = $nf->meta::relational::functions::pureToSqlQuery::processFunctionExpression([], ^SelectWithCursor(select=^SelectSQLQuery()), ^Map<VariableExpression, ValueSpecification>(), ^$newState(inScopeVars=$updatedInScopeVars), JoinType.LEFT_OUTER, '', ^List<ColumnGroup>(), $context, $extensions);
                                                                                                                                                                                                                                     let df = $res.element->cast(@SelectWithCursor).select.columns->at(0);
                                                                                                                                                                                                                                     ^DateWrapper(date=$df);
                                                                                                                                                                                                                                 ,|  $f->reactivate($inScopeVars)->map(d|^DateWrapper(date=^Literal(value=$d->cast(@Date)))))
                                                                                                                                                                                      )
                                                                                              );
                                                               ]););                                                                                                                                                                                                                                                                                                                                                                
}

function <<access.private>> meta::relational::milestoning::newThisMilestonedPropertyExpression(t:SingleDateTemporalStrategy[1]):FunctionExpression[1]
{
   let bd = temporalMilestoningThisContextProperty($t);
   let ve = ^VariableExpression(name='this', genericType = ^GenericType(rawType = meta::relational::milestoning::TemporalMilestoningThisContext), multiplicity = PureOne);
   ^FunctionExpression(func=$bd, genericType = ^GenericType(rawType = Date), parametersValues = $ve, importGroup = system::imports::coreImport, multiplicity = PureOne); 
}

function meta::relational::milestoning::temporalMilestoningThisContextProperty(t:SingleDateTemporalStrategy[1]):Property<TemporalMilestoningThisContext, Any|*>[1]
{
   TemporalMilestoningThisContext.properties->filter(p|$p.name==$t->temporalStrategyToPropertyName())->at(0);
}

function <<access.private>> meta::relational::milestoning::replaceThisMilestoningPropertyVariableExpression(v:ValueSpecification[1], new:FunctionExpression[1], t:SingleDateTemporalStrategy[1]):ValueSpecification[1]
{
   $v->match([
               f:FunctionExpression[1]| let newF = if($f->isMilestonedGeneratedDateProperty($t),| $new ,| ^$f(parametersValues=$f.parametersValues->map(v|$v->replaceThisMilestoningPropertyVariableExpression($new, $t)))),                                     
               e:ExtendedRoutedValueSpecification[1]|$e.value->replaceThisMilestoningPropertyVariableExpression($new, $t),
               e:FunctionRoutedValueSpecification[1]|$e.value->replaceThisMilestoningPropertyVariableExpression($new, $t),
               i:InstanceValue[1]|^$i(values = $i.values->map(v|$v->match([e:ValueSpecification[1]|$e->replaceThisMilestoningPropertyVariableExpression($new, $t),a:Any[1]|$a]))),
               v:ValueSpecification[1]|$v
            ])
}

function <<access.private>> meta::relational::milestoning::isThisMilestonedGeneratedDateProperty(f:FunctionExpression[1], t:SingleDateTemporalStrategy[0..1]):Boolean[1]
{
   if($f.parametersValues->size() > 0 ,| let lhs = $f.parametersValues->at(0)->byPassRouterInfo();
                                         $f->isMilestonedGeneratedDateProperty() && $lhs->isThisVariableExpression();
                                      ,| false)
}

function <<access.private>> meta::relational::milestoning::referencesVariableExpression(v:ValueSpecification[1]):Boolean[1]
{
   $v->byPassRouterInfo()->match([f:FunctionExpression[1] | $f.parametersValues->fold({x, y| $x->referencesVariableExpression() || $y }, false),
                                  v:VariableExpression[1] | true,
                                  e:ExtendedRoutedValueSpecification[1] | $e->byPassRouterInfo()->referencesVariableExpression(),
                                  v:ValueSpecification[1] | false])
}


function <<access.private>> meta::relational::milestoning::isNonThisRootVariableExpression(v:ValueSpecification[1]):Boolean[1]
{
   $v->byPassRouterInfo()->match([f:FunctionExpression[1] | if($f.parametersValues->isNotEmpty(),|$f.parametersValues->at(0)->isNonThisRootVariableExpression(),|false),
                                  v:VariableExpression[1] | true && $v.name != 'this',
                                  v:ValueSpecification[1] | false])
}

function <<access.private>> meta::relational::milestoning::isThisVariableExpression(v:ValueSpecification[1]):Boolean[1]
{
   $v->instanceOf(VariableExpression) && $v->cast(@VariableExpression).name == 'this'
}

function meta::relational::milestoning::relationalElementIsMilestoned(relationalOperationElement : RelationalOperationElement[1]):Boolean[1]
{
   $relationalOperationElement->match([     v : ViewSelectSQLQuery[1] | $v.selectSQLQuery.data.alias.relationalElement->toOne()->relationalElementIsMilestoned(),
                                            table : Table[1]          | $table.milestoning->isNotEmpty(),
                                            u : Union[1]              | $u.queries.data.alias.relationalElement->exists(q | $q->relationalElementIsMilestoned()) ,
                                            a : Any[1]                | false]);
}

function meta::relational::milestoning::relationalElementCanSupportStrategy(t:TemporalStrategy[1], relationalOperationElement : RelationalOperationElement[1]):Boolean[1]
{
   $relationalOperationElement->match([ table : Table[1] | $table.milestoning->exists(m|$m->milestoningCanSupportTemporalStrategy($t)),
                                            u : Union[1] | $u.queries->tail().data.alias.relationalElement->fold({a,b| $t->relationalElementCanSupportStrategy($a) || $b}, $t->relationalElementCanSupportStrategy($u.queries->head().data.alias.relationalElement->toOne())),
                                            a : Any[1]   | false]);
}

function meta::relational::milestoning::milestoningCanSupportTemporalStrategy(milestoning:Milestoning[1], temporalStrategy:TemporalStrategy[1]):Boolean[1]
{
   $milestoning->instanceOf(TemporalMilestoning) && $temporalStrategy->expandToSingleTemporalStrategies()->map(s|$s->getRelationalMilestoningType())->contains($milestoning->class());
}

function meta::relational::milestoning::getAllTemporalColumns(milestoning:Milestoning[*]):List<Column>[1]
{
   BusinessMilestoning->concatenate(BusinessSnapshotMilestoning)->concatenate(ProcessingMilestoning)->map(milestoningType| $milestoning->filter(m|$m->instanceOf($milestoningType)))->map(milestoning| $milestoning->getAllTemporalColumns())->list();
}

function meta::pure::milestoning::getAllTemporalColumns(milestoning:Milestoning[0..1]):Column[*]
{
   $milestoning->match([ b : BusinessMilestoning[1]           | [$b.from, $b.thru],
                         s : BusinessSnapshotMilestoning[1]   | $s.snapshotDate,
                         p : ProcessingMilestoning[1]         | [$p.in, $p.out]]);
}

function meta::relational::milestoning::concatenateTemporalTdsQueries(lfs:LambdaFunction<{->TabularDataSet[1]}>[*]):LambdaFunction<{->TabularDataSet[1]}>[1]
{
   let concat = ^SimpleFunctionExpression(func=concatenate_TabularDataSet_1__TabularDataSet_1__TabularDataSet_1_, multiplicity=ZeroOne, genericType=^GenericType(rawType=TabularDataSet), importGroup = system::imports::coreImport)->evaluateAndDeactivate();

   let concatSfe = $lfs->fold({lf:LambdaFunction<{->TabularDataSet[1]}>[1], s:SimpleFunctionExpression[1]|  let fe = $lf.expressionSequence->at(0)->evaluateAndDeactivate()->cast(@ValueSpecification)->meta::relational::milestoning::reprocessValueSpecification($lf->openVariableValues())->cast(@SimpleFunctionExpression);
                                                                                                            if($s.parametersValues->size() < 2 ,| ^$s(parametersValues+=$fe)
                                                                                                                                               ,| ^$concat(parametersValues=[$s, $fe]);


                                                                                                              );
                              }, $concat);

   let templateLambda = {|^TabularDataSet()};
   ^$templateLambda(expressionSequence = $concatSfe);
}

function meta::relational::milestoning::reprocessValueSpecification(v:ValueSpecification[1], vars:Map<String, List<Any>>[1]):ValueSpecification[1]
{
    $v->evaluateAndDeactivate()->match(  [   f: FunctionExpression[1] | ^$f(parametersValues=$f.parametersValues->map(vs | $vs->reprocessValueSpecification($vars))),
                    v: VariableExpression[1] | if($vars->get($v.name)->isEmpty(),|$v,|^InstanceValue(genericType=$v.genericType, multiplicity=PureOne, values=$vars->get($v.name).values)),
                    i: InstanceValue[1] | ^$i(values=$i.values->map(val | $val->match([
                                                  fd: FunctionDefinition<Any>[1] | ^$fd(expressionSequence=$fd.expressionSequence->map(vs | $vs->reprocessValueSpecification($vars))),
                                                  fe: FunctionExpression[1] | $fe->reprocessValueSpecification($vars),
                                                  ve: VariableExpression[1] | $ve->reprocessValueSpecification($vars),
                                                  a:  Any[1] | $a
                                                ]))),
                    v: ValueSpecification[1]| $v
                ]
             )->toOne();
}

function meta::pure::milestoning::temporalType(s:Stereotype[1]):TemporalStrategy[0..1]
{
   let t = [pair('temporal:processingtemporal', ^ProcessingTemporal()),pair('temporal:businesstemporal',^BusinessTemporal()), pair('temporal:bitemporal',^BiTemporal())];
   $t->filter(p|$p.first==$s.profile.name->toOne()+':'+$s.value)->map(p|$p.second)->first();
}

function meta::pure::milestoning::dateParamCount(s:TemporalStrategy[1]):Integer[1]
{
   $s->match([s:SingleDateTemporalStrategy[1] | 1,
              b:BiTemporal[1] | 2])
}

function meta::pure::milestoning::isMilestonedEqualityOperation(vs:ValueSpecification[1]) : Boolean[1]{
    let isSimpleFuncExpression =  { vs:ValueSpecification[1] | $vs->instanceOf(SimpleFunctionExpression)};
    let withSimpleFunctionExpressionArg =  { vs:ValueSpecification[1] | $vs->cast(@SimpleFunctionExpression).parametersValues->at(0)->byPassRouterInfo()->instanceOf(SimpleFunctionExpression)};
    let isGeneratedMilestoningProperty =  { vs:ValueSpecification[1] | $vs->cast(@SimpleFunctionExpression).parametersValues->at(0)->byPassRouterInfo()->cast(@SimpleFunctionExpression).func->hasGeneratedMilestoningPropertyStereotype()};
    $isSimpleFuncExpression->eval($vs) && $withSimpleFunctionExpressionArg->eval($vs) && $isGeneratedMilestoningProperty->eval($vs);
}

function meta::pure::milestoning::getTemporalMilestoningStrategy(vs:ValueSpecification[1]):TemporalStrategy[0..1]
{
   if($vs->isMilestonedEqualityOperation(),| let leftParam = $vs->cast(@FunctionExpression).parametersValues->at(0)->byPassRouterInfo();
                                             let lhsClass = $leftParam->cast(@SimpleFunctionExpression).func->cast(@Property<Nil,Any|*>).owner.classifierGenericType.typeArguments->at(0).rawType->toOne()->cast(@Class<Any>);
                                             getTemporalMilestoningStrategy($lhsClass);,
                                           | [])
}

function meta::pure::milestoning::getTemporalMilestoningStrategy(cls:Class<Any>[1]):TemporalStrategy[0..1]
{
   let temporalStereotype = $cls.stereotypes->filter(s|$s.profile.name == 'temporal');
   if (!$temporalStereotype->isEmpty(),|  assertFalse($temporalStereotype->size() > 1,  | 'Only one temporal stereotype should be specified, Class:'+ $cls.name->makeString(',')+' stereotypes: '+$temporalStereotype->makeString(','));
                                          temporalType($temporalStereotype->at(0));
                                      ,|[]);
}

function meta::pure::milestoning::expandToSingleTemporalStrategies(t:TemporalStrategy[1]):SingleDateTemporalStrategy[*]
{
   $t->match([s:SingleDateTemporalStrategy[1] | $s, b:BiTemporal[1] | [^BusinessTemporal(), ^ProcessingTemporal()]]);
}

function meta::pure::milestoning::isLatestDate(d:Date[1]):Boolean[1]
{
   $d->instanceOf(LatestDate)
}

function meta::relational::milestoning::getMilestoningContextForAll(expression:FunctionExpression[1],set:SetImplementation[1], parameters:ValueSpecification[*], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):TemporalMilestoningContext[0..1]
{
   let milestoningStrategy = getTemporalMilestoningStrategy($set.class);
   let dateParameters = $parameters->tail();
   
   if ($milestoningStrategy->isNotEmpty(),
       |if($expression.func == getAllForEachDate_Class_1__Date_MANY__T_MANY_,
                | $milestoningStrategy->toOne()->cast(@SingleDateTemporalStrategy)->getMilestoningContextForAllForEachDate($set),
                | $dateParameters->match([p0:ValueSpecification[0] | $milestoningStrategy->toOne()->getMilestoningContextForAllVersions($set),
                                          p1:ValueSpecification[1] | $milestoningStrategy->toOne()->getMilestoningContextFromTemporalDates($p1, [], MilestoningProcessingState.MILESTONED_ALL_FUNC, $state, $vars, $context, $extensions),
                                          p2:ValueSpecification[2] | $milestoningStrategy->match([s:SingleDateTemporalStrategy[1] | $s->getMilestoningContextForAllVersionsInRange($set, $p2, $state, $vars, $context, $extensions),
                                                                                         b:BiTemporal[1]                 | $b->getMilestoningContextFromTemporalDates($p2, [], MilestoningProcessingState.MILESTONED_ALL_FUNC, $state, $vars, $context, $extensions)])])),
       | []
   );
}

function meta::relational::milestoning::getMilestoningContextForQualifiedProperty(vs : ValueSpecification[1], parentMilestoningContext: TemporalMilestoningContext[0..1], leftSideMilestoningContext: TemporalMilestoningContext[0..1], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):TemporalMilestoningContext[0..1]
{
   let extractedVs = $vs->match([e:ExtendedRoutedValueSpecification[1]|$e.value, a:Any[1]|$a]);
   if ($extractedVs->instanceOf(FunctionExpression) && $extractedVs->cast(@FunctionExpression).func->instanceOf(QualifiedProperty) && $extractedVs->cast(@FunctionExpression).func->hasGeneratedMilestoningPropertyStereotype(),
      |
         let qpFe = $extractedVs->cast(@FunctionExpression);
         let qpReturnType = $qpFe.genericType.rawType->toOne()->match([c:Class<Any>[1]|$c, a:Any[1]|[]]);
         let milestoningStrategy = getTemporalMilestoningStrategy($qpReturnType->toOne());
         if(!$milestoningStrategy->isEmpty(),|$milestoningStrategy->toOne()->getMilestoningContextForQualifiedProperty($qpFe, $parentMilestoningContext, $state, $vars, $context, $extensions),|fail('Unable to identify Milestoning Context for Milestoned Qualified Property:'+$qpFe.func.name->toOne());[];);,
      | $leftSideMilestoningContext);
}

function <<access.private>> meta::relational::milestoning::getMilestoningContextForQualifiedProperty(milestoningStrategy:TemporalStrategy[1], fe:FunctionExpression[1], sourceMilestoningContext: TemporalMilestoningContext[0..1], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):TemporalMilestoningContext[0..1]
{
    let isGenProp = $fe->instanceOf(SimpleFunctionExpression) && $fe.func->hasGeneratedMilestoningPropertyStereotype();
    let dateArgs = $fe.parametersValues->tail();
    assertFalse($isGenProp && $dateArgs->isEmpty() ,|'No-Arg milestoned property: \''+$fe.func->meta::pure::metamodel::serialization::grammar::printFunctionSignature()+'\' must either be supplied with dates or be called in a Milestoned Context');
    
    if ($isGenProp,| if ($fe.func.name->endsWith('AllVersionsInRange'),
                       | $milestoningStrategy->cast(@SingleDateTemporalStrategy)->getMilestoningContextForAllVersionsInRangeQualifiedProperty($dateArgs, $state, $vars, $context, $extensions);,
                       | $milestoningStrategy->getMilestoningContextFromTemporalDates($dateArgs, $sourceMilestoningContext, MilestoningProcessingState.MILESTONED_CLASS_PROPERTY, $state, $vars, $context, $extensions))
                  ,| []);
}

function meta::relational::milestoning::getMilestoningContextFromTemporalDates(t:TemporalStrategy[1], milestoneDatesValues : ValueSpecification[*], currentMilestoningContext: TemporalMilestoningContext[0..1], currentProcessingState:MilestoningProcessingState[1], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):TemporalMilestoningContext[1]
{
    let milestoningDates = resolveMilestoningDateParams($t, $milestoneDatesValues, $currentMilestoningContext, $state, $vars, $context, $extensions);
    $t->newTemporalMilestoningContext($milestoningDates, [], $currentProcessingState);
}

function meta::relational::milestoning::getMilestoningContextForAllVersions(milestoningStrategy:TemporalStrategy[1], s:SetImplementation[1]):TemporalMilestoningContext[0..1]
{
   if ($s->instanceOf(RootRelationalInstanceSetImplementation) && $milestoningStrategy->relationalElementCanSupportStrategy($s->cast(@RootRelationalInstanceSetImplementation)->mainTable()),
       | let inclusiveTemporalColumns = $milestoningStrategy->expandToSingleTemporalStrategies()->map(temporalStrategy | $temporalStrategy->getInclusiveTemporalColumn($s->cast(@RootRelationalInstanceSetImplementation)))->reverse();
         $milestoningStrategy->newTemporalMilestoningContext($inclusiveTemporalColumns, [], MilestoningProcessingState.ALL_VERSIONS);,
       | []
   )
}

function meta::relational::milestoning::getMilestoningContextForAllVersionsInRange(milestoningStrategy:SingleDateTemporalStrategy[1], s:SetImplementation[1], dateParameters:ValueSpecification[*], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):TemporalMilestoningContext[0..1]
{
   if ($s->instanceOf(RootRelationalInstanceSetImplementation) && $milestoningStrategy->relationalElementCanSupportStrategy($s->cast(@RootRelationalInstanceSetImplementation)->mainTable()),
       | let milestoningDates = resolveMilestoningDateParams($milestoningStrategy, $dateParameters, [], $state, $vars, $context, $extensions);
         let inclusiveTemporalColumns = $milestoningStrategy->getInclusiveTemporalColumn($s->cast(@RootRelationalInstanceSetImplementation));
         $milestoningStrategy->newTemporalMilestoningContext($inclusiveTemporalColumns, $milestoningDates, MilestoningProcessingState.ALL_VERSIONS_IN_RANGE);,
       | []
   )
}

function meta::relational::milestoning::getMilestoningContextForAllVersionsInRangeQualifiedProperty(milestoningStrategy:SingleDateTemporalStrategy[1], dateParameters:ValueSpecification[*], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):TemporalMilestoningContext[0..1]
{
   let milestoningDates = resolveMilestoningDateParams($milestoningStrategy, $dateParameters, [], $state, $vars, $context, $extensions);   
   $milestoningStrategy->newTemporalMilestoningContext([], $milestoningDates, MilestoningProcessingState.ALL_VERSIONS_IN_RANGE);
}

function meta::relational::milestoning::getMilestoningContextForAllForEachDate(milestoningStrategy:SingleDateTemporalStrategy[1], s:SetImplementation[1]):TemporalMilestoningContext[0..1]
{
   if ($s->instanceOf(RootRelationalInstanceSetImplementation) && $milestoningStrategy->relationalElementCanSupportStrategy($s->cast(@RootRelationalInstanceSetImplementation)->mainTable()),
       | let inclusiveTemporalColumns = getInclusiveTemporalColumn($milestoningStrategy->cast(@SingleDateTemporalStrategy),$s->cast(@RootRelationalInstanceSetImplementation));
         $milestoningStrategy->newTemporalMilestoningContext($inclusiveTemporalColumns, [], MilestoningProcessingState.ALL_FOR_EACH_DATE);,
       | []
   )
}

function meta::relational::milestoning::getInclusiveTemporalColumn(milestoningStrategy:SingleDateTemporalStrategy[1], r:RootRelationalInstanceSetImplementation[1]):DateWrapper[1]
{
   let milestoning = $r->mainTable().milestoning->filter(m| $m->milestoningCanSupportTemporalStrategy($milestoningStrategy));
   let tableAlias = $r.mainTableAlias;
   ^DateWrapper(date = if ($milestoning->isEmpty(),| ^Literal(value = ^SQLNull()),| ^TableAliasColumn(alias = ^$tableAlias(name = 'root'), setMappingOwner = $r, column = $milestoning->toOne()->getInclusiveTemporalColumn())));
}

function meta::pure::milestoning::getInclusiveTemporalColumn(milestoning:Milestoning[1]):Column[1]
{
   $milestoning->match([p:ProcessingMilestoning[1]       | if ($p.outIsInclusive,| $p.out,| $p.in),
                        b:BusinessMilestoning[1]         | if ($b.thruIsInclusive,| $b.thru,| $b.from),
                        s:BusinessSnapshotMilestoning[1] | $s.snapshotDate]);
}

function <<access.private>> meta::relational::milestoning::newTemporalMilestoningContext(t:TemporalStrategy[1], temporalDates:DateWrapper[*], dateRangeParameters:DateWrapper[*], processingState:MilestoningProcessingState[0..1]):TemporalMilestoningContext[1]
{  
   let temporalMilestoningContext = ^TemporalMilestoningContext(currentMilestoningStrategy=$t, currentProcessingState=$processingState);
   let temporalMilestoningContextWithTemporalDate = if ($temporalDates->isNotEmpty(),
                                                        | $t->match([ p:ProcessingTemporal[1] | ^$temporalMilestoningContext(processingDate=$temporalDates->at(0).date),
                                                                      b:BusinessTemporal[1]   | ^$temporalMilestoningContext(businessDate=$temporalDates->at(0).date),
                                                                      bi:BiTemporal[1]        | ^$temporalMilestoningContext(processingDate=$temporalDates->at(0).date, businessDate=$temporalDates->at(1).date)]),
                                                        | $temporalMilestoningContext
                                                    );
   if ($dateRangeParameters->isNotEmpty(),
       | $t->match([ s:SingleDateTemporalStrategy[1] | ^$temporalMilestoningContextWithTemporalDate(startDate = $dateRangeParameters->at(0).date, endDate = $dateRangeParameters->at(1).date),
                     b:BiTemporal[1]                 | $temporalMilestoningContextWithTemporalDate]);,                                                 
       | $temporalMilestoningContextWithTemporalDate
   );
}