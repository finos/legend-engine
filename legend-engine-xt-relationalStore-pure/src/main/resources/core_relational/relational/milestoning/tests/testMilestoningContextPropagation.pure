// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::functions::asserts::*;
import meta::pure::runtime::*;
import meta::relational::mapping::*;
import meta::relational::metamodel::execute::*;
import meta::relational::runtime::*;
import meta::relational::tests::*;
import meta::relational::tests::milestoning::*;

function <<test.BeforePackage>> meta::relational::tests::milestoning::contextpropagation::setup():Any[0..1]
{
   initDatabase();
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningFiltersAppliedToIntermediateMilestonedJoinTablesWhereTargetTypeIsTemporalAndTargetMainTableIsNotMilestoned():Boolean[1]
{
   let businessDate = %2015-8-14;

   let result = execute(|Order.all()->project([o|$o.systemADescription($businessDate).description],['systemADescription']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());

   let tds = $result.values->at(0);
   assertEquals(['system A order description 1', 'system A order description 2'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "systemaorderdescriptiontable_0".description as "systemADescription" from OrderTable as "root" left outer join OrderToSystemADescriptions as "ordertosystemadescriptions_0" on ("root".id = "ordertosystemadescriptions_0".orderId and "ordertosystemadescriptions_0".from_z <= \'2015-08-14\' and "ordertosystemadescriptions_0".thru_z > \'2015-08-14\') left outer join SystemAOrderDescriptionTable as "systemaorderdescriptiontable_0" on ("ordertosystemadescriptions_0".systemADescriptionId = "systemaorderdescriptiontable_0".descriptionId)', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testExtraColumnsAreNotAppliedToIntermediateMilestonedJoinTables():Boolean[1]
{
   let businessDate = %2015-8-15;

   let result = execute(|Order.all()->project([o|$o.product($businessDate).stockProductName],['stockProductName']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());

   let tds = $result.values->at(0);
   assertEquals(['ProductName', 'TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "productdescriptiontable_0".description as "stockProductName" from OrderTable as "root" left outer join ProductTable as "producttable_0" on ("root".prodFk = "producttable_0".id and "producttable_0".from_z <= \'2015-08-15\' and "producttable_0".thru_z > \'2015-08-15\') left outer join (select "stockproducttable_1".id as id from StockProductTable as "stockproducttable_1" where "stockproducttable_1".from_z <= \'2015-08-15\' and "stockproducttable_1".thru_z > \'2015-08-15\') as "stockproducttable_0" on ("producttable_0".id = "stockproducttable_0".id) left outer join ProductDescriptionTable as "productdescriptiontable_0" on ("stockproducttable_0".id = "productdescriptiontable_0".id)', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningFiltersAppliedToIntermediateMilestonedJoinTablesWhereSourceIsEmbeddedTargetTypeIsNonTemporalAndTargetMainTableIsNotMilestoned():Boolean[1]
{
   let businessDate = %2015-10-16;

   let result = execute(|StockProduct.all($businessDate)->project([s|$s.classification($businessDate).system.name],['systemName']), milestoningMapWithEmbedded, testRuntime(), meta::relational::extension::relationalExtensions());

   let tds = $result.values->at(0);
   assertEquals(['SYS1', 'SYS1'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "systemtable_0".name as "systemName" from ProductTable as "root" left outer join ProductClassificationSystemTable as "productclassificationsystemtable_0" on ("root".classificationSystemId = "productclassificationsystemtable_0".id and "productclassificationsystemtable_0".from_z <= \'2015-10-16\' and "productclassificationsystemtable_0".thru_z > \'2015-10-16\') left outer join SystemTable as "systemtable_0" on ("productclassificationsystemtable_0".name = "systemtable_0".name) where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);

}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningFiltersPropogatedToDataTypePropertiesFromAllInProject():Boolean[1]
{
   let businessDate = %2015-10-16;

   let result = execute(|Product.all($businessDate)->project([p|$p.name, p|$p.classificationType],['name','classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);

   assertEquals(['ProductName2,STOCK', 'ProductName3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".name as "name", "productclassificationtable_0".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testLatestMilestoningFiltersPropogatedToDataTypePropertiesFromAllInProject():Boolean[1]
{
   let result = execute(|Product.all(%latest)->project([p|$p.name, p|$p.classificationType],['name','classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".name as "name", "productclassificationtable_0".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".thru_z = \'9999-12-31 00:00:00.0000\') where "root".thru_z = \'9999-12-31 00:00:00.0000\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningFiltersPropogatedFromAllThroughFilterToDataTypePropertiesInProject():Boolean[1]
{
   let businessDate = %2015-10-16;

   let result = execute(|Product.all($businessDate)->filter(p|$p.name!='')->project([p|$p.name, p|$p.classificationType],['name','classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);

   assertEquals(['ProductName2,STOCK', 'ProductName3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".name as "name", "productclassificationtable_0".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') where ("root".name <> \'\' OR "root".name is null) and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningFiltersPropogatedToDataTypePropertiesFromAllInFilter():Boolean[1]
{
   let businessDate = %2015-10-16;

   let result = execute(|Product.all($businessDate)->filter(p|$p.classificationType == ProductClassificationType.STOCK), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());

   assertEquals([ProductClassificationType.STOCK], $result.values->map(p|$p.classificationType));
   assertSameSQL('select "root".id as "pk_0", "root".name as "pk_1", "root".id as "id", "root".name as "name", "root".type as "type", "productdescriptiontable_0".description as "stockProductName", "productclassificationtable_0".type as "classificationType", \'2015-10-16\' as "k_businessDate" from ProductTable as "root" left outer join StockProductTable as "stockproducttable_0" on ("root".id = "stockproducttable_0".id and "stockproducttable_0".from_z <= \'2015-10-16\' and "stockproducttable_0".thru_z > \'2015-10-16\') left outer join ProductDescriptionTable as "productdescriptiontable_0" on ("stockproducttable_0".id = "productdescriptiontable_0".id) left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') left outer join ProductClassificationTable as "productclassificationtable_1" on ("root".type = "productclassificationtable_1".type and "productclassificationtable_1".from_z <= \'2015-10-16\' and "productclassificationtable_1".thru_z > \'2015-10-16\') where "productclassificationtable_1".type = \'STOCK\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningFiltersNotPropogatedFromAllToNonTemporalClassMappedToTemporalTable():Boolean[1]
{
   let businessDate = %2015-10-16;

   let result = execute(|Product.all($businessDate)->project([p|$p.id, p|$p.newActivity.createdBy],['name','classificationType']), propagationMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);

   assertEquals(['2,smith', '3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".id as "name", "newactivityinfotable_0".created_by as "classificationType" from ProductTable as "root" left outer join NewActivityInfoTable as "newactivityinfotable_0" on ("root".id = "newactivityinfotable_0".productId) where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningFiltersUsedOnIntermediateJoinOnlyFromAllToNonTemporalClassMappedToTemporalTable():Boolean[1]
{
   let businessDate = %2015-10-16;

   let result = execute(|Product.all($businessDate)->project([p|$p.id, p|$p.cancelActivity.createdBy],['name','classificationType']), propagationMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);

   assertEquals(['2,smith', '3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".id as "name", "newactivityinfotable_0".created_by as "classificationType" from ProductTable as "root" left outer join CancelActivitiesTable as "cancelactivitiestable_0" on ("root".id = "cancelactivitiestable_0".productId and "cancelactivitiestable_0".from_z <= \'2015-10-16\' and "cancelactivitiestable_0".thru_z > \'2015-10-16\') left outer join NewActivityInfoTable as "newactivityinfotable_0" on ("cancelactivitiestable_0".productId = "newactivityinfotable_0".productId) where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningFiltersUsedOnIntermediateJoinOnlyFromAllToNonTemporalClassMappedToTemporalTableWithFilter():Boolean[1]
{
   let businessDate = %2015-10-16;

   let result = execute(|Product.all($businessDate)->project([p|$p.id, p|$p.cancelProductActivity.createdBy],['name','classificationType']), propagationMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);

   assertEquals(['2,smith', '3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".id as "name", "cancelactivitiestable_0".created_by as "classificationType" from ProductTable as "root" left outer join (select "cancelactivitiestable_1".productId as productId, "newactivityinfotable_0".created_by as created_by from CancelActivitiesTable as "cancelactivitiestable_1" inner join NewActivityInfoTable as "newactivityinfotable_0" on ("cancelactivitiestable_1".productId = "newactivityinfotable_0".productId) where "newactivityinfotable_0".productId > 0 and "cancelactivitiestable_1".from_z <= \'2015-10-16\' and "cancelactivitiestable_1".thru_z > \'2015-10-16\') as "cancelactivitiestable_0" on ("root".id = "cancelactivitiestable_0".productId) where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testIsolationOfMilestoningFiltersUsedOnIntermediateJoinInOR():Boolean[1]
{
   let businessDate = %2015-10-16;
   let result = execute(|Product.all($businessDate)->filter(p| $p.cancelProductActivity.createdBy == 'David' || $p.newActivity.createdBy == 'Peter'), propagationMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".id as "pk_0", "root".name as "pk_1", "root".id as "id", "cancelactivitiestable_0".created_by as "cancelProductActivityCreatedBy", \'2015-10-16\' as "k_businessDate" from ProductTable as "root" left outer join (select "cancelactivitiestable_0".productId as productId, "cancelactivitiestable_0".from_z as from_z, "cancelactivitiestable_0".thru_z as thru_z, "newactivityinfotable_0".created_by as created_by from CancelActivitiesTable as "cancelactivitiestable_0" inner join NewActivityInfoTable as "newactivityinfotable_0" on ("cancelactivitiestable_0".productId = "newactivityinfotable_0".productId and "newactivityinfotable_0".from_z <= \'2015-10-16\' and "newactivityinfotable_0".thru_z > \'2015-10-16\')) as "cancelactivitiestable_0" on ("root".id = "cancelactivitiestable_0".productId and "cancelactivitiestable_0".from_z <= \'2015-10-16\' and "cancelactivitiestable_0".thru_z > \'2015-10-16\') left outer join (select "cancelactivitiestable_2".productId as productId, "newactivityinfotable_1".created_by as created_by from CancelActivitiesTable as "cancelactivitiestable_2" inner join NewActivityInfoTable as "newactivityinfotable_1" on ("cancelactivitiestable_2".productId = "newactivityinfotable_1".productId) where "newactivityinfotable_1".productId > 0 and "cancelactivitiestable_2".from_z <= \'2015-10-16\' and "cancelactivitiestable_2".thru_z > \'2015-10-16\') as "cancelactivitiestable_1" on ("root".id = "cancelactivitiestable_1".productId) left outer join NewActivityInfoTable as "newactivityinfotable_2" on ("root".id = "newactivityinfotable_2".productId) where ("cancelactivitiestable_1".created_by = \'David\' or "newactivityinfotable_2".created_by = \'Peter\') and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningFiltersOnIntermediateInnerJoins():Boolean[1]
{
   let businessDate = %2015-10-16;

   let result = execute(|Product.all($businessDate)->project([p|$p.id, p|$p.cancelProductActivityCreatedBy],['name','cancelProductActivityCreatedBy']), propagationMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);

   assertEquals(['2,TDSNull', '3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".id as "name", "cancelactivitiestable_0".created_by as "cancelProductActivityCreatedBy" from ProductTable as "root" left outer join (select "cancelactivitiestable_1".productId as productId, "newactivityinfotable_0".created_by as created_by from CancelActivitiesTable as "cancelactivitiestable_1" inner join NewActivityInfoTable as "newactivityinfotable_0" on ("cancelactivitiestable_1".productId = "newactivityinfotable_0".productId) where "newactivityinfotable_0".from_z <= \'2015-10-16\' and "newactivityinfotable_0".thru_z > \'2015-10-16\' and "cancelactivitiestable_1".from_z <= \'2015-10-16\' and "cancelactivitiestable_1".thru_z > \'2015-10-16\') as "cancelactivitiestable_0" on ("root".id = "cancelactivitiestable_0".productId) where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextNotPropogatedThroughNonTemporalPropertiesFromAll():Boolean[1]
{
   let businessDate = %2015-10-16;
                                                                          //referenceSystem is a nonTemporal property, systemDescription requires a date or use the EdgePointProperty
   let result = execute(|Product.all($businessDate)->project([p|$p.id, p|$p.referenceSystem.systemDescriptionAllVersions.description],['name','sysDescription']), propagationMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);

   assertEquals(['2,SYS1 description 1-v1', '2,SYS1 description 1-v2', '3,SYS1 description 1-v1', '3,SYS1 description 1-v2'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".id as "name", "systemdescriptiontable_0".description as "sysDescription" from ProductTable as "root" left outer join SystemTable as "systemtable_0" on ("root".referenceSystemName = "systemtable_0".name) left outer join SystemDescriptionTable as "systemdescriptiontable_0" on ("systemtable_0".name = "systemdescriptiontable_0".systemName) where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextWithLatestDateNotPropogatedThroughNonTemporalPropertiesFromAll():Boolean[1]
{
   let result = execute(|Product.all(%latest)->project([p|$p.id, p|$p.referenceSystem.systemDescriptionAllVersions.description],['name','sysDescription']), propagationMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".id as "name", "systemdescriptiontable_0".description as "sysDescription" from ProductTable as "root" left outer join SystemTable as "systemtable_0" on ("root".referenceSystemName = "systemtable_0".name) left outer join SystemDescriptionTable as "systemdescriptiontable_0" on ("systemtable_0".name = "systemdescriptiontable_0".systemName) where "root".thru_z = \'9999-12-31 00:00:00.0000\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextNotPropogatedThroughNonTemporalPropertiesFromMilestonedQualifiedProperty():Boolean[1]
{
   let businessDate = %2015-10-16;
                                                                                  //referenceSystem is a nonTemporal property, systemDescription requires a date or use the EdgePointProperty
   let result = execute(|Order.all()->project([o|$o.id, o|$o.product($businessDate).referenceSystem.systemDescriptionAllVersions.description],['name','sysDescription']), propagationMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);

   assertEquals(['1,TDSNull', '2,SYS1 description 1-v1', '2,SYS1 description 1-v2'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".id as "name", "systemdescriptiontable_0".description as "sysDescription" from OrderTable as "root" left outer join ProductTable as "producttable_0" on ("root".prodFk = "producttable_0".id and "producttable_0".from_z <= \'2015-10-16\' and "producttable_0".thru_z > \'2015-10-16\') left outer join SystemTable as "systemtable_0" on ("producttable_0".referenceSystemName = "systemtable_0".name) left outer join SystemDescriptionTable as "systemdescriptiontable_0" on ("systemtable_0".name = "systemdescriptiontable_0".systemName)', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationThruFilterIsIndenpendentOfDateManipulationWithinTheFilter():Boolean[1]
{
   let resultWithDatePropogated = execute(|Product.all(%2015-10-16)->filter(p|$p.classification(%2015-10-15).type=='STOCK')->project([p|$p.id, p|$p.classification.type],['id','classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $resultWithDatePropogated.values->at(0);
   assertEquals(['2,STOCK'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL( 'select "root".id as "id", "productclassificationtable_1".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-15\' and "productclassificationtable_0".thru_z > \'2015-10-15\') left outer join ProductClassificationTable as "productclassificationtable_1" on ("root".type = "productclassificationtable_1".type and "productclassificationtable_1".from_z <= \'2015-10-16\' and "productclassificationtable_1".thru_z > \'2015-10-16\') where "productclassificationtable_0".type = \'STOCK\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $resultWithDatePropogated->sqlRemoveFormatting());
   let resultWithDateSpecified = execute(|Product.all(%2015-10-16)->filter(p|$p.classification(%2015-10-15).type=='STOCK')->project([p|$p.id, p|$p.classification(%2015-10-16).type],['id','classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals($resultWithDatePropogated->sqlRemoveFormatting(),$resultWithDateSpecified->sqlRemoveFormatting());
}

//Product.classification is a business temporal property, businessDate is automatically propogated from Product.all(..)
function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationFromTypeQueryToNoArgMilestonedQpInFilter():Boolean[1]
{
   let result = execute(|Product.all(%2015-10-16)->filter(p|$p.classification.type=='STOCK'), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let products = $result.values;
   assertEquals(1, $products->size());
   assertEquals(['ProductName2'], $products->map(p|$p.name));
   assertEquals([%2015-10-16], $products->map(p|$p.businessDate));
   assertSameSQL( 'select "root".id as "pk_0", "root".name as "pk_1", "root".id as "id", "root".name as "name", "root".type as "type", "productdescriptiontable_0".description as "stockProductName", "productclassificationtable_0".type as "classificationType", \'2015-10-16\' as "k_businessDate" from ProductTable as "root" left outer join StockProductTable as "stockproducttable_0" on ("root".id = "stockproducttable_0".id and "stockproducttable_0".from_z <= \'2015-10-16\' and "stockproducttable_0".thru_z > \'2015-10-16\') left outer join ProductDescriptionTable as "productdescriptiontable_0" on ("stockproducttable_0".id = "productdescriptiontable_0".id) left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') left outer join ProductClassificationTable as "productclassificationtable_1" on ("root".type = "productclassificationtable_1".type and "productclassificationtable_1".from_z <= \'2015-10-16\' and "productclassificationtable_1".thru_z > \'2015-10-16\') where "productclassificationtable_1".type = \'STOCK\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationFromTypeQueryThroughFilterToNoArgMilestonedQpInProject():Boolean[1]
{
   let result = execute(|Product.all(%2015-10-16)->filter(p|$p.classification.type=='STOCK')->project([p|$p.classification.type],['classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(['STOCK'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL( 'select "productclassificationtable_0".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') where "productclassificationtable_0".type = \'STOCK\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationFromTypeQueryDoesNotOverrideThatSpecifiedAsArgToMilestonedQpInFilter():Boolean[1]
{
   let result = execute(|Product.all(%2015-10-16)->filter(p|$p.classification(%2015-10-17).type=='STOCK'), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let products = $result.values;
   assertEquals(1, $products->size());
   assertEquals(['ProductName2'], $products->map(p|$p.name));
   assertEquals([%2015-10-16], $products->map(p|$p.businessDate));
   assertSameSQL('select "root".id as "pk_0", "root".name as "pk_1", "root".id as "id", "root".name as "name", "root".type as "type", "productdescriptiontable_0".description as "stockProductName", "productclassificationtable_0".type as "classificationType", \'2015-10-16\' as "k_businessDate" from ProductTable as "root" left outer join StockProductTable as "stockproducttable_0" on ("root".id = "stockproducttable_0".id and "stockproducttable_0".from_z <= \'2015-10-16\' and "stockproducttable_0".thru_z > \'2015-10-16\') left outer join ProductDescriptionTable as "productdescriptiontable_0" on ("stockproducttable_0".id = "productdescriptiontable_0".id) left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') left outer join ProductClassificationTable as "productclassificationtable_1" on ("root".type = "productclassificationtable_1".type and "productclassificationtable_1".from_z <= \'2015-10-17\' and "productclassificationtable_1".thru_z > \'2015-10-17\') where "productclassificationtable_1".type = \'STOCK\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testLatestMilestoneDatePropogationFromTypeQueryDoesNotOverrideThatSpecifiedAsArgToMilestonedQpInFilter():Boolean[1]
{
   let result = execute(|Product.all(%latest)->filter(p|$p.classification(%2015-10-17).type=='STOCK'), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".id as "pk_0", "root".name as "pk_1", "root".id as "id", "root".name as "name", "root".type as "type", "productdescriptiontable_0".description as "stockProductName", "productclassificationtable_0".type as "classificationType", \'9999-12-31T00:00:00.0000+0000\' as "k_businessDate" from ProductTable as "root" left outer join StockProductTable as "stockproducttable_0" on ("root".id = "stockproducttable_0".id and "stockproducttable_0".thru_z = \'9999-12-31 00:00:00.0000\') left outer join ProductDescriptionTable as "productdescriptiontable_0" on ("stockproducttable_0".id = "productdescriptiontable_0".id) left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".thru_z = \'9999-12-31 00:00:00.0000\') left outer join ProductClassificationTable as "productclassificationtable_1" on ("root".type = "productclassificationtable_1".type and "productclassificationtable_1".from_z <= \'2015-10-17\' and "productclassificationtable_1".thru_z > \'2015-10-17\') where "productclassificationtable_1".type = \'STOCK\' and "root".thru_z = \'9999-12-31 00:00:00.0000\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testLatestMilestoneDateMappedTableDateDoesNotOverrideLatestDateFromChildPropertyInPropogation():Boolean[1]
{
   let result = execute(|Product.all(%latest)->filter(p|$p.classification.type=='STOCK'), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "root".id as "pk_0", "root".name as "pk_1", "root".id as "id", "root".name as "name", "root".type as "type", "productdescriptiontable_0".description as "stockProductName", "productclassificationtable_0".type as "classificationType", \'9999-12-31T00:00:00.0000+0000\' as "k_businessDate" from ProductTable as "root" left outer join StockProductTable as "stockproducttable_0" on ("root".id = "stockproducttable_0".id and "stockproducttable_0".thru_z = \'9999-12-31 00:00:00.0000\') left outer join ProductDescriptionTable as "productdescriptiontable_0" on ("stockproducttable_0".id = "productdescriptiontable_0".id) left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".thru_z = \'9999-12-31 00:00:00.0000\') left outer join ProductClassificationTable as "productclassificationtable_1" on ("root".type = "productclassificationtable_1".type and "productclassificationtable_1".thru_z = \'9999-12-31 00:00:00.0000\') where "productclassificationtable_1".type = \'STOCK\' and "root".thru_z = \'9999-12-31 00:00:00.0000\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationFromTypeQueryDoesNotOverrideThatSpecifiedAsArgToMilestonedQpInProject():Boolean[1]
{
   let result = execute(|Product.all(%2015-10-16)->filter(p|$p.classification(%2017-10-16).type=='STOCK')->project([p|$p.classification(%2018-10-16).type],['classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(['STOCK'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "productclassificationtable_1".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2017-10-16\' and "productclassificationtable_0".thru_z > \'2017-10-16\') left outer join ProductClassificationTable as "productclassificationtable_1" on ("root".type = "productclassificationtable_1".type and "productclassificationtable_1".from_z <= \'2018-10-16\' and "productclassificationtable_1".thru_z > \'2018-10-16\') where "productclassificationtable_0".type = \'STOCK\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationFromTypeQueryToProjectIsNotOverridenBySamePropertyUsedInFilterWithDifferentDateArguments():Boolean[1]
{
   let result = execute(|Product.all(%2015-10-16)->filter(p|$p.classification(%2017-10-16).type=='STOCK')->project([p|$p.classification.type],['classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(['STOCK'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "productclassificationtable_1".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2017-10-16\' and "productclassificationtable_0".thru_z > \'2017-10-16\') left outer join ProductClassificationTable as "productclassificationtable_1" on ("root".type = "productclassificationtable_1".type and "productclassificationtable_1".from_z <= \'2015-10-16\' and "productclassificationtable_1".thru_z > \'2015-10-16\') where "productclassificationtable_0".type = \'STOCK\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDateNotPropogatedThroughNonMilestonedType():Boolean[1]
{
   let result = execute(|Product.all(%2015-10-16)->filter(p|$p.referenceSystem->toOne().systemDescription(%2014-10-17).description=='SYS1 description 1-v1')->project([p|$p.id],['id']), propagationMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(['2','3'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".id as "id" from ProductTable as "root" left outer join SystemTable as "systemtable_0" on ("root".referenceSystemName = "systemtable_0".name) left outer join SystemDescriptionTable as "systemdescriptiontable_0" on ("systemtable_0".name = "systemdescriptiontable_0".systemName and "systemdescriptiontable_0".from_z <= \'2014-10-17\' and "systemdescriptiontable_0".thru_z > \'2014-10-17\') where "systemdescriptiontable_0".description = \'SYS1 description 1-v1\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

//we don't support this yet in the Compiler
// function <<test.Test, test.ToFix>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationFromWithinTheMapToProject():Boolean[1]
// {
//    let resultWithDatePropagated = execute(|Product.all(%2015-10-16)->map(p|$p.classification(%2015-1-15))->project([c|$c.description, c|$c.exchange.name], ['productClassificationDescription','productClassificationExchangeName']), milestoningmap,testRuntime(), meta::relational::extension::relationalExtensions());
//    let tds = $resultWithDatePropagated.values->at(0);
   
//    assertEquals(['OPTION DESC-V1,ISE'],$tds.rows->map(r|$r.values->makeString(',')));
//    assertSameSQL('select "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".type_description as "productClassificationDescription", "ProductExchangeTable_d#6_d_m2_md".name as "productClassificationExchangeName" from ProductTable as "root" left outer join ProductClassificationTable as "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1" on ("root".type = "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".type) left outer join (select "ProductExchangeTable_d#6".name as name from ProductExchangeTable as "ProductExchangeTable_d#6" where "ProductExchangeTable_d#6".from_z <= \'2015-01-15\' and "ProductExchangeTable_d#6".thru_z > \'2015-01-15\') as "ProductExchangeTable_d#6_d_m2_md" on ("ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".exchange = "ProductExchangeTable_d#6_d_m2_md".name) where "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".from_z <= \'2015-01-15\' and "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".thru_z > \'2015-01-15\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'',$resultWithDatePropagated->sqlRemoveFormatting());
//    let resultWithDateSpecified = execute(|Product.all(%2015-10-16)->map(p|$p.classification(%2015-1-15))->project([c|$c.description, c|$c.exchange(%2015-1-15).name], ['productClassificationDescription','productClassificationExchangeName']), milestoningmap,testRuntime(), meta::relational::extension::relationalExtensions());
//    assertEquals($resultWithDatePropagated->sqlRemoveFormatting(),$resultWithDateSpecified->sqlRemoveFormatting());
// }

//test.ExpectedFailure -- "No-Arg milestoned property: 'exchange(this: ProductClassification[1]): Exchange[1]' must either be supplied with dates or be called in a Milestoned Context"
// function <<test.Test, test.ToFix>> meta::relational::tests::milestoning::contextpropagation::testRuntimeProcessingErrorWhenBusinessDateIsNotPropagatedThroughUserDefinedDerivedPropertyWithBusinessTemporalReturnType():Boolean[1]
// {
//    let businessDate = %2015-10-16;

//    let result = execute(|Product.all($businessDate)->project([p|$p.classificationByTestType().exchange.name],['testClassificationExchange']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
//    let tds = $result.values->at(0);

//    assertEquals(['1,TDSNull', '2,SYS1 description 1-v1', '2,SYS1 description 1-v2'],$tds.rows->map(r|$r.values->makeString(',')));
//    assertSameSQL('select "root".id as "name", "SystemDescriptionTable_d#4_f_d_d_m2_r#2".description as "sysDescription" from OrderTable as "root" left outer join ProductTable as "ProductTable_d#10_d_m2" on ("root".prodFk = "ProductTable_d#10_d_m2".id and "ProductTable_d#10_d_m2".from_z <= \'2015-10-16\' and "ProductTable_d#10_d_m2".thru_z > \'2015-10-16\') left outer join SystemTable as "SystemTable_d#6_f_d_d_m2_r" on ("ProductTable_d#10_d_m2".referenceSystemName = "SystemTable_d#6_f_d_d_m2_r".name) left outer join SystemDescriptionTable as "SystemDescriptionTable_d#4_f_d_d_m2_r#2" on ("SystemTable_d#6_f_d_d_m2_r".name = "SystemDescriptionTable_d#4_f_d_d_m2_r#2".systemName)',$result);
// }

//ProductMapping has relational property mapping (property) joins which results in problems in filter && merge, finding the lastJoinTreeNode/commonNode
function <<test.Test, test.ToFix>> meta::relational::tests::milestoning::contextpropagation::testMilestoningQueryOnATypeWithManyRelationalPropertyMappingChildrenFollowedByMap():Boolean[1]
{
   let result = execute(|Product.all(%2015-10-16)->map(p|$p.classification.type), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let productTypes = $result.values;
   assertEquals(1, $productTypes->size());
   assertEquals(['ProductName2'], $productTypes);
   assertSameSQL('select "root".name as "pk_0", "root".id as "id", "root".name as "name", "root".type as "type", "ProductDescriptionTable_d#2_l_d#2_m4_r".description as "stockProductName", "ProductClassificationTable_d#2_d#2_m5".type as "classificationType", \'2015-10-16\' as \"k_businessDate\" from ProductTable as "root" left outer join StockProductTable as "StockProductTable_d#2_d#2_m4" on ("root".id = "StockProductTable_d#2_d#2_m4".id and "StockProductTable_d#2_d#2_m4".from_z <= \'2015-10-16\' and "StockProductTable_d#2_d#2_m4".thru_z > \'2015-10-16\') left outer join ProductDescriptionTable as "ProductDescriptionTable_d#2_l_d#2_m4_r" on ("StockProductTable_d#2_d#2_m4".id = "ProductDescriptionTable_d#2_l_d#2_m4_r".id) left outer join ProductClassificationTable as "ProductClassificationTable_d#2_d#2_m5" on ("root".type = "ProductClassificationTable_d#2_d#2_m5".type and "ProductClassificationTable_d#2_d#2_m5".from_z <= \'2015-10-16\' and "ProductClassificationTable_d#2_d#2_m5".thru_z > \'2015-10-16\') left outer join ProductClassificationTable as "ProductClassificationTable_d#7_d_m1" on ("root".type = "ProductClassificationTable_d#7_d_m1".type) where "ProductClassificationTable_d#7_d_m1".from_z <= \'2015-10-16\' and "ProductClassificationTable_d#7_d_m1".thru_z > \'2015-10-16\' and "ProductClassificationTable_d#7_d_m1".type = \'STOCK\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'',$result);
}

function <<test.Test, test.ToFix>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationFromTypeQueryToNoArgMilestonedQpInMapFollowedByProjectOnDataTypeProperty():Boolean[1]
{
   let result = execute(|Product.all(%2015-10-16)->map(p|$p.classification)->project([c|$c.type], ['productClassificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   
   assertEquals(['STOCK'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".type as "productClassificationType" from ProductTable as "root" left outer join ProductClassificationTable as "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1" on ("root".type = "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".type) where "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".from_z <= \'2015-10-16\' and "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".thru_z > \'2015-10-16\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'',$result);
}

//Not supported in the compiler
// function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationFromTypeQueryThroughNoArgMilestonedQpInMapThroughToProjectOnComplexDataMilestonedProperty():Boolean[1]
// {
//    let result = execute(|Product.all(%2015-10-16)->map(p|$p.classification)->project([c|$c.exchange.name], ['productClassificationExchangeName']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
//    let tds = $result.values->at(0);
   
//    assertEquals(['LNSE'],$tds.rows->map(r|$r.values->makeString(',')));
//    assertSameSQL('select "ProductExchangeTable_d#6_d_m1_md".name as "productClassificationExchangeName" from ProductTable as "root" left outer join ProductClassificationTable as "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1" on ("root".type = "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".type) left outer join (select "ProductExchangeTable_d#6".name as name from ProductExchangeTable as "ProductExchangeTable_d#6" where "ProductExchangeTable_d#6".from_z <= \'2015-10-16\' and "ProductExchangeTable_d#6".thru_z > \'2015-10-16\') as "ProductExchangeTable_d#6_d_m1_md" on ("ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".exchange = "ProductExchangeTable_d#6_d_m1_md".name) where "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".from_z <= \'2015-10-16\' and "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".thru_z > \'2015-10-16\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'',$result);
// }

function <<test.Test, test.ToFix>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationFromTypeQueryThroughNoArgMilestonedQpInMapWhereSubsequentProjectOverrides():Boolean[1]
{
   let result = execute(|Product.all(%2015-10-16)->map(p|$p.classification)->project([c|$c.description, c|$c.exchange(%2014-1-15).name], ['productClassificationDescription','productClassificationExchangeName']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   
   assertEquals(['STOCK DESC-V3,LNSE'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".type_description as "productClassificationDescription", "ProductExchangeTable_d#6_d_m2_md".name as "productClassificationExchangeName" from ProductTable as "root" left outer join ProductClassificationTable as "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1" on ("root".type = "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".type) left outer join (select "ProductExchangeTable_d#6".name as name from ProductExchangeTable as "ProductExchangeTable_d#6" where "ProductExchangeTable_d#6".from_z <= \'2014-01-15\' and "ProductExchangeTable_d#6".thru_z > \'2014-01-15\') as "ProductExchangeTable_d#6_d_m2_md" on ("ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".exchange = "ProductExchangeTable_d#6_d_m2_md".name) where "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".from_z <= \'2015-10-16\' and "ProductClassificationTable_d#2_f_d#4_d#2_f_d_m1".thru_z > \'2015-10-16\' and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'',$result);
}

function <<test.Test, test.ToFix>> meta::relational::tests::milestoning::contextpropagation::testFiltersRemainOnMilestonedRootTypeWhenMappedToNonTemporalTypeDataType():Boolean[1]
{
   let result = execute(|ProductClassification.all(%2015-10-16)->map(pc|$pc.system.name), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let productTypes = $result.values;
   assertEquals(1, $productTypes->size());
   assertEquals(['SYS1'], $productTypes);
   assertSameSQL('select "SystemTable_d_f_d#2".name from ProductClassificationTable as "root" left outer join SystemTable as "SystemTable_d_f_d#2" on ("root".system = "SystemTable_d_f_d#2".name) where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'',$result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationThruExistsIsIndenpendentOfDateManipulationWithinTheFilter():Boolean[1]
{
   let resultWithDatePropogated = execute(|Product.all(%2015-10-16)->filter(p|$p.classification(%2015-10-15)->exists(c|$c.type=='STOCK'))->project([p|$p.id, p|$p.classification.type],['id','classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $resultWithDatePropogated.values->at(0);
   assertEquals(['2,STOCK'],$tds.rows->map(r|$r.values->makeString(',')));
   
   assertSameSQL('select "root".id as "id", "productclassificationtable_2".type as "classificationType" from ProductTable as "root" left outer join (select distinct "productclassificationtable_1".type from ProductClassificationTable as "productclassificationtable_1" where "productclassificationtable_1".from_z <= \'2015-10-15\' and "productclassificationtable_1".thru_z > \'2015-10-15\' and "productclassificationtable_1".type = \'STOCK\') as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type) left outer join ProductClassificationTable as "productclassificationtable_2" on ("root".type = "productclassificationtable_2".type and "productclassificationtable_2".from_z <= \'2015-10-16\' and "productclassificationtable_2".thru_z > \'2015-10-16\') where "productclassificationtable_0".type is not null and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $resultWithDatePropogated);
   let resultWithDateSpecified = execute(|Product.all(%2015-10-16)->filter(p|$p.classification(%2015-10-15)->exists(c|$c.type=='STOCK'))->project([p|$p.id, p|$p.classification(%2015-10-16).type],['id','classificationType']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals($resultWithDatePropogated->sqlRemoveFormatting(),$resultWithDateSpecified->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoneDatePropogationThruExistsConditionalClause():Boolean[1]
{
   let resultWithDatePropogated = execute(|Order.all()->filter(o|$o.product(%2015-10-15)->exists(p|$p.classificationTypeStr=='STOCK'))->project([o|$o.id],['order id']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $resultWithDatePropogated.values->at(0);
   assertEquals(['2'],$tds.rows->map(r|$r.values->makeString(',')));
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextIsPropogatedThroughAutoMap():Boolean[1]
{
   let businessDate = %2015-8-15;

   let result = execute(|Order.all()->project([o|$o.id, o|$o.product($businessDate).classification.description],['orderId','classificationDescription']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());

   let tds = $result.values->at(0);
   assertEquals(['1,STOCK DESC-V1', '2,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".id as "orderId", "productclassificationtable_0".type_description as "classificationDescription" from OrderTable as "root" left outer join ProductTable as "producttable_0" on ("root".prodFk = "producttable_0".id and "producttable_0".from_z <= \'2015-08-15\' and "producttable_0".thru_z > \'2015-08-15\') left outer join (select "productclassificationtable_1".type as type, "productclassificationtable_1".type_description as type_description from ProductClassificationTable as "productclassificationtable_1" where "productclassificationtable_1".from_z <= \'2015-08-15\' and "productclassificationtable_1".thru_z > \'2015-08-15\') as "productclassificationtable_0" on ("producttable_0".type = "productclassificationtable_0".type)', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextIsPropogatedThroughSubType():Boolean[1]
{
   let businessDate = %2015-8-15;

   let result = execute(|Order.all()->project([o|$o.id, o|$o.product($businessDate)->subType(@Product).classification.description],['orderId','classificationDescription']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());

   let tds = $result.values->at(0);
   assertEquals(['1,STOCK DESC-V1', '2,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".id as "orderId", "productclassificationtable_0".type_description as "classificationDescription" from OrderTable as "root" left outer join ProductTable as "producttable_0" on ("root".prodFk = "producttable_0".id and "producttable_0".from_z <= \'2015-08-15\' and "producttable_0".thru_z > \'2015-08-15\') left outer join (select "productclassificationtable_1".type as type, "productclassificationtable_1".type_description as type_description from ProductClassificationTable as "productclassificationtable_1" where "productclassificationtable_1".from_z <= \'2015-08-15\' and "productclassificationtable_1".thru_z > \'2015-08-15\') as "productclassificationtable_0" on ("producttable_0".type = "productclassificationtable_0".type)', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextPropagatedThroughFilterToNoArgMilestonedQualifiedPropertyInProjectPath():Boolean[1]
{
   let businessDate = %2015-8-15;
                        
   let result = execute(|Product.all(%2015-10-16)->filter(p|$p.name!='')->project([#/Product/name#, #/Product/classification/description#]), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   
   let tds = $result.values->at(0);
   assertEquals(['ProductName2,STOCK DESC-V3', 'ProductName3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".name as "name", "productclassificationtable_0".type_description as "description" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') where ("root".name <> \'\' OR "root".name is null) and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextPropagatedThroughToLeftSideOfQualifiedPropertyFilter():Boolean[1]
{
   let result = execute(|ProductClassification.all(%2015-10-16)->project([#/ProductClassification/product/stockProductName#]), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(['ProductName2'],$tds.rows->map(r|$r.values->makeString(',')));
   let expectedSQL = 'select "productdescriptiontable_0".description as "stockProductName" from ProductClassificationTable as "root" left outer join ProductTable as "producttable_0" on ("producttable_0".type = "root".type and "producttable_0".from_z <= \'2015-10-16\' and "producttable_0".thru_z > \'2015-10-16\') left outer join (select "stockproducttable_1".id as id from StockProductTable as "stockproducttable_1" where "stockproducttable_1".from_z <= \'2015-10-16\' and "stockproducttable_1".thru_z > \'2015-10-16\') as "stockproducttable_0" on ("producttable_0".id = "stockproducttable_0".id) left outer join ProductDescriptionTable as "productdescriptiontable_0" on ("stockproducttable_0".id = "productdescriptiontable_0".id) where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\''; 
   assertSameSQL($expectedSQL , $result);
   let businessDate = %2015-8-15;                       
   let resultWithVar = execute(|ProductClassification.all(%2015-10-16)->project([#/ProductClassification/product/stockProductName#]), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL($expectedSQL ,$resultWithVar);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextPropagatedFromMilestoningQualifiedPropertyWithArgToNoArgMilestonedQualifiedPropertyInProjectPath():Boolean[1]
{
   let businessDate = %2015-8-15;
                        
   let result = execute(|Product.all(%2015-10-16)->filter(p|$p.name!='')->project([#/Product/name#, #/Product/classification(%2016-10-16)/exchange/name#],['productName','exchangeName']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   
   let tds = $result.values->at(0);
   assertEquals(['ProductName2,LNSE', 'ProductName3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".name as "productName", "productexchangetable_0".name as "exchangeName" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2016-10-16\' and "productclassificationtable_0".thru_z > \'2016-10-16\') left outer join (select "productexchangetable_1".name as name from ProductExchangeTable as "productexchangetable_1" where "productexchangetable_1".from_z <= \'2016-10-16\' and "productexchangetable_1".thru_z > \'2016-10-16\') as "productexchangetable_0" on ("productclassificationtable_0".exchange = "productexchangetable_0".name) where ("root".name <> \'\' OR "root".name is null) and "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextPropagatedUsingVariableInProjectPath():Boolean[1]
{
   let businessDate = %2015-10-16;
                        
   let result = execute(|Product.all($businessDate)->project([#/Product/name#, #/Product/classification/description#]), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());

   let tds = $result.values->at(0);
   assertEquals(['ProductName2,STOCK DESC-V3', 'ProductName3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".name as "name", "productclassificationtable_0".type_description as "description" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testCurrentMappingPropagationThroughMilestonedQualifiedPropertyWithEmbeddedLeftSideToSubsequentPropertyInProjectPath():Boolean[1]
{
   let businessDate = %2015-10-16;
                        
   let result = execute(|StockProduct.all($businessDate)->project([#/Product/name#, #/Product/classification/system/name#],['productName','classificationSystemName']), milestoningMapWithEmbeddedSimple, testRuntime(), meta::relational::extension::relationalExtensions());

   let tds = $result.values->at(0);
   assertEquals(['ProductName2,SYS1', 'ProductName3,SYS1'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".name as "productName", "systemtable_0".name as "classificationSystemName" from ProductTable as "root" left outer join ProductClassificationSystemTable as "productclassificationsystemtable_0" on ("root".classificationSystemId = "productclassificationsystemtable_0".id and "productclassificationsystemtable_0".from_z <= \'2015-10-16\' and "productclassificationsystemtable_0".thru_z > \'2015-10-16\') left outer join SystemTable as "systemtable_0" on ("productclassificationsystemtable_0".name = "systemtable_0".name) where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextPropagatedUsingVariableInProject():Boolean[1]
{
   let businessDate = %2015-10-16;
                        
   let result = execute(|Product.all($businessDate)->project([p|$p.name, p|$p.classification.description],['name','description']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());

   let tds = $result.values->at(0);
   assertEquals(['ProductName2,STOCK DESC-V3', 'ProductName3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".name as "name", "productclassificationtable_0".type_description as "description" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test>> {meta::pure::executionPlan::profiles::serverVersion.start='V1_7_0'} meta::relational::tests::milestoning::contextpropagation::testMilestoningContextPropagatedUsingVariableInProjectMoveLetInBlock():Boolean[1]
{
   let result = execute(|let businessDate = now();
                         Product.all($businessDate)->project([p|$p.name, p|$p.classification.description],['name','description']);, milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(['ProductName2,STOCK DESC-V4', 'ProductName3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
}

function <<test.Test>> meta::relational::tests::milestoning::contextpropagation::testMilestoningContextPropagatedUsingConstantInProjectMoveLetInBlock():Boolean[1]
{
   let result = execute(|let businessDate = %2015-10-16;
                         Product.all($businessDate)->project([p|$p.name, p|$p.classification.description],['name','description']);, milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(['ProductName2,STOCK DESC-V3', 'ProductName3,TDSNull'],$tds.rows->map(r|$r.values->makeString(',')));
   assertSameSQL('select "root".name as "name", "productclassificationtable_0".type_description as "description" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'2015-10-16\' and "productclassificationtable_0".thru_z > \'2015-10-16\') where "root".from_z <= \'2015-10-16\' and "root".thru_z > \'2015-10-16\'', $result);
}

function <<test.Test, test.ExcludeAlloy>> meta::relational::tests::milestoning::contextpropagation::testDatePropagationWithInheritance():Boolean[1]
{
   let businessDate = %2015-8-14;
   let result = execute(|OrderWithProductWithConstraints.all($businessDate)->project([o|$o.getClassificationDescription($businessDate)],['classificationDescription']), milestoningmap, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "ordertable_1".aggCol as "classificationDescription" from OrderTable as "root" left outer join (select "ordertable_2".id as id, group_concat("productclassificationtable_0".type_description ) as aggCol from OrderTable as "ordertable_2" left outer join ProductTable as "producttable_0" on ("ordertable_2".prodFk = "producttable_0".id and "producttable_0".from_z <= \'2015-08-14\' and "producttable_0".thru_z > \'2015-08-14\') left outer join (select "productclassificationtable_0".type as type, "productclassificationtable_0".type_description as type_description from ProductClassificationTable as "productclassificationtable_0" where "productclassificationtable_0".from_z <= \'2015-08-14\' and "productclassificationtable_0".thru_z > \'2015-08-14\') as "productclassificationtable_0" on ("producttable_0".type = "productclassificationtable_0".type) group by "ordertable_2".id) as "ordertable_1" on ("root".id = "ordertable_1".id)',$result);
}