// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

###Pure
import meta::pure::runtime::*;
import meta::relational::functions::asserts::*;
import meta::relational::mapping::*;
import meta::relational::tests::*;
import meta::relational::tests::milestoning::*;
import meta::relational::tests::milestoning::union::*;

function <<test.Test>> meta::relational::tests::milestoning::union::testHybridMilestoningUnionOperationWithNonTemporalRoot():Boolean[1]
{
   let result = execute(|Order.all()->filter(o|$o.biTemporalProduct(%2015-8-25, %2018-8-26).name == 'ProductName1'), hybridMilestoningUnionMap, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase".u_type as u_type, "unionBase"."pk_0_0" as "pk_0_0", "unionBase"."pk_0_1" as "pk_0_1", "unionBase"."pk_0_2" as "pk_0_2", "unionBase"."pk_0_3" as "pk_0_3", "unionBase"."id" as "id" from (select \'0\' as u_type, "root".id as "pk_0_0", null as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".id as "id", "root".prodFk as prodFk_0, null as prodFk_1, null as prodFk_2, null as prodFk_3 from OrderTable as "root" UNION ALL select \'1\' as u_type, null as "pk_0_0", "root".id as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".id as "id", null as prodFk_0, "root".prodFk as prodFk_1, null as prodFk_2, null as prodFk_3 from OrderTable as "root" UNION ALL select \'2\' as u_type, null as "pk_0_0", null as "pk_0_1", "root".id as "pk_0_2", null as "pk_0_3", "root".id as "id", null as prodFk_0, null as prodFk_1, "root".prodFk as prodFk_2, null as prodFk_3 from OrderTable as "root" UNION ALL select \'3\' as u_type, null as "pk_0_0", null as "pk_0_1", null as "pk_0_2", "root".id as "pk_0_3", "root".id as "id", null as prodFk_0, null as prodFk_1, null as prodFk_2, "root".prodFk as prodFk_3 from OrderTable as "root") as "unionBase" left outer join (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".id as id, "root".name as "BiTemporalProductTableWithBusinessMilestoningname_BiTemporalProductTableWithBusinessSnapshotMilestoningname_BiTemporalProductTableWithProcessingMilestoningname_BiTemporalProductTableWithNoMilestoningname" from BiTemporalProductTableWithBusinessMilestoning as "root" where "root".from_z <= \'2018-08-26\' and "root".thru_z > \'2018-08-26\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".snapshotDate as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".id as id, "root".name as "BiTemporalProductTableWithBusinessMilestoningname_BiTemporalProductTableWithBusinessSnapshotMilestoningname_BiTemporalProductTableWithProcessingMilestoningname_BiTemporalProductTableWithNoMilestoningname" from BiTemporalProductTableWithBusinessSnapshotMilestoning as "root" where "root".snapshotDate = \'2018-08-26\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", "root".in_z as "in_z_2", "root".out_z as "out_z_2", "root".id as id, "root".name as "BiTemporalProductTableWithBusinessMilestoningname_BiTemporalProductTableWithBusinessSnapshotMilestoningname_BiTemporalProductTableWithProcessingMilestoningname_BiTemporalProductTableWithNoMilestoningname" from BiTemporalProductTableWithProcessingMilestoning as "root" where "root".in_z <= \'2015-08-25\' and "root".out_z > \'2015-08-25\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".id as id, "root".name as "BiTemporalProductTableWithBusinessMilestoningname_BiTemporalProductTableWithBusinessSnapshotMilestoningname_BiTemporalProductTableWithProcessingMilestoningname_BiTemporalProductTableWithNoMilestoningname" from BiTemporalProductTableWithNoMilestoning as "root") as "unionalias_1" on (("unionBase".prodFk_0 = "unionalias_1".id or "unionBase".prodFk_1 = "unionalias_1".id or "unionBase".prodFk_2 = "unionalias_1".id or "unionBase".prodFk_3 = "unionalias_1".id) and (("unionalias_1"."in_z_2" <= \'2015-08-25\' and "unionalias_1"."out_z_2" > \'2015-08-25\') or coalesce("unionalias_1"."in_z_2", "unionalias_1"."out_z_2") is null and (("unionalias_1"."from_z_0" <= \'2018-08-26\' and "unionalias_1"."thru_z_0" > \'2018-08-26\') or coalesce("unionalias_1"."from_z_0", "unionalias_1"."thru_z_0") is null) and ("unionalias_1"."snapshotDate_1" = \'2018-08-26\' or "unionalias_1"."snapshotDate_1" is null))) where "unionalias_1"."BiTemporalProductTableWithBusinessMilestoningname_BiTemporalProductTableWithBusinessSnapshotMilestoningname_BiTemporalProductTableWithProcessingMilestoningname_BiTemporalProductTableWithNoMilestoningname" = \'ProductName1\'', $result->sqlRemoveFormatting());
   assertEquals([1, 1, 1, 1, 1, 1, 1, 1], $result.values.id);
}

/* 
FIXME: Inflow execution vs plan generation do not perform the same table alias trimming.
If a table alias is hashed, we also add an index to the end for plan execution ONLY eg: hash_0
but for non-hashed names we leave the fully-qualified name for plan execution and in-flow.
*/
function <<test.Test, test.AlloyOnly>> meta::relational::tests::milestoning::union::testPlanHybridMilestoningUnionOperationWithNonTemporalRootWithPropagation():Boolean[1]
{
   testHybridMilestoningUnionOperationWithNonTemporalRootWithPropagation([
     'BiTemporalProductClassificationTableWithBusinessMilestoningtype_description_BiTemporalProductClassificationTableWithBusinessSnapshotMilestoningtype_description_BiTemporalProductClassificationTableWithProcessingMilestoning___c88f893dbce2fa7329ae22_0'
   ]->repeat(5));
}

function <<test.Test, test.ExcludeAlloy>> meta::relational::tests::milestoning::union::testInFlowHybridMilestoningUnionOperationWithNonTemporalRootWithPropagation():Boolean[1]
{
   testHybridMilestoningUnionOperationWithNonTemporalRootWithPropagation([
     'BiTemporalProductClassificationTableWithBusinessMilestoningtype_description_BiTemporalProductClassificationTableWithBusinessSnapshotMilestoningtype_description_BiTemporalProductClassificationTableWithProcessingMilestoning___c88f893dbce2fa7329ae22544d6bcf41'
   ]->repeat(5));
}

function <<access.private>> meta::relational::tests::milestoning::union::testHybridMilestoningUnionOperationWithNonTemporalRootWithPropagation(
  tableNames: String[*]
): Boolean[1]
{
   let result = execute(|Order.all()->filter(o|$o.biTemporalProduct(%2015-8-25, %2018-8-26).biTemporalClassification.description == 'STOCK DESC-V2'), hybridMilestoningUnionMap, testRuntime(), meta::relational::extension::relationalExtensions());                 
   assertSameSQL('select "unionBase".u_type as u_type, "unionBase"."pk_0_0" as "pk_0_0", "unionBase"."pk_0_1" as "pk_0_1", "unionBase"."pk_0_2" as "pk_0_2", "unionBase"."pk_0_3" as "pk_0_3", "unionBase"."id" as "id" from (select \'0\' as u_type, "root".id as "pk_0_0", null as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".id as "id", "root".prodFk as prodFk_0, null as prodFk_1, null as prodFk_2, null as prodFk_3 from OrderTable as "root" UNION ALL select \'1\' as u_type, null as "pk_0_0", "root".id as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".id as "id", null as prodFk_0, "root".prodFk as prodFk_1, null as prodFk_2, null as prodFk_3 from OrderTable as "root" UNION ALL select \'2\' as u_type, null as "pk_0_0", null as "pk_0_1", "root".id as "pk_0_2", null as "pk_0_3", "root".id as "id", null as prodFk_0, null as prodFk_1, "root".prodFk as prodFk_2, null as prodFk_3 from OrderTable as "root" UNION ALL select \'3\' as u_type, null as "pk_0_0", null as "pk_0_1", null as "pk_0_2", "root".id as "pk_0_3", "root".id as "id", null as prodFk_0, null as prodFk_1, null as prodFk_2, "root".prodFk as prodFk_3 from OrderTable as "root") as "unionBase" left outer join (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".id as id, "root".type as type_0, null as type_1, null as type_2, null as type_3 from BiTemporalProductTableWithBusinessMilestoning as "root" where "root".from_z <= \'2018-08-26\' and "root".thru_z > \'2018-08-26\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".snapshotDate as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".id as id, null as type_0, "root".type as type_1, null as type_2, null as type_3 from BiTemporalProductTableWithBusinessSnapshotMilestoning as "root" where "root".snapshotDate = \'2018-08-26\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", "root".in_z as "in_z_2", "root".out_z as "out_z_2", "root".id as id, null as type_0, null as type_1, "root".type as type_2, null as type_3 from BiTemporalProductTableWithProcessingMilestoning as "root" where "root".in_z <= \'2015-08-25\' and "root".out_z > \'2015-08-25\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".id as id, null as type_0, null as type_1, null as type_2, "root".type as type_3 from BiTemporalProductTableWithNoMilestoning as "root") as "unionalias_1" on (("unionBase".prodFk_0 = "unionalias_1".id or "unionBase".prodFk_1 = "unionalias_1".id or "unionBase".prodFk_2 = "unionalias_1".id or "unionBase".prodFk_3 = "unionalias_1".id) and (("unionalias_1"."in_z_2" <= \'2015-08-25\' and "unionalias_1"."out_z_2" > \'2015-08-25\') or coalesce("unionalias_1"."in_z_2", "unionalias_1"."out_z_2") is null and (("unionalias_1"."from_z_0" <= \'2018-08-26\' and "unionalias_1"."thru_z_0" > \'2018-08-26\') or coalesce("unionalias_1"."from_z_0", "unionalias_1"."thru_z_0") is null) and ("unionalias_1"."snapshotDate_1" = \'2018-08-26\' or "unionalias_1"."snapshotDate_1" is null))) left outer join (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".type as type, "root".type_description as "%s" from BiTemporalProductClassificationTableWithBusinessMilestoning as "root" where "root".from_z <= \'2018-08-26\' and "root".thru_z > \'2018-08-26\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".snapshotDate as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".type as type, "root".type_description as "%s" from BiTemporalProductClassificationTableWithBusinessSnapshotMilestoning as "root" where "root".snapshotDate = \'2018-08-26\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", "root".in_z as "in_z_2", "root".out_z as "out_z_2", "root".type as type, "root".type_description as "%s" from BiTemporalProductClassificationTableWithProcessingMilestoning as "root" where "root".in_z <= \'2015-08-25\' and "root".out_z > \'2015-08-25\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".type as type, "root".type_description as "%s" from BiTemporalProductClassificationTableWithNoMilestoning as "root") as "unionalias_2" on (("unionalias_1".type_0 = "unionalias_2".type or "unionalias_1".type_1 = "unionalias_2".type or "unionalias_1".type_2 = "unionalias_2".type or "unionalias_1".type_3 = "unionalias_2".type) and (("unionalias_2"."in_z_2" <= \'2015-08-25\' and "unionalias_2"."out_z_2" > \'2015-08-25\') or coalesce("unionalias_2"."in_z_2", "unionalias_2"."out_z_2") is null and (("unionalias_2"."from_z_0" <= \'2018-08-26\' and "unionalias_2"."thru_z_0" > \'2018-08-26\') or coalesce("unionalias_2"."from_z_0", "unionalias_2"."thru_z_0") is null) and ("unionalias_2"."snapshotDate_1" = \'2018-08-26\' or "unionalias_2"."snapshotDate_1" is null))) where "unionalias_2"."%s" = \'STOCK DESC-V2\''->format($tableNames), $result->sqlRemoveFormatting());
   assertEquals([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], $result.values.id);
}

function <<test.Test, test.AlloyOnly>> meta::relational::tests::milestoning::union::testPlanHybridMilestoningUnionOperationWithTemporalRootWithPropagation():Boolean[1]
{
   testHybridMilestoningUnionOperationWithTemporalRootWithPropagation([
     'BiTemporalProductClassificationTableWithBusinessMilestoningtype_description_BiTemporalProductClassificationTableWithBusinessSnapshotMilestoningtype_description_BiTemporalProductClassificationTableWithProcessingMilestoning___c88f893dbce2fa7329ae22_0'
   ]->repeat(5));
}

function <<test.Test, test.ExcludeAlloy>> meta::relational::tests::milestoning::union::testInFlowHybridMilestoningUnionOperationWithTemporalRootWithPropagation():Boolean[1]
{
   testHybridMilestoningUnionOperationWithTemporalRootWithPropagation([
     'BiTemporalProductClassificationTableWithBusinessMilestoningtype_description_BiTemporalProductClassificationTableWithBusinessSnapshotMilestoningtype_description_BiTemporalProductClassificationTableWithProcessingMilestoning___c88f893dbce2fa7329ae22544d6bcf41'
   ]->repeat(5));
}

function <<access.private>> meta::relational::tests::milestoning::union::testHybridMilestoningUnionOperationWithTemporalRootWithPropagation(
  tableNames: String[*]
): Boolean[1]
{
   let result = execute(|BiTemporalProduct.all(%2015-8-25, %2018-8-26)->filter(p|$p.biTemporalClassification.description == 'STOCK DESC-V2'), hybridMilestoningUnionMap, testRuntime(), meta::relational::extension::relationalExtensions());
   assertSameSQL('select "unionBase".u_type as u_type, "unionBase"."pk_0_0" as "pk_0_0", "unionBase"."pk_0_1" as "pk_0_1", "unionBase"."pk_0_2" as "pk_0_2", "unionBase"."pk_0_3" as "pk_0_3", "unionBase"."id" as "id", "unionBase"."name" as "name", "unionBase"."k_processingDate" as "k_processingDate", "unionBase"."k_businessDate" as "k_businessDate", "unionBase"."from_z_0" as "from_z_0", "unionBase"."thru_z_0" as "thru_z_0", "unionBase"."snapshotDate_1" as "snapshotDate_1", "unionBase"."in_z_2" as "in_z_2", "unionBase"."out_z_2" as "out_z_2" from (select \'0\' as u_type, "root".id as "pk_0_0", null as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".id as "id", "root".name as "name", \'2015-08-25\' as "k_processingDate", \'2018-08-26\' as "k_businessDate", "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".type as type_0, null as type_1, null as type_2, null as type_3 from BiTemporalProductTableWithBusinessMilestoning as "root" where "root".from_z <= \'2018-08-26\' and "root".thru_z > \'2018-08-26\' UNION ALL select \'1\' as u_type, null as "pk_0_0", "root".id as "pk_0_1", null as "pk_0_2", null as "pk_0_3", "root".id as "id", "root".name as "name", \'2015-08-25\' as "k_processingDate", \'2018-08-26\' as "k_businessDate", null as "from_z_0", null as "thru_z_0", "root".snapshotDate as "snapshotDate_1", null as "in_z_2", null as "out_z_2", null as type_0, "root".type as type_1, null as type_2, null as type_3 from BiTemporalProductTableWithBusinessSnapshotMilestoning as "root" where "root".snapshotDate = \'2018-08-26\' UNION ALL select \'2\' as u_type, null as "pk_0_0", null as "pk_0_1", "root".id as "pk_0_2", null as "pk_0_3", "root".id as "id", "root".name as "name", \'2015-08-25\' as "k_processingDate", \'2018-08-26\' as "k_businessDate", null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", "root".in_z as "in_z_2", "root".out_z as "out_z_2", null as type_0, null as type_1, "root".type as type_2, null as type_3 from BiTemporalProductTableWithProcessingMilestoning as "root" where "root".in_z <= \'2015-08-25\' and "root".out_z > \'2015-08-25\' UNION ALL select \'3\' as u_type, null as "pk_0_0", null as "pk_0_1", null as "pk_0_2", "root".id as "pk_0_3", "root".id as "id", "root".name as "name", \'2015-08-25\' as "k_processingDate", \'2018-08-26\' as "k_businessDate", null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", null as type_0, null as type_1, null as type_2, "root".type as type_3 from BiTemporalProductTableWithNoMilestoning as "root") as "unionBase" left outer join (select "root".from_z as "from_z_0", "root".thru_z as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".type as type, "root".type_description as "%s" from BiTemporalProductClassificationTableWithBusinessMilestoning as "root" where "root".from_z <= \'2018-08-26\' and "root".thru_z > \'2018-08-26\' UNION ALL select null as "from_z_0", null as "thru_z_0", "root".snapshotDate as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".type as type, "root".type_description as "%s" from BiTemporalProductClassificationTableWithBusinessSnapshotMilestoning as "root" where "root".snapshotDate = \'2018-08-26\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", "root".in_z as "in_z_2", "root".out_z as "out_z_2", "root".type as type, "root".type_description as "%s" from BiTemporalProductClassificationTableWithProcessingMilestoning as "root" where "root".in_z <= \'2015-08-25\' and "root".out_z > \'2015-08-25\' UNION ALL select null as "from_z_0", null as "thru_z_0", null as "snapshotDate_1", null as "in_z_2", null as "out_z_2", "root".type as type, "root".type_description as "%s" from BiTemporalProductClassificationTableWithNoMilestoning as "root") as "unionalias_1" on (("unionBase".type_0 = "unionalias_1".type or "unionBase".type_1 = "unionalias_1".type or "unionBase".type_2 = "unionalias_1".type or "unionBase".type_3 = "unionalias_1".type) and (("unionalias_1"."in_z_2" <= \'2015-08-25\' and "unionalias_1"."out_z_2" > \'2015-08-25\') or coalesce("unionalias_1"."in_z_2", "unionalias_1"."out_z_2") is null and (("unionalias_1"."from_z_0" <= \'2018-08-26\' and "unionalias_1"."thru_z_0" > \'2018-08-26\') or coalesce("unionalias_1"."from_z_0", "unionalias_1"."thru_z_0") is null) and ("unionalias_1"."snapshotDate_1" = \'2018-08-26\' or "unionalias_1"."snapshotDate_1" is null))) where "unionalias_1"."%s" = \'STOCK DESC-V2\''->format($tableNames), $result->sqlRemoveFormatting());
   assertEquals([1, 1, 1, 1, 1, 1, 1, 1], $result.values.id);
}

function <<test.Test>> meta::relational::tests::milestoning::union::testMilestoningWithUnionOnView():Boolean[1]
{
  let result = execute(|BiTemporalProduct.all(%2015-8-25, %2018-8-26)->project(p|$p.classification.type, 'classification type'), meta::relational::tests::milestoning::UnionOnViewWithMilestoningMapping, testRuntime(), meta::relational::extension::relationalExtensions());
  assertEquals('classification type\nSTOCK\n\n', $result.values->cast(@TabularDataSet)->meta::relational::tests::csv::toCSV());
}

function <<test.Test>> meta::relational::tests::milestoning::union::testMilestoningWithUnionOnViewWithAllVersions():Boolean[1]
{
  let result = execute(|BiTemporalProduct.all(%2015-8-25, %2018-8-26)->project(p|$p.classificationAllVersions.type, 'classification type'), meta::relational::tests::milestoning::UnionOnViewWithMilestoningMapping, testRuntime(), meta::relational::extension::relationalExtensions());
  assertEquals('classification type\nSTOCK\nSTOCK\nSTOCK\nSTOCK\nOPTION\n', $result.values->cast(@TabularDataSet)->meta::relational::tests::csv::toCSV());
}

function <<test.BeforePackage>> meta::relational::tests::milestoning::union::setUp():Runtime[1]
{
   initDatabase();
}
