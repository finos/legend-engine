// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::executionPlan::*;
import meta::pure::executionPlan::toString::*;
import meta::pure::graphFetch::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::pure::graphFetch::routing::*;
import meta::pure::mapping::*;
import meta::pure::mapping::xStore::*;
import meta::pure::milestoning::*;
import meta::pure::router::clustering::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::pure::router::routing::*;
import meta::pure::runtime::*;
import meta::relational::functions::pureToSqlQuery::*;
import meta::relational::functions::pureToSqlQuery::metamodel::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::functions::typeInference::*;
import meta::relational::graphFetch::executionPlan::*;
import meta::relational::mapping::*;
import meta::relational::translation::*;
import meta::relational::metamodel::*;
import meta::relational::metamodel::datatype::*;
import meta::relational::metamodel::join::*;
import meta::relational::metamodel::operation::*;
import meta::relational::metamodel::relation::*;
import meta::relational::milestoning::*;
import meta::relational::runtime::*;


Class meta::relational::graphFetch::executionPlan::RelationalGraphFetchExecutionNode extends LocalGraphFetchExecutionNode
{
   children : RelationalGraphFetchExecutionNode[*];
}

Class meta::relational::graphFetch::executionPlan::RelationalTempTableGraphFetchExecutionNode extends RelationalGraphFetchExecutionNode
{
   tempTableName : String[1];
   columns : SQLResultColumn[*];
   processedTempTableName : String[0..1];
   tempTableStrategy : TempTableStrategy[0..1];
}

Class meta::relational::graphFetch::executionPlan::RelationalClassQueryTempTableGraphFetchExecutionNode extends RelationalTempTableGraphFetchExecutionNode
{
}

Class meta::relational::graphFetch::executionPlan::RelationalPrimitiveQueryGraphFetchExecutionNode extends RelationalGraphFetchExecutionNode
{
}

Class meta::relational::graphFetch::executionPlan::RelationalRootQueryTempTableGraphFetchExecutionNode extends RelationalClassQueryTempTableGraphFetchExecutionNode
{
   batchSize : Integer[0..1];
   enableConstraints : Boolean[1];
   checked : Boolean[1];
}

Class meta::relational::graphFetch::executionPlan::RelationalCrossRootQueryTempTableGraphFetchExecutionNode extends RelationalClassQueryTempTableGraphFetchExecutionNode
{
   parentTempTableStrategy : TempTableStrategy[0..1];
   parentTempTableName    : String[1];
   parentTempTableColumns : SQLResultColumn[*];
   processedParentTempTableName : String[0..1];
}

Class meta::relational::graphFetch::executionPlan::TempTableStrategy
{
   createTempTableNode : ExecutionNode[0..1];
   loadTempTableNode : ExecutionNode[0..1];
   dropTempTableNode : ExecutionNode[0..1];
}

Enum meta::relational::graphFetch::executionPlan::TempTableStrategyType
{
   LoadFromTempFileTempTableStrategy, LoadFromSubQueryTempTableStrategy, LoadFromResultSetAsValueTuplesTempTableStrategy
}

Class meta::relational::graphFetch::executionPlan::LoadFromTempFileTempTableStrategy extends meta::relational::graphFetch::executionPlan::TempTableStrategy
{
}

Class meta::relational::graphFetch::executionPlan::LoadFromSubQueryTempTableStrategy extends meta::relational::graphFetch::executionPlan::TempTableStrategy
{
}

Class meta::relational::graphFetch::executionPlan::LoadFromResultSetAsValueTuplesTempTableStrategy extends meta::relational::graphFetch::executionPlan::TempTableStrategy
{
  tupleBatchSize : Integer[0..1];
}

function meta::relational::graphFetch::executionPlan::useTempTableStrategy(dbType: DatabaseType[1]):Boolean[1]
{
   if($dbType->in([DatabaseType.Snowflake,DatabaseType.H2]),
   |  true,
   |  false;
   )
}

function <<access.private>> meta::relational::graphFetch::executionPlan::stringToPlaceHolder(s:String[1]):String[1]
{
   ^VarPlaceHolder(name= $s, type = $s->type())->processPlaceHolder(String,'','',[],[]);
}

function <<access.private>> meta::relational::graphFetch::executionPlan::getTupleBatchSize(dbType: DatabaseType[1]):Integer[1]
{
   if($dbType == DatabaseType.DB2,
    | 100,
    | if($dbType == DatabaseType.Snowflake,
      | 1000,
      | 100;
      );
    );
}

function <<access.private>> meta::relational::graphFetch::executionPlan::dbsUsingLoadFromTempFileTempTableStrategyForRoot():DatabaseType[*]
{
   [DatabaseType.H2,DatabaseType.MemSQL,DatabaseType.SybaseIQ]
}

function <<access.private>> meta::relational::graphFetch::executionPlan::dbsUsingLoadFromSubQueryTempTableStrategyForComplexProperty():DatabaseType[*]
{
   [DatabaseType.Snowflake]
}

function <<access.private>> meta::relational::graphFetch::executionPlan::dbsUsingLoadFromResultSetAsValueTuplesTempTableStrategyForNonPrimitiveChildNode():DatabaseType[*]
{
   [DatabaseType.DB2]
}

function <<access.private>> meta::relational::graphFetch::executionPlan::dbsUsingLoadFromResultSetAsValueTuplesTempTableStrategyForRoot():DatabaseType[*]
{
   if(dbsUsingLoadFromSubQueryTempTableStrategyForComplexProperty()->fold({dbType, anyOverlap | dbsUsingLoadFromResultSetAsValueTuplesTempTableStrategyForNonPrimitiveChildNode()->contains($dbType) || $anyOverlap}, false),|fail('Multiple temp table creation strategies specified for the same db type' ),|[]);
   dbsUsingLoadFromSubQueryTempTableStrategyForComplexProperty()->concatenate(dbsUsingLoadFromResultSetAsValueTuplesTempTableStrategyForNonPrimitiveChildNode());
}

function meta::relational::graphFetch::executionPlan::createTable(tempTableName: String[1], columns: SQLResultColumn[*], tempTableSchemaName: String[0..1], dbConfig: DbConfig[1]): Table[1]
{
  let tempTableColumns = $columns->map(x|^Column(name = $x.label, type = $x.dataType->toOne()));
  ^Table( name = $dbConfig.procesTempTableName($tempTableName),
          schema = ^Schema(name = if($tempTableSchemaName->isNotEmpty(),|$tempTableSchemaName->toOne(),|'default') , database = ^Database(name='TempTableDb')),
          columns = $tempTableColumns,
          temporaryTable = true
        );
}

function meta::relational::graphFetch::executionPlan::sqlsForTempTableCreation(dbType: DatabaseType[1], temporaryTable: Table[1]): String[*]
{
  let create = ^CreateTableSQL(table = $temporaryTable, isTempTable=true);
  let dbConfig  = $dbType->createDbConfig([]);
  $create->meta::relational::functions::sqlQueryToString::ddlSqlQueryToString($dbConfig);
}

function meta::relational::graphFetch::executionPlan::sqlsForTempTableDeletion(dbType: DatabaseType[1], temporaryTable: Table[1]): String[*]
{
  let dbConfig  = $dbType->createDbConfig([]);
  ^DropTableSQL(table = $temporaryTable)->meta::relational::functions::sqlQueryToString::ddlSqlQueryToString($dbConfig);
}

function meta::relational::graphFetch::executionPlan::sqlsForTempTableLoadFromTempFile(dbType: DatabaseType[1], temporaryTable: Table[1]): String[*]
{
    let VarPlaceHolder = 'csv_file_location';
    let load = ^LoadTableSQL(table = $temporaryTable, absolutePathToFile=^VarPlaceHolder(name= $VarPlaceHolder, type = $VarPlaceHolder->type()), columnsToLoad=$temporaryTable.columns->cast(@Column));
    let dbConfig  = $dbType->createDbConfig([]);
    $load->meta::relational::functions::sqlQueryToString::ddlSqlQueryToString($dbConfig);
}

function meta::relational::graphFetch::executionPlan::sqlsForTempTableLoadFromSubQuery(dbType: DatabaseType[1], temporaryTable: Table[1], selectSqlStatement: String[1]): String[*]
{   
  let tempTableName = getTableName($dbType, $temporaryTable);
  let columns = $temporaryTable.columns->map(x|$x->cast(@Column).name);
  [['INSERT INTO ', $tempTableName, '(', $columns->joinStrings(',') ,') SELECT DISTINCT "', $columns->joinStrings('","'),'" FROM ( ',$selectSqlStatement,' );']->joinStrings('')];
}

function meta::relational::graphFetch::executionPlan::getTableName(dbType: DatabaseType[1], temporaryTable: Table[1]):String[1]
{
      let dbConfig  = $dbType->createDbConfig([]);
      let schemaName = $dbConfig.schemaNameToIdentifier($temporaryTable.schema.name);
      let tableName = $dbConfig.tableNameToIdentifier($temporaryTable.name);
      if($schemaName == 'default', | $dbConfig.identifierProcessor($tableName), | $dbConfig.identifierProcessor($schemaName) + '.' + $dbConfig.identifierProcessor($tableName));
}

function meta::relational::graphFetch::executionPlan::sqlsForInsertIntoTableUsingResultSet(dbType: DatabaseType[1], temporaryTable: Table[1]):String[1]
{
  
  let tempTableName = getTableName($dbType, $temporaryTable);
  'INSERT INTO '+ $tempTableName + ' VALUES ' +
  stringToPlaceHolder('temp_table_rows_from_result_set');
}

function <<access.private>> meta::relational::graphFetch::executionPlan::tempTableName(index: Integer[1]):String[1]
{
   'temp_table_node_' + toString($index)
}

function <<access.private>> meta::relational::graphFetch::executionPlan::crossTempTableName(index: Integer[1]):String[1]
{
   'cross_temp_table_node_' + toString($index)
}

function meta::relational::graphFetch::executionPlan::getTempTableStrategyForRootNode(dbType : DatabaseType[1]): TempTableStrategyType[1]
{
  if($dbType->in(dbsUsingLoadFromTempFileTempTableStrategyForRoot()),
    | TempTableStrategyType.LoadFromTempFileTempTableStrategy,
    | TempTableStrategyType.LoadFromResultSetAsValueTuplesTempTableStrategy
  );
}

function meta::relational::graphFetch::executionPlan::getTempTableStrategyForNonPrimitiveChildNode(dbType : DatabaseType[1]): TempTableStrategyType[1]
{
  if($dbType->in(dbsUsingLoadFromResultSetAsValueTuplesTempTableStrategyForNonPrimitiveChildNode()),
    | TempTableStrategyType.LoadFromResultSetAsValueTuplesTempTableStrategy,
    | if($dbType->in(dbsUsingLoadFromSubQueryTempTableStrategyForComplexProperty()),
      | TempTableStrategyType.LoadFromSubQueryTempTableStrategy,
      | TempTableStrategyType.LoadFromTempFileTempTableStrategy
      );
  );
}

function meta::relational::graphFetch::executionPlan::getCreateTempTableNode(dbType:DatabaseType[1], table:Table[1], dbConnection:DatabaseConnection[1], extensions: Extension[*]): SequenceExecutionNode[1]
{
  let createTempTableSqlExecNodes = sqlsForTempTableCreation($dbType,$table)->map(sql | ^SQLExecutionNode(
        sqlQuery         = $sql,
        resultType       = ^VoidResultType(type = Any),
        connection       = $dbConnection->meta::relational::mapping::updateConnection($extensions)->cast(@DatabaseConnection),
        supportFunctions = relationalPlanSupportFunctions($dbConnection)
      )
    );
  ^SequenceExecutionNode(resultType = ^VoidResultType(type = Any), executionNodes = $createTempTableSqlExecNodes);
}

function meta::relational::graphFetch::executionPlan::getLoadTempTableNodeForRoot(dbType:DatabaseType[1], table:Table[1], dbConnection:DatabaseConnection[1], extensions: Extension[*]): SequenceExecutionNode[1]
{
  let insertIntoTempTableSqlExecNodes = if(($dbType->getTempTableStrategyForRootNode() == TempTableStrategyType.LoadFromTempFileTempTableStrategy),
    | sqlsForTempTableLoadFromTempFile($dbType,$table)->map(sql | ^SQLExecutionNode(
        sqlQuery         = $sql,
        resultType       = ^VoidResultType(type = Any),
        connection       = $dbConnection->meta::relational::mapping::updateConnection($extensions)->cast(@DatabaseConnection),
        supportFunctions = relationalPlanSupportFunctions($dbConnection)
        )
      ),
    | sqlsForInsertIntoTableUsingResultSet($dbType,$table)->map(sql | ^SQLExecutionNode(
        sqlQuery         = $sql,
        resultType       = ^VoidResultType(type = Any),
        connection       = $dbConnection->meta::relational::mapping::updateConnection($extensions)->cast(@DatabaseConnection),
        supportFunctions = relationalPlanSupportFunctions($dbConnection)
        )
      );
  );
  ^SequenceExecutionNode(resultType = ^VoidResultType(type = Any), executionNodes = $insertIntoTempTableSqlExecNodes);
}

function meta::relational::graphFetch::executionPlan::getLoadTempTableNodeForNonPrimitiveChild(dbType:DatabaseType[1], table:Table[1], dbConnection:DatabaseConnection[1], extensions: Extension[*], selectSqlStatement: String[1]): SequenceExecutionNode[1]
{
  let insertIntoTempTableSqlExecNodes = if(($dbType->getTempTableStrategyForNonPrimitiveChildNode() == TempTableStrategyType.LoadFromResultSetAsValueTuplesTempTableStrategy),
    | sqlsForInsertIntoTableUsingResultSet($dbType,$table)->map(sql | ^SQLExecutionNode(
          sqlQuery         = $sql,
          resultType       = ^VoidResultType(type = Any),
          connection       = $dbConnection->meta::relational::mapping::updateConnection($extensions)->cast(@DatabaseConnection),
          supportFunctions = relationalPlanSupportFunctions($dbConnection)
        )
      ),
    | if(($dbType->getTempTableStrategyForNonPrimitiveChildNode() == TempTableStrategyType.LoadFromSubQueryTempTableStrategy),
      | sqlsForTempTableLoadFromSubQuery($dbType,$table,$selectSqlStatement)->map(sql | ^SQLExecutionNode(
          sqlQuery         = $sql,
          resultType       = ^VoidResultType(type = Any),
          connection       = $dbConnection->meta::relational::mapping::updateConnection($extensions)->cast(@DatabaseConnection),
          supportFunctions = relationalPlanSupportFunctions($dbConnection)
        )
        ),
      | sqlsForTempTableLoadFromTempFile($dbType,$table)->map(sql | ^SQLExecutionNode(
          sqlQuery         = $sql,
          resultType       = ^VoidResultType(type = Any),
          connection       = $dbConnection->meta::relational::mapping::updateConnection($extensions)->cast(@DatabaseConnection),
          supportFunctions = relationalPlanSupportFunctions($dbConnection)
          )
        );
      );
  );
  ^SequenceExecutionNode(resultType = ^VoidResultType(type = Any), executionNodes = $insertIntoTempTableSqlExecNodes);
}

function meta::relational::graphFetch::executionPlan::getDropTempTableNode(dbType:DatabaseType[1], table: Table[1], dbConnection:DatabaseConnection[1], extensions: Extension[*]): SequenceExecutionNode[1]
{
  let dropTempTableSqlExecNodes = sqlsForTempTableDeletion($dbType,$table)->map(sql | ^SQLExecutionNode(
                sqlQuery         = $sql,
                resultType       = ^VoidResultType(type = Any),
                connection       = $dbConnection->meta::relational::mapping::updateConnection($extensions)->cast(@DatabaseConnection),
                supportFunctions = relationalPlanSupportFunctions($dbConnection)
              )
    );
  ^SequenceExecutionNode(resultType = ^VoidResultType(type = Any), executionNodes = $dropTempTableSqlExecNodes);
}

function meta::relational::graphFetch::executionPlan::getTempTableStrategyForRootNode(dbType : DatabaseType[1], createTempTableNode:SequenceExecutionNode[0..1], loadTempTableNode:SequenceExecutionNode[0..1], dropTempTableNode:SequenceExecutionNode[0..1]): TempTableStrategy[1]
{
  if($dbType->in(dbsUsingLoadFromTempFileTempTableStrategyForRoot()),
    | ^LoadFromTempFileTempTableStrategy(
        createTempTableNode = $createTempTableNode,
        loadTempTableNode = $loadTempTableNode,
        dropTempTableNode = $dropTempTableNode
      ),
    | ^LoadFromResultSetAsValueTuplesTempTableStrategy(
        createTempTableNode = $createTempTableNode,
        loadTempTableNode = $loadTempTableNode,
        dropTempTableNode = $dropTempTableNode,
        tupleBatchSize = getTupleBatchSize($dbType)
      );
  );
}

function meta::relational::graphFetch::executionPlan::getTempTableStrategyForNonPrimitiveChildNode(dbType : DatabaseType[1], createTempTableNode:SequenceExecutionNode[0..1], loadTempTableNode:SequenceExecutionNode[0..1], dropTempTableNode:SequenceExecutionNode[0..1]): TempTableStrategy[1]
{
  if($dbType->in(dbsUsingLoadFromResultSetAsValueTuplesTempTableStrategyForNonPrimitiveChildNode()),
    | ^LoadFromResultSetAsValueTuplesTempTableStrategy(
        createTempTableNode = $createTempTableNode,
        loadTempTableNode = $loadTempTableNode,
        dropTempTableNode = $dropTempTableNode,
        tupleBatchSize = getTupleBatchSize($dbType)
      ),
    | if($dbType->in(dbsUsingLoadFromSubQueryTempTableStrategyForComplexProperty()),
      | ^LoadFromSubQueryTempTableStrategy(
          createTempTableNode = $createTempTableNode,
          loadTempTableNode = $loadTempTableNode,
          dropTempTableNode = $dropTempTableNode
        ),
      | ^LoadFromTempFileTempTableStrategy(
          createTempTableNode = $createTempTableNode,
          loadTempTableNode = $loadTempTableNode,
          dropTempTableNode = $dropTempTableNode
        );
      );
  );
}



function meta::relational::graphFetch::executionPlan::planRootGraphFetchExecutionRelational(sq: StoreQuery[1], ext: RoutedValueSpecification[0..1], clusteredTree: StoreMappingClusteredGraphFetchTree[1], orderedPaths: String[*], mapping: Mapping[1], runtime: Runtime[1], exeCtx: ExecutionContext[1], enableConstraints: Boolean[1], checked: Boolean[1], extensions: Extension[*], debug: DebugContext[1]): LocalGraphFetchExecutionNode[1]
{
   print(if($debug.debug,|$debug.space+'>Relational root graphFetch plan generation:\n',|''));
   let fe           = $sq.fe->evaluateAndDeactivate();
   let lhsFe        = $fe.parametersValues->evaluateAndDeactivate()->at(0)->byPassRouterInfo()->cast(@FunctionExpression);
   let rootTree     = $clusteredTree->byPassClusteringInfo()->cast(@RoutedRootGraphFetchTree<Any>);
   let setImpls     = $rootTree.sets->cast(@RootRelationalInstanceSetImplementation);
   let store        = $sq.store->cast(@Database);
   let dbConnection = $runtime->connectionByElement($store)->toOne()->cast(@DatabaseConnection)->map(x | ^$x(element = $store));
   let oneRuntime   = ^Runtime(connections = [$dbConnection]);
   let batchSize    = if($fe.func == graphFetch_T_MANY__RootGraphFetchTree_1__Integer_1__T_MANY_ || $fe.func == meta::pure::graphFetch::execution::graphFetchChecked_T_MANY__RootGraphFetchTree_1__Integer_1__Checked_MANY_,
                       | $fe->instanceValueAtParameter(2)->cast(@Integer), 
                       | 1000);

   let simplePrimitiveProperties = $rootTree.subTrees->cast(@PropertyGraphFetchTree).property
                                      ->filter(x | $x->instanceOf(Property))->cast(@Property<Nil,Any|*>)
                                      ->filter(x | $x->isPrimitiveValueProperty() && $x->functionReturnMultiplicity()->hasToOneUpperBound());

   /* Assert conditions on sets */
   $setImpls->map(x | $x->assertConditionsOnSetImpl($simplePrimitiveProperties));

   /* Generate SQL Query */
   print(if($debug.debug,|$debug.space+'   >Process left expression (with properties - '+$simplePrimitiveProperties->map(p|$p.name)->removeDuplicates()->joinStrings('[',', ',']')+'): '+$lhsFe->meta::pure::router::printer::asString()+'\n',|''));
   let pureToSqlState      = createPureToSqlState($simplePrimitiveProperties, $sq.inScopeVars, $mapping, $exeCtx);
   let selectWithCursor    = $lhsFe->toSelectWithCursor($mapping, $sq.inScopeVars, $debug->indent(2), $pureToSqlState, $extensions);
   let postProcessorResult = $selectWithCursor.select->toOne()->cast(@SelectSQLQuery)->postProcessSQLQuery($store, $ext, $mapping, $oneRuntime, $exeCtx, $extensions);
   let postProcessedQuery  = $postProcessorResult.query->cast(@SelectSQLQuery);
   print(if($debug.debug,|$debug.space+'   >End process left expression: '+$postProcessedQuery->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n',|''));

   /* Create execution node */
   let sqlNode       = $postProcessedQuery->buildSQLExecutionNode($dbConnection, addEnumMapSupportFunctions($sq, $mapping), $extensions);
   let allExecNodes  = $postProcessorResult.executionNodes->concatenate($sqlNode)->concatenate($postProcessorResult.postExecutionNodes);
   let wrappedNode   = generateExecutionNodeForPostProcessedResult($sqlNode, $allExecNodes, $postProcessorResult, $extensions);
   
   let children = $rootTree->generateRelationalChildGraphNodes($rootTree->nodePathName(), $setImpls, $simplePrimitiveProperties, $orderedPaths, $store, $mapping, $oneRuntime, $sq.inScopeVars, $selectWithCursor.milestoningContext, $exeCtx, $extensions, $debug);
   let columns = $sqlNode.resultColumns->filter(x | $x.label->startsWith('"pk_'))->map(x | ^SQLResultColumn(label = $x.label->substring(1, $x.label->length() - 1), dataType = $x.dataType->toOne()));
   let dbType = $dbConnection.type;
   let hasChildren = $children->isNotEmpty();
   let dbConfig = $dbType->createDbConfig();
   let tempTableName = tempTableName(0);
   let tempTableStrategy = if(($hasChildren && useTempTableStrategy($dbType)),
                            | let table = createTable($tempTableName,$columns,[],$dbConfig);
                              let createTempTableNode = meta::relational::graphFetch::executionPlan::getCreateTempTableNode($dbType,$table,$dbConnection,$extensions);
                              let loadTempTableNode = meta::relational::graphFetch::executionPlan::getLoadTempTableNodeForRoot($dbType,$table,$dbConnection,$extensions);
                              let dropTempTableNode = meta::relational::graphFetch::executionPlan::getDropTempTableNode($dbType,$table,$dbConnection,$extensions);
                              getTempTableStrategyForRootNode($dbType, $createTempTableNode, $loadTempTableNode, $dropTempTableNode);,
                            | []);
   ^RelationalRootQueryTempTableGraphFetchExecutionNode
   (
      tempTableStrategy = $tempTableStrategy,
      resultType     = $rootTree->resultTypeFromGraphFetchTree(),
      nodeIndex      = 0,
      graphFetchTree = $rootTree,
      batchSize      = $batchSize,
      tempTableName  = $tempTableName,
      processedTempTableName = $dbConfig.procesTempTableName($tempTableName),
      columns        = $columns,
      children       = $children,
      executionNodes = $wrappedNode,
      enableConstraints = $enableConstraints,
      checked = $checked
   );
}

function <<access.private>> meta::relational::graphFetch::executionPlan::planGraphFetchExecutionPrimitiveChild(currentTree: RoutedPropertyGraphFetchTree[1], parentTree: GraphFetchTree[1], parentPath: String[1], orderedPaths: String[*], parentSets: RelationalInstanceSetImplementation[*], store: Database[1], mapping: Mapping[1], runtime: Runtime[1], inScopeVars: Map<String, List<Any>>[1], mc: TemporalMilestoningContext[0..1], exeCtx : ExecutionContext[1], extensions:Extension[*], debug : DebugContext[1]): RelationalPrimitiveQueryGraphFetchExecutionNode[1]
{
   print(if($debug.debug,|$debug.space+'>Generating relational store local child node for primitive property :\''+$currentTree.property.name->toOne()+'\'\n',|''));
  
   let currentPath = $parentPath + '.' + $currentTree->nodePathName();

   /* Assertions */
   assert($parentPath->in($orderedPaths),   | 'Unknown path ' + $parentPath  + '; known are: ' + $orderedPaths->joinStrings('[', '; ', ']'));
   assert($currentPath->in($orderedPaths),  | 'Unknown path ' + $currentPath + '; known are: ' + $orderedPaths->joinStrings('[', '; ', ']'));

   let parentIdx        = $orderedPaths->indexOf($parentPath);
   let currentIdx       = $orderedPaths->indexOf($currentPath);
   let currentIdxString = $currentIdx->toString();

   /* Generate Sql Query */
   print(if($debug.debug,|$debug.space+'   >Generate local store property query\n',|''));
   let primitiveQuery     = generatePrimitivePropertyQuery($parentSets, $currentTree, $parentTree, $mapping, $inScopeVars, $mc, $debug->indent(2), $extensions);
   let resultColumnnName  = '"node_' + $currentIdxString + '_result"';
   let namedColumnQuery   = ^$primitiveQuery(columns = ^Alias(name = $resultColumnnName, relationalElement = $primitiveQuery.columns->toOne()));
   let changedDriverQuery = $namedColumnQuery->changeDriverToTempWithPkProjection(tempTableName($parentIdx), $parentSets, $extensions);
   let shouldManageAgg    = $currentTree.property->instanceOf(QualifiedProperty) && $currentTree.property->containsAggregationFunctionInFunction(defaultState($mapping, $inScopeVars).supportedFunctions);
   let managedAggQuery    = if ($shouldManageAgg,
                                | ^$changedDriverQuery
                                  (
                                     groupBy = $changedDriverQuery.columns->filter(x | $x->cast(@Alias).name != $resultColumnnName)
                                  ),
                                | ^$changedDriverQuery
                                  (
                                     filteringOperation = andFilters($changedDriverQuery.filteringOperation->concatenate($changedDriverQuery.columns->cast(@Alias)->filter(x | $x.name == $resultColumnnName)->map(x | ^DynaFunction(name = 'isNotNull', parameters =  $x.relationalElement))->toOne()), $extensions)
                                  )
                            );

   let postProcessorResult = $managedAggQuery->postProcessSQLQuery($store, [], $mapping, $runtime, $exeCtx, $extensions);
   let postProcessedQuery  = $postProcessorResult.query->cast(@SelectSQLQuery);
   print(if($debug.debug,|$debug.space+'   >Generated local store property query: '+$postProcessedQuery->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n',|''));


   /* Create execution node */
   let dbConnection  = $runtime.connections->toOne()->cast(@DatabaseConnection);
   let sqlNode       = $postProcessedQuery->buildSQLExecutionNode($dbConnection, $extensions);
   let allExecNodes  = $postProcessorResult.executionNodes->concatenate($sqlNode)->concatenate($postProcessorResult.postExecutionNodes);
   let wrappedNode   = generateExecutionNodeForPostProcessedResult($sqlNode, $allExecNodes, $postProcessorResult, $extensions);

   ^RelationalPrimitiveQueryGraphFetchExecutionNode
   (
      resultType     = ^ResultType(type = $currentTree.property->functionReturnType().rawType->toOne()),
      nodeIndex      = $currentIdx,
      parentIndex    = $parentIdx,
      graphFetchTree = $currentTree,
      executionNodes = $wrappedNode
   );
}

function <<access.private>> meta::relational::graphFetch::executionPlan::planGraphFetchExecutionNonPrimitiveChild(currentTree: RoutedPropertyGraphFetchTree[1], parentTree: GraphFetchTree[1], parentPath: String[1], orderedPaths: String[*], parentSets: RelationalInstanceSetImplementation[*], store: Database[1], mapping: Mapping[1], runtime: Runtime[1], inScopeVars: Map<String, List<Any>>[1], mc: TemporalMilestoningContext[0..1], exeCtx: ExecutionContext[1], extensions:Extension[*], debug: DebugContext[1]): RelationalClassQueryTempTableGraphFetchExecutionNode[1]
{
   print(if($debug.debug,|$debug.space+'>Generating relational store local child node for non-primitive property :\''+$currentTree.property.name->toOne()+'\', tree: '+$currentTree->asString(false)+'\n',|''));

   let currentPath = $parentPath + '.' + $currentTree->nodePathName();

   /* Assertions */
   assert($parentPath->in($orderedPaths),   | 'Unknown path ' + $parentPath  + '; known are: ' + $orderedPaths->joinStrings('[', '; ', ']'));
   assert($currentPath->in($orderedPaths),  | 'Unknown path ' + $currentPath + '; known are: ' + $orderedPaths->joinStrings('[', '; ', ']'));

   let parentIdx        = $orderedPaths->indexOf($parentPath);
   let currentIdx       = $orderedPaths->indexOf($currentPath);
   let currentIdxString = $currentIdx->toString();
   let setImpls         = $currentTree.sets->toOne()->cast(@RelationalInstanceSetImplementation);

   let simplePrimitiveProperties = $currentTree.subTrees->cast(@PropertyGraphFetchTree).property
                                      ->filter(x | $x->instanceOf(Property))->cast(@Property<Nil,Any|*>)
                                      ->filter(x | $x->isPrimitiveValueProperty() && $x->functionReturnMultiplicity()->hasToOneUpperBound());

   /* Assert conditions on sets */
   $setImpls->map(x | $x->assertConditionsOnSetImpl($simplePrimitiveProperties));


   /* Generate Sql Query */
   print(if($debug.debug,|$debug.space+'   >Generate local store property query (with properties - '+$simplePrimitiveProperties->map(p|$p.name)->removeDuplicates()->joinStrings('[',', ',']')+'\n',|''));
   let nonPrimitiveQuery   = generateNonPrimitivePropertyQuery($parentSets, $currentTree, $parentTree, $mapping, $inScopeVars, $mc, $simplePrimitiveProperties, $debug->indent(2), $extensions);
   let changedDriverQuery  = $nonPrimitiveQuery->changeDriverToTempWithPkProjection(tempTableName($parentIdx), $parentSets, $extensions);
   let pkFilteredQuery     = ^$changedDriverQuery
                             (
                                filteringOperation = andFilters($changedDriverQuery.filteringOperation->concatenate($changedDriverQuery.columns->cast(@Alias)->filter(x | $x.name->startsWith('"pk_'))->map(x | ^DynaFunction(name = 'isNotNull', parameters =  $x.relationalElement))->orFilters($extensions)), $extensions)
                             );
   let postProcessorResult = $pkFilteredQuery->postProcessSQLQuery($store, [], $mapping, $runtime, $exeCtx, $extensions);
   let postProcessedQuery  = $postProcessorResult.query->cast(@SelectSQLQuery);
   print(if($debug.debug,|$debug.space+'   >Generated local store property query: '+$postProcessedQuery->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n',|''));

   /* Create execution node */
   let dbConnection  = $runtime.connections->toOne()->cast(@DatabaseConnection);
   let sqlNode       = $postProcessedQuery->buildSQLExecutionNode($dbConnection, $extensions);
   let allExecNodes  = $postProcessorResult.executionNodes->concatenate($sqlNode)->concatenate($postProcessorResult.postExecutionNodes);
   let wrappedNode   = generateExecutionNodeForPostProcessedResult($sqlNode, $allExecNodes, $postProcessorResult, $extensions);


   let newVars = if($currentTree.property->instanceOf(QualifiedProperty),
                    | $currentTree.property->cast(@QualifiedProperty<Any>)->functionType().parameters->evaluateAndDeactivate()->tail()->map(x | pair($x.name, list($currentTree.parameters->evaluateAndDeactivate()->at($currentTree.property->cast(@QualifiedProperty<Any>)->functionType().parameters->evaluateAndDeactivate()->indexOf($x) - 1)->evaluateAndDeactivate()->reactivate($inScopeVars)->evaluateAndDeactivate()))),
                    | []
                 );
   let mcForProperty = milestoningContextFromPropertyTree($currentTree, $parentTree, defaultState($mapping, $inScopeVars->putAll($newVars)), $extensions);
   let children = $currentTree->generateRelationalChildGraphNodes($currentPath, $setImpls, $simplePrimitiveProperties, $orderedPaths, $store, $mapping, $runtime, $inScopeVars, $mcForProperty, $exeCtx, $extensions, $debug);
   let columns = $sqlNode.resultColumns->filter(x | $x.label->startsWith('"pk_'))->map(x | ^SQLResultColumn(label = $x.label->substring(1, $x.label->length() - 1), dataType = $x.dataType->toOne()));
   let dbType = $dbConnection.type;
   let hasChildren = $children->isNotEmpty();
   let dbConfig = $dbType->createDbConfig();
   let tempTableName = tempTableName($currentIdx);

   let tempTableStrategy = if(($hasChildren && useTempTableStrategy($dbType)),
                            | let table = createTable($tempTableName,$columns,[],$dbConfig);
                              let createTempTableNode = meta::relational::graphFetch::executionPlan::getCreateTempTableNode($dbType,$table,$dbConnection,$extensions);
                              let loadTempTableNode = meta::relational::graphFetch::executionPlan::getLoadTempTableNodeForNonPrimitiveChild($dbType,$table,$dbConnection,$extensions,$sqlNode.sqlQuery);
                              let dropTempTableNode = meta::relational::graphFetch::executionPlan::getDropTempTableNode($dbType,$table,$dbConnection,$extensions);
                              getTempTableStrategyForNonPrimitiveChildNode($dbType, $createTempTableNode, $loadTempTableNode, $dropTempTableNode);,
                            | []);

   ^RelationalClassQueryTempTableGraphFetchExecutionNode
   (
      tempTableStrategy = $tempTableStrategy,
      resultType     = $currentTree->resultTypeFromGraphFetchTree(),
      nodeIndex      = $currentIdx,
      parentIndex    = $parentIdx,
      graphFetchTree = $currentTree,
      tempTableName  = $tempTableName,
      processedTempTableName = $dbConfig.procesTempTableName($tempTableName),
      columns        = $columns,
      children       = $children,
      executionNodes = $wrappedNode
   );
}

function meta::relational::graphFetch::executionPlan::planCrossRootGraphFetchExecutionRelational(clusteredTree: StoreMappingClusteredGraphFetchTree[1], orderedPaths: String[*], parentPath: String[1], inScopeVars: Map<String, List<Any>>[1], mapping: Mapping[1], runtime: Runtime[1], exeCtx: ExecutionContext[1], extensions: Extension[*], debug: DebugContext[1]): RelationalCrossRootQueryTempTableGraphFetchExecutionNode[1]
{
   print(if($debug.debug,|$debug.space+'>Relational cross-store graphFetch plan generation:\n',|''));
   let store    = $clusteredTree.store->cast(@Database);
   let rootTree = $clusteredTree->byPassClusteringInfo()->cast(@RoutedPropertyGraphFetchTree);
   let rootPath = $parentPath + '.' + $rootTree->nodePathName();
   let setImpl  = $rootTree.sets->toOne()->cast(@RootRelationalInstanceSetImplementation);

   /* Assertions */
   assert($parentPath->in($orderedPaths), | 'Unknown path ' + $parentPath + '; known are: ' + $orderedPaths->joinStrings('[', '; ', ']'));
   assert($rootPath->in($orderedPaths),   | 'Unknown path ' + $rootPath   + '; known are: ' + $orderedPaths->joinStrings('[', '; ', ']'));

   let parentIdx             = $orderedPaths->indexOf($parentPath);
   let currentIdx            = $orderedPaths->indexOf($rootPath);

   let xStorePropertyMapping = $rootTree.propertyMapping->toOne()->cast(@XStorePropertyMapping);
   let crossExpression       = $xStorePropertyMapping.crossExpression.expressionSequence->evaluateAndDeactivate()->toOne();
   let propertyPathNodes     = $crossExpression->meta::pure::lineage::scanProperties::scanProperties().result;
   $propertyPathNodes->map({ppn |
      assert($ppn.values->size() <= 1, | 'Only single property traversal is supported in XStore mappings used in relational graph fetch. Found incompatible traversal: ' +
                                         $ppn->meta::pure::lineage::scanProperties::printPropertyNodeLists() + ' in XStore mapping from ' +
                                         '"' + $xStorePropertyMapping.sourceSetImplementationId + '" to "' + $xStorePropertyMapping.targetSetImplementationId + '"')
   });

   let sourceCls = $mapping->classMappingById($xStorePropertyMapping.sourceSetImplementationId)->toOne()->cast(@InstanceSetImplementation)->map(i | if($i.mappingClass->isNotEmpty(), | $i.mappingClass->toOne(), | $i.class));
   let targetCls = $mapping->classMappingById($xStorePropertyMapping.targetSetImplementationId)->toOne()->cast(@InstanceSetImplementation)->map(i | if($i.mappingClass->isNotEmpty(), | $i.mappingClass->toOne(), | $i.class));
   
   let sourcePropertyPathNodes = $propertyPathNodes->filter(ppn | $sourceCls->_subTypeOf($ppn->get(0).class));
   let sourceFetchTree         = $sourcePropertyPathNodes->meta::pure::lineage::scanProperties::propertyTree::buildPropertyTree()->propertyTreeToGraphFetchTree($sourceCls);
   let srcProperties           = $sourceFetchTree.subTrees->cast(@PropertyGraphFetchTree)->map(st |
      assert($st.property->isPrimitiveValueProperty() && ($st.property->instanceOf(Property) || ($st.property->instanceOf(QualifiedProperty) && $st.property->functionType().parameters->evaluateAndDeactivate()->size() == 1)),
             | 'Only primitive properties / primitive no-arg qualifiers are supported as source properties in XStore mapping expression in relational graph fetch. Found incompatible property: ' + $st.property.name->toOne()
      );
      $st.property;
   );

   let targetPropertyPathNodes = $propertyPathNodes->filter(ppn | $targetCls->_subTypeOf($ppn->get(0).class));
   let targetFetchTree         = $targetPropertyPathNodes->meta::pure::lineage::scanProperties::propertyTree::buildPropertyTree()->propertyTreeToGraphFetchTree($targetCls);
   let tgtProperties           = $targetFetchTree.subTrees->cast(@PropertyGraphFetchTree)->map(st |
      assert($st.property->isPrimitiveValueProperty() && $st.property->instanceOf(Property),
             | 'Only primitive properties are supported as target properties in XStore mapping expression in relational graph fetch. Found incompatible property: ' + $st.property.name->toOne()
      );
      $st.property->cast(@Property<Nil,Any|*>);
   );

   let simplePrimitiveProperties = $rootTree.subTrees->cast(@PropertyGraphFetchTree).property
                                      ->filter(x | $x->instanceOf(Property))->cast(@Property<Nil,Any|*>)
                                      ->filter(x | $x->isPrimitiveValueProperty() && $x->functionReturnMultiplicity()->hasToOneUpperBound())
                                      ->concatenate($tgtProperties);

   /* Assert conditions on sets */
   $setImpl->assertConditionsOnSetImpl($simplePrimitiveProperties);

   /* Generate Sql Query */
   print(if($debug.debug,|$debug.space+'   >Generate cross property query (with properties - '+$simplePrimitiveProperties->map(p|$p.name)->removeDuplicates()->joinStrings('[',', ',']')+'\n',|''));
   let crossQuery          = generateCrossPropertyQuery($rootTree, $parentIdx, $xStorePropertyMapping, $srcProperties, $mapping, $inScopeVars, $simplePrimitiveProperties, $debug->indent(2), $extensions);
   let dbConnection        = $runtime->connectionByElement($store)->cast(@DatabaseConnection);
   let oneRuntime          = ^Runtime(connections = $dbConnection);
   let postProcessorResult = $crossQuery->postProcessSQLQuery($store, [], $mapping, $oneRuntime, $exeCtx, $extensions);
   let postProcessedQuery  = $postProcessorResult.query->cast(@SelectSQLQuery);
   print(if($debug.debug,|$debug.space+'   >Generated cross property query: '+$postProcessedQuery->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n',|''));

   /* Create execution node */
   let sqlNode      = $postProcessedQuery->buildSQLExecutionNode($dbConnection, $extensions);
   let allExecNodes = $postProcessorResult.executionNodes->concatenate($sqlNode)->concatenate($postProcessorResult.postExecutionNodes);
   let wrappedNode  = generateExecutionNodeForPostProcessedResult($sqlNode, $allExecNodes, $postProcessorResult, $extensions);

   let children = $rootTree->generateRelationalChildGraphNodes($rootPath, $setImpl, $simplePrimitiveProperties, $orderedPaths, $store, $mapping, $oneRuntime, $inScopeVars, [], $exeCtx, $extensions, $debug);
   let columns = $postProcessedQuery.columns->cast(@Alias)->filter(x | $x.name->startsWith('"pk_'))->map(c | ^SQLResultColumn(label = $c.name->substring(1, $c.name->length() - 1), dataType = $c->inferRelationalType(^TranslationContext(dbType=$dbConnection.type))->toOne()));
   let dbType = $dbConnection.type;
   let hasChildren = $children->isNotEmpty();
   let dbConfig = $dbType->createDbConfig();
   let tempTableName = tempTableName($currentIdx);
   let parentTempTableName = crossTempTableName($parentIdx);
   
   let tempTableStrategy = if(($hasChildren && useTempTableStrategy($dbType)),
                            | let table = createTable($tempTableName,$columns,[],$dbConfig);
                              let createTempTableNode = meta::relational::graphFetch::executionPlan::getCreateTempTableNode($dbType,$table,$dbConnection,$extensions);
                              let loadTempTableNode = meta::relational::graphFetch::executionPlan::getLoadTempTableNodeForRoot($dbType,$table,$dbConnection,$extensions);
                              let dropTempTableNode = meta::relational::graphFetch::executionPlan::getDropTempTableNode($dbType,$table,$dbConnection,$extensions);
                              getTempTableStrategyForRootNode($dbType, $createTempTableNode, $loadTempTableNode, $dropTempTableNode);,
                            | []);
   
   let parentTempTableColumns = $srcProperties->map(x | ^SQLResultColumn(label = $x.name->toOne(), dataType = $x->crossKeyRelationalType()));
   let parentTable = createTable($parentTempTableName,$parentTempTableColumns,[],$dbConfig);
   let parentCreateTempTableNode = meta::relational::graphFetch::executionPlan::getCreateTempTableNode($dbType,$parentTable,$dbConnection,$extensions);
   let parentLoadTempTableNode = meta::relational::graphFetch::executionPlan::getLoadTempTableNodeForRoot($dbType,$parentTable,$dbConnection,$extensions);
   let parentDropTempTableNode = meta::relational::graphFetch::executionPlan::getDropTempTableNode($dbType,$parentTable,$dbConnection,$extensions);
   
   ^RelationalCrossRootQueryTempTableGraphFetchExecutionNode
   (
      parentTempTableStrategy = if(useTempTableStrategy($dbType),|getTempTableStrategyForRootNode($dbType, $parentCreateTempTableNode, $parentLoadTempTableNode, $parentDropTempTableNode),|[]),
      tempTableStrategy       = $tempTableStrategy,
      resultType              = $rootTree->resultTypeFromGraphFetchTree(),
      nodeIndex               = $currentIdx,
      parentIndex             = $parentIdx,
      graphFetchTree          = $rootTree,
      tempTableName           = $tempTableName,
      processedTempTableName  = $dbConfig.procesTempTableName($tempTableName),
      columns                 = $columns,
      parentTempTableName     = $parentTempTableName,
      processedParentTempTableName = $dbConfig.procesTempTableName($parentTempTableName),
      parentTempTableColumns  = $parentTempTableColumns,
      children                = $children,
      executionNodes          = $wrappedNode
   );
}

function <<access.private>> meta::relational::graphFetch::executionPlan::assertConditionsOnSetImpl(setImpl: RelationalInstanceSetImplementation[1], simplePrimitiveProperties: Property<Nil,Any|*>[*]):Boolean[1]
{
   let r = $setImpl->match([
      e: EmbeddedRelationalInstanceSetImplementation[1] | $e.setMappingOwner,
      r: RootRelationalInstanceSetImplementation[1] | $r
   ]);
   
   assert($r->resolvePrimaryKey()->isNotEmpty(), | 'Primary Key definition is must in graph fetch flow');
   assert($r->meta::relational::functions::pureToSqlQuery::getGroupBy()->isEmpty(), | 'Store group by not allowed in graph fetch flow');
   assert($r->meta::relational::functions::pureToSqlQuery::getDistinct() != true,  | 'Store distinct not allowed in graph fetch flow');
   
   $simplePrimitiveProperties->forAll({prop |
      assert($prop->meta::pure::milestoning::hasGeneratedMilestoningPropertyStereotype() || $setImpl->_propertyMappingsByPropertyName($prop.name->toOne())->isNotEmpty(),
             | 'Property "' + $prop.name->toOne() + '" is not mapped in the set: "' + $setImpl.id + '"')
   });
}

function <<access.private>> meta::relational::graphFetch::executionPlan::createPureToSqlState(simplePrimitiveProperties: Property<Nil,Any|*>[*], inScopeVars: Map<String, List<Any>>[1], mapping: Mapping[1], exeCtx: ExecutionContext[1]):State[1]
{
   let defaultPureToSqlState = defaultState($mapping, $inScopeVars);
   let sqlStateAsPerContext  = if($exeCtx->isNotEmpty() && $exeCtx->toOne()->instanceOf(RelationalExecutionContext),
                                  | let relContext = $exeCtx->toOne()->cast(@RelationalExecutionContext);
                                    ^$defaultPureToSqlState
                                     (
                                        preserveJoinOrder              = $relContext.preserveJoinOrder,
                                        addDriverTablePkForProject     = $relContext.addDriverTablePkForProject,
                                        insertDriverTablePkInTempTable = $relContext.insertDriverTablePkInTempTable,
                                        useTempTableAsDriver           = $relContext.useTempTableAsDriver
                                     );,
                                  | $defaultPureToSqlState
                               );
   ^$sqlStateAsPerContext
    (
       graphFetchFlow       = true,
       graphFetchProperties = $simplePrimitiveProperties
    );
}

function <<access.private>> meta::relational::graphFetch::executionPlan::buildSQLExecutionNode(query: SelectSQLQuery[1], dbConnection: DatabaseConnection[1], extensions:Extension[*]):SQLExecutionNode[1]
{
  buildSQLExecutionNode($query, $dbConnection, [], $extensions)
}

function <<access.private>> meta::relational::graphFetch::executionPlan::buildSQLExecutionNode(query: SelectSQLQuery[1], dbConnection: DatabaseConnection[1], enumMapSupportFunctions:String[*], extensions:Extension[*]):SQLExecutionNode[1]
{
   let sql = $query->sqlQueryToString($dbConnection.type, $dbConnection.timeZone, $dbConnection.quoteIdentifiers, $extensions);
   
   ^SQLExecutionNode
    (
       sqlComment       = $query.comment,
       sqlQuery         = $sql,
       resultColumns    = $query.columns->cast(@Alias)->map(c | ^SQLResultColumn(label = $c.name, dataType = $c->inferRelationalType(^TranslationContext(dbType=$dbConnection.type))->toOne())),
       resultType       = ^ResultType(type = Any),
       connection       = $dbConnection->meta::relational::mapping::updateConnection($extensions)->cast(@DatabaseConnection),
       supportFunctions = relationalPlanSupportFunctions($dbConnection)->concatenate($enumMapSupportFunctions)
    );
}

function <<access.private>> meta::relational::graphFetch::executionPlan::generateExecutionNodeForPostProcessedResult(relationalNode:ExecutionNode[1], allExecNodes:ExecutionNode[*], postProcessorResult:PostProcessorResult[1], extensions:Extension[*]):ExecutionNode[1]
{
   if($allExecNodes->size() > 1,
      | if($allExecNodes->map(node | $node->allNodes($extensions))->exists(node | $node->instanceOf(CreateAndPopulateTempTableExecutionNode)),
           | ^RelationalBlockExecutionNode(resultType = $relationalNode.resultType, executionNodes = $allExecNodes, supportFunctions = $postProcessorResult.templateFunctions),
           | ^SequenceExecutionNode(resultType = $relationalNode.resultType, executionNodes = $allExecNodes, supportFunctions = $postProcessorResult.templateFunctions)
        ),
      | $relationalNode
   );
}

function <<access.private>> meta::relational::graphFetch::executionPlan::generateRelationalChildGraphNodes(tree: RoutedGraphFetchTree[1], treePath: String[1], setImpls: RelationalInstanceSetImplementation[*], simplePrimitiveProperties: Property<Nil,Any|*>[*], orderedPaths: String[*], store: Database[1], mapping: Mapping[1], runtime: Runtime[1], inScopeVars: Map<String, List<Any>>[1], mc: TemporalMilestoningContext[0..1], exeCtx: ExecutionContext[1], extensions:Extension[*], debug: DebugContext[1]): RelationalGraphFetchExecutionNode[*]
{
   $tree.subTrees->cast(@RoutedPropertyGraphFetchTree)->map({st |
      let property = $st.property;
      if (!$simplePrimitiveProperties->contains($st.property),
          | if ($property->isPrimitiveValueProperty(),
                | $st->planGraphFetchExecutionPrimitiveChild($tree, $treePath, $orderedPaths, $setImpls, $store, $mapping, $runtime, $inScopeVars, $mc, $exeCtx, $extensions, $debug->indent()),
                | $st->planGraphFetchExecutionNonPrimitiveChild($tree, $treePath, $orderedPaths, $setImpls, $store, $mapping, $runtime, $inScopeVars, $mc, $exeCtx, $extensions, $debug->indent())
            ),
          | []
      );
   });
}

function <<access.private>> meta::relational::graphFetch::executionPlan::generatePrimitivePropertyQuery(setImpls: RelationalInstanceSetImplementation[*], propTree: RoutedPropertyGraphFetchTree[1], parentTree: GraphFetchTree[1], mapping:Mapping[1], inScopeVars: Map<String, List<Any>>[1], mc: TemporalMilestoningContext[0..1], debug: DebugContext[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   let isQualified    = $propTree.property->instanceOf(QualifiedProperty);
   let pureToSqlState = defaultState($mapping, $inScopeVars);
   let srcSetImpl     = $setImpls->match([
      s:RootRelationalInstanceSetImplementation[1]     | $s,
      s:EmbeddedRelationalInstanceSetImplementation[1] | $s.setMappingOwner;
   ])->cast(@RootRelationalInstanceSetImplementation);

   let mainTable     = $srcSetImpl->mainRelation()->processRelation([], '', false, 0, false, [], $pureToSqlState, $debug, $extensions);
   let currentNode   = ^RootJoinTreeNode(alias=^TableAlias(name = 'root', relationalElement = $mainTable));
   let basePreFilter = ^SelectWithCursor(select = ^SelectSQLQuery(data = $currentNode), currentTreeNode = $currentNode, milestoningContext = $mc)->applyTypeFilter($srcSetImpl, '_gftm', $pureToSqlState, $debug, $extensions);
   let base          = ^$basePreFilter(select = $basePreFilter.select->pushFilters($extensions));
   
   let res = if ($isQualified,
                {|
                   let qualifier    = $propTree.property->cast(@QualifiedProperty<Any>);
                   let newVars      = $qualifier->functionType().parameters->evaluateAndDeactivate()->tail()->map(x | pair($x.name, list($propTree.parameters->evaluateAndDeactivate()->at($qualifier->functionType().parameters->evaluateAndDeactivate()->indexOf($x) - 1)->evaluateAndDeactivate()->reactivate($inScopeVars)->evaluateAndDeactivate())));
                   let updatedState = ^$pureToSqlState(inGetterFlow = true, qualifierBase=^OperationWithParentPropertyMapping(element = $base), inScopeVars = $pureToSqlState.inScopeVars->putAll($newVars));
                   processQualifiedProperty($qualifier, [], $base, ^Map<VariableExpression, ValueSpecification>(), $updatedState, JoinType.LEFT_OUTER, '_gftq', ^List<ColumnGroup>(), $debug, $extensions).element->cast(@SelectWithCursor);
                },
                {|
                   processPropertyMapping($propTree.propertyMapping, $parentTree->typeFromGraphFetchTree()->cast(@Class<Any>), $base, ^$pureToSqlState(inGetterFlow = true), JoinType.LEFT_OUTER, '_gftp', ^List<ColumnGroup>(), $debug, $extensions)->cast(@SelectWithCursor)
                }
             ).select;

  ^$res(distinct = true)->pushFilters($extensions);
}

function meta::relational::graphFetch::executionPlan::generateNonPrimitivePropertyQuery(setImpls: RelationalInstanceSetImplementation[*], propTree: RoutedPropertyGraphFetchTree[1], parentTree: GraphFetchTree[1], mapping: Mapping[1], inScopeVars: Map<String, List<Any>>[1], mc: TemporalMilestoningContext[0..1], propertiesToFetch: Property<Nil,Any|*>[*], debug: DebugContext[1], extensions:Extension[*]): SelectSQLQuery[1]
{
   let isQualified    = $propTree.property->instanceOf(QualifiedProperty);
   let pureToSqlState = ^State(inScopeVars = $inScopeVars, mapping=$mapping, supportedFunctions=getSupportedFunctions(), inProject=false, inFilter=false, filterChainDepth=0, inProjectFunctions=false,  processingProjectionThread=false, shouldIsolate=false, contextBasedSupportedFunctions=getContextBasedSupportedFunctions());
   let srcSetImpl     = $setImpls->match([
      s:RootRelationalInstanceSetImplementation[1]     | $s,
      s:EmbeddedRelationalInstanceSetImplementation[1] | $s.setMappingOwner;
   ])->cast(@RootRelationalInstanceSetImplementation);

   let mainTable     = $srcSetImpl->mainRelation()->processRelation([], '', false, 0, false, [], $pureToSqlState, $debug, $extensions);
   let currentNode   = ^RootJoinTreeNode(alias=^TableAlias(name = 'root', relationalElement = $mainTable));
   let basePreFilter = ^SelectWithCursor(select = ^SelectSQLQuery(data = $currentNode), currentTreeNode = $currentNode, milestoningContext = $mc)->applyTypeFilter($srcSetImpl, '_gftm', $pureToSqlState, $debug, $extensions);
   let base          = ^$basePreFilter(select = $basePreFilter.select->pushFilters($extensions));
   
   let res = if ($isQualified,
                {|
                   let qualifier     = $propTree.property->cast(@QualifiedProperty<Any>);
                   let newVars       = $qualifier->functionType().parameters->evaluateAndDeactivate()->tail()->map(x | pair($x.name, list($propTree.parameters->evaluateAndDeactivate()->at($qualifier->functionType().parameters->evaluateAndDeactivate()->indexOf($x) - 1)->reactivate($inScopeVars)->evaluateAndDeactivate())));
                   let mcForProperty = milestoningContextFromPropertyTree($propTree, $parentTree, ^$pureToSqlState(inScopeVars = $pureToSqlState.inScopeVars->putAll($newVars)), $extensions);
                   let baseWithMc    = ^$base(milestoningContext = $mcForProperty);
                   let updatedState  = ^$pureToSqlState(inGetterFlow = true, qualifierBase = ^OperationWithParentPropertyMapping(element = $baseWithMc), inScopeVars = $pureToSqlState.inScopeVars->putAll($newVars));
                   let withQualifier = processQualifiedProperty($qualifier, [], $baseWithMc, ^Map<VariableExpression, ValueSpecification>(), $updatedState, JoinType.LEFT_OUTER, '_gftq', ^List<ColumnGroup>(), $debug, $extensions).element->cast(@SelectWithCursor);
                   let newSelect     = $withQualifier.select->pushFilters($extensions);
                   let innerRes      = ^$withQualifier(select = ^$newSelect(leftSideOfFilter = []));
                   let toPropagateMc = if ($propTree.property->hasGeneratedMilestoningPropertyStereotype(),
                                           | updateMilestoningContextWithPropagatedColumns($innerRes.select, $mcForProperty),
                                           | if ($propTree.property->functionReturnType().rawType->toOne()->isTemporal(),
                                                 | $innerRes.milestoningContext,
                                                 | []
                                             )
                                       );
                  if ($toPropagateMc->isEmpty(),
                      | ^$innerRes(milestoningContext=[]),
                      | let c = $toPropagateMc->toOne();
                        ^$innerRes(milestoningContext=^$c(currentProcessingState=MilestoningProcessingState.MILESTONED_ALL_FUNC));
                  );
               },
               {|
                  processPropertyMapping($propTree.propertyMapping, $parentTree->typeFromGraphFetchTree()->cast(@Class<Any>), $base, ^$pureToSqlState(inGetterFlow = true), JoinType.LEFT_OUTER, '_gftp', ^List<ColumnGroup>(), $debug, $extensions)->cast(@SelectWithCursor)
               }
   )->manageIsolation([], '_gftmp', false, ^$pureToSqlState(shouldIsolate=true), $debug, $extensions);

   let targetSetImplementation    = $propTree.sets->cast(@RelationalInstanceSetImplementation)->toOne();
   let targetMainSetImplementation = $targetSetImplementation->match([
      e:EmbeddedRelationalInstanceSetImplementation[1] | $e.setMappingOwner,
      r:RootRelationalInstanceSetImplementation[1]     | $r
   ]);
   
//    let targetWithFilter = $res->applyTypeFilter($targetMainSetImplementation, '_gftmp', $pureToSqlState, $debug);

   let properties = $targetSetImplementation->dataTypePropertyMappings()->filter(x | $x.property->in($propertiesToFetch))->map({pm | 
      let newQuery = $pm->cast(@RelationalPropertyMapping).relationalOperationElement->processColumnsInRelationalOperationElements($pureToSqlState, $res->cast(@SelectWithCursor), '_gftmp', ^List<ColumnGroup>(), false, $debug, $extensions);
      rebuildSelectWithCursor($pm.property.name->toOne(), [], $newQuery, true);
   });

   let targetPrimaryKeys = $targetSetImplementation->resolvePrimaryKey();

   let targetPks = $targetPrimaryKeys->map({pk |
      let newQuery = $pk->processColumnsInRelationalOperationElements($pureToSqlState, $res->cast(@SelectWithCursor), '_gftmp', ^List<ColumnGroup>(), false, $debug, $extensions);
      rebuildSelectWithCursor('pk_'+$targetPrimaryKeys->indexOf($pk)->toString(), [], $newQuery, true);
   });

   let pksAndProperties = $targetPks->concatenate($properties).select->mergeSQLQueryData('_gftmp', ^$pureToSqlState(shouldIsolate=true), $debug, $extensions);
   let newQueryMerged = $pksAndProperties->concatenate($res->cast(@SelectWithCursor).select)->mergeSQLQueryData('_gftmp', $pureToSqlState, $debug, $extensions);
   let newQueryMergedWithMilestoneFilters = if($res.milestoningContext->isNotEmpty(), 
                                               | let milestoningStrategy = $res.milestoningContext.currentMilestoningStrategy->toOne();
                                                 let tableFilter = $milestoningStrategy->getAllMilestonedTableFilter($newQueryMerged, $res.milestoningContext->toOne(), $pureToSqlState.inScopeVars, $extensions);
                                                 let queryWithMilestoningFilters = $newQueryMerged->applyMilestoningFilters($tableFilter, getTableToTableIdentifyFunction(), true, $extensions)->cast(@SelectSQLQuery);
                                                 let queryWithMilestoningColumns = ^$queryWithMilestoningFilters(columns+=$res.milestoningContext.columns($res.currentTreeNode.alias.relationalElement->toOne()->findMainTable()));,
                                               | $newQueryMerged);
   ^$newQueryMergedWithMilestoneFilters(distinct = true)->pushFilters($extensions);
}

function <<access.private>> meta::relational::graphFetch::executionPlan::generateCrossPropertyQuery(propTree: RoutedPropertyGraphFetchTree[1], parentIndex: Integer[1], xStorePropertyMapping: XStorePropertyMapping[1], srcProperties: AbstractProperty<Any>[*], mapping: Mapping[1], inScopeVars: Map<String, List<Any>>[1], propertiesToFetch: Property<Nil,Any|*>[*], debug: DebugContext[1], extensions:Extension[*]): SelectSQLQuery[1]
{
   let setImpl        = $propTree.sets->toOne()->cast(@RootRelationalInstanceSetImplementation);
   let pureToSqlState = ^State(inScopeVars = $inScopeVars, mapping=$mapping, supportedFunctions=getSupportedFunctions(), inProject=false, inFilter=false, filterChainDepth=0, inProjectFunctions=false,  processingProjectionThread=false, shouldIsolate=false, contextBasedSupportedFunctions=getContextBasedSupportedFunctions());
   let currentNode    = ^RootJoinTreeNode(alias=^TableAlias(name = 'root', relationalElement = $setImpl->mainRelation()->processRelation([], '', false, 0, false, [], $pureToSqlState, $debug, $extensions)));
   let basePreFilter  = ^SelectWithCursor(select = ^SelectSQLQuery(data = $currentNode), currentTreeNode = $currentNode)->applyTypeFilter($setImpl, '_gftcm', $pureToSqlState, $debug, $extensions);
   let base           = ^$basePreFilter(select = $basePreFilter.select->pushFilters($extensions));

   let propertyQueries = $setImpl->dataTypePropertyMappings()->filter(x | $x.property->in($propertiesToFetch))->map({pm |
      let newQuery = $pm->cast(@RelationalPropertyMapping).relationalOperationElement->processColumnsInRelationalOperationElements($pureToSqlState, $base, '_gftcm', ^List<ColumnGroup>(), false, $debug, $extensions);
      rebuildSelectWithCursor($pm.property.name->toOne(), [], $newQuery, true);
   });

   let pks = $setImpl->resolvePrimaryKey();
   let pkQuries = $pks->map({pk |
      let newQuery = $pk->processColumnsInRelationalOperationElements($pureToSqlState, $base->cast(@SelectWithCursor), '_gftcm', ^List<ColumnGroup>(), false, $debug, $extensions);
      rebuildSelectWithCursor('pk_'+$pks->indexOf($pk)->toString(), [], $newQuery, true);
   });

   let targetWithFilter = $base->applyTypeFilter($setImpl, '_gftcm', $pureToSqlState, $debug, $extensions);

   print(if($debug.debug,|$debug.space+'>Processing xstore join operation: '+$xStorePropertyMapping.crossExpression.expressionSequence->evaluateAndDeactivate()->toOne()->cast(@FunctionExpression)->meta::pure::router::printer::asString()+'\n',|''));
   let joinOpProcessed = processFunctionExpression($xStorePropertyMapping.crossExpression.expressionSequence->evaluateAndDeactivate()->toOne()->replaceQualifiersWithSynthesizedProperties()->cast(@FunctionExpression), [], $base, ^Map<VariableExpression, ValueSpecification>(), ^$pureToSqlState(inScopeVars = $pureToSqlState.inScopeVars->put('this', list(^PlanVarPlaceHolder(name = 'cross_src$', type = $propTree->typeFromGraphFetchTree(), multiplicity = PureOne)))),  JoinType.LEFT_OUTER, '_gftce', ^List<ColumnGroup>(), $debug->indent(), $extensions).element->cast(@SelectWithCursor)->toOne();
   let joinOpQuery     = rebuildSelectWithCursor('cross_join_op$', [], $joinOpProcessed, true);

   let pksAndProperties = $pkQuries->concatenate($propertyQueries).select->mergeSQLQueryData('_gftcm', ^$pureToSqlState(shouldIsolate=true), $debug, $extensions);
   let mergedQuery  = $joinOpQuery->concatenate($targetWithFilter).select->concatenate($pksAndProperties)->mergeSQLQueryData('_gftcm', $pureToSqlState, $debug, $extensions);
   let mergedSelect = ^$mergedQuery(distinct = true)->pushFilters($extensions);

   let tempSelectSQL = ^SelectSQLQuery(data = ^RootJoinTreeNode(alias = ^TableAlias(name = 'root', relationalElement = ^VarSetPlaceHolder(varName = crossTempTableName($parentIndex)))));
   let tempAlias     = ^TableAlias(name = 'driverTemp', relationalElement = $tempSelectSQL);

   let replaceFunction = {r:RelationalOperationElement[1] | if($r->instanceOf(Literal) && $r->cast(@Literal).value->instanceOf(VarPlaceHolder) && $r->cast(@Literal).value->cast(@VarPlaceHolder).name == 'cross_src$', | ^TableAliasColumn(alias = $tempAlias, column = ^Column(name = $r->cast(@Literal).value->cast(@VarPlaceHolder).propertyPath->toOne().name->toOne(), type = ^meta::relational::metamodel::datatype::Integer())), | $r)};
   let replacedSQL     = $mergedSelect->meta::relational::postProcessor::transform($replaceFunction)->cast(@SelectSQLQuery);
   let selectData      = $replacedSQL.data->toOne();
   let mainAlias       = $selectData.alias;

   ^$replacedSQL
   (
      columns = $replacedSQL.columns->cast(@Alias)
                   ->concatenate($srcProperties->map(x | ^Alias(name = '"parent_cross_key_' + $srcProperties->indexOf($x)->toString() + '"', relationalElement = ^TableAliasColumn(alias = $tempAlias, column = ^Column(name = $x.name->toOne(), type = $x->crossKeyRelationalType()))))),
      data    = ^RootJoinTreeNode
                (
                   alias = $tempAlias,
                   childrenData = ^JoinTreeNode
                                  (
                                     joinName = 'driverTemp_cross_parent_' + $setImpl->mainRelation()->cast(@NamedRelation).name,
                                     database = ^Database(),
                                     alias = $mainAlias,
                                     join = ^Join
                                            (
                                               name = 'driverTemp_cross_parent_' + $setImpl->mainRelation()->cast(@NamedRelation).name,
                                               aliases = [pair($tempAlias, $mainAlias), pair($mainAlias, $tempAlias)],
                                               operation = ^DynaFunction(name = 'equal', parameters = [^Literal(value = 1), ^Literal(value = 1)])
                                            ),
                                     joinType=JoinType.INNER,
                                     childrenData = $selectData.childrenData
                                  )
                ),
      filteringOperation = $replacedSQL.filteringOperation->concatenate($replacedSQL.columns->cast(@Alias)->filter(x | $x.name == '"cross_join_op$"')->toOne().relationalElement)->andFilters($extensions)
   );


}

function <<access.private>> meta::relational::graphFetch::executionPlan::replaceQualifiersWithSynthesizedProperties(vs: ValueSpecification[1]): ValueSpecification[1]
{
   $vs->match([
      fe: FunctionExpression[1] | let newFunc = $fe.func->match([
                                     q: QualifiedProperty<Any>[1] | ^Property<Nil,Any|*>(name = $q.name, owner = ^PropertyOwner(), aggregation = AggregationKind.None, genericType = $q.genericType, multiplicity = $q->functionReturnMultiplicity()),
                                     f: meta::pure::metamodel::function::Function<Any>[1] | $f
                                  ]);
                                  ^$fe(func = $newFunc, parametersValues = $fe.parametersValues->evaluateAndDeactivate()->map(pv | $pv->replaceQualifiersWithSynthesizedProperties()));,
      v : ValueSpecification[1] | $v
   ])
}

function <<access.private>> meta::relational::graphFetch::executionPlan::pushFilters(query: SelectSQLQuery[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   $query
      ->pushSavedFilteringOperation($extensions)
      ->pushExtraFilteringOperation($extensions)
}

function <<access.private>> meta::relational::graphFetch::executionPlan::changeDriverToTempWithPkProjection(select: SelectSQLQuery[1], var: String[1], parentSets: RelationalInstanceSetImplementation[*], extensions:Extension[*]):SelectSQLQuery[1]
{
   assert($parentSets->size() == 1, | 'Unions are not supported yet in graph fetch flow!');

   let selectData    = $select.data->toOne();
   let mainAlias     = $selectData.alias;
   let mainRelation  = $parentSets->toOne()->resolveMainRelation()->cast(@NamedRelation);
   let primaryKeys   = $parentSets->toOne()->resolvePrimaryKey()->cast(@TableAliasColumn).column;
   let tempTableEl   = ^VarSetPlaceHolder(varName = $var);
   let tempSelectSQL = ^SelectSQLQuery(data = ^RootJoinTreeNode(alias = ^TableAlias(name = 'root', relationalElement = $tempTableEl)));
   let tempAlias     = ^TableAlias(name = 'driverTemp', relationalElement = $tempSelectSQL);
   
   let joinOperation = $primaryKeys->map({pk |
      ^DynaFunction
      (
         name = 'equal',
         parameters = [
            ^TableAliasColumn(alias = $tempAlias, column = ^$pk(name = 'pk_' + $primaryKeys->indexOf($pk)->toString(), owner = $tempTableEl)),
            ^TableAliasColumn(alias = $mainAlias, column = $pk)
         ]
      )
   })->andFilters($extensions)->toOne()->cast(@Operation);

   ^$select
   (
      columns = $primaryKeys->map(pk | ^Alias(name = '"parent_key_gen_' + $primaryKeys->indexOf($pk)->toString() + '"', relationalElement = ^TableAliasColumn(alias = $tempAlias, column = ^$pk(name = 'pk_' + $primaryKeys->indexOf($pk)->toString(), owner = $tempTableEl))))
                   ->concatenate($select.columns),
      data = ^RootJoinTreeNode
             (
                alias = $tempAlias,
                childrenData = ^JoinTreeNode
                               (
                                  joinName = 'driverTemp_' + $var + '_' + $mainRelation.name,
                                  database = ^Database(),
                                  alias = $mainAlias,
                                  join = ^Join
                                         (
                                            name = 'driverTemp_' + $var + '_' + $mainRelation.name,
                                            aliases = [pair($tempAlias, $mainAlias), pair($mainAlias, $tempAlias)],
                                            operation = $joinOperation
                                         ),
                                  joinType=JoinType.INNER,
                                  childrenData = $selectData.childrenData
                               )
             )
   );
}

function <<access.private>> meta::relational::graphFetch::executionPlan::milestoningContextFromPropertyTree(propTree: RoutedPropertyGraphFetchTree[1], parentTree: GraphFetchTree[1], state: State[1], extensions:Extension[*]):TemporalMilestoningContext[0..1]
{
   let isQualified = $propTree.property->instanceOf(QualifiedProperty);
   if($isQualified,
      | let dummyL = {|1+2};
        let dummySFE = $dummyL.expressionSequence->cast(@SimpleFunctionExpression)->map(x | ^$x(func = $propTree.property, genericType = $propTree.property.genericType, parametersValues=[^InstanceValue(genericType=^GenericType(rawType=$parentTree->typeFromGraphFetchTree()), multiplicity=ZeroMany, values = [])]->concatenate($propTree.property->cast(@QualifiedProperty<Any>)->functionType().parameters->evaluateAndDeactivate()->tail())))->toOne();
        getMilestoningContextForQualifiedProperty($dummySFE->evaluateAndDeactivate(), [], [], $state, ^Map<VariableExpression, ValueSpecification>(), noDebug(), $extensions);,
      | []
   );
}

function <<access.private>> meta::relational::graphFetch::executionPlan::crossKeyRelationalType(p: AbstractProperty<Any>[1]):meta::relational::metamodel::datatype::DataType[1]
{
   let returnType = $p->functionReturnType().rawType->toOne();
   if($returnType->subTypeOf(Enum) || ($returnType == String),
      | ^meta::relational::metamodel::datatype::Varchar(size = 4000),
      | meta::relational::transform::fromPure::pureTypeToDataTypeMap()->get($returnType)->toOne()
   );
}


function meta::pure::graphFetch::executionPlan::relationalGraphFetchExecutionNodeToString(t: RelationalGraphFetchExecutionNode[1], space: String[1], extensions:meta::pure::extension::Extension[*]):String[1]
{
//    $g->match([
//       t : RelationalRootGraphFetchExecutionNode[1] |
//          'RelationalRootGraphFetch\n' +
//          $space + '(' + header($t, $space, $extensions) + '\n'+
//          $space + '  nodeIndex = ' + $t.nodeIndex->toString() + '\n'+
//          $space + '  tempTableName = ' + $t.tempTableName + '\n'+
//          $space + '  columns = ' + $t.columns->map(c | '(' + $c.label +', '+$c.dataType->toOne()->meta::relational::metamodel::datatype::dataTypeToSqlText() + ')')->joinStrings('[', ', ' ,']') + '\n'+
//          $space + '  children = ' + $t.children->map(x | relationalGraphFetchExecutionNodeToString($x, $space + '     ', $extensions))->joinStrings('[\n'+ $space + '     ', '\n' + $space + '     ', '\n' + $space + '  ]\n') +
//          $t.implementation->printImplementation('implementation', $space+'  ', $extensions)+
//          $space + ')\n';,
//       t : RelationalCrossRootGraphFetchExecutionNode[1] |
//          'RelationalCrossRootGraphFetch\n' +
//          $space + '(' + header($t, $space, $extensions) + '\n'+
//          $space + '  parentTempTableName = ' + $t.parentTempTableName + '\n'+
//          $space + '  parentTempTableColumns = ' + $t.parentTempTableColumns->map(c | '(' + $c.label +', '+$c.dataType->toOne()->meta::relational::metamodel::datatype::dataTypeToSqlText() + ')')->joinStrings('[', ', ' ,']') + '\n'+
//          $space + '  nodeIndex = ' + $t.nodeIndex->toString() + '\n'+
//          $space + '  tempTableName = ' + $t.tempTableName + '\n'+
//          $space + '  columns = ' + $t.columns->map(c | '(' + $c.label +', '+$c.dataType->toOne()->meta::relational::metamodel::datatype::dataTypeToSqlText() + ')')->joinStrings('[', ', ' ,']') + '\n'+
//          $space + '  relationalNode = \n' + $t.relationalNode->toOne()->planNodeToString($space + '     ', $extensions) +
//          $space + '  children = ' + $t.children->map(x | relationalGraphFetchExecutionNodeToString($x, $space + '     ', $extensions))->joinStrings('[\n'+ $space + '     ', '\n' + $space + '     ', '\n' + $space + '  ]\n') +
//          $t.implementation->printImplementation('implementation', $space+'  ', $extensions)+
//          $space + ')\n';,
//       t : RelationalTempTableGraphFetchExecutionNode[1] |
//          'RelationalTempTableGraphFetch\n' +
//          $space + '(' + header($t, $space, $extensions) + '\n'+
//          $space + '  nodeIndex = ' + $t.nodeIndex->toString() + '\n'+
//          $space + '  tempTableName = ' + $t.tempTableName + '\n'+
//          $space + '  columns = ' + $t.columns->map(c | '(' + $c.label +', '+$c.dataType->toOne()->meta::relational::metamodel::datatype::dataTypeToSqlText() + ')')->joinStrings('[', ', ' ,']') + '\n'+
//          $space + '  relationalNode = \n' + $t.relationalNode->toOne()->planNodeToString($space + '     ', $extensions) +
//          $space + '  children = ' + $t.children->map(x | relationalGraphFetchExecutionNodeToString($x, $space + '     ', $extensions))->joinStrings('[\n'+ $space + '     ', '\n' + $space + '     ', '\n' + $space + '  ]\n') +
//          $t.implementation->printImplementation('implementation', $space+'  ', $extensions)+
//          $space + ')\n';,
//       t : RelationalGraphFetchExecutionNode[1] |
//          'RelationalGraphFetch\n' +
//          $space + '(' + header($t, $space, $extensions) + '\n'+
//          $space + '  nodeIndex = ' + $t.nodeIndex->toString() + '\n'+
//          $space + '  relationalNode = \n' + $t.relationalNode->toOne()->planNodeToString($space + '     ', $extensions) +
//          $space + '  children = ' + $t.children->map(x | relationalGraphFetchExecutionNodeToString($x, $space + '     ', $extensions))->joinStrings('[\n'+ $space + '     ', '\n' + $space + '     ', '\n' + $space + '  ]\n') +
//          $t.implementation->printImplementation('implementation', $space+'  ', $extensions)+
//          $space + ')\n';
//    ]->toOneMany())

   'RelationalGraphFetch\n' +
   $space + '(' + header($t, $space, $extensions) + '\n'+
   $space + '  nodeIndex = ' + $t.nodeIndex->toString() + '\n'+
   $space + '  relationalNode = \n' + $t.executionNodes->toOne()->planNodeToString($space + '     ', $extensions) +
   $space + '  children = ' + $t.children->map(x | relationalGraphFetchExecutionNodeToString($x, $space + '     ', $extensions))->joinStrings('[\n'+ $space + '     ', '\n' + $space + '     ', '\n' + $space + '  ]\n') +
   $t.implementation->printImplementation('implementation', $space+'  ', $extensions)+
   $space + ')\n';
}