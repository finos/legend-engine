// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::executionPlan::*;
import meta::pure::graphFetch::*;
import meta::relational::tests::model::simple::*;
import meta::pure::executionPlan::profiles::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::alloy::connections::*;
import meta::relational::tests::*;
import meta::relational::runtime::*;
import meta::relational::metamodel::execute::*;
import meta::pure::runtime::*;

function <<test.BeforePackage>> meta::relational::graphFetch::tests::subType::setup(): Boolean[1]
{
   let runtime =  ^Runtime(connections = [^TestDatabaseConnection(element=meta::relational::graphFetch::tests::subType::db, type=DatabaseType.H2)]);
   let connection  = $runtime.connections->at(0)->cast(@DatabaseConnection);
   executeInDb('Drop table if exists addressTable;', $connection);
   executeInDb('Drop table if exists landmarkTable;', $connection);
   executeInDb('Drop table if exists streetTable;', $connection);
   executeInDb('Drop table if exists cityTable;', $connection);
   executeInDb('Drop table if exists coordinateTable;', $connection);
   executeInDb('Create Table addressTable(Id INT PRIMARY KEY, type VARCHAR(200));', $connection);
   executeInDb('insert into addressTable(Id, type) values (1, \'address\');', $connection);
   executeInDb('insert into addressTable(Id, type) values (2, \'address\');', $connection);
   executeInDb('insert into addressTable(Id, type) values (3, \'street\');', $connection);
   executeInDb('insert into addressTable(Id, type) values (4, \'street\');', $connection);
   executeInDb('insert into addressTable(Id, type) values (5, \'city\');', $connection);
   executeInDb('insert into addressTable(Id, type) values (6, \'city\');', $connection);
   executeInDb('Create Table streetTable(Id INT PRIMARY KEY, street VARCHAR(200));', $connection);
   executeInDb('insert into streetTable(ID, street) values(3, \'str1\');', $connection);
   executeInDb('insert into streetTable(ID, street) values(4, \'str2\');', $connection);
   executeInDb('Create Table landmarkTable(addId INT PRIMARY KEY, lmName VARCHAR(200));', $connection);
   executeInDb('insert into landmarkTable(addId, lmName) values(1, \'lm1\');', $connection);
   executeInDb('insert into landmarkTable(addId, lmName) values(2, \'lm2\');', $connection);
   executeInDb('insert into landmarkTable(addId, lmName) values(3, \'lm3\');', $connection);
   executeInDb('insert into landmarkTable(addId, lmName) values(4, \'lm4\');', $connection);
   executeInDb('insert into landmarkTable(addId, lmName) values(5, \'lm5\');', $connection);
   executeInDb('insert into landmarkTable(addId, lmName) values(6, \'lm6\');', $connection);
   executeInDb('Create Table coordinateTable(streetId INT PRIMARY KEY, latitude VARCHAR(200), longitude VARCHAR(200));', $connection);
   executeInDb('insert into coordinateTable(streetId, latitude, longitude) values(3, \'38.8951\', \' -77.0364\');', $connection);
   executeInDb('insert into coordinateTable(streetId, latitude, longitude) values(4, \'37.8951\', \' -76.0364\')', $connection);
   executeInDb('Create Table cityTable(Id INT PRIMARY KEY, name VARCHAR(200));', $connection);
   executeInDb('insert into cityTable(Id, name) values(5, \'City1\');', $connection);
   executeInDb('insert into cityTable(Id, name) values(6, \'City2\');', $connection);
   true;
}

function <<test.Test, test.AlloyOnly>> {serverVersion.start='vX_X_X'} meta::relational::graphFetch::tests::subType::testSubTypeAtRootLevelWithSimpleProperty(): Boolean[1]
{
  let treeString =  '#{\n'+
                    '  meta::relational::graphFetch::tests::subType::Address{\n'+
                    '    Id,\n'+
                    '    ->subType(@meta::relational::graphFetch::tests::subType::Street){\n'+
                    '      street\n'+
                    '    }\n'+          
                    '  }\n'+
                    '}#';
  let tree = meta::legend::compileLegendValueSpecification($treeString)->cast(@RootGraphFetchTree<meta::relational::graphFetch::tests::subType::Address>);
  let query = {|meta::relational::graphFetch::tests::subType::Address.all()->graphFetch($tree)->serialize($tree)};
  let mapping = meta::relational::graphFetch::tests::subType::testMapping;
  let runtime = meta::relational::tests::testRuntime();

  let result = execute($query, $mapping, $runtime, meta::relational::extension::relationalExtensions()).values;

  assertJsonStringsEqual(
  '[{"Id":1,"street":null},' +
  '{"Id":2,"street":null},' +
  '{"Id":3,"street":"str1"},' +
  '{"Id":4,"street":"str2"}]',
  $result
  );
}

function <<test.Test, test.AlloyOnly>> {serverVersion.start='vX_X_X'} meta::relational::graphFetch::tests::subType::testSubTypeAtRootLevelWithComplexProperty(): Boolean[1]
{
  let treeString =  '#{\n'+
                    '  meta::relational::graphFetch::tests::subType::Address{\n'+
                    '    Id,\n'+
                    '    landmark{\n' +
                    '      lmName\n' +
                    '    },\n'+
                    '    ->subType(@meta::relational::graphFetch::tests::subType::Street){\n'+
                    '      street,\n' +
                    '      coordinate{\n' +
                    '        latitude,\n' +
                    '        longitude\n' +
                    '      }\n'+           
                    '    }\n'+          
                    '  }\n'+
                    '}#';
  let tree = meta::legend::compileLegendValueSpecification($treeString)->cast(@RootGraphFetchTree<meta::relational::graphFetch::tests::subType::Address>);
  let query = {|meta::relational::graphFetch::tests::subType::Address.all()->graphFetch($tree)->serialize($tree)};
  let mapping = meta::relational::graphFetch::tests::subType::testMapping;
  let runtime = meta::relational::tests::testRuntime();

  let result = execute($query, $mapping, $runtime, meta::relational::extension::relationalExtensions()).values;

  assertJsonStringsEqual(
  '[{"Id":1,"landmark":{"lmName":"lm1"},"street":null,"coordinate":null},' +
  '{"Id":2,"landmark":{"lmName":"lm2"},"street":null,"coordinate":null},' +
  '{"Id":3,"landmark":{"lmName":"lm3"},"street":"str1","coordinate":{"latitude":"38.8951","longitude":" -77.0364"}},' +
  '{"Id":4,"landmark":{"lmName":"lm4"},"street":"str2","coordinate":{"latitude":"37.8951","longitude":" -76.0364"}}]',
  $result
  );
}

function <<test.Test, test.AlloyOnly>> {serverVersion.start='vX_X_X'} meta::relational::graphFetch::tests::subType::testSubTypeAtRootLevelWithFilter(): Boolean[1]
{
  let treeString =  '#{\n'+
                    '  meta::relational::graphFetch::tests::subType::Address{\n'+
                    '    Id,\n'+
                    '    landmark{\n' +
                    '      lmName\n' +
                    '    },\n'+
                    '    ->subType(@meta::relational::graphFetch::tests::subType::Street){\n'+
                    '      street,\n' +
                    '      coordinate{\n' +
                    '        latitude,\n' +
                    '        longitude\n' +
                    '      }\n'+           
                    '    }\n'+          
                    '  }\n'+
                    '}#';
  let tree = meta::legend::compileLegendValueSpecification($treeString)->cast(@RootGraphFetchTree<meta::relational::graphFetch::tests::subType::Address>);
  let query = {|meta::relational::graphFetch::tests::subType::Address.all()->filter(x | $x.Id->in([1,3]))->graphFetch($tree)->serialize($tree)};
  let mapping = meta::relational::graphFetch::tests::subType::testMapping;
  let runtime = meta::relational::tests::testRuntime();

  let result = execute($query, $mapping, $runtime, meta::relational::extension::relationalExtensions()).values;

  assertJsonStringsEqual(
  '[{"Id":1,"landmark":{"lmName":"lm1"},"street":null,"coordinate":null},' +
  '{"Id":3,"landmark":{"lmName":"lm3"},"street":"str1","coordinate":{"latitude":"38.8951","longitude":" -77.0364"}}]',
  $result
  );
}

function <<test.Test, test.AlloyOnly>> {serverVersion.start='vX_X_X'} meta::relational::graphFetch::tests::subType::testMultipleSubTypeAtRootLevel(): Boolean[1]
{
  let treeString =  '#{\n'+
                    '  meta::relational::graphFetch::tests::subType::Address{\n'+
                    '    Id,\n'+
                    '    landmark{\n' +
                    '      lmName\n' +
                    '    },\n'+
                    '    ->subType(@meta::relational::graphFetch::tests::subType::Street){\n'+
                    '      street,\n' +
                    '      coordinate{\n' +
                    '        latitude,\n' +
                    '        longitude\n' +
                    '      }\n'+  
                    '    },\n'+                
                    '    ->subType(@meta::relational::graphFetch::tests::subType::City){\n'+
                    '      name\n' +
                    '    }\n'+          
                    '  }\n'+
                    '}#';
  let tree = meta::legend::compileLegendValueSpecification($treeString)->cast(@RootGraphFetchTree<meta::relational::graphFetch::tests::subType::Address>);
  let query = {|meta::relational::graphFetch::tests::subType::Address.all()->graphFetch($tree)->serialize($tree)};
  let mapping = meta::relational::graphFetch::tests::subType::testMapping;
  let runtime = meta::relational::tests::testRuntime();

  let result = execute($query, $mapping, $runtime, meta::relational::extension::relationalExtensions()).values;

  assertJsonStringsEqual(
  '[{"Id":5,"landmark":{"lmName":"lm5"},"street":null,"coordinate":null,"name":"City1"},' +
  '{"Id":6,"landmark":{"lmName":"lm6"},"street":null,"coordinate":null,"name":"City2"},' +
  '{"Id":1,"landmark":{"lmName":"lm1"},"street":null,"coordinate":null,"name":null}' +
  ',{"Id":2,"landmark":{"lmName":"lm2"},"street":null,"coordinate":null,"name":null},' +
  '{"Id":3,"landmark":{"lmName":"lm3"},"street":"str1","coordinate":{"latitude":"38.8951","longitude":" -77.0364"},"name":null},' +
  '{"Id":4,"landmark":{"lmName":"lm4"},"street":"str2","coordinate":{"latitude":"37.8951","longitude":" -76.0364"},"name":null}]',
  $result
  );
}

function <<test.Test, test.AlloyOnly>> {serverVersion.start='vX_X_X'} meta::relational::graphFetch::tests::subType::testSubTypeAtRootLevelWithInheritanceMapping(): Boolean[1]
{
  let treeString =  '#{\n'+
                    '  meta::relational::graphFetch::tests::subType::Address{\n'+
                    '    Id,\n'+
                    '    landmark{\n' +
                    '      lmName\n' +
                    '    },\n'+
                    '    ->subType(@meta::relational::graphFetch::tests::subType::Street){\n'+
                    '      street,\n' +
                    '      coordinate{\n' +
                    '        latitude,\n' +
                    '        longitude\n' +
                    '      }\n'+  
                    '    },\n'+                
                    '    ->subType(@meta::relational::graphFetch::tests::subType::City){\n'+
                    '      name\n' +
                    '    }\n'+          
                    '  }\n'+
                    '}#';
  let tree = meta::legend::compileLegendValueSpecification($treeString)->cast(@RootGraphFetchTree<meta::relational::graphFetch::tests::subType::Address>);
  let mapping = meta::relational::graphFetch::tests::subType::InheritanceMapping;
  let runtime = meta::relational::tests::testRuntime();

  let query = {|meta::relational::graphFetch::tests::subType::Address.all()->graphFetch($tree)->serialize($tree)};
  let result = execute($query, $mapping, $runtime, meta::relational::extension::relationalExtensions()).values;
  assertJsonStringsEqual('[{"coordinate":null,"street":null,"name":"City1","Id":5,"landmark":{"lmName":"lm5"}},' +
                          '{"coordinate":null,"street":null,"name":"City2","Id":6,"landmark":{"lmName":"lm6"}},' +
                          '{"coordinate":{"latitude":"38.8951","longitude":" -77.0364"},"street":"str1","name":null,"Id":3,"landmark":{"lmName":"lm3"}},' +
                          '{"coordinate":{"latitude":"37.8951","longitude":" -76.0364"},"street":"str2","name":null,"Id":4,"landmark":{"lmName":"lm4"}}]',
                         $result);
}

###Pure
Class meta::relational::graphFetch::tests::subType::Address
{
   Id : Integer[1];
   landmark : meta::relational::graphFetch::tests::subType::LandMark[1];
}
 
Class meta::relational::graphFetch::tests::subType::Street extends meta::relational::graphFetch::tests::subType::Address
{
   street: String[1];
   coordinate : meta::relational::graphFetch::tests::subType::Coordinate[1];
}

Class meta::relational::graphFetch::tests::subType::City extends meta::relational::graphFetch::tests::subType::Address
{
  name : String[1];
}

Class meta::relational::graphFetch::tests::subType::LandMark
{
  addId :String[1];
  lmName : String[1];
}

Class meta::relational::graphFetch::tests::subType::Coordinate
{
  streetId : Integer[1];
  latitude : String[1];
  longitude : String[1];
}

###Mapping
Mapping meta::relational::graphFetch::tests::subType::testMapping
(
  meta::relational::graphFetch::tests::subType::Address[a]: Relational
  {
    ~filter [meta::relational::graphFetch::tests::subType::db]address_filter
    Id : [meta::relational::graphFetch::tests::subType::db]addressTable.Id,
    landmark : [meta::relational::graphFetch::tests::subType::db]@ad_l
  }
  meta::relational::graphFetch::tests::subType::Street extends [a]: Relational
  {
    ~filter [meta::relational::graphFetch::tests::subType::db]street_filter
    street : [meta::relational::graphFetch::tests::subType::db]@ad_st | streetTable.street,
    coordinate : [meta::relational::graphFetch::tests::subType::db]@ad_co
  }
  meta::relational::graphFetch::tests::subType::City extends [a]: Relational
  {
    ~filter [meta::relational::graphFetch::tests::subType::db]city_filter
    name : [meta::relational::graphFetch::tests::subType::db]@ad_city | cityTable.name
  }
  meta::relational::graphFetch::tests::subType::Coordinate : Relational
  {
    streetId : [meta::relational::graphFetch::tests::subType::db]coordinateTable.streetId,
    latitude : [meta::relational::graphFetch::tests::subType::db]coordinateTable.latitude,
    longitude : [meta::relational::graphFetch::tests::subType::db]coordinateTable.longitude
  }
  meta::relational::graphFetch::tests::subType::LandMark :Relational
  {
    addId : [meta::relational::graphFetch::tests::subType::db]landmarkTable.addId,
    lmName : [meta::relational::graphFetch::tests::subType::db]landmarkTable.lmName
  }
)

Mapping meta::relational::graphFetch::tests::subType::InheritanceMapping
(
  *meta::relational::graphFetch::tests::subType::Address: Operation
  {
    meta::pure::router::operations::inheritance_OperationSetImplementation_1__SetImplementation_MANY_()
  }
  meta::relational::graphFetch::tests::subType::Street : Relational
  {
    Id : [meta::relational::graphFetch::tests::subType::db]streetTable.Id,
    street : [meta::relational::graphFetch::tests::subType::db]streetTable.street,
    landmark : [meta::relational::graphFetch::tests::subType::db]@st_l,
    coordinate : [meta::relational::graphFetch::tests::subType::db]@st_co
  }
  meta::relational::graphFetch::tests::subType::City: Relational
  {
      Id : [meta::relational::graphFetch::tests::subType::db]cityTable.Id,
      name : [meta::relational::graphFetch::tests::subType::db]cityTable.name,
      landmark : [meta::relational::graphFetch::tests::subType::db]@c_l
  }
  meta::relational::graphFetch::tests::subType::LandMark :Relational
  {
    addId : [meta::relational::graphFetch::tests::subType::db]landmarkTable.addId,
    lmName : [meta::relational::graphFetch::tests::subType::db]landmarkTable.lmName
  }
  meta::relational::graphFetch::tests::subType::Coordinate : Relational
  {
    streetId : [meta::relational::graphFetch::tests::subType::db]coordinateTable.streetId,
    latitude : [meta::relational::graphFetch::tests::subType::db]coordinateTable.latitude,
    longitude : [meta::relational::graphFetch::tests::subType::db]coordinateTable.longitude
  }
)

###Relational
Database meta::relational::graphFetch::tests::subType::db
(
  Table addressTable(Id INT PRIMARY KEY, type VARCHAR(200))
  Table streetTable(Id INT PRIMARY KEY, street VARCHAR(200))
  Table cityTable(Id INT PRIMARY KEY, name VARCHAR(200))
  Table landmarkTable(addId INT PRIMARY KEY, lmName VARCHAR(200))
  Table coordinateTable(streetId INT PRIMARY KEY, latitude VARCHAR(200), longitude VARCHAR(200))
  Join st_l(streetTable.Id = landmarkTable.addId)
  Join st_co(streetTable.Id = coordinateTable.streetId)
  Join c_l(cityTable.Id = landmarkTable.addId)
  Join ad_l(addressTable.Id = landmarkTable.addId)
  Join ad_st(addressTable.Id = streetTable.Id)
  Join ad_city(addressTable.Id = cityTable.Id)
  Join ad_co(addressTable.Id = coordinateTable.streetId)
  Filter street_filter(addressTable.type = 'street')
  Filter address_filter(addressTable.type = 'address')
  Filter city_filter(addressTable.type = 'city')
)
 
 
