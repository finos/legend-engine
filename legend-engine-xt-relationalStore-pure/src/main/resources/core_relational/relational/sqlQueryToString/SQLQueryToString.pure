// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::functions::pureToSqlQuery::*;
import meta::pure::router::extension::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::metamodel::*;
import meta::relational::metamodel::operation::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::join::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::runtime::*;
import meta::relational::functions::sqlQueryToString::functions::*;
import meta::pure::profiles::*;

Enum meta::relational::functions::sqlQueryToString::GenerationSide
{
   Select,
   Where
}

Class meta::relational::functions::sqlQueryToString::GenerationState
{
  <<equality.Key>> generationSide : GenerationSide[1];
  <<equality.Key>> withinWhenClause : Boolean[0..1];
}

Class meta::relational::functions::sqlQueryToString::Config
{
   callingFromFilter : Boolean[0..1];
   useQuotesForTableAliasColumn : Boolean[0..1];
   generateJoin:Boolean[0..1];
   generateJoinTarget : TableAlias[0..1];
}

Class meta::relational::functions::sqlQueryToString::Format
{
   newLine:String[1];
   indent:String[1];

   indentStack:String[*];

   separator(){
      $this.newLine + $this.indentStack->makeString();
   }:String[1];
}

Class meta::relational::functions::sqlQueryToString::DbConfig
{
   dbType:DatabaseType[1];
   dbTimeZone:String[0..1];
   quoteIdentifiers:Boolean[1];

   dbExtension: DbExtension[1];

   isDbReservedIdentifier(str:String[1])
   {
     $this.dbExtension.isDbReservedIdentifier->eval($str);
   }: Boolean[1];

   literalProcessor(type:Type[1])
   {
     getLiteralProcessorForType($type, $this.dbExtension.literalProcessor, $this.dbTimeZone);
   }: LiteralProcessor[1];

   windowColumnProcessor(w:WindowColumn[1], sgc:SqlGenerationContext[1])
   {
     assert($this.dbExtension.windowColumnProcessor->isNotEmpty(), 'Window Columns not supported for Database Type: ' + $this.dbType->toString());
     $this.dbExtension.windowColumnProcessor->toOne()->eval($w, $sgc);
   }: String[1];

   semiStructuredElementProcessor(s:RelationalOperationElement[1], sgc:SqlGenerationContext[1])
   {
     assert($this.dbExtension.semiStructuredElementProcessor->isNotEmpty(), 'Semi structured array element processing not supported for Database Type: ' + $this.dbType->toString());
     $this.dbExtension.semiStructuredElementProcessor->toOne()->eval($s, $sgc);
   }: String[1];

   joinStringsProcessor(j:JoinStrings[1], sgc:SqlGenerationContext[1])
   {
     assert($this.dbExtension.joinStringsProcessor->isNotEmpty(), 'Join strings operation not supported for Database Type: ' + $this.dbType->toString());
     $this.dbExtension.joinStringsProcessor->toOne()->eval($j, $sgc);
   }: String[1];

   selectSQLQueryProcessor(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1])
   {
     $this.dbExtension.selectSQLQueryProcessor->eval($s, $sgc, $isSubSelect);
   }: String[1];

   schemaNameToIdentifier(s:String[1])
   {
     if($this.dbExtension.schemaNameToIdentifier->isEmpty(), |$s, |$this.dbExtension.schemaNameToIdentifier->toOne()->eval($s, $this));
   }: String[1];

   tableNameToIdentifier(s:String[1])
   {
     if($this.dbExtension.tableNameToIdentifier->isEmpty(), |$s, |$this.dbExtension.tableNameToIdentifier->toOne()->eval($s, $this));
   }: String[1];

   columnNameToIdentifier(s:String[1])
   {
     if($this.dbExtension.columnNameToIdentifier->isEmpty(), |$s, |$this.dbExtension.columnNameToIdentifier->toOne()->eval($s, $this));
   }: String[1];

   identifierProcessor(s:String[1])
   {
     $this.dbExtension.identifierProcessor->eval($s, $this);
   }: String[1];

   dynaFuncDispatch(dynaFn:DynaFunction[1], sgc:SqlGenerationContext[1])
   {
     $this.dbExtension.dynaFuncDispatch->eval($dynaFn, $sgc);
   }: DynaFunctionToSql[1];
}

Class meta::relational::functions::sqlQueryToString::DbExtension
{
   isBooleanLiteralSupported: Boolean[1];
   isDbReservedIdentifier: meta::pure::metamodel::function::Function<{String[1] -> Boolean[1]}>[1];
   literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1];
   windowColumnProcessor: meta::pure::metamodel::function::Function<{WindowColumn[1], SqlGenerationContext[1] -> String[1]}>[0..1];
   semiStructuredElementProcessor: meta::pure::metamodel::function::Function<{RelationalOperationElement[1], SqlGenerationContext[1] -> String[1]}>[0..1];
   joinStringsProcessor: meta::pure::metamodel::function::Function<{JoinStrings[1], SqlGenerationContext[1] -> String[1]}>[0..1];
   selectSQLQueryProcessor: meta::pure::metamodel::function::Function<{SelectSQLQuery[1], SqlGenerationContext[1], Boolean[1] -> String[1]}>[1];
   schemaNameToIdentifier: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[0..1];
   tableNameToIdentifier: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[0..1];
   columnNameToIdentifier: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[0..1];
   identifierProcessor: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[1];
   dynaFuncDispatch: meta::pure::metamodel::function::Function<{DynaFunction[1], SqlGenerationContext[1] -> DynaFunctionToSql[1]}>[1];
}

Class meta::relational::functions::sqlQueryToString::SqlGenerationContext
{
   dbConfig: DbConfig[1];
   format: Format[1];
   generationState: GenerationState[1];
   config: Config[1];
   extensions: RouterExtension[*];
}

function meta::relational::functions::sqlQueryToString::sqlQueryToString(sqlQuery:SQLQuery[1], dbType:DatabaseType[1], extensions:RouterExtension[*]):String[1]
{
   sqlQueryToString($sqlQuery, $dbType, [], [], $extensions);
}

function meta::relational::functions::sqlQueryToString::sqlQueryToString(sqlQuery:SQLQuery[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:RouterExtension[*]):String[1]
{
   sqlQueryToString($sqlQuery, $dbType, $dbTimeZone, $quoteIdentifiers, ^Format(newLine='', indent=''), $extensions);
}

function meta::relational::functions::sqlQueryToString::sqlQueryToStringPretty(sqlQuery:SQLQuery[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:RouterExtension[*]):String[1]
{
   sqlQueryToString($sqlQuery, $dbType, $dbTimeZone, $quoteIdentifiers, ^Format(newLine='\n', indent='\t'), $extensions);
}

function meta::relational::functions::sqlQueryToString::sqlQueryToString(sqlQuery:SQLQuery[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], format:Format[1], extensions:RouterExtension[*]):String[1]
{
   processOperation($sqlQuery, createDbConfig($dbType, $dbTimeZone, $quoteIdentifiers), $format, ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::createDbConfig(dbType:DatabaseType[1]):DbConfig[1]
{
   createDbConfig($dbType, []);
}

function meta::relational::functions::sqlQueryToString::createDbConfig( dbType:DatabaseType[1], dbTimeZone:String[0..1]):DbConfig[1]
{
   createDbConfig($dbType, $dbTimeZone, []);
}

function meta::relational::functions::sqlQueryToString::createDbConfig( dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1]):DbConfig[1]
{
   ^DbConfig(
      dbType = $dbType,
      dbTimeZone = $dbTimeZone,
      quoteIdentifiers = if($quoteIdentifiers->isEmpty(), |false, |$quoteIdentifiers->toOne()),
      dbExtension = $dbType->createDbExtension($dbTimeZone)
   );
}

function meta::relational::functions::sqlQueryToString::createDbExtension(dbType:DatabaseType[1], dbTimeZone:String[0..1]):DbExtension[1]
{
   let isBooleanLiteralSupported = !$dbType->in([DatabaseType.SybaseIQ, DatabaseType.DB2]);

   let reservedWords = [
     option(DatabaseType.Postgres, |postgresReservedWords()),
     option(DatabaseType.SybaseIQ, |sybaseReservedWords()),
     option(DatabaseType.MemSQL, |memSQLReservedWords()),
     option(DatabaseType.H2, |h2ReservedWords())
   ]->evalByDbType($dbType, |['kerberos', 'date', 'first']);

   let isDbReservedIdentifier = {str:String[1]| $str->in($reservedWords)};

   let literalProcessors = getDefaultLiteralProcessors($dbTimeZone)->putAll([
     option(DatabaseType.SybaseIQ, |getLiteralProcessorsForSybaseIQ($dbTimeZone)),
     option(DatabaseType.Sybase, |getLiteralProcessorsForSybaseASE($dbTimeZone)),
     option(DatabaseType.Databricks, |getLiteralProcessorsForDatabricks($dbTimeZone)),
     option(DatabaseType.Postgres, |getLiteralProcessorsForPostgres($dbTimeZone)),
     option(DatabaseType.Presto, |getLiteralProcessorsForPresto($dbTimeZone)),
     option(DatabaseType.BigQuery, |getLiteralProcessorsForBigQuery($dbTimeZone)),
     option(DatabaseType.Redshift, |getLiteralProcessorsForRedshift($dbTimeZone))
   ]->evalByDbType($dbType, |newMap([]->cast(@Pair<Type, LiteralProcessor>))));
   
   let literalProcessor = {type:Type[1]| $literalProcessors->get(if($type->instanceOf(Enumeration), | Enum, | $type))->toOne()};

   let windowColumnProcessor = [
     option(
       [DatabaseType.Sybase,DatabaseType.SybaseIQ,DatabaseType.DB2,DatabaseType.Hive,DatabaseType.H2,DatabaseType.MemSQL, DatabaseType.BigQuery, DatabaseType.Redshift, DatabaseType.Snowflake, DatabaseType.Databricks],
       |processWindowColumn_WindowColumn_1__SqlGenerationContext_1__String_1_
     )
   ]->evalByDbType($dbType, |[]);

   let semiStructuredElementProcessor = [
     option(DatabaseType.Snowflake, |processSemiStructuredElementForSnowflake_RelationalOperationElement_1__SqlGenerationContext_1__String_1_),
     option(DatabaseType.H2, |processSemiStructuredElementForH2_RelationalOperationElement_1__SqlGenerationContext_1__String_1_)
   ]->evalByDbType($dbType, |[]);

   let joinStringsProcessor = [
     option(DatabaseType.H2, |processJoinStringsOperationForH2_JoinStrings_1__SqlGenerationContext_1__String_1_),
     option(DatabaseType.SybaseIQ, |processJoinStringsOperationForSybaseIQ_JoinStrings_1__SqlGenerationContext_1__String_1_),
     option(DatabaseType.DB2, |processJoinStringsOperationForDB2_JoinStrings_1__SqlGenerationContext_1__String_1_),
     option(DatabaseType.SqlServer, |processJoinStringsOperationForSqlServer_JoinStrings_1__SqlGenerationContext_1__String_1_),
     option(DatabaseType.Postgres, |processJoinStringsOperationForPostgres_JoinStrings_1__SqlGenerationContext_1__String_1_),
     option(DatabaseType.Snowflake, |processJoinStringsOperationForSnowflake_JoinStrings_1__SqlGenerationContext_1__String_1_),
     option(
       [DatabaseType.MemSQL, DatabaseType.Presto, DatabaseType.BigQuery, DatabaseType.Redshift, DatabaseType.Databricks],
       |processJoinStringsOperationWithConcatCall_JoinStrings_1__SqlGenerationContext_1__String_1_
     )
   ]->evalByDbType($dbType, |[]);

   let selectSQLQueryProcessor = [
     option(DatabaseType.SybaseIQ, |processSelectSQLQueryForSybaseIQ_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_),
     option(DatabaseType.MemSQL, |processSelectSQLQueryForMemSQL_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_),
     option(DatabaseType.DB2, |processSelectSQLQueryForDB2_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_),
     option(DatabaseType.Sybase, |processSelectSQLQueryForSybase_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_),
     option(DatabaseType.Presto, |processSelectSQLQueryForPresto_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_),
     option(DatabaseType.Snowflake, |processSelectSQLQueryForSnowflake_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_),
     option(DatabaseType.Postgres, |processSelectSQLQueryForPostgres_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_),
     option(DatabaseType.BigQuery, |processSelectSQLQueryForBigQuery_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_),
     option(DatabaseType.Databricks, |processSelectSQLQueryForDatabricks_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_)
   ]->evalByDbType($dbType, |processSelectSQLQueryDefault_SelectSQLQuery_1__SqlGenerationContext_1__Boolean_1__String_1_);

   let schemaNameToIdentifier = [
     option(DatabaseType.Presto, |schemaNameToIdentifierForPresto_String_1__DbConfig_1__String_1_)
   ]->evalByDbType($dbType, |[]);

   let columnNameToIdentifier = [
     option(DatabaseType.SybaseIQ, |columnNameToIdentifierForSybaseIQ_String_1__DbConfig_1__String_1_),
     option([DatabaseType.H2, DatabaseType.Postgres], |[])
   ]->evalByDbType($dbType, |columnNameToIdentifierDefault_String_1__DbConfig_1__String_1_);

   let identifierProcessor = [
     option([DatabaseType.MemSQL, DatabaseType.BigQuery, DatabaseType.Databricks], |processIdentifierWithBackTicks_String_1__DbConfig_1__String_1_)
   ]->evalByDbType($dbType, |processIdentifierWithDoubleQuotes_String_1__DbConfig_1__String_1_);

   let dynaFuncDispatch = getDynaFunctionToSqlDefault($literalProcessor)->groupBy(d| $d.funcName)->putAll([
     option(DatabaseType.H2, |getDynaFunctionToSqlForH2()),
     option(DatabaseType.DB2, |getDynaFunctionToSqlForDB2()),
     option(DatabaseType.SqlServer, |getDynaFunctionToSqlForSqlServer()),
     option(DatabaseType.Redshift, |getDynaFunctionToSqlForRedshift()),
     option(DatabaseType.Snowflake, |getDynaFunctionToSqlForSnowflake()),
     option(DatabaseType.Presto, |getDynaFunctionToSqlForPresto()),
     option(DatabaseType.MemSQL, |getDynaFunctionToSqlForMemSQL()),
     option(DatabaseType.BigQuery, |getDynaFunctionToSqlForBigQuery()),
     option(DatabaseType.Databricks, |getDynaFunctionToSqlForDatabricks()),
     option(DatabaseType.Postgres, |getDynaFunctionToSqlForPostgres()),
     option(DatabaseType.Composite, |getDynaFunctionToSqlForComposite()),
     option(DatabaseType.Sybase, |getDynaFunctionToSqlForSybaseASE()),
     option(DatabaseType.SybaseIQ, |getDynaFunctionToSqlForSybaseIQ())
   ]->evalByDbType($dbType, |[]->cast(@DynaFunctionToSql))->groupBy(d| $d.funcName))->getDynaFunctionDispatcher();

   ^DbExtension(
      isBooleanLiteralSupported = $isBooleanLiteralSupported,
      isDbReservedIdentifier = $isDbReservedIdentifier,
      literalProcessor = $literalProcessor,
      windowColumnProcessor = $windowColumnProcessor,
      semiStructuredElementProcessor = $semiStructuredElementProcessor,
      joinStringsProcessor = $joinStringsProcessor,
      selectSQLQueryProcessor = $selectSQLQueryProcessor,
      schemaNameToIdentifier = $schemaNameToIdentifier,
      columnNameToIdentifier = $columnNameToIdentifier,
      identifierProcessor = $identifierProcessor,
      dynaFuncDispatch = $dynaFuncDispatch
   );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::evalByDbType<K|m>(options:Pair<List<DatabaseType>, meta::pure::metamodel::function::Function<{->K[m]}>>[*], dbType:DatabaseType[1], default:meta::pure::metamodel::function::Function<{->K[m]}>[1]): K[m]
{
   let option = $options->filter(o| $dbType->in($o.first.values));
   assert($option->size() <= 1, 'Expected atmost one matching option for db type: ' + $dbType->toString() + ', found ' + $option->size()->toString());
   if($option->isEmpty(), |$default->eval(), |$option->toOne().second->eval());
}

function <<access.private>> meta::relational::functions::sqlQueryToString::option<K>(dbTypes:DatabaseType[*], val:K[1]): Pair<List<DatabaseType>, K>[1]
{
   pair(list($dbTypes), $val);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::indent(d:Format[1]):Format[1]
{
   ^$d(indentStack += $d.indent);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], extensions:RouterExtension[*]):String[1]
{
   processOperation($relationalOperationElement, createDbConfig($dbType, []), ^Format(newLine='', indent=''), ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:RouterExtension[*]):String[1]
{
   processOperation($relationalOperationElement, createDbConfig($dbType, $dbTimeZone, $quoteIdentifiers), ^Format(newLine='', indent=''), ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], config:Config[1], extensions:RouterExtension[*]):String[1]
{
   processOperation($relationalOperationElement, createDbConfig($dbType, []), ^Format(newLine='', indent=''), $config, $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], extensions:RouterExtension[*]):String[1]
{
   processOperation($relationalOperationElement, $dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Where, withinWhenClause = false), ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], extensions:RouterExtension[*]):String[1]
{
   processOperation($relationalOperationElement, $dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Where, withinWhenClause = false), $config, $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], extensions:RouterExtension[*]):String[1]
{
   processOperation($relationalOperationElement, $dbConfig, $format, $generationState, ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], config:Config[1], extensions:RouterExtension[*]):String[1]
{
   let sgc = ^SqlGenerationContext(dbConfig=$dbConfig, format=$format, generationState=$generationState, config=$config, extensions=$extensions);
   $relationalOperationElement->match($extensions->map(e|$e.moduleExtension('relational')->cast(@RelationalExtension).sqlQueryToString_processOperation)->map(f | $f->eval($dbConfig, $format, $generationState, $config, $extensions))->concatenate(
                                       [
                                          v:VarPlaceHolder[1]| '${'+$v.name+'}',
                                          v:VarSetPlaceHolder[1]| '${'+$v.varName+'}',
                                          v:VarCrossSetPlaceHolder[1]| '${'+$v.varName+'}',
                                          w:WindowColumn[1]|$dbConfig.windowColumnProcessor($w, $sgc),
                                          s:ViewSelectSQLQuery[1]|'('+$s.selectSQLQuery->processOperation($dbConfig, $format, $generationState, $config, $extensions)+')',
                                          t:Table[1]|$t->tableToString($dbConfig),
                                          js:JoinStrings[1] | $dbConfig.joinStringsProcessor($js, ^$sgc(config=^Config())),
                                          alias:Alias[1]|
                                                let innerTerm = $alias.relationalElement->match([
                                                   r : VarSetPlaceHolder[1]|$r->processOperation($dbConfig, $format, $generationState, $config, $extensions),
                                                   s : SelectSQLQuery[1]|$s->processSelectSQLQuery($sgc, true),
                                                   r : RelationalOperationElement[1]|$r->processOperation($dbConfig, $format, $generationState, $config, $extensions)
                                                ]);

                                                let identifier = $dbConfig.identifierProcessor($alias.name);
                                            
                                                let sqlOp = $alias.relationalElement->instanceOf(SelectSQLQuery) || $alias.relationalElement->instanceOf(VarCrossSetPlaceHolder);

                                                '%s%s%s as %s'->format([
                                                      if ($sqlOp,|'(',|''),
                                                      $innerTerm,
                                                      if ($sqlOp,|')',|''),
                                                      $identifier
                                                      ]);
                                             ,
                                          c:TableAliasColumn[1]|let doubleQuote = if($config.useQuotesForTableAliasColumn == false, |'', |'"');
                                                                if(!$config.generateJoin->isEmpty() && $config.generateJoin->toOne(),|if ($config.generateJoinTarget == $c.alias,
                                                                                                                                          |'{target}.',
                                                                                                                                          |let schema = $c.alias.relationalElement->match([t:Table[1]|$t.schema.name, v:View[1]|$v.schema.name]);
                                                                                                                                           if ($schema == 'default',|'',|$schema+'.');
                                                                                                                                      )
                                                                                                                                    ,|''
                                                                ) + if ($config.generateJoinTarget == $c.alias, |'',|$dbConfig.identifierProcessor($doubleQuote+$c.alias.name->toOne()+$doubleQuote) + '.') + processColumnName($c.column.name->toOne(), $dbConfig);,
                                          l:Literal[1]| processLiteral($l, $dbConfig),
                                          ll:LiteralList[1] | $ll.values->map(e | $e->processOperation($dbConfig, $format, $generationState, $config, $extensions))->joinStrings('(', ', ', ')'),
                                          s:SelectSQLQuery[1]| $s->processSelectSQLQuery($sgc, false),
                                          u:UnionAll[1]| '('+$u.queries->map(q|$q->processSelectSQLQuery($sgc, false))->makeString(' UNION ALL ')+')',
                                          u:Union[1]| '('+$u.queries->map(q|$q->processSelectSQLQuery($sgc, false))->makeString(' UNION ')+')',
                                          f:FreeMarkerOperationHolder[1]|processFreeMarkerOperationHolder($f, $dbConfig, $format, $generationState, $config, false, $extensions),
                                          d:DynaFunction[1]|processDynaFunction($d, $sgc),
                                          c:ColumnName[1]|$dbConfig.identifierProcessor($c.name->toOne()),
                                          s:SemiStructuredObjectNavigation[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
                                          s:SemiStructuredArrayFlatten[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
                                          s:SemiStructuredArrayFlattenOutput[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
                                          {f:meta::relational::metamodel::operation::Function[1]| assert(false, 'Don\'t know how to handle %s', $f->type()); 'TO DO'; }
                                       ])->toOneMany()
                                     );
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], sgc:SqlGenerationContext[1]):String[1]
{
   $relationalOperationElement->processOperation($sgc.dbConfig, $sgc.format, $sgc.generationState, $sgc.config, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processWindowColumn(w:WindowColumn[1], sgc:SqlGenerationContext[1]):String[1]
{
   $w.func->processOperation($sgc) + ' OVER ('
   + if($w.window.partition->isNotEmpty(),
        |'Partition By ' + $w.window.partition->map(f|$f->processOperation($sgc))->joinStrings(',')+' ',
        |'')
   + if($w.window.sortBy->isNotEmpty(),
        |'Order By '+$w.window.sortBy->toOne()->processOperation($sgc)
              + if($w.window.sortDirection->isNotEmpty(), | ' ' +$w.window.sortDirection->toOne().name, | '')
              +')',
        |')') ;
}

Class <<access.private>> meta::relational::functions::sqlQueryToString::LiteralProcessor
{
   types:Type[*];
   format: String[1];
   transform: meta::pure::metamodel::function::Function<{Nil[1]->String[1]}>[1];

   formatValue(value:Any[1]) {
      $this.format->format($this.transformValue($value))
   }:String[1];

   transformValue(value:Any[1]) {
      $this.transform->eval($value)
   }:String[1];
}

function meta::relational::functions::sqlQueryToString::getLiteralProcessorForType(type:Type[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1], dbTimeZone:String[0..1]): LiteralProcessor[1]
{
   if($type->equal(VarPlaceHolder),
      |^LiteralProcessor(format = '%s', transform = {v:VarPlaceHolder[1] | convertPlaceHolderToSQLString($v, $literalProcessor, $dbTimeZone)}),
      |$literalProcessor->eval($type));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDefaultLiteralProcessors(dbTimeZone:String[0..1]):Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(Enum,           ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_)),
      pair(String,         ^LiteralProcessor(format = '\'%s\'', transform = convertStringToSQLString_String_1__String_1_)),
      pair(Number,         ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_)),
      pair(Integer,        ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_)),
      pair(Float,          ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_)),
      pair(Decimal,        ^LiteralProcessor(format = '%s',     transform = toString_Any_1__String_1_)),
      pair(Boolean,        ^LiteralProcessor(format = '\'%s\'', transform = toString_Any_1__String_1_)),
      pair(SQLNull,        ^LiteralProcessor(format = '%s',     transform = convertSQLNullToSQLString_SQLNull_1__String_1_)),
      pair(StrictDate,     ^LiteralProcessor(format = '\'%s\'', transform = {d:StrictDate[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,       ^LiteralProcessor(format = '\'%s\'', transform = {d:DateTime[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,           ^LiteralProcessor(format = '\'%s\'', transform = {d:Date[1] | $d->convertDateToSqlString($dbTimeZone)}))
   ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getLiteralProcessorsForSybaseASE(dbTimeZone:String[0..1]):Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(StrictDate,     ^LiteralProcessor(format = 'convert(DATE, \'%s\', 101)',     transform = {d:StrictDate[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,       ^LiteralProcessor(format = 'convert(DATETIME, \'%s\', 101)', transform = {d:DateTime[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,           ^LiteralProcessor(format = 'convert(DATETIME, \'%s\', 101)', transform = {d:Date[1] | $d->convertDateToSqlString($dbTimeZone)}))
   ])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getLiteralProcessorsForSybaseIQ(dbTimeZone:String[0..1]):Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(StrictDate,     ^LiteralProcessor(format = 'convert(DATE, \'%s\', 121)',     transform = {d:StrictDate[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,       ^LiteralProcessor(format = 'convert(DATETIME, \'%s\', 121)', transform = {d:DateTime[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,           ^LiteralProcessor(format = 'convert(DATETIME, \'%s\', 121)', transform = {d:Date[1] | $d->convertDateToSqlString($dbTimeZone)}))
   ])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getLiteralProcessorsForDatabricks(dbTimeZone:String[0..1]):Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(StrictDate,     ^LiteralProcessor(format = 'to_date(\'%s\')',    transform = {d:StrictDate[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,       ^LiteralProcessor(format = 'to_timestamp(\'%s\')', transform = {d:DateTime[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,           ^LiteralProcessor(format = 'to_date(\'%s\')',    transform = {d:Date[1] | $d->convertDateToSqlString($dbTimeZone)}))
   ])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getLiteralProcessorsForPostgres(dbTimeZone:String[0..1]):Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(Enum,           ^LiteralProcessor(format = 'Text%s',          transform = toString_Any_1__String_1_)),
      pair(String,         ^LiteralProcessor(format = 'Text\'%s\'',          transform = convertStringToSQLString_String_1__String_1_)),
      pair(Boolean,        ^LiteralProcessor(format = 'Boolean\'%s\'',   transform = toString_Any_1__String_1_)),
      pair(StrictDate,     ^LiteralProcessor(format = 'Date\'%s\'',      transform = {d:StrictDate[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,       ^LiteralProcessor(format = 'Timestamp\'%s\'', transform = {d:DateTime[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,           ^LiteralProcessor(format = 'Timestamp\'%s\'', transform = {d:Date[1] | $d->convertDateToSqlString($dbTimeZone)}))
   ])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getLiteralProcessorsForPresto(dbTimeZone:String[0..1]):Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(StrictDate,     ^LiteralProcessor(format = 'Date(\'%s\')',      transform = {d:StrictDate[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,       ^LiteralProcessor(format = 'Timestamp\'%s\'', transform = {d:DateTime[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,           ^LiteralProcessor(format = 'Timestamp\'%s\'', transform = {d:Date[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Boolean,        ^LiteralProcessor(format = '%s', transform = toString_Any_1__String_1_))
   ])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getLiteralProcessorsForBigQuery(dbTimeZone:String[0..1]):Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(StrictDate,     ^LiteralProcessor(format = 'PARSE_DATE(\'%%Y-%%m-%%d\', \'%s\')',   transform = {d:StrictDate[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,       ^LiteralProcessor(format = 'PARSE_DATETIME(\'%%Y-%%m-%%d %%H:%%M:%%E6S\', \'%s\')', transform = {d:DateTime[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,           ^LiteralProcessor(format = 'PARSE_DATE(\'%%Y-%%m-%%d\', \'%s\')', transform = {d:Date[1] | $d->convertDateToSqlString($dbTimeZone)}))
   ])
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getLiteralProcessorsForRedshift(dbTimeZone:String[0..1]):Map<Type,LiteralProcessor>[1]
{
   newMap([
      pair(StrictDate,     ^LiteralProcessor(format = 'Date\'%s\'',      transform = {d:StrictDate[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(DateTime,       ^LiteralProcessor(format = 'Timestamp\'%s\'', transform = {d:DateTime[1] | $d->convertDateToSqlString($dbTimeZone)})),
      pair(Date,           ^LiteralProcessor(format = 'Timestamp\'%s\'', transform = {d:Date[1] | $d->convertDateToSqlString($dbTimeZone)}))
   ])
}


function <<access.private>> meta::relational::functions::sqlQueryToString::processLiteral(literal:Literal[1], dbConfig : DbConfig[1]) : String[1]
{
   $literal.value->processLiteralValue($dbConfig);
}

function  meta::relational::functions::sqlQueryToString::processLiteralDefaultForPlanService(a:Any[1], dbType:DatabaseType[1], dbTimeZone : String[0..1], quoteIdentifiers:Boolean[0..1]): String[1]
{
   let dbConfig = createDbConfig($dbType, $dbTimeZone, $quoteIdentifiers);
   let type = if($a->instanceOf(List),
                 |
                 if($a->cast(@List<Any>).values->isNotEmpty(),
                    |$a->cast(@List<Any>).values->type(),
                    |let typeArgumentType = $a.classifierGenericType.typeArguments.rawType; if($typeArgumentType->isEmpty(),|String,|$typeArgumentType->toOne());),
                 |$a->type());
   let processor = $dbConfig.literalProcessor($type);
   if(!$a->type()==String,
      | if($a->type()==List,
           | $a->cast(@List<Any>)->processLiteralListForPlanService($type, $dbConfig, $dbType, $dbTimeZone)->joinStrings(','),
           | $processor.formatValue($a)),
      |$processor.formatValue($a)->replace('\'\'', '\''));
}

function meta::relational::functions::sqlQueryToString::processLiteralListForPlanService(a:List<Any>[*], type:Type[1], dbConfig : DbConfig[1], dbType:DatabaseType[1], dbTimeZone : String[0..1]): String[1]
{

   $a.values->map(v|$v->match([
                     s:String[1]| $dbConfig.literalProcessor($type).formatValue($s)->replace('\'\'', '\''),
                     a:Any[1]| $dbConfig.literalProcessor($type).formatValue($a)
                  ]))
   ->joinStrings(',');
}

function meta::relational::functions::sqlQueryToString::processLiteralValue(a:Any[1], dbTimeZone:String[0..1], dbType:DatabaseType[1], quoteIdentifiers:Boolean[0..1]) : String[1]
{
   let dbConfig = createDbConfig($dbType, $dbTimeZone, $quoteIdentifiers);
   processLiteralValue($a, $dbConfig);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processLiteralValue(a:Any[1], dbConfig : DbConfig[1]) : String[1]
{
   let processor = $dbConfig.literalProcessor($a->type());
   $processor.formatValue($a);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processLiteralValue(a:Any[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1]) : String[1]
{
   let processor = $literalProcessor->eval($a->type());
   $processor.formatValue($a);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertStringToSQLString(s:String[1]):String[1]
{
   $s->replace('\'', '\'\'')->replace('\@@','\'')
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertSQLNullToSQLString(s:SQLNull[1]):String[1]
{
   'null'
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getPrefixAndSuffixForType(type:Type[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1]):Pair<String, String>[1]
{
   let lp           = $literalProcessor->eval($type);
   // We need this replace here to mimic what we would have done if we had executed the format string on input.
   // %% is used in format to escape a required % symbol. We don't need to do this while building freemarker context
   let lpFormat     = $lp.format->replace('%%', '%');

   let index        = $lpFormat->indexOf('%s');
   let prefix       = $lpFormat->substring(0, $index);
   let suffix       = $lpFormat->substring($index+2);

   ^Pair<String, String>(first = $prefix, second = $suffix);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getVariableType(v:VarPlaceHolder[1]):Type[1]
{
   if ($v.propertyPath->isNotEmpty(),
       | $v.propertyPath->last().genericType.rawType->toOne(),
       | $v.type);
}

function meta::relational::functions::sqlQueryToString::convertPlaceHolderToSQLString(v:VarPlaceHolder[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1], dbTimeZone:String[0..1]):String[1]
{
   let vType        = $v->getVariableType();

   let prefixSuffix = getPrefixAndSuffixForType($vType, $literalProcessor);
   let prefix       = $prefixSuffix.first;
   let suffix       = $prefixSuffix.second;
   let value        = processPlaceHolder($v, $vType, $prefix, $suffix, $dbTimeZone);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processPlaceHolder(v:VarPlaceHolder[1], type:Type[1], prefix:String[1], suffix:String[1], dbTimeZone:String[0..1]): String[1]
{
   let noPropertyPath              = $v.propertyPath->isEmpty();
   let placeHolderWithPath         = $v.name+if($noPropertyPath,|'',|'[\"')+$v.propertyPath->map(p|$p.name)->joinStrings('.')+if($noPropertyPath,|'',|'\"]');
   let resolvedPlaceHolder         = if($type == String,
                                           | $placeHolderWithPath->convertStringToSQLString(),
                                           | $placeHolderWithPath);

   let isPossibleDateTimeType      = [Date, DateTime]->contains($v.type);
   let possiblyApplyDateTzFunction = if($isPossibleDateTimeType,| processDatePlaceHolder($resolvedPlaceHolder, $dbTimeZone),| $resolvedPlaceHolder);

   if($v->isCollectionPlaceHolder(),
      |if($resolvedPlaceHolder == $possiblyApplyDateTzFunction,
         |'${renderCollection('+$resolvedPlaceHolder + ' \",\" \"' + $prefix + '\" \"'+ $suffix + '\" ' + placeHolderDefaultValue() +')}',
         |'${renderCollectionWithTz('+ $resolvedPlaceHolder + ' "['+$dbTimeZone->toOne()+']" '+ '\",\" \"' + $prefix + '\" \"'+ $suffix + '\" ' + placeHolderDefaultValue() +')}'),
      |if($v.multiplicity->isNotEmpty() && $v.multiplicity->toOne()->isZeroOne() && $resolvedPlaceHolder == $possiblyApplyDateTzFunction,
          |'${varPlaceHolderToString(' + $possiblyApplyDateTzFunction + '![] ' + ' \"' + $prefix + '\" \"'+ $suffix + '\" '+ placeHolderDefaultValue()+')}',
          |$prefix + '${'+$possiblyApplyDateTzFunction+'}' + $suffix)
      );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isCollectionPlaceHolder(v:VarPlaceHolder[1]):Boolean[1]
{
   $v.multiplicity->isNotEmpty() && $v.multiplicity == ZeroMany;
}

function <<access.private>> meta::relational::functions::sqlQueryToString::placeHolderDefaultValue():String[1]
{
   '\"' + convertSQLNullToSQLString(^SQLNull()) +'\"';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processDatePlaceHolder(dateParameter:String[1], dbTimeZone:String[0..1]): String[1]
{
   let isNonSystemTz = $dbTimeZone->isNotEmpty() && !meta::pure::functions::date::systemDefaultTimeZones()->contains($dbTimeZone->toOne());
   if($isNonSystemTz,|'GMTtoTZ( "['+$dbTimeZone->toOne()+']" '+$dateParameter+')'
                    ,| $dateParameter);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processTop(s:SelectSQLQuery[1], format:Format[1]):String[1]
{
   if ($s.fromRow == [] && $s.toRow != [] && !$s.toRow->toOne().value->instanceOf(SQLNull),
         |'top '+$s.toRow->toOne()->getValueForTake()+' ', |'');
}

function  meta::relational::functions::sqlQueryToString::getValueForTake(l:Literal[1]):String[1]
{
   $l.value->match([
      i:Integer[1]| $i->toString(),
      v:VarPlaceHolder[1] |$v->processPlaceHolder($v->getVariableType(), '', '', [])
   ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processLimit(s:SelectSQLQuery[1], format:Format[1],
              takeProcessor:meta::pure::metamodel::function::Function<{SelectSQLQuery[1], Format[1] -> String[1]}>[0..1],
              sliceOrDropProcessor:meta::pure::metamodel::function::Function<{SelectSQLQuery[1], Format[1], Any[1] -> String[1]}>[1]):String[1]
{
   if ($s.fromRow == [] && $s.toRow == [],
      |
         // No limit or offset required
         '';
      , |let size = if ($s.toRow == [] || $s.fromRow == [],
                      | -1,
                      |$s.toRow.value->match([
                          i:Integer[1]| $s.toRow->toOne().value->cast(@Integer) - $s.fromRow->toOne().value->cast(@Integer) ,
                          v:VarPlaceHolder[1]|[$s.toRow->toOne().value->cast(@VarPlaceHolder).name, $s.fromRow->toOne().value->cast(@VarPlaceHolder).name]->joinStrings('${','?number - ', '?number}')
                          ])
                      );
         if ($s.fromRow == [],
            |
               // We have a "take"
               assert($s.toRow->isNotEmpty());
               if($takeProcessor->isNotEmpty(), |$takeProcessor->toOne()->eval($s, $format), |'');
            ,
            |
               //We have a "slice" or a "drop"
               assert($s.fromRow->isNotEmpty());
               $sliceOrDropProcessor->eval($s, $format, $size);
            );
      );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSliceOrDropDefault(s:SelectSQLQuery[1], format:Format[1], size:Any[1]):String[1]
{
   '%s limit %s,%s'->format([$format.separator, $s.fromRow->toOne()->getValueForTake(), $size]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSliceOrDropForPostgres(s:SelectSQLQuery[1], format:Format[1], size:Any[1]):String[1]
{
   '%s offset %s'->format([$format.separator, $s.fromRow->toOne()->getValueForTake()]) + if ($size == -1, | '', | ' limit %s'->format($size));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSliceOrDropForSybaseIQ(s:SelectSQLQuery[1], format:Format[1], size:Any[1]):String[1]
{
    // queries where specifying query with "limit 100,1000" would return 1100 rows.
    // However when a order by column is specified, the expected number of rows is returned (i.e. 900 rows).
    // Given that a slice without an order is largely meaningless, we'll simply report an error (rather than trying to simulate something)
    //
    // http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.infocenter.dc00801.1601/doc/html/san1281564978024.html

    assert($s.orderBy->isNotEmpty(), | 'SybaseIQ requires an order by column for meaningful limit/offset');
    '%s limit %s,%s'->format([$format.separator, $s.fromRow->toOne()->getValueForTake(), $size]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSliceOrDropForSnowflake(s:SelectSQLQuery[1], format:Format[1], size:Any[1]):String[1]
{
   if ($s.fromRow->isNotEmpty(),
       | if ($size == -1,
             | '%s limit \'\' offset %s'->format([$format.separator, $s.fromRow->toOne()->getValueForTake()]),
             | '%s limit %s offset %s'->format([$format.separator, $size, $s.fromRow->toOne()->getValueForTake()])),
       | '%s limit %s'->format($size));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSliceOrDropForPresto(s:SelectSQLQuery[1], format:Format[1], size:Any[1]):String[1]
{
   if ($s.fromRow->isNotEmpty(),
       | if ($size == -1,
            | '%s offset %s'->format([$format.separator, $s.fromRow->toOne()->getValueForTake()]),
            | '%s offset %s rows fetch next %s rows only'->format([$format.separator, $s.fromRow->toOne()->getValueForTake(), $size])),
       | '%s limit %s'->format($size));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processTakeDefault(s:SelectSQLQuery[1], format:Format[1]):String[1]
{
   '%s limit %s'->format([$format.separator, $s.toRow->toOne()->getValueForTake()]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processTakeForDB2(s:SelectSQLQuery[1], format:Format[1]):String[1]
{
   ' ' + $format.separator +'fetch first ' + $s.toRow->toOne()->getValueForTake()->toString() +' rows only';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::rewriteSliceAsWindowFunction(selectQuery:SelectSQLQuery[1]):SelectSQLQuery[1]
{
   assert($selectQuery.fromRow->isNotEmpty() || $selectQuery.toRow->isNotEmpty(), 'Expected at least one of fromRow/toRow');

   let columnName = 'row_number';
   let func = ^DynaFunction(name = meta::pure::functions::math::olap::rowNumber_Any_MANY__Map_1_.functionName->toOne()) ;
   let sortDirection = if($selectQuery.orderBy->isNotEmpty(),
                   | $selectQuery.orderBy->at(0).direction, //We probably should pass on all order by columns (rather than just the first), but WindowColumn doesn't support that
                   | []
                   );
   let sortBy = if($selectQuery.orderBy->isNotEmpty(),
                   | $selectQuery.orderBy.column->at(0), //We probably should pass on all order by columns (rather than just the first), but WindowColumn doesn't support that
                   | $selectQuery.columns->at(0)
                   )
                  ->match([
                         a:Alias[1]|$a.relationalElement,
                         r:RelationalOperationElement[1]|$r
                      ]);

   let windowColumn = ^Alias(
          name='"'+$columnName+'"' ,
          relationalElement = ^meta::relational::metamodel::WindowColumn(
                columnName = $columnName,
                func= $func,
                window = ^meta::relational::metamodel::Window(partition=[],sortBy=$sortBy, sortDirection=$sortDirection)
             )
          );

   let innerQuery = ^$selectQuery(
      columns = $selectQuery.columns->concatenate($windowColumn),
      toRow = [],
      fromRow = [],
      orderBy = []
      );

   let tableAlias = ^TableAlias(name = 'limitoffset_via_window_subquery', relationalElement=$innerQuery);

   let row_number_col = ^TableAliasColumn(
                           alias =  $tableAlias,
                           column = ^Column(
                                           name = $columnName,
                                           type = ^meta::relational::metamodel::datatype::Integer()
                                           )
                        );


   let filters = if($selectQuery.fromRow->isEmpty(),
                       | [],
                       | ^DynaFunction(name = greaterThan_Number_1__Number_1__Boolean_1_.functionName->toOne(), parameters = [$row_number_col, $selectQuery.fromRow->toOne()])
                       )
                 ->concatenate(
                       if($selectQuery.toRow->isEmpty(),
                          | [],
                          | ^DynaFunction(name = lessThanEqual_Number_1__Number_1__Boolean_1_.functionName->toOne(), parameters = [$row_number_col,  $selectQuery.toRow->toOne()])
                          )
                       );

   let filter = if($filters->size() <= 1,
                   | $filters->first(),
                   | ^DynaFunction(name = and_Boolean_MANY__Boolean_1_.functionName->toOne(), parameters = $filters)
                );

   ^TdsSelectSqlQuery(
      columns = $innerQuery.columns->init()->cast(@Alias)->map(c|
            ^Alias(
               name = $c.name,
               relationalElement = ^TableAliasColumn(
                                                     alias =  $tableAlias,
                                                     column = ^Column(
                                                              name = $c.name,
                                                              type = ^meta::relational::metamodel::datatype::Integer()
                                                              )
                                                      )
                )
            ),
      data =^RootJoinTreeNode(alias = $tableAlias),
      filteringOperation = $filter
      );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQuery(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   if ($s.columns->isEmpty() && !$s.data->isEmpty() && $s.data.alias.relationalElement->toOne()->instanceOf(Union) && $s.data.children->isEmpty(),
      | $s.data.alias.relationalElement->toOne()->processOperation($sgc.dbConfig, $sgc.format->indent(), $sgc.config, $sgc.extensions),
      | $sgc.dbConfig.selectSQLQueryProcessor($s, $sgc, $isSubSelect)
   );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryDefault(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryDefault($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryDefault(s:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));

  $format.separator + 'select ' + processTop($s, $format) + if($s.distinct == true,|'distinct ',|'') +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), true, $extensions) +
  if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), true, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, [], processSliceOrDropDefault_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForSybaseIQ(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForSybaseIQ($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForSybaseIQ(sq:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  // Sybase IQ does not support limit / offset in a subselect, so we need to adjust it, e.g.
  //       select * from (select top 10 "root".id as "ID" from trades as "root" ) as x
  // gives
  //       SQL Anywhere Error -1001030: Feature,  TOP/FIRST/LIMIT in a view, is not supported.
  // but instead needs to be
  //      select * from (select "limitoffset_via_window_subquery"."ID" as "ID" from (select "root".id as "ID", row_number() OVER (Order By "root".id) as "row_number" from trades as "root")
  //            as "limitoffset_via_window_subquery" where "limitoffset_via_window_subquery".row_number < 10) as x
  // Also see https://www.jooq.org/doc/3.1/manual/sql-building/sql-statements/select-statement/limit-clause/#N467C4

  let s = if($isSubSelect && ($sq.fromRow->isNotEmpty() || $sq.toRow->isNotEmpty()), |$sq->rewriteSliceAsWindowFunction(), |$sq);
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->wrapAsBooleanOperation($extensions)->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  
  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') + processTop($s, $format) +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), false, $extensions) +
  if ($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), true, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, [], processSliceOrDropForSybaseIQ_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForMemSQL(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForMemSQL($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForMemSQL(sq:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  let s = if($sq.fromRow->isNotEmpty() && $sq.toRow->isEmpty(), |$sq->rewriteSliceAsWindowFunction(), |$sq);
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let joinOrder = [JoinType.INNER, JoinType.LEFT_OUTER, JoinType.RIGHT_OUTER];

  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), true, $extensions) +
  if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), $joinOrder, $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), true, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, processTakeDefault_SelectSQLQuery_1__Format_1__String_1_, processSliceOrDropDefault_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForDB2(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForDB2($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForDB2(s:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->wrapAsBooleanOperation($extensions)->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));

  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), false, $extensions) +
  if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), false, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, processTakeForDB2_SelectSQLQuery_1__Format_1__String_1_, processSliceOrDropDefault_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForSybase(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForSybase($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForSybase(s:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));

  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') + processTop($s, $format) +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), true, $extensions) +
  if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), false, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, [], processSliceOrDropDefault_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForPresto(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForPresto($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForPresto(s:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));

  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), true, $extensions) +
  if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), false, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, processTakeDefault_SelectSQLQuery_1__Format_1__String_1_, processSliceOrDropForPresto_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForSnowflake(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForSnowflake($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForSnowflake(s:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));

  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), true, $extensions) +
  if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), false, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, processTakeDefault_SelectSQLQuery_1__Format_1__String_1_, processSliceOrDropForSnowflake_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForPostgres(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForPostgres($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForPostgres(s:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));

  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), true, $extensions) +
  if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), true, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, processTakeDefault_SelectSQLQuery_1__Format_1__String_1_, processSliceOrDropForPostgres_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForBigQuery(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForBigQuery($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForBigQuery(s:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));

  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), true, $extensions) +
  if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), true, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, processTakeDefault_SelectSQLQuery_1__Format_1__String_1_, processSliceOrDropDefault_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForDatabricks(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   $s->processSelectSQLQueryForDatabricks($sgc.dbConfig, $sgc.format, $sgc.config, $isSubSelect, $sgc.extensions);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectSQLQueryForDatabricks(s:SelectSQLQuery[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], isSubSelect : Boolean[1], extensions:RouterExtension[*]):String[1]
{
  let opStr = if($s.filteringOperation->isEmpty(), |'', |$s.filteringOperation->map(s|$s->processOperation($dbConfig, $format->indent(), ^$config(callingFromFilter = true), $extensions))->filter(s|$s != '')->joinStrings(' <||> '));
  let havingStr = if($s.havingOperation->isEmpty(), |'', |$s.havingOperation->map(s|$s->processOperation($dbConfig, $format->indent(), $config, $extensions))->filter(s|$s != '')->joinStrings(' <||> '));

  $format.separator + 'select ' + if($s.distinct == true,|'distinct ',|'') +
  processSelectColumns($s.columns, $dbConfig, $format->indent(), true, $extensions) +
  if($s.data == [],|'',| ' ' + $format.separator + 'from ' + $s.data->toOne()->processJoinTreeNode([], $dbConfig, $format->indent(), [], $extensions)) +
  if (eq($opStr, ''), |'', | ' ' + $format.separator + 'where ' + $opStr) +
  if ($s.groupBy->isEmpty(),|'',| ' ' + $format.separator + 'group by '+$s.groupBy->processGroupByColumns($dbConfig, $format->indent(), true, $extensions)->makeString(','))+
  if (eq($havingStr, ''), |'', | ' ' + $format.separator + 'having ' + $havingStr) +
  if ($s.orderBy->isEmpty(),|'',| ' ' + $format.separator + 'order by '+ $s.orderBy->processOrderBy($dbConfig, $format->indent(), $config, $extensions)->makeString(','))+
  + processLimit($s, $format, processTakeDefault_SelectSQLQuery_1__Format_1__String_1_, processSliceOrDropDefault_SelectSQLQuery_1__Format_1__Any_1__String_1_);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processGroupByColumns(columns:RelationalOperationElement[*], dbConfig : DbConfig[1], format:Format[1], supportsAliasInGroupBy:Boolean[1], extensions:RouterExtension[*]):String[*]
{
   $columns->map(c | $c->match([
                                a:Alias[1] | if($supportsAliasInGroupBy == true, | $dbConfig.identifierProcessor($a->cast(@Alias).name)
                                                                               , | $a->cast(@Alias).relationalElement->processOperation($dbConfig, $format, $extensions)),
                                c:TableAliasColumn[1] | $c->processOperation($dbConfig, $format, $extensions)
                                ]));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processOrderBy(orderBy:OrderBy[*], dbConfig : DbConfig[1], format:Format[1], config:Config[1], extensions:RouterExtension[*]):String[*]
{
   $orderBy->map(o | $o.column->match([
        a:Alias[1]|$dbConfig.identifierProcessor($a.name),
        r:RelationalOperationElement[1]|$r->processOperation($dbConfig, $format, $config, $extensions)
   ]) + if ($o.direction == meta::relational::metamodel::SortDirection.ASC, |'', | ' desc'));
}

function meta::relational::functions::sqlQueryToString::convertDateToSqlString(date:Date[1], dbTimeZone:String[0..1]):String[1]
{
   //Default to UTC, if timezone is not specified. GMT is the same as UTC, UTC is not actually a timezone
   let timeZone = if( $dbTimeZone->isEmpty(), | 'GMT', |  $dbTimeZone->toOne());
   if($date->hasSecond(),
      | if ($date->hasSubsecond(),
            | format('%t{[' + $timeZone + ']yyyy-MM-dd HH:mm:ss.SSSSSS}', $date),
            | format('%t{[' + $timeZone + ']yyyy-MM-dd HH:mm:ss}', $date)),
      | format('%t{[' + $timeZone + ']yyyy-MM-dd}', $date));

}

function <<access.private>> meta::relational::functions::sqlQueryToString::processJoinStringsOperation(js:JoinStrings[1], sgc:SqlGenerationContext[1],
         groupByCat:meta::pure::metamodel::function::Function<{String[1], String[1] -> String[1]}>[0..1], stringCat:meta::pure::metamodel::function::Function<{String[*], String[1] -> String[1]}>[0..1]):String[1]
{
    let strings = $js.strings->map(s | $s->processOperation($sgc));
    let isGroupByCat = $js.strings->size() == 1;

    let separator = if($js.separator->isEmpty(), |'\'\'', |$js.separator->toOne()->processOperation($sgc));
    let prefix = if($js.prefix->isEmpty(), |'\'\'', |$js.prefix->toOne()->processOperation($sgc));
    let suffix = if($js.suffix->isEmpty(), |'\'\'', |$js.suffix->toOne()->processOperation($sgc));
    let strs = if(eq($prefix, '\'\''),
                  | if(eq($suffix, '\'\''), | $strings, | $strings->add($suffix)),
                  | if(eq($suffix, '\'\''), | $strings->add(0, $prefix), | $strings->add(0, $prefix)->add($suffix)));
    if ($strs->size() == 0, | $strs->at(0), | if ($isGroupByCat,
        |assert($groupByCat->isNotEmpty(), 'The database type \''+$sgc.dbConfig.dbType->id()+'\' is not supported yet!'); $groupByCat->toOne()->eval($strs->at(0), $separator);,
        |assert($stringCat->isNotEmpty(), 'The database type \''+$sgc.dbConfig.dbType->id()+'\' is not supported yet!'); $stringCat->toOne()->eval($strs, $separator);));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processJoinStringsOperationForH2(js:JoinStrings[1], sgc:SqlGenerationContext[1]): String[1]
{
   processJoinStringsOperation($js, $sgc, {col, sep| 'group_concat(' + $col + if($sep == '\'\'', |'', |' separator ' + $sep) + ' )'},
    {strs, sep| $strs->joinStrings('concat(', if('\'\'' == $sep, |', ', |',' + $sep + ',') , ')')});
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processJoinStringsOperationForSybaseIQ(js:JoinStrings[1], sgc:SqlGenerationContext[1]): String[1]
{
   processJoinStringsOperation($js, $sgc, {col, sep| 'list(' + $col + ',' + $sep + ' )'}, {strs, sep| $strs->joinStrings(if('\'\'' == $sep, |'+', |'+' + $sep + '+'))});
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processJoinStringsOperationForSnowflake(js:JoinStrings[1], sgc:SqlGenerationContext[1]): String[1]
{
   processJoinStringsOperation($js, $sgc, {col, sep| 'listagg(' + $col + if($sep == '\'\'', |'', |', ' + $sep) + ')'},
    {strs, sep| $strs->joinStrings('concat(', if('\'\'' == $sep, |', ', |', ' + $sep + ', ') , ')')});
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processJoinStringsOperationForDB2(js:JoinStrings[1], sgc:SqlGenerationContext[1]): String[1]
{
   processJoinStringsOperation($js, $sgc, [], {strs, sep| $strs->joinStrings('(', if('\'\'' == $sep, |' concat ', |' concat ' + $sep + ' concat '), ')')});
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processJoinStringsOperationForSqlServer(js:JoinStrings[1], sgc:SqlGenerationContext[1]): String[1]
{
   processJoinStringsOperation($js, $sgc, [], {strs, sep| $strs->joinStrings(if('\'\'' == $sep, |'+', |'+' + $sep + '+'))});
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processJoinStringsOperationForPostgres(js:JoinStrings[1], sgc:SqlGenerationContext[1]): String[1]
{
   processJoinStringsOperation($js, $sgc, [], {strs, sep| $strs->joinStrings('concat(', if('Text\'\'' == $sep, |', ', |',' + $sep + ',') , ')')});
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processJoinStringsOperationWithConcatCall(js:JoinStrings[1], sgc:SqlGenerationContext[1]): String[1]
{
   processJoinStringsOperation($js, $sgc, [], {strs, sep| $strs->joinStrings('concat(', if('\'\'' == $sep, |', ', |',' + $sep + ',') , ')')});
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSelectColumns(s:RelationalOperationElement[*], dbConfig : DbConfig[1], format:Format[1], conditionalExprAllowed:Boolean[1], extensions:RouterExtension[*]):String[1]
{
   if ($s->size() == 0,
         |'*',
         | $format.separator + $s->map(r|  $r->match([a:Alias[1] | let shouldWrapWithCase = ( $a.relationalElement->isBooleanOperation($extensions) && !$conditionalExprAllowed );

                                                                   $shouldWrapWithCase->if(|'case when (' + $a.relationalElement->processOperation($dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Select, withinWhenClause = true), $extensions) + ') then \'true\' else \'false\' end as ' + $a.name,
                                                                                           | $r->processOperation($dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Select, withinWhenClause = false), $extensions)
                                                                                           );,
                                                      z:RelationalOperationElement[1]   | $z->processOperation($dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Select, withinWhenClause = false), $extensions)
                                                      ])

                                      )->joinStrings(', ' + $format.separator);

       );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::wrapAsBooleanOperation(e:RelationalOperationElement[1], extensions:RouterExtension[*]):RelationalOperationElement[1]
{
   if ($e->isBooleanOperation($extensions), | $e, | ^DynaFunction(name ='equal', parameters=[$e, ^Literal(value=true)]));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processJoinTreeNode(joinTreeNode:RelationalTreeNode[1], parent:TableAlias[0..1], dbConfig : DbConfig[1], format:Format[1], joinOrder:JoinType[*], extensions:RouterExtension[*]):String[1]
{
   let tableAlias = $joinTreeNode->match(
                                    [
                                       r:RootJoinTreeNode[1] | $r.alias,
                                       j:JoinTreeNode[1] | $j.join.otherTableFromAlias($parent->toOne());
                                    ]
                                    );
   let val = $joinTreeNode->match(
                                    [
                                       r:RootJoinTreeNode[1] |
                                             $tableAlias->toOne()
                                                ->map(a|^$a(name = '"' + $a.name + '"')) //Not sure why this is necessary, but it's retained to keep the generated SQL the same as previously (and does no real harm)
                                                ->processOperation($dbConfig, $format->indent(), $extensions),
                                       j:JoinTreeNode[1] |
                                             if($j.joinType == JoinType.INNER,| ' ' + $format.separator() + 'inner join ',|if($j.joinType == JoinType.LEFT_OUTER,| ' ' + $format.separator() + 'left outer join ',| ' ' + $format.separator() + 'right outer join '))
                                                + if ($j.lateral == true, | 'lateral ', | '')
                                                + $j.alias
                                                      ->map(a|^$a(name = '"' + $a.name + '"')) //Not sure why this is necessary, but it's retained to keep the generated SQL the same as previously (and does no real harm)
                                                      ->toOne()->processOperation($dbConfig, $format->indent(), $extensions) + $format.separator()
                                                + ' ' + 'on (' + processOperation($j.join.operation, $dbConfig, $format->indent(), ^Config(), $extensions) + ')';,
                                       a:Any[1] | ''
                                    ]
                                    );
   let children = if($joinOrder->isNotEmpty(),
                     |$joinTreeNode.children()->sortBy({node | if($node.joinType->isEmpty(), |2, |$joinOrder->indexOf($node.joinType->toOne()))}),
                     |$joinTreeNode.children());
   $children->map(child | processJoinTreeNode($child, $tableAlias->cast(@TableAlias), $dbConfig, $format, $joinOrder, $extensions))->joinStrings($val, '', '');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::tableToString(table:Table[1], dbConfig : DbConfig[1]):String[1]
{
   let schemaName = $dbConfig.schemaNameToIdentifier($table.schema.name);
   let tableName = $dbConfig.tableNameToIdentifier($table.name);
   if($schemaName == 'default', | $dbConfig.identifierProcessor($tableName), | $dbConfig.identifierProcessor($schemaName) + '.' + $dbConfig.identifierProcessor($tableName));
}

function meta::relational::functions::sqlQueryToString::processColumnName(name:String[1], dbConfig:DbConfig[1]):String[1]
{
   $dbConfig.identifierProcessor($dbConfig.columnNameToIdentifier($name));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::schemaNameToIdentifierForPresto(schemaName: String[1], dbConfig: DbConfig[1]): String[1]
{
   $schemaName->replace('$', '.');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::columnNameToIdentifierForSybaseIQ(columnName: String[1], dbConfig: DbConfig[1]): String[1]
{
   if($dbConfig.isDbReservedIdentifier($columnName->toLower()), |'"' + $columnName->toLower() + '"', |$columnName);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::columnNameToIdentifierDefault(columnName: String[1], dbConfig: DbConfig[1]): String[1]
{
   if($columnName->toLower()->in(['kerberos', 'date', 'first']), |'"' + $columnName->toUpper() + '"', |$columnName);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processIdentifierWithBackTicks(identifier:String[1], dbConfig: DbConfig[1]):String[1]
{
   $identifier->processIdentifierWithQuoteChar('`', $dbConfig);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processIdentifierWithDoubleQuotes(identifier:String[1], dbConfig: DbConfig[1]):String[1]
{
   $identifier->processIdentifierWithQuoteChar('"', $dbConfig);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processIdentifierWithQuoteChar(identifier:String[1], quoteChar: String[1], dbConfig : DbConfig[1]):String[1]
{
  if($dbConfig.quoteIdentifiers || $identifier->startsWith('"') || $dbConfig.isDbReservedIdentifier($identifier),
    | '%s%s%s'->format([$quoteChar, $identifier->replace('"', ''), $quoteChar]),
    | $identifier
  );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::removeQuotes(s:String[1]):String[1]
{
   let firstQuote = $s->indexOf('\'') +1;
   $s->substring($firstQuote, $s->length()-1);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processFreeMarkerOperationHolder(freeMarkerOp:FreeMarkerOperationHolder[1], dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], config: Config[1], nestedFreeMarkerOperationHolder: Boolean[1], extensions:RouterExtension[*]):String[1]
{
   let freeMarkerOpMap = getFreeMarkerOperationMap();
   let res = $freeMarkerOpMap->get($freeMarkerOp.name);
   assert($res->isNotEmpty(),  | $freeMarkerOp.name + 'freeMarker Operation is not supported!');

   let processedParams = $freeMarkerOp.parameters->map(p | $p->match([
                                                               f:FreeMarkerOperationHolder[1] | $f->processFreeMarkerOperationHolder($dbConfig, $format, $generationState, $config, true, $extensions);,
                                                               l:Literal[1]                   | $l.value->match([v:VarPlaceHolder[1] | if($v.multiplicity->isNotEmpty() && $v.multiplicity->toOne()->isZeroOne(), |$v.name + '![]', |$v.name);,
                                                                                                                 a:Any[1]            | $a->toString();]),
                                                               a:RelationalOperationElement[1]| '\'' + $a->processOperation($dbConfig, $format, $generationState, $config, $extensions)->replace('\'', '\\\'') + '\'';
   ]));
   let params = if($res.transform->isEmpty(), | $processedParams, | $res.transform->toOne()->eval($processedParams));

   if($nestedFreeMarkerOperationHolder, |format($res->toOne().format, $params), |'(${' + format($res->toOne().format, $params) + '})');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::maybeWrapAsBooleanOperation(e:RelationalOperationElement[1], sgc:SqlGenerationContext[1]):RelationalOperationElement[1]
{
   if ($sgc.dbConfig.dbExtension.isBooleanLiteralSupported, |$e, |$e->wrapAsBooleanOperation($sgc.extensions));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processDynaFunction(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   if ($func->isEqualsFromFilter($sgc.config),
      | processEqualFromFilter($func,$sgc),
      |
   if ($func.name == 'case',
      | processCase($func,$sgc),
      |
   if ($func.name == 'not',
      | processNot($func,$sgc),
      | let result = $sgc.dbConfig.dynaFuncDispatch($func, $sgc);

        let params = if ($func.name->in(['and', 'or']),
                        | $func.parameters->map(p | $p->maybeWrapAsBooleanOperation($sgc)),
                        |
                     if($func.name == 'if',
                        | $func.parameters->head()->map(p | $p->maybeWrapAsBooleanOperation($sgc))->concatenate($func.parameters->tail()),
                        | $func.parameters
                     ));
        let config = $sgc.config;
        let generationState = $sgc.generationState;
        let newSgc = if($func.name->in(['and', 'or']), | $sgc, | ^$sgc(config = ^$config(callingFromFilter = [])));
        let paramWiseSgcs = if($result.toSql.parametersWithinWhenClause->isEmpty(),|range(0,$params->size(),1)->map(i|$newSgc),|$result.toSql.parametersWithinWhenClause->map(b|^$newSgc(generationState = ^$generationState(withinWhenClause=$b))));
        $result->toOne().toSql($params, $paramWiseSgcs);
   )));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processCase(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let params = $func.parameters;
   let size = ($params->size()-1)/2;
   let range = range(0, $size->floor()*2, 2);
   let sgcNoConfig = ^$sgc(config=^Config());
   let generationState = $sgc.generationState;
   let sgcWithinWhen = ^$sgcNoConfig(generationState=^$generationState(withinWhenClause = true));
   'case '+ $range->map(o| $sgc.format.separator + 'when '+$params->at($o)->processOperation($sgcWithinWhen)+ ' ' + $sgc.format.separator + 'then '+$params->at($o+1)->processOperation($sgcNoConfig))->makeString(' ')+ ' ' + $sgc.format.separator + 'else '+$params->at($params->size()-1)->processOperation($sgcNoConfig)+' end';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isEqualsFromFilter(func:DynaFunction[1], config: Config[1]):Boolean[1]
{
   $func.name == 'equal' && $config.callingFromFilter == true &&
      $func.parameters->forAll(p | $p->instanceOf(TableAliasColumn) && $p->cast(@TableAliasColumn).column.nullable != false);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isAndOr(func:DynaFunction[1]):Boolean[1]
{
   $func.name == 'and' || $func.name == 'or';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isNot(func:DynaFunction[1]):Boolean[1]
{
   $func.name == 'not';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processEqualFromFilter(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let params = $func.parameters->map(p | $p->processOperation($sgc));
   let left = $params->at(0);
   let right = $params->at(1);
   '(' + $left + ' = ' + $right + ' OR (' + $left + ' is null AND ' + $right + ' is null))';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processNot(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let parameter = $func.parameters->at(0);
   $parameter->match([
                       dynaFunction:DynaFunction[1] |  let functionName = $dynaFunction.name;
                                                       if($functionName == 'equal', | $dynaFunction->processNotEqual($sgc),
                                                                                    | if($functionName == 'in', | $dynaFunction->processNotIn($sgc),
                                                                                                                | if($dynaFunction->isAndOr() || $dynaFunction->isNot(), | 'not ('+$dynaFunction->processOperation($sgc) +')';,
                                                                                                                                                                         | 'not ' + $dynaFunction->maybeWrapAsBooleanOperation($sgc)->processOperation($sgc);
                                                                                                                     );
                                                                                         );
                                                          );,
                       rOp: RelationalOperationElement[1] | 'not ' + $rOp->maybeWrapAsBooleanOperation($sgc)->processOperation($sgc)
                    ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processNotEqual(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let processedParams = $func.parameters->map(p | $p->processOperation($sgc));
   let left = $func.parameters->at(0);
   let right = $func.parameters->at(1);
   let processedLeft = $processedParams->at(0);
   let processedRight = $processedParams->at(1);
   let orNull =   if($left->instanceOf(Literal) && $right->instanceOf(Literal),
                     | '',
                     | if(!$left->instanceOf(Literal) && $right->instanceOf(Literal),
                          |' OR ' + $processedLeft + ' is null',
                          |if ($left->instanceOf(Literal) && !$right->instanceOf(Literal),
                               |' OR ' + $processedRight + ' is null',
                               | ' OR ' + $processedLeft + ' is null' + ' AND ' + $processedRight + ' is not null' + ' OR ' + $processedLeft + ' is not null' + ' AND ' + $processedRight + ' is null'
                              )
                         )
                   );
   '(' + $processedLeft + ' <> ' + $processedRight + $orNull + ')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processNotIn(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let processedParams = $func.parameters->map(p | $p->processOperation($sgc));
   let processedLeft = $processedParams->at(0);
   let processedRight = $processedParams->at(1);
   '(' + $processedLeft + ' not in ' + if($processedRight->startsWith('(') && $processedRight->endsWith(')'), | $processedRight, | '(' + $processedRight + ')') + ' OR ' + $processedLeft + ' is null)';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSemiStructuredElementForSnowflake(s:RelationalOperationElement[1], sgc:SqlGenerationContext[1]): String[1]
{
   $s->match([
      o:SemiStructuredObjectNavigation[1] | $o->processSemiStructuredObjectNavigationForSnowflake($sgc),
      a:SemiStructuredArrayFlatten[1] | $a->processSemiStructuredArrayFlattenForSnowflake($sgc),
      a:SemiStructuredArrayFlattenOutput[1] | $a->processSemiStructuredArrayFlattenOutputForSnowflake($sgc)
   ])  
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSemiStructuredObjectNavigationForSnowflake(s:SemiStructuredObjectNavigation[1], sgc:SqlGenerationContext[1]): String[1]
{
   // https://docs.snowflake.com/en/user-guide/querying-semistructured.html

   let processedOperand = $s.operand->processOperation($sgc);

   let elementAccess = $processedOperand + $s->match([
      p: SemiStructuredPropertyAccess[1]     | '[\'' + $p.property->cast(@Literal).value->cast(@String) + '\']' + if($p.index->isEmpty(),|'',|'['+ $p.index->toOne()->cast(@Literal).value->toString()+']'),
      a: SemiStructuredArrayElementAccess[1] | '[' + $a.index->cast(@Literal).value->toString() + ']'
   ]);

   $elementAccess + castSuffixForSnowflakeSemiStructuredData($s.returnType);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSemiStructuredArrayFlattenForSnowflake(s:SemiStructuredArrayFlatten[1], sgc:SqlGenerationContext[1]): String[1]
{
   // https://docs.snowflake.com/en/sql-reference/functions/flatten.html

   let processedNavigation = $s.navigation->processOperation($sgc);
   'flatten(input => ' + $processedNavigation + ', outer => true, recursive => false, mode => \'array\')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSemiStructuredArrayFlattenOutputForSnowflake(s:SemiStructuredArrayFlattenOutput[1], sgc:SqlGenerationContext[1]): String[1]
{
   // https://docs.snowflake.com/en/sql-reference/functions/flatten.html

   let doubleQuote = if($sgc.config.useQuotesForTableAliasColumn == false, |'', |'"');
   let processedIdentifier = $sgc.dbConfig.identifierProcessor($doubleQuote + $s.tableAliasColumn.alias.name->toOne() + $doubleQuote);
   $processedIdentifier + '.' + processColumnName('value', $sgc.dbConfig) + castSuffixForSnowflakeSemiStructuredData($s.returnType);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::castSuffixForSnowflakeSemiStructuredData(type:Type[0..1]): String[1]
{
   if($type == String, | '::varchar', |
   if($type == StrictDate, | '::date', |
   if($type->isNotEmpty() && $type->toOne()->_subTypeOf(Date), | '::timestamp', |
   if($type->isNotEmpty() && $type->toOne()->instanceOf(Enumeration), | '::varchar', |
   ''))));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSemiStructuredElementForH2(s:RelationalOperationElement[1], sgc:SqlGenerationContext[1]): String[1]
{
   $s->match([
      o:SemiStructuredObjectNavigation[1] | $o->processSemiStructuredObjectNavigationForH2($sgc)
   ])  
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processSemiStructuredObjectNavigationForH2(s:SemiStructuredObjectNavigation[1], sgc:SqlGenerationContext[1]): String[1]
{
   // Use a user defined function for H2 (testing purpose)

   let processedOperand = $s.operand->processOperation($sgc);

   let udfName = 'legend_h2_extension_json_navigate';

   let elementAccess = $s->match([
      p: SemiStructuredPropertyAccess[1] |
         let propertyAccess = $udfName + '(' + $processedOperand + ', \'' + $p.property->cast(@Literal).value->cast(@String) + '\', null)';
         if ($p.index->isNotEmpty(),
             | $udfName + '(' + $propertyAccess + ', null, ' + $p.index->toOne()->cast(@Literal).value->toString() + ')',
             | $propertyAccess
         );,

      a: SemiStructuredArrayElementAccess[1] | $udfName + '(' + $processedOperand + ', null, ' + $a.index->cast(@Literal).value->toString() + ')'
   ]);

   if ($s.returnType == String, | 'cast(' + $elementAccess + ' as varchar)', |
   if ($s.returnType == Boolean, | 'cast(' + $elementAccess + ' as boolean)', |
   if ($s.returnType == Float, | 'cast(' + $elementAccess + ' as float)', |
   if ($s.returnType == Integer, | 'cast(' + $elementAccess + ' as integer)', |
   if ($s.returnType == StrictDate, | 'cast(' + $elementAccess + ' as date)', |
   if ($s.returnType->isNotEmpty() && $s.returnType->toOne()->_subTypeOf(Date), | 'cast(' + $elementAccess + ' as timestamp)', |
   if ($s.returnType->isNotEmpty() && $s.returnType->toOne()->instanceOf(Enumeration), | 'cast(' + $elementAccess + ' as varchar)', |
   $elementAccess)))))));
}

Class <<access.private>> meta::relational::functions::sqlQueryToString::DynaFunctionToSql
{
   funcName:String[1];
   stateMatch:GenerationState[*];
   toSql: ToSql[1];

   toSql(parameters:RelationalOperationElement[*], sgcs:SqlGenerationContext[*])
   {
      let processedParams = $parameters->zip($sgcs)->map(p | $p.first->processOperation($p.second));
      let params = if($this.toSql.transform->isEmpty(), | $processedParams, | $this.toSql.transform->toOne()->eval($processedParams));

      format($this.toSql.format, $params);
   }:String[1];
}

Class <<access.private>> meta::relational::functions::sqlQueryToString::ToSql
[
    !$this.format->contains(' when ') || !$this.parametersWithinWhenClause->isEmpty()
]
{
   format:String[1];
   transform:meta::pure::metamodel::function::Function<{String[*]->String[*]}>[0..1];
   parametersWithinWhenClause : Boolean[*];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::mapToDBUnitType(unit:String[1]):String[1]
{
   [
      pair(DurationUnit.YEARS->toString(), 'YEAR'),
      pair(DurationUnit.MONTHS->toString(), 'MONTH'),
      pair(DurationUnit.WEEKS->toString(), 'WEEK'),
      pair(DurationUnit.DAYS->toString(), 'DAY'),
      pair(DurationUnit.HOURS->toString(), 'HOUR'),
      pair(DurationUnit.MINUTES->toString(), 'MINUTE'),
      pair(DurationUnit.SECONDS->toString(), 'SECOND'),
      pair(DurationUnit.MILLISECONDS->toString(), 'MILLISECOND'),
      pair(DurationUnit.MICROSECONDS->toString(), 'MICROSECOND')
   ]->filter(p | $p.first == $unit).second->toOne();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::mapToDBDayOfWeekNumber(day:String[1]):Integer[1]
{
   [
      pair(DayOfWeek.Monday->toString(), 2),
      pair(DayOfWeek.Tuesday->toString(), 3),
      pair(DayOfWeek.Wednesday->toString(), 4),
      pair(DayOfWeek.Thursday->toString(), 5),
      pair(DayOfWeek.Friday->toString(), 6),
      pair(DayOfWeek.Saturday->toString(), 7),
      pair(DayOfWeek.Sunday->toString(), 1)
   ]->filter(p | $p.first == $day).second->toOne();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::mapToDBDayOfWeekNumberPresto(day:String[1]):Integer[1]
{
   [
      pair(DayOfWeek.Monday->toString(), 1),
      pair(DayOfWeek.Tuesday->toString(), 2),
      pair(DayOfWeek.Wednesday->toString(), 3),
      pair(DayOfWeek.Thursday->toString(), 4),
      pair(DayOfWeek.Friday->toString(), 5),
      pair(DayOfWeek.Saturday->toString(), 6),
      pair(DayOfWeek.Sunday->toString(), 7)
   ]->filter(p | $p.first == $day).second->toOne();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::dateDiffDatabricks(p:String[2..3]):String[1]
{
    let interval = if($p->size() == 2, |'DAY', |$p->at(2)->mapToDBUnitType());
    let cmd = if ($interval == 'YEAR',
        | 'year('+ $p->at(0) +') - year('+ $p->at(1) +')',
        | if ($interval == 'MONTH',
             | 'months_between('+ $p->at(0) +', '+ $p->at(1) +')',
             | if ($interval == 'DAY',
                  | 'datediff('+ $p->at(0) +', '+ $p->at(1) +')',
                  | ''
             )
        )
    );
    if ($cmd == '',|fail('The DurationUnit \''+$p->at(2)+'\' is not supported yet for date_diff'),|'');
    [$cmd];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::formatMostRecentMemSnowflake(p:String[1..2], defaultDay:String[1]):String[*]
{
   let day = $p->last()->toOne()->mapToDBDayOfWeekNumber()->toString();
   let current = if ($p->size() == 2, | $p->first()->toOne(), | $defaultDay);
   [$day, $current, $day, $current, $day, $current, $current];
}


function <<access.private>> meta::relational::functions::sqlQueryToString::formatMostRecentPresto(p:String[1..2], defaultDay:String[1]):String[*]
{
   let day = $p->last()->toOne()->mapToDBDayOfWeekNumberPresto()->toString();
   let current = if ($p->size() == 2, | $p->first()->toOne(), | $defaultDay);
   [$day, $current, $day, $current, $day, $current, $current];
}
function <<access.private>> meta::relational::functions::sqlQueryToString::formatMostRecentMemDb2(p:String[1..2], defaultDay:String[1]):String[*]
{
   let day = $p->last()->toOne()->mapToDBDayOfWeekNumber()->toString();
   let current = if ($p->size() == 2, | $p->first()->toOne(), | $defaultDay);
   [$current, $day, $current, $day, $current, $day, $current];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::formatMostRecentDatabricks(p:String[1..2], defaultDay:String[1]):String[*]
{
   let day = $p->last()->toOne()->mapToDBDayOfWeekNumber()->toString();
   let current = if ($p->size() == 2, | $p->first()->toOne(), | $defaultDay);
   [$current, $current, $day, $current, $day];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::formatMostRecentH2Sybase(p:String[1..2], defaultDay:String[1]):String[*]
{
   let day = $p->last()->toOne()->mapToDBDayOfWeekNumber()->toString();
   let current = if ($p->size() == 2, | $p->first()->toOne(), | $defaultDay);
   [$day, $current, $day, $current, $day, $current, $current];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isBooleanOperation(relationalElement:RelationalOperationElement[1], extensions:RouterExtension[*]):Boolean[1]
{
   $relationalElement->match($extensions.moduleExtension('relational')->cast(@RelationalExtension).sqlQueryToString_isBooleanOperation->concatenate([
      d:DynaFunction[1] | $d.name->in(['or', 'and', 'lessThan', 'lessThanEqual', 'greaterThan', 'greaterThanEqual', 'equal', 'notEqual', 'notEqualAnsi', 'startsWith', 'endsWith', 'contains', 'isEmpty', 'isNotEmpty', 'isNull', 'isNotNull','isAlphaNumeric', 'exists', 'not', 'in', 'isNumeric', 'matches', 'isDistinct'])
                                       || ($d.name == 'group' && $d.parameters->toOne()->isBooleanOperation($extensions));,
      f:FreeMarkerOperationHolder[1] | $f.name->in(['optionalVarPlaceHolderOpSelector']);,
      a:Any[1] | false
   ])->toOneMany()
   )
}
function <<access.private>> meta::relational::functions::sqlQueryToString::getTransformForAddPlus():LambdaFunction<{String[*]->String[*]}>[1]
{
   {p:String[*]|if($p->size() == 1, | 'sum(' + $p->toOne() + ')', | $p->joinStrings('(', ' + ', ')'))};
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForH2(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='dateadd(%s)', transform={p:String[3] | $p->at(2)->mapToDBUnitType() + ', ' + $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='concat%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('convertDate',            $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDateH2()})),
    dynaFnToSql('convertDateTime',        $allStates,            ^ToSql(format='%s' , transform={p:String[*] | $p->convertToDateTimeH2()})),
    dynaFnToSql('convertVarchar128',      $allStates,            ^ToSql(format='convert(%s, VARCHAR(128))')),
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='datediff(%s,%s,%s)', transform={p:String[*]|[$p->at(2)->processDateDiffDurationUnitForH2(),$p->at(0),$p->at(1)]})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='cast(truncate(%s) as date)')),
    dynaFnToSql('dayOfMonth',             $allStates,            ^ToSql(format='DAY_OF_MONTH(%s)')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='DAY_OF_WEEK(%s)')),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='dateadd(DAY, -(dayofmonth(%s) - 1), %s)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='dateadd(MONTH, 3 * quarter(%s) - 3, dateadd(DAY, -(dayofyear(%s) - 1), %s))', transform={p:String[1] | $p->repeat(3)})),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='dateadd(DAY, -(dayofmonth(current_date()) - 1), current_date())')),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='dateadd(MONTH, 3 * quarter(current_date) - 3, dateadd(DAY, -(dayofyear(current_date()) - 1), current_date()))')),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='dateadd(DAY, -(dayofyear(current_date()) - 1), current_date())')),
    dynaFnToSql('firstDayOfWeek',         $allStates,            ^ToSql(format='dateadd(DAY, -(mod(dayofweek(%s)+5, 7)), %s)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='dateadd(DAY, -(dayofyear(%s) - 1), %s)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='hour(%s)')),
    dynaFnToSql('indexOf',                $allStates,            ^ToSql(format='LOCATE(%s)', transform={p:String[2] | $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('isNumeric',              $allStates,            ^ToSql(format='(lower(%s) = upper(%s))')),
    dynaFnToSql('isAlphaNumeric',         $allStates,            ^ToSql(format=regexpPattern('%s'), transform={p:String[1]|$p->transformAlphaNumericParamsDefault()})),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='group_concat(%s separator %s)')),
    dynaFnToSql('left',                   $allStates,            ^ToSql(format='left(%s,%s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='char_length(%s)')),
    dynaFnToSql('ltrim',                  $allStates,            ^ToSql(format='ltrim(%s)')),
    dynaFnToSql('matches',                $allStates,            ^ToSql(format=regexpPattern('%s'), transform={p:String[2]|$p->transformRegexpParams()})),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('mostRecentDayOfWeek',    $allStates,            ^ToSql(format='dateadd(DAY, case when %s - DAY_OF_WEEK(%s) > 0 then %s - DAY_OF_WEEK(%s) - 7 else %s - DAY_OF_WEEK(%s) end, %s)', transform={p:String[1..2] | $p->formatMostRecentH2Sybase('current_date()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='current_timestamp()')),
    dynaFnToSql('parseDate',              $allStates,            ^ToSql(format='parsedatetime(%s,%s)')),
    dynaFnToSql('parseDecimal',           $allStates,            ^ToSql(format='cast(%s as decimal)')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='position(%s, %s)')),
    dynaFnToSql('previousDayOfWeek',      $allStates,            ^ToSql(format='dateadd(DAY, case when %s - DAY_OF_WEEK(%s) >= 0 then %s - DAY_OF_WEEK(%s) - 7 else %s - DAY_OF_WEEK(%s) end, %s)', transform={p:String[1..2] | $p->formatMostRecentH2Sybase('current_date()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('right',                  $allStates,            ^ToSql(format='right(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='current_date()')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar)')),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='week(%s)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='year(%s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForDB2(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='%s', transform=meta::relational::functions::sqlQueryToString::transformAdjustDB2SQL_String_3__String_1_)),
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='%s', transform={p:String[*]|$p->joinStrings('(',' concat ', ')')})),
    dynaFnToSql('convertDate',            $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDateDB2()})),
    dynaFnToSql('convertDateTime',        $allStates,            ^ToSql(format='%s' , transform={p:String[*] | $p->convertToDateTimeDB2()})),
    dynaFnToSql('convertVarchar128',      $allStates,            ^ToSql(format='cast(%s as VARCHAR(128))')),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='date(%s)')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='dayofweek_iso(%s)')),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='date(1) + (year(%s)-1) YEARS + (month(%s)-1) MONTHS', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='date(1) + ((year(%s)-1) YEARS) + (3 * QUARTER(%s) - 3) MONTHS', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='date(1) + (year(current date)-1) YEARS + (month(current date)-1) MONTHS')),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='date(1) + ((year(current date)-1) YEARS) + (3 * QUARTER(current date) - 3) MONTHS')),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='date(1) + (year(current date)-1) YEARS')),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='date(1) + (year(%s)-1) YEARS')),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='hour(%s)')),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='listagg(%s,%s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='CHARACTER_LENGTH(%s,CODEUNITS32)')),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('mostRecentDayOfWeek',    $allStates,            ^ToSql(format='%s + case when %s - dayofweek(%s) > 0 then %s - dayofweek(%s) - 7 else %s - dayofweek(%s) end DAY', transform={p:String[1..2] | $p->formatMostRecentMemDb2('current date')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='current timestamp')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='position(%s, %s)')),
    dynaFnToSql('previousDayOfWeek',      $allStates,            ^ToSql(format='%s + case when %s - dayofweek(%s) >= 0 then %s - dayofweek(%s) - 7 else %s - dayofweek(%s) end DAY', transform={p:String[1..2] | $p->formatMostRecentMemDb2('current date')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substr%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='current date')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar(16000))')),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='week_iso(%s)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='year(%s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForSqlServer(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atn2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='%s', transform={p:String[*]|$p->joinStrings(' + ')})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='cast(%s as date)')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='datepart(dw, %s)')),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='dateadd(day, -(day(cast(%s as date)) - 1), cast(%s as date))', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='dateadd(qq, datediff(qq, 0, %s), 0)')),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='dateadd(day, -(day(cast(getdate() as date)) - 1), cast(getdate() as date))')),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='dateadd(qq, datediff(qq, 0, getdate()), 0)')),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='dateadd(yy, datediff(yy, 0, getdate()), 0)')),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='dateadd(yy, datediff(yy, 0, %s), 0)')),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='hour(%s)')),
    dynaFnToSql('left',                   $allStates,            ^ToSql(format='left(%s,%s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='len(%s)')),
    dynaFnToSql('ltrim',                  $allStates,            ^ToSql(format='ltrim(%s)')),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='getdate()')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='charindex(%s, %s)')),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('right',                  $allStates,            ^ToSql(format='right(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, 0)')),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stdevp(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stdev(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='cast(getdate() as date)')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar)')),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='datepart(wk, %s)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='year(wk, %s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForRedshift(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='%s', transform={p:String[*]|$p->joinStrings(' + ')})),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='date_part(hour, %s)')),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='listagg(%s, %s)')),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='extract(minute from %s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='extract(month from %s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='extract(month from %s)')),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='now()')),
    dynaFnToSql('parseDecimal',           $allStates,            ^ToSql(format='cast(%s as decimal)')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='position(%s in %s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('right',                  $allStates,            ^ToSql(format='right(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='extract( second from %s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='current_date')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar)')),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='extract(week from %s)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='extract(year from %s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForSnowflake(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='dateadd(%s)', transform={p:String[3] | $p->at(2)->mapToDBUnitType() + ', ' + $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='concat%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('convertDate',            $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDateSnowflake()})),
    dynaFnToSql('convertDateTime',        $allStates,            ^ToSql(format='%s' , transform={p:String[*] | $p->convertToDateTimeSnowflake()})),
    dynaFnToSql('convertVarchar128',      $allStates,            ^ToSql(format='to_char(%s)')),
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='datediff(%s,%s,%s)', transform={p:String[*]|[$p->at(2)->processDateDiffDurationUnitForSnowflake(),$p->at(0),$p->at(1)]})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='Date(%s)')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='DAYOFWEEKISO(%s)')),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='DATE_TRUNC(\'MONTH\', %s)')),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='DATE_TRUNC(\'QUARTER\', %s)')),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='DATE_TRUNC(\'MONTH\', CURRENT_DATE)%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='DATE_TRUNC(\'QUARTER\', CURRENT_DATE)%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='DATE_TRUNC(\'YEAR\', CURRENT_DATE)%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfWeek',         $allStates,            ^ToSql(format='DATE_TRUNC(\'WEEK\', %s)')),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='DATE_TRUNC(\'YEAR\', %s)')),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='date_part(\'hour\', %s)')),
    dynaFnToSql('indexOf',                $allStates,            ^ToSql(format='CHARINDEX(%s)', transform={p:String[2] | $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('isAlphaNumeric',         $allStates,            ^ToSql(format=regexpPattern('%s'), transform={p:String[1]|$p->transformAlphaNumericParamsDefault()})),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='listagg(%s, %s)')),
    dynaFnToSql('left',                   $allStates,            ^ToSql(format='left(%s,%s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='length(%s)')),
    dynaFnToSql('ltrim',                  $allStates,            ^ToSql(format='ltrim(%s)')),
    dynaFnToSql('matches',                $allStates,            ^ToSql(format=regexpPattern('%s'), transform={p:String[2]|$p->transformRegexpParams()})),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='MONTH(%s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='MONTH(%s)')),
    dynaFnToSql('mostRecentDayOfWeek',    $allStates,            ^ToSql(format='DATE_TRUNC(\'WEEK\', CURRENT_DATE)%s', transform={p:String[*] | ''})),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='current_timestamp')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('parseJson',              $allStates,            ^ToSql(format='parse_json(%s)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='position(%s in %s)')),
    dynaFnToSql('previousDayOfWeek',      $allStates,            ^ToSql(format='dateadd(DAY, case when %s - DAYOFWEEK(%s) +1  >= 0 then %s  - DAYOFWEEK(%s) -1 - 7 else %s - DAYOFWEEK(%s) -1 end, %s)', transform={p:String[1..2] | $p->formatMostRecentMemSnowflake('current_date')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('right',                  $allStates,            ^ToSql(format='right(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round((%s)::numeric, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='current_date')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar)')),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='WEEKOFYEAR(%s)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='year(%s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForPresto(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='date_add(%s)', transform={p:String[3] | '\'' + $p->at(2)->mapToDBUnitType() + '\', ' + $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='concat%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('convertDate',            $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDatePresto()})),
    dynaFnToSql('convertDateTime',        $allStates,            ^ToSql(format='%s' , transform={p:String[*] | $p->convertToDateTimePresto()})),
    dynaFnToSql('convertVarchar128',      $allStates,            ^ToSql(format='cast(%s as VARCHAR(128))')),
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='date_diff(%s,%s,%s)', transform={p:String[*]|[$p->at(2)->processDateDiffDurationUnitForPresto(),$p->at(0),$p->at(1)]})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='Date(%s)')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='day_of_week(%s)')),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='date_trunc(\'month\', %s)')),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='date_trunc(\'quarter\', %s)')),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='date_trunc(\'month\', current_date)%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='date_trunc(\'quarter\', current_date)%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='date_trunc(\'year\', current_date)%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfWeek',         $allStates,            ^ToSql(format='date_trunc(\'week\', %s)')),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='date_trunc(\'year\', %s)')),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='hour(%s)')),
    dynaFnToSql('indexOf',                $allStates,            ^ToSql(format='strpos(%s)', transform={p:String[2] | $p->at(0) + ', ' + $p->at(1)})),
    dynaFnToSql('left',                   $allStates,            ^ToSql(format='substr(%s,1,%s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='length(%s)')),
    dynaFnToSql('ltrim',                  $allStates,            ^ToSql(format='ltrim(%s)')),
    dynaFnToSql('matches',                $allStates,            ^ToSql(format=regexpLikePattern('%s','%s'), transform={p:String[2]|$p->transformRegexpParams()})),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('mostRecentDayOfWeek',    $allStates,            ^ToSql(format='date_add(\'day\', case when %s - day_of_week(%s) > 0 then %s - day_of_week(%s) - 7 else %s - day_of_week(%s) end, %s)', transform={p:String[1..2] | $p->formatMostRecentPresto('current_date')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='current_timestamp')),
    dynaFnToSql('parseDate',              $allStates,            ^ToSql(format='date_parse(%s,%s)')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as double)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='position(%s in %s)')),
    dynaFnToSql('previousDayOfWeek',      $allStates,            ^ToSql(format='date_add(\'day\', case when %s - day_of_week(%s) >= 0 then %s - day_of_week(%s) - 7 else %s - day_of_week(%s) end, %s)', transform={p:String[1..2] | $p->formatMostRecentPresto('current_date')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('right',                  $allStates,            ^ToSql(format='substr(%s,-1,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='current_date')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar)')),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='week(%s)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='year(%s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForMemSQL(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='adddate(%s)', transform={p:String[3] | $p->at(0) + ', INTERVAL ' + $p->at(1) + ' ' + $p->at(2)->mapToDBUnitType()})),
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='concat%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('convertDate',            $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDateMemSQL()})),
    dynaFnToSql('convertVarchar128',      $allStates,            ^ToSql(format='convert(%s, CHAR)')),
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='%s', transform={p:String[*]|generateDateDiffExpressionForMemSQL ([$p->at(1),$p->at(0), $p->at(2)])})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='date(%s)')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='dayofweek(%s)')),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='subdate(%s, INTERVAL dayofmonth(%s) - 1 DAY) ', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='adddate(subdate(%s, INTERVAL dayofyear(%s) - 1 DAY), INTERVAL (quarter(date(%s) -1)) QUARTER)', transform={p:String[1] | $p->repeat(3)})),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='subdate(curdate(), INTERVAL dayofmonth(current_date()) - 1 DAY) ')),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='adddate(subdate(curdate(), INTERVAL dayofyear(current_date()) - 1 DAY), INTERVAL (quarter(curdate()) -1) QUARTER)')),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='subdate(curdate(), INTERVAL dayofyear(current_date()) - 1 DAY)')),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='subdate(%s, INTERVAL dayofyear(%s) - 1 DAY)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='hour(%s)')),
    dynaFnToSql('indexOf',                $allStates,            ^ToSql(format='LOCATE(%s)', transform={p:String[2] | $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='group_concat(%s separator %s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='char_length(%s)')),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('mostRecentDayOfWeek',    $allStates,            ^ToSql(format='adddate(%s, INTERVAL case when %s - dayofweek(%s) > 0 then %s - dayofweek(%s) - 7 else %s - dayofweek(%s) end DAY)', transform={p:String[1..2] | $p->formatMostRecentMemDb2('curdate()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='now()')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as decimal)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as signed integer)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='LOCATE(%s, %s)')),
    dynaFnToSql('previousDayOfWeek',      $allStates,            ^ToSql(format='adddate(%s, INTERVAL case when %s - dayofweek(%s) >= 0 then %s - dayofweek(%s) - 7 else %s - dayofweek(%s) end DAY)', transform={p:String[1..2] | $p->formatMostRecentMemDb2('curdate()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='curdate()')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as char)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='year(%s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForBigQuery(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='date_add(%s)', transform={p:String[3] | $p->at(0) + ', INTERVAL ' + $p->at(1) + ' ' + $p->at(2)->mapToDBUnitType()})),
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='concat%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='extract(hour from %s)')),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='string_agg(%s, %s)')),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='extract(minute from %s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='extract(month from %s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='extract(month from %s)')),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='current_timestamp()')),
    dynaFnToSql('parseDecimal',           $allStates,            ^ToSql(format='cast(%s as decimal)')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float64)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as int64)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='strpos(%s, %s)')),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='extract( quarter from %s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='extract( quarter from %s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('right',                  $allStates,            ^ToSql(format='right(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, 0)')),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='extract( second from %s)')),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='CURRENT_DATE()')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as string)')),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='extract(week from %s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForDatabricks(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='%s', transform={p:String[3] | $p->at(0) + ' + INTERVAL ' + $p->at(1) + ' ' + $p->at(2)->mapToDBUnitType()})),
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='concat%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('convertDate',            $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDateDatabricks()})),
    dynaFnToSql('convertDateTime',        $allStates,            ^ToSql(format='%s' , transform={p:String[*] | $p->convertToDateTimeDatabricks()})),
    dynaFnToSql('convertVarchar128',      $allStates,            ^ToSql(format='case(%s as STRING)')),
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='%s' , transform={p:String[2..3] | $p->dateDiffDatabricks()})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='to_date(%s)')),
    dynaFnToSql('dayOfMonth',             $allStates,            ^ToSql(format='dayofmonth(%s)')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='dayofweek(%s)')),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='trunc(%s, \'MONTH\')')),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='trunc(%s, \'QUARTER\')')),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='trunc(current_date(), \'MONTH\')%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='trunc(CURRENT_DATE, \'QUARTER\')%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='trunc(CURRENT_DATE, \'YEAR\')%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfWeek',         $allStates,            ^ToSql(format='trunc(%s, \'WEEK\')')),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='trunc(%s, \'YEAR\')')),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='hour(%s)')),
    dynaFnToSql('indexOf',                $allStates,            ^ToSql(format='locate(%s)', transform={p:String[2] | $p->at(0) + ', ' + $p->at(1)})),
    dynaFnToSql('isNumeric',              $allStates,            ^ToSql(format='(lower(%s) = upper(%s))')),
    dynaFnToSql('isAlphaNumeric',         $allStates,            ^ToSql(format='rlike(%s)', transform={p:String[1]|$p->transformAlphaNumericParamsDefault()})),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='array_join(%s, %s)')),
    dynaFnToSql('left',                   $allStates,            ^ToSql(format='left(%s,%s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='length(%s)')),
    dynaFnToSql('ltrim',                  $allStates,            ^ToSql(format='ltrim(%s)')),
    dynaFnToSql('matches',                $allStates,            ^ToSql(format='rlike(%s)', transform={p:String[2]|$p->transformRegexpParams()})),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('mostRecentDayOfWeek',    $allStates,            ^ToSql(format='date_sub(%s, case when dayofweek(%s) = %s then 0 else dayofweek(%s) - %s end)', transform={p:String[1..2] | $p->formatMostRecentDatabricks('current_date()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='current_timestamp')),
    dynaFnToSql('parseDate',              $allStates,            ^ToSql(format='to_date(%s,%s)')),
    dynaFnToSql('parseDecimal',           $allStates,            ^ToSql(format='cast(%s as double)')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as int)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='array_position(%s, %s)')),
    dynaFnToSql('previousDayOfWeek',      $allStates,            ^ToSql(format='date_sub(%s, case when dayofweek(%s) = %s then 7 else dayofweek(%s) - %s end)', transform={p:String[1..2] | $p->formatMostRecentDatabricks('current_date()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('right',                  $allStates,            ^ToSql(format='right(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='current_date')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as string)')),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='WEEKOFYEAR(%s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForPostgres(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='(%s + (INTERVAL \'1 %s\' * %s))', transform={p:String[3] | [$p->at(0), $p->at(2)->replace('Text', ''), $p->at(1)]})), //https://www.postgresql.org/message-id/2B704E31-B533-4159-B6F0-EC284CFE824C%40skype.net,
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='%s', transform={p:String[*]|generateDateDiffExpressionForPostgres($p)})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='Date(%s)')),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='date_part(\'hour\', %s)')),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='string_agg(%s, %s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='char_length(%s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='now()')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='position(%s in %s)')),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round((%s)::numeric, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='current_date')),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForComposite(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='hour(%s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='char_length(%s)')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='position(%s, %s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')}))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForSybaseASE(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='datediff(%s,%s,%s)', transform={p:String[*]|[$p->at(2)->processDateDiffDurationUnitForSybase(),$p->at(0),$p->at(1)]})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='cast(%s as date)')),
    dynaFnToSql('isAlphaNumeric',         $allStates,            ^ToSql(format=likePatternWithoutEscape('%%%s%%'), transform={p:String[1]|$p->transformAlphaNumericParamsDefault()})),
    dynaFnToSql('trim',                   $allStates,            ^ToSql(format='rtrim(ltrim(%s))'))
  ]->concatenate(getDynaFunctionToSqlCommonToBothSybases());
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlForSybaseIQ(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('contains',               $allStates,            ^ToSql(format=likePattern('%%%s%%'), transform={p:String[2]|$p->transformLikeParamsForSybaseIQ()})),
    dynaFnToSql('dateDiff',               $allStates,            ^ToSql(format='datediff(%s,%s,%s)', transform={p:String[*]|[$p->at(2)->processDateDiffDurationUnitForSybaseIQ(),$p->at(0),$p->at(1)]})),
    dynaFnToSql('datePart',               $allStates,            ^ToSql(format='date(%s)')),
    dynaFnToSql('endsWith',               $allStates,            ^ToSql(format=likePattern('%%%s'), transform={p:String[2]|$p->transformLikeParamsForSybaseIQ()})),
    dynaFnToSql('isAlphaNumeric',         $allStates,            ^ToSql(format=likePatternWithoutEscape('%%%s%%'), transform={p:String[1]|$p->transformAlphaNumericParamsForSybaseIQ()})),
    dynaFnToSql('startsWith',             $allStates,            ^ToSql(format=likePattern('%s%%'), transform={p:String[2]|$p->transformLikeParamsForSybaseIQ()}))
  ]->concatenate(getDynaFunctionToSqlCommonToBothSybases());
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlCommonToBothSybases(): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();
  let selectOutsideWhen = selectOutsideWhenGenerationState();
  let notSelectOutsideWhen = notSelectOutsideWhenGenerationStates();

  [
    dynaFnToSql('adjust',                 $allStates,            ^ToSql(format='dateadd(%s)', transform={p:String[3] | $p->at(2)->mapToDBUnitType() + ', ' + $p->at(1) + ', ' + $p->at(0)})),
    dynaFnToSql('atan2',                  $allStates,            ^ToSql(format='atan2(%s,%s)')),
    dynaFnToSql('concat',                 $allStates,            ^ToSql(format='%s', transform={p:String[*]|$p->joinStrings(' + ')})),
    dynaFnToSql('convertDate',            $allStates,            ^ToSql(format='%s', transform={p:String[*] | $p->convertToDateIQ()})),
    dynaFnToSql('convertDateTime',        $allStates,            ^ToSql(format='%s' , transform={p:String[*] | $p->convertToDateTimeIQ()})),
    dynaFnToSql('convertVarchar128',      $allStates,            ^ToSql(format='convert(VARCHAR(128), %s)')),
    dynaFnToSql('dayOfWeekNumber',        $allStates,            ^ToSql(format='datepart(WEEKDAY,%s)')),
    dynaFnToSql('firstDayOfMonth',        $allStates,            ^ToSql(format='dateadd(DAY, -(day(%s) - 1), %s)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfQuarter',      $allStates,            ^ToSql(format='dateadd(QUARTER, quarter(%s) - 1, dateadd(DAY, -(datepart(dayofyear, %s) - 1), %s))', transform={p:String[1] | $p->repeat(3)})),
    dynaFnToSql('firstDayOfThisMonth',    $allStates,            ^ToSql(format='dateadd(DAY, -(day(today()) - 1), today())%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisQuarter',  $allStates,            ^ToSql(format='dateadd(QUARTER, quarter(today()) - 1, dateadd(DAY, -(datepart(dayofyear, today()) - 1), today()))%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfThisYear',     $allStates,            ^ToSql(format='dateadd(DAY, -(datepart(dayofyear, today()) - 1), today())%s', transform={p:String[*] | ''})),
    dynaFnToSql('firstDayOfWeek',         $allStates,            ^ToSql(format='dateadd(DAY, -(mod(datepart(weekday, %s)+5, 7)), %s)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('firstDayOfYear',         $allStates,            ^ToSql(format='dateadd(DAY, -(datepart(dayofyear, %s) - 1), %s)', transform={p:String[1] | $p->repeat(2)})),
    dynaFnToSql('hour',                   $allStates,            ^ToSql(format='hour(%s)')),
    dynaFnToSql('indexOf',                $allStates,            ^ToSql(format='LOCATE(%s)', transform={p:String[2] | $p->at(0) + ', ' + $p->at(1)})),
    dynaFnToSql('isEmpty',                $selectOutsideWhen,    ^ToSql(format='case when (%s is null) then \'true\' else \'false\' end', parametersWithinWhenClause=true)),
    dynaFnToSql('isEmpty',                $notSelectOutsideWhen, ^ToSql(format='%s is null')),
    dynaFnToSql('isNotEmpty',             $selectOutsideWhen,    ^ToSql(format='case when (%s is not null) then \'true\' else \'false\' end', parametersWithinWhenClause=true)),
    dynaFnToSql('isNotEmpty',             $notSelectOutsideWhen, ^ToSql(format='%s is not null')),
    dynaFnToSql('isNotNull',              $selectOutsideWhen,    ^ToSql(format='case when (%s is not null) then \'true\' else \'false\' end', parametersWithinWhenClause=true)),
    dynaFnToSql('isNotNull',              $notSelectOutsideWhen, ^ToSql(format='%s is not null')),
    dynaFnToSql('isNull',                 $selectOutsideWhen,    ^ToSql(format='case when (%s is null) then \'true\' else \'false\' end', parametersWithinWhenClause=true)),
    dynaFnToSql('isNull',                 $notSelectOutsideWhen, ^ToSql(format='%s is null')),
    dynaFnToSql('isNumeric',              $allStates,            ^ToSql(format='isnumeric(%s)')),
    dynaFnToSql('joinStrings',            $allStates,            ^ToSql(format='list(%s,%s)')),
    dynaFnToSql('left',                   $allStates,            ^ToSql(format='left(%s,%s)')),
    dynaFnToSql('length',                 $allStates,            ^ToSql(format='char_length(%s)')),
    dynaFnToSql('ltrim',                  $allStates,            ^ToSql(format='ltrim(%s)')),
    dynaFnToSql('matches',                $allStates,            ^ToSql(format=regexpPattern('%s'), transform={p:String[2]|$p->transformRegexpParams()})),
    dynaFnToSql('minute',                 $allStates,            ^ToSql(format='minute(%s)')),
    dynaFnToSql('mod',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('month',                  $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('monthNumber',            $allStates,            ^ToSql(format='month(%s)')),
    dynaFnToSql('mostRecentDayOfWeek',    $allStates,            ^ToSql(format='dateadd(Day, case when %s - dow(%s) > 0 then %s - dow(%s) - 7 else %s - dow(%s) end, %s)', transform={p:String[1..2] | $p->formatMostRecentH2Sybase('today()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('now',                    $allStates,            ^ToSql(format='now(%s)', transform={p:String[*] | ''})),
    dynaFnToSql('parseDate',              $allStates,            ^ToSql(format='%s', transform={p:String[*] | if( $p->size()==1,|'cast('+$p->at(0)+' as timestamp)' ,|'convert( datetime,'+ $p->at(0)+','+$p->at(1)+')' )})),
    dynaFnToSql('parseDecimal',           $allStates,            ^ToSql(format='cast(%s as decimal)')),
    dynaFnToSql('parseFloat',             $allStates,            ^ToSql(format='cast(%s as float)')),
    dynaFnToSql('parseInteger',           $allStates,            ^ToSql(format='cast(%s as integer)')),
    dynaFnToSql('position',               $allStates,            ^ToSql(format='charindex(%s, %s)')),
    dynaFnToSql('previousDayOfWeek',      $allStates,            ^ToSql(format='dateadd(DAY, case when %s - dow(%s) >= 0 then %s - dow(%s) - 7 else %s - dow(%s) end, %s)', transform={p:String[1..2] | $p->formatMostRecentH2Sybase('today()')}, parametersWithinWhenClause = [false, false])),
    dynaFnToSql('quarter',                $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('quarterNumber',          $allStates,            ^ToSql(format='quarter(%s)')),
    dynaFnToSql('rem',                    $allStates,            ^ToSql(format='mod(%s,%s)')),
    dynaFnToSql('right',                  $allStates,            ^ToSql(format='right(%s,%s)')),
    dynaFnToSql('round',                  $allStates,            ^ToSql(format='round(%s, %s)', transform=transformRound_String_MANY__String_MANY_)),
    dynaFnToSql('rtrim',                  $allStates,            ^ToSql(format='rtrim(%s)')),
    dynaFnToSql('second',                 $allStates,            ^ToSql(format='second(%s)')),
    dynaFnToSql('substring',              $allStates,            ^ToSql(format='substring%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('stdDevPopulation',       $allStates,            ^ToSql(format='stddev_pop(%s)')),
    dynaFnToSql('stdDevSample',           $allStates,            ^ToSql(format='stddev_samp(%s)')),
    dynaFnToSql('today',                  $allStates,            ^ToSql(format='today(%s)', transform={p:String[*] | ''})),
    dynaFnToSql('toString',               $allStates,            ^ToSql(format='cast(%s as varchar)')),
    dynaFnToSql('weekOfYear',             $allStates,            ^ToSql(format='datepart(WEEK,%s)')),
    dynaFnToSql('year',                   $allStates,            ^ToSql(format='year(%s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionToSqlDefault(literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1]): DynaFunctionToSql[*]
{
  let allStates = allGenerationStates();

  [
    dynaFnToSql('abs',                    $allStates,            ^ToSql(format='abs(%s)')),
    dynaFnToSql('acos',                   $allStates,            ^ToSql(format='acos(%s)')),
    dynaFnToSql('add',                    $allStates,            ^ToSql(format='%s',  transform=getTransformForAddPlus())),
    dynaFnToSql('and',                    $allStates,            ^ToSql(format='%s', transform={p:String[*]|$p->makeString(' and ')})),
    dynaFnToSql('asin',                   $allStates,            ^ToSql(format='asin(%s)')),
    dynaFnToSql('atan',                   $allStates,            ^ToSql(format='atan(%s)')),
    dynaFnToSql('average',                $allStates,            ^ToSql(format='avg(1.0 * %s)')),
    dynaFnToSql('averageRank',            $allStates,            ^ToSql(format='average_rank()')),
    dynaFnToSql('ceiling',                $allStates,            ^ToSql(format='ceiling(%s)')),
    dynaFnToSql('coalesce',               $allStates,            ^ToSql(format='coalesce%s', transform={p:String[*]|$p->joinStrings('(', ', ', ')')})),
    dynaFnToSql('contains',               $allStates,            ^ToSql(format=likePattern('%%%s%%'), transform={p:String[2]|$p->transformLikeParamsDefault()})),
    dynaFnToSql('cos',                    $allStates,            ^ToSql(format='cos(%s)')),
    dynaFnToSql('count',                  $allStates,            ^ToSql(format='count(%s)', transform={p:String[*]|if($p->isEmpty(),|'*',|$p)})),
    dynaFnToSql('denseRank',              $allStates,            ^ToSql(format='dense_rank()')),
    dynaFnToSql('distinct',               $allStates,            ^ToSql(format='distinct(%s)', transform={p:String[*]|if($p->isEmpty(),|'*',|$p)})),
    dynaFnToSql('divide',                 $allStates,            ^ToSql(format='((1.0 * %s) / %s)')),
    dynaFnToSql('equal',                  $allStates,            ^ToSql(format='%s = %s')),
    dynaFnToSql('endsWith',               $allStates,            ^ToSql(format=likePattern('%%%s'), transform={p:String[2]|$p->transformLikeParamsDefault()})),
    dynaFnToSql('exists',                 $allStates,            ^ToSql(format='exists(%s)')),
    dynaFnToSql('exp',                    $allStates,            ^ToSql(format='exp(%s)')),
    dynaFnToSql('floor',                  $allStates,            ^ToSql(format='floor(%s)')),
    dynaFnToSql('greaterThan',            $allStates,            ^ToSql(format='%s > %s')),
    dynaFnToSql('greaterThanEqual',       $allStates,            ^ToSql(format='%s >= %s')),
    dynaFnToSql('group',                  $allStates,            ^ToSql(format='(%s)')),
    dynaFnToSql('if',                     $allStates,            ^ToSql(format='case when %s then %s else %s end', parametersWithinWhenClause = [true, false, false])),
    dynaFnToSql('in',                     $allStates,            ^ToSql(format='%s in %s', transform={p:String[2] | if($p->at(1)->startsWith('(') && $p->at(1)->endsWith(')'), | $p, | [$p->at(0), ('(' + $p->at(1) + ')')])})),
    dynaFnToSql('objectReferenceIn',      $allStates,            ^ToSql(format='%s objectReferenceIn %s', transform={p:String[*] | if($p->at(1)->startsWith('(') && $p->at(1)->endsWith(')'), | [$p->at(0), $p->at(1)], | [$p->at(0), ('(' + $p->at(1) + ')')])})),
    dynaFnToSql('isDistinct',             $allStates,            ^ToSql(format='count(distinct(%s)) = count(%s)', transform={p:String[*]|assert($p->isNotEmpty(), |'"isDistinct" aggregation can be applied on primitive values only'); $p->concatenate($p);})),
    dynaFnToSql('isEmpty',                $allStates,            ^ToSql(format='%s is null')),
    dynaFnToSql('isNotEmpty',             $allStates,            ^ToSql(format='%s is not null')),
    dynaFnToSql('isNotNull',              $allStates,            ^ToSql(format='%s is not null')),
    dynaFnToSql('isNull',                 $allStates,            ^ToSql(format='%s is null')),
    dynaFnToSql('lessThan',               $allStates,            ^ToSql(format='%s < %s')),
    dynaFnToSql('lessThanEqual',          $allStates,            ^ToSql(format='%s <= %s')),
    dynaFnToSql('log',                    $allStates,            ^ToSql(format='ln(%s)')),
    dynaFnToSql('max',                    $allStates,            ^ToSql(format='max(%s)')),
    dynaFnToSql('min',                    $allStates,            ^ToSql(format='min(%s)')),
    dynaFnToSql('minus',                  $allStates,            ^ToSql(format='%s', transform={p:String[*]|if($p->size() == 1, | '-' + $p->toOne(), | $p->joinStrings('(', ' - ', ')'))})),
    dynaFnToSql('notEqual',               $allStates,            ^ToSql(format='%s != %s')),
    dynaFnToSql('notEqualAnsi',           $allStates,            ^ToSql(format='%s <> %s')),
    dynaFnToSql('or',                     $allStates,            ^ToSql(format='%s', transform={p:String[*]|$p->makeString(' or ')})),
    dynaFnToSql('plus',                   $allStates,            ^ToSql(format='%s', transform=getTransformForAddPlus())),
    dynaFnToSql('pow',                    $allStates,            ^ToSql(format='power(%s, %s)')),
    dynaFnToSql('percentile',             $allStates,            ^ToSql(format='%s', transform = {p:String[*] | $p->transformPercentile($literalProcessor)})),
    dynaFnToSql('rank',                   $allStates,            ^ToSql(format='rank()')),
    dynaFnToSql('replace',                $allStates,            ^ToSql(format='replace(%s, %s, %s)')),
    dynaFnToSql('rowNumber',              $allStates,            ^ToSql(format='row_number()')),
    dynaFnToSql('sin',                    $allStates,            ^ToSql(format='sin(%s)')),
    dynaFnToSql('size',                   $allStates,            ^ToSql(format='count(%s)', transform={p:String[*]|if($p->isEmpty(),|'*',|$p)})),
    dynaFnToSql('sqlFalse',               $allStates,            ^ToSql(format='%s', transform={p:String[*]|processLiteralValue(false, $literalProcessor)})),
    dynaFnToSql('sqlNull',                $allStates,            ^ToSql(format='null')),
    dynaFnToSql('sqlTrue',                $allStates,            ^ToSql(format='%s', transform={p:String[*]|processLiteralValue(true, $literalProcessor)})),
    dynaFnToSql('sqrt',                   $allStates,            ^ToSql(format='sqrt(%s)')),
    dynaFnToSql('startsWith',             $allStates,            ^ToSql(format=likePattern('%s%%'), transform={p:String[2]|$p->transformLikeParamsDefault()})),
    dynaFnToSql('sub',                    $allStates,            ^ToSql(format='%s-%s')),
    dynaFnToSql('sum',                    $allStates,            ^ToSql(format='sum(%s)')),
    dynaFnToSql('tan',                    $allStates,            ^ToSql(format='tan(%s)')),
    dynaFnToSql('times',                  $allStates,            ^ToSql(format='%s', transform={p:String[*]|if($p->size() == 1, | $p->toOne() , | $p->joinStrings('(', ' * ', ')'))})),
    dynaFnToSql('toLower',                $allStates,            ^ToSql(format='lower(%s)')),
    dynaFnToSql('toOne',                  $allStates,            ^ToSql(format='%s')),
    dynaFnToSql('toUpper',                $allStates,            ^ToSql(format='upper(%s)')),
    dynaFnToSql('trim',                   $allStates,            ^ToSql(format='trim(%s)'))
  ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getFreeMarkerOperationMap():Map<String, ToSql>[1]
{
   let freeMarkerOpMap = [
      pair('variableCollectionSize', ^ToSql(format='collectionSize(%s)')),
      pair('optionalVarPlaceHolderOpSelector', ^ToSql(format='optionalVarPlaceHolderOperationSelector(%s, %s, %s)'))
   ]->newMap();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::allGenerationStates(): GenerationState[*]
{
  let selectInsideWhen  = ^GenerationState(generationSide=GenerationSide.Select, withinWhenClause=true);
  let selectOutsideWhen = ^GenerationState(generationSide=GenerationSide.Select, withinWhenClause=false);
  let whereInsideWhen   = ^GenerationState(generationSide=GenerationSide.Where,  withinWhenClause=true);
  let whereOutsideWhen  = ^GenerationState(generationSide=GenerationSide.Where,  withinWhenClause=false);
  [$selectInsideWhen, $selectOutsideWhen, $whereInsideWhen, $whereOutsideWhen];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::selectOutsideWhenGenerationState(): GenerationState[1]
{
  ^GenerationState(generationSide=GenerationSide.Select, withinWhenClause=false);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::notSelectOutsideWhenGenerationStates(): GenerationState[*]
{
  let selectInsideWhen  = ^GenerationState(generationSide=GenerationSide.Select, withinWhenClause=true);
  let whereInsideWhen   = ^GenerationState(generationSide=GenerationSide.Where,  withinWhenClause=true);
  let whereOutsideWhen  = ^GenerationState(generationSide=GenerationSide.Where,  withinWhenClause=false);
  [$selectInsideWhen, $whereInsideWhen, $whereOutsideWhen];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::dynaFnToSql(dynafunctionName: String[1], generationStates:GenerationState[*], toSql:ToSql[1]): DynaFunctionToSql[1]
{
   ^DynaFunctionToSql(funcName=$dynafunctionName, stateMatch=$generationStates, toSql=$toSql);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getDynaFunctionDispatcher(dispatch: Map<String, List<DynaFunctionToSql>>[1]): meta::pure::metamodel::function::Function<{DynaFunction[1], SqlGenerationContext[1]->DynaFunctionToSql[1]}>[1]
{
   { func:DynaFunction[1], sgc:SqlGenerationContext[1] |
        let result = $dispatch->get($func.name)->cast(@List<DynaFunctionToSql>).values->filter(d | $d.stateMatch->isEmpty() || $sgc.generationState->in($d.stateMatch));
        assertSize($result, 1, | 'The function \''+$func.name+'\' (state: ['+$sgc.generationState.generationSide->id()+', '+if($sgc.generationState->isEmpty(),|'empty',|$sgc.generationState.withinWhenClause->toOne()->toString())+']) is not supported yet');
        assert($result.toSql.parametersWithinWhenClause->isEmpty() || ($result.toSql.parametersWithinWhenClause->size() >= $func.parameters->size()),|'Error generating \''+$func.name+'\' The function takes '+$func.parameters->size()->toString()+' parameters but '+$result.toSql.parametersWithinWhenClause->size()->toString()+' within where clause flag were provided.');
        $result->toOne();
   };
}

function <<access.private>> meta::relational::functions::sqlQueryToString::regexpLikePattern(query1: String[1], query2: String[1]):String[1]
{
   'REGEXP_LIKE(' + $query1 + ', \'' + '^' +$query2 + '$' +'\')'
}

function <<access.private>> meta::relational::functions::sqlQueryToString::regexpPattern(query: String[1]):String[1]
{
   '%s regexp \'' + '^' +$query + '$' +'\''
}

function <<access.private>> meta::relational::functions::sqlQueryToString::transformRegexpParams(params: String[2]):String[*]
{
   let regExpression = $params->at(1)->meta::relational::functions::sqlQueryToString::removeQuotes();
   $params->at(0)->concatenate($regExpression);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::likePattern(query: String[1]):String[1]
{
   '%s like \'' + $query + '\'%s'
}

function <<access.private>> meta::relational::functions::sqlQueryToString::transformLikeParamsDefault(params: String[2]):String[*]
{
   let likeExpression = $params->at(1)->meta::relational::functions::sqlQueryToString::removeQuotes()->escapeLikeExprDefault();
   $params->at(0)
      ->concatenate($likeExpression)
      ->concatenate('');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::transformLikeParamsForSybaseIQ(params: String[2]):String[*]
{
   let likeExpression = $params->at(1)->meta::relational::functions::sqlQueryToString::removeQuotes()->escapeLikeExprForSybaseIQ();
   $params->at(0)
      ->concatenate($likeExpression)
      ->concatenate(likeEscapeClauseForSybaseIQ($likeExpression));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::escapeLikeExprDefault(query: String[1]):String[1]
{
   // Escaping references...
   // DB2: https://www.ibm.com/support/knowledgecenter/SSEPGG_9.7.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000751.html
   // H2: http://www.h2database.com/html/grammar.html#condition_right_hand_side

   $query
      ->replace('_', '\\_')
      ->replace('%', '\\%');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::escapeLikeExprForSybaseIQ(query: String[1]):String[1]
{
   // Escaping references...
   // Sybase IQ: http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.infocenter.dc38151.1520/html/iqrefbb/CACGCGGC.htm

   $query
      ->replace('_', '\\_')
      ->replace('%', '\\%')
      ->replace('[', '\\[');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::likeEscapeClauseForSybaseIQ(expr: String[1]):String[*]
{
   if($expr->contains('\\'),
      |' escape \'\\\'',
      |'');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::likePatternWithoutEscape(query: String[1]):String[1]
{
   '%s not like \'' + $query + '\''
}

function <<access.private>> meta::relational::functions::sqlQueryToString::transformAlphaNumericParamsDefault(params: String[1]):String[*]
{
   let param = '\'[a-zA-Z0-9]*\'';
   let expression = $param->meta::relational::functions::sqlQueryToString::removeQuotes();
   $params->at(0)->concatenate($expression);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::transformAlphaNumericParamsForSybaseIQ(params: String[1]):String[*]
{
   let param = '\'[^a-zA-Z0-9]\'';
   let expression = $param->meta::relational::functions::sqlQueryToString::removeQuotes();
   $params->at(0)->concatenate($expression);
}

function  <<access.private>> meta::relational::functions::sqlQueryToString::generateDateDiffExpressionForMemSQL(params:String[*]):String[1]
{
  let enumList = [DurationUnit.YEARS,DurationUnit.MONTHS,DurationUnit.WEEKS,DurationUnit.DAYS,DurationUnit.HOURS,DurationUnit.MINUTES,DurationUnit.SECONDS,DurationUnit.MILLISECONDS]->map(e|$e->toString());

  let indexOfDiff = $enumList->indexOf($params->at(2)->replace('Text', ''));

  let dbSpecificUnits = [

     {| fail('The DurationUnit \''+$params->at(2)+'\' is not supported yet!');'';},
     {| fail('The DurationUnit \''+$params->at(2)+'\' is not supported yet!');'';},
     {| fail('The DurationUnit \''+$params->at(2)+'\' is not supported yet!');'';},
     {| format('(%s)', [
        'datediff(%s , %s)'
     ])},
     {| fail('The DurationUnit \''+$params->at(2)+'\' is not supported yet!');'';},
     {| fail('The DurationUnit \''+$params->at(2)+'\' is not supported yet!');'';},
     {| format('(%s)', [
        'time_to_sec(timediff(%s , %s))'
     ])},
     {| fail('The DurationUnit \''+$params->at(2)+'\' is not supported yet!');'';}
  ];

  format($dbSpecificUnits->at($indexOfDiff)->eval(), [$params->at(0), $params->at(1)]);
}


function <<access.private>> meta::relational::functions::sqlQueryToString::transformRound(p:String[*]):String[*]
{
   if ($p->size() == 2,
       | [$p->at(0), $p->at(1)],
       | [$p->at(0), '0']);
}


function <<access.private>> meta::relational::functions::sqlQueryToString::transformAdjustDB2SQL(p:String[3]):String[1]
{
   let startDate = $p->at(0);
   let number = $p->at(1)->parseInteger();
   let unit = $p->at(2);

   'date(%s) %s %s %s'->format([
      $startDate,
      if ($number < 0 , | '-', | '+'),
      if($unit == 'WEEKS', | $number * 7, | $number)->abs()->toString(),
      if($unit == 'WEEKS', | 'DAYS', | $unit)
   ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::postgresReservedWords():String[*]
{
  [];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::h2ReservedWords():String[*]
{
   [
      'all','array','case','check','constraint','cross','current_date','current_time','current_timestamp','current_user','distinct','except','exists','false','fetch','for','foreign','from',
      'full','group','having','if','inner','intersect','intersects','interval','is','join','like','limit','localtime','localtimestamp','minus','natural','not','null','offset','on','order','primary',
      'qualify','row','rownum','select','sysdate','systime','systimestamp','table','today','top','true','union','unique','values','where','window','with'
   ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::memSQLReservedWords():String[*]
{
    [
       'absolute','action','allocate','are','assertion',
       'bit', 'bit_length', 'both',
       'cascaded',' case',' cast',' catalog',' char',' char_length',' character',' character_length',' coalesce',' collate',' collation',' column',' connection',' constraints',' corresponding',' cross',' current_date',' current_time',' current_timestamp',' current_user',
       'date',' day',' dec',' decimal',' deferrable',' deferred',' describe',' descriptor',' diagnostics',' disconnect',' domain',
       'end-exec',' exception',' extract',
       'false',' first',' float',' found',' full',
       'get',' global',' go',
       'hour',
       'immediate',' indicator',' initially',' inner',' input',' insensitive',' int',' integer',' interval',
       'join',
       'kerberos','key',
       'language',' last',' leading',' left',' local',' lower',
       'match',' minute',' module',' month',
       'names',' natural',' nchar',' next',' no',' nullif',' numeric',
       'octet_length',' outer',' output',' overlaps',
       'pad',' partial',' position',' preserve',' prior',
       'real',' relative',' restrict',' right',
       'scroll',' second',' section',' semi_sensitive',' session_user ',' size ',' smallint',' space',' sql',' sqlcode',' sqlerror',' sqlstate',' substring',' system_user',
       'then',' time',' timestamp',' timezone_hour',' timezone_minute',' trailing',' translate',' translation',' trim',' true',
       'unknown',' upper',' usage',
       'value', 'varchar',
       'when',' whenever',' write',' year',
       'zone'
       ];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::sybaseReservedWords():String[*]
{
   //Based on
   // http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.infocenter.dc38151.1510/html/iqrefbb/Alhakeywords.htm
   // and
   // http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.infocenter.dc38151.1601/doc/html/san1278452828146.html

   [
   'active',
   'add',
   'algorithm',
   'all',
   'alter',
   'and',
   'any',
   'append',
   'array',
   'as',
   'asc',
   'attach',
   'auto',
   'backup',
   'begin',
   'between',
   'bigint',
   'binary',
   'bit',
   'bottom',
   'break',
   'by',
   'calibrate',
   'calibration',
   'call',
   'cancel',
   'capability',
   'cascade',
   'case',
   'cast',
   'certificate',
   'char',
   'char_convert',
   'character',
   'check',
   'checkpoint',
   'checksum',
   'clientport',
   'close',
   'columns',
   'comment',
   'commit',
   'committed',
   'comparisons',
   'compressed',
   'computes',
   'conflict',
   'connect',
   'constraint',
   'contains',
   'continue',
   'convert',
   'create',
   'cross',
   'cube',
   'current',
   'current_timestamp',
   'current_user',
   'cursor',
   'date',
   'datetimeoffset',
   'dbspace',
   'dbspacename',
   'deallocate',
   'debug',
   'dec',
   'decimal',
   'declare',
   'decoupled',
   'decrypted',
   'default',
   'delay',
   'delete',
   'deleting',
   'density',
   'desc',
   'detach',
   'deterministic',
   'disable',
   'distinct',
   'do',
   'double',
   'drop',
   'dynamic',
   'elements',
   'else',
   'elseif',
   'enable',
   'encapsulated',
   'encrypted',
   'end',
   'endif',
   'escape',
   'except',
   'exception',
   'exclude',
   'exec',
   'execute',
   'existing',
   'exists',
   'explicit',
   'express',
   'externlogin',
   'fastfirstrow',
   'fetch',
   'first',
   'float',
   'following',
   'for',
   'force',
   'foreign',
   'forward',
   'from',
   'full',
   'gb',
   'goto',
   'grant',
   'group',
   'grouping',
   'having',
   'hidden',
   'history',
   'holdlock',
   'identified',
   'if',
   'in',
   'inactive',
   'index',
   'index_lparen',
   'inner',
   'inout',
   'input',
   'insensitive',
   'insert',
   'inserting',
   'install',
   'instead',
   'int',
   'integer',
   'integrated',
   'intersect',
   'into',
   'iq',
   'is',
   'isolation',
   'jdk',
   'join',
   'json',
   'kb',
   'kerberos',
   'key',
   'lateral',
   'left',
   'like',
   'limit',
   'lock',
   'logging',
   'login',
   'long',
   'match',
   'mb',
   'membership',
   'merge',
   'message',
   'mode',
   'modify',
   'namespace',
   'natural',
   'nchar',
   'new',
   'no',
   'noholdlock',
   'nolock',
   'not',
   'notify',
   'null',
   'numeric',
   'nvarchar',
   'of',
   'off',
   'on',
   'open',
   'openstring',
   'openxml',
   'optimization',
   'option',
   'options',
   'or',
   'order',
   'others',
   'out',
   'outer',
   'over',
   'pages',
   'paglock',
   'partial',
   'partition',
   'passthrough',
   'password',
   'plan',
   'preceding',
   'precision',
   'prepare',
   'primary',
   'print',
   'privileges',
   'proc',
   'procedure',
   'proxy',
   'publication',
   'raiserror',
   'range',
   'raw',
   'readcommitted',
   'readonly',
   'readpast',
   'readtext',
   'readuncommitted',
   'readwrite',
   'real',
   'recursive',
   'reference',
   'references',
   'refresh',
   'release',
   'relocate',
   'remote',
   'remove',
   'rename',
   'reorganize',
   'repeatable',
   'repeatableread',
   'reserve',
   'resizing',
   'resource',
   'restore',
   'restrict',
   'return',
   'revoke',
   'right',
   'rollback',
   'rollup',
   'root',
   'row',
   'rowlock',
   'rows',
   'rowtype',
   'save',
   'savepoint',
   'schedule',
   'scroll',
   'secure',
   'select',
   'sensitive',
   'serializable',
   'service',
   'session',
   'set',
   'setuser',
   'share',
   'smallint',
   'soapaction',
   'some',
   'space',
   'spatial',
   'sqlcode',
   'sqlstate',
   'start',
   'stop',
   'subtrans',
   'subtransaction',
   'synchronize',
   'syntax_error',
   'table',
   'tablock',
   'tablockx',
   'tb',
   'temporary',
   'then',
   'ties',
   'time',
   'timestamp',
   'tinyint',
   'to',
   'top',
   'tran',
   'transaction',
   'transactional',
   'transfer',
   'treat',
   'tries',
   'trigger',
   'truncate',
   'tsequal',
   'unbounded',
   'uncommitted',
   'union',
   'unique',
   'uniqueidentifier',
   'unknown',
   'unnest',
   'unsigned',
   'update',
   'updating',
   'updlock',
   'url',
   'user',
   'using',
   'utc',
   'validate',
   'values',
   'varbinary',
   'varbit',
   'varchar',
   'variable',
   'varray',
   'varying',
   'view',
   'virtual',
   'wait',
   'waitfor',
   'web',
   'when',
   'where',
   'while',
   'window',
   'with',
   'with_cube',
   'with_lparen',
   'with_rollup',
   'withauto',
   'within',
   'word',
   'work',
   'writeserver',
   'writetext',
   'xlock',
   'xml'
   ]
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processDateDiffDurationUnitForH2(durationUnit:String[1]):String[1]
{
   let durationEnumNames = [DurationUnit.YEARS,DurationUnit.MONTHS,DurationUnit.WEEKS,DurationUnit.DAYS,DurationUnit.HOURS,DurationUnit.MINUTES,DurationUnit.SECONDS,DurationUnit.MILLISECONDS]->map(e|$e->toString());
   let durationDbNames = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
   $durationEnumNames->zip($durationDbNames)->filter(h | $h.first == $durationUnit).second->toOne();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processDateDiffDurationUnitForSybase(durationUnit:String[1]):String[1]
{
   let durationEnumNames = [DurationUnit.YEARS,DurationUnit.MONTHS,DurationUnit.WEEKS,DurationUnit.DAYS,DurationUnit.HOURS,DurationUnit.MINUTES,DurationUnit.SECONDS,DurationUnit.MILLISECONDS]->map(e|$e->toString());
   let durationDbNames = ['yy', 'mm', 'wk', 'dd', 'hh', 'mi', 'ss', 'ms'];
   $durationEnumNames->zip($durationDbNames)->filter(h | $h.first == $durationUnit).second->toOne();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processDateDiffDurationUnitForSybaseIQ(durationUnit:String[1]):String[1]
{
   let durationEnumNames = [DurationUnit.YEARS,DurationUnit.MONTHS,DurationUnit.WEEKS,DurationUnit.DAYS,DurationUnit.HOURS,DurationUnit.MINUTES,DurationUnit.SECONDS,DurationUnit.MILLISECONDS]->map(e|$e->toString());
   let durationDbNames = ['yy', 'mm', 'wk', 'dd', 'hh', 'mi', 'ss', 'ms'];
   $durationEnumNames->zip($durationDbNames)->filter(h | $h.first == $durationUnit).second->toOne();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processDateDiffDurationUnitForPresto(durationUnit:String[1]):String[1]
{
   let durationEnumNames = [DurationUnit.YEARS,DurationUnit.MONTHS,DurationUnit.WEEKS,DurationUnit.DAYS,DurationUnit.HOURS,DurationUnit.MINUTES,DurationUnit.SECONDS,DurationUnit.MILLISECONDS]->map(e|$e->toString());
   let durationDbNames = ['\'year\'', '\'month\'', '\'week\'', '\'day\'', '\'hour\'', '\'minute\'', '\'second\'', '\'millisecond\''];
   $durationEnumNames->zip($durationDbNames)->filter(h | $h.first == $durationUnit).second->toOne();
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processDateDiffDurationUnitForSnowflake(durationUnit:String[1]):String[1]
{
   let durationEnumNames = [DurationUnit.YEARS,DurationUnit.MONTHS,DurationUnit.WEEKS,DurationUnit.DAYS,DurationUnit.HOURS,DurationUnit.MINUTES,DurationUnit.SECONDS,DurationUnit.MILLISECONDS]->map(e|$e->toString());
   let durationDbNames = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second',''];
   $durationEnumNames->zip($durationDbNames)->filter(h | $h.first == $durationUnit).second->toOne();
}

function meta::relational::functions::sqlQueryToString::createSelectOneRowSql(table:Table[1], schema:Schema[1], dbType:DatabaseType[1]):String[1]
{
   'select top 1 ' + $table.columns->cast(@Column).name->map(s | $s->processColumnName(createDbConfig($dbType, [])))->makeString(',') + ' from ' + $schema.name + '.' + $table.name;
}


function meta::relational::functions::sqlQueryToString::sqlNull():SQLNull[1]
{
    ^SQLNull();
}


function meta::relational::functions::sqlQueryToString::sqlTrue():Boolean[1]
{
    true;
}

function meta::relational::functions::sqlQueryToString::sqlFalse():Boolean[1]
{
    false;
}

function <<access.private>> meta::relational::functions::sqlQueryToString::generateDateDiffExpressionForPostgres(params:String[*]):String[1]
{
  let enumList = [DurationUnit.YEARS,DurationUnit.MONTHS,DurationUnit.WEEKS,DurationUnit.DAYS,DurationUnit.HOURS,DurationUnit.MINUTES,DurationUnit.SECONDS,DurationUnit.MILLISECONDS]->map(e|$e->toString());

  let indexOfDiff = $enumList->indexOf($params->at(2)->replace('Text', ''));

  let dbSpecificUnits = [

     { | format('(%s)', [
        'DATE_PART(\'year\', %s) - DATE_PART(\'year\', %s)'
     ])},
     {| format('(%s * 12 + (%s))', [
        generateDateDiffExpressionForPostgres([$params->at(0), $params->at(1), DurationUnit.YEARS->toString()]),
        'DATE_PART(\'month\', %s) - DATE_PART(\'month\', %s)'
     ])},
     {| format('(%s)', [
        'TRUNC(DATE_PART(\'day\', %s - %s)/7)'
     ])},
     {| format('(%s)', [
        'DATE_PART(\'day\', %s - %s)'
     ])},
     {| format('(%s * 24 + (%s))', [
        generateDateDiffExpressionForPostgres([$params->at(0), $params->at(1), DurationUnit.DAYS->toString()]),
        'DATE_PART(\'hour\', %s - %s)'
     ])},
     {| format('(%s * 60 + (%s))', [
        generateDateDiffExpressionForPostgres([$params->at(0), $params->at(1), DurationUnit.HOURS->toString()]),
        'DATE_PART(\'minute\', %s - %s)'
     ])},
     {| format('(%s * 60 + (%s))', [
        generateDateDiffExpressionForPostgres([$params->at(0), $params->at(1), DurationUnit.MINUTES->toString()]),
        'DATE_PART(\'second\', %s - %s)'
     ])},
     {| format('(%s * 1000 + (%s))', [
        generateDateDiffExpressionForPostgres([$params->at(0), $params->at(1), DurationUnit.SECONDS->toString()]),
        'DATE_PART(\'milliseconds\', %s - %s)'
     ])}
  ];

  format($dbSpecificUnits->at($indexOfDiff)->eval(), [$params->at(0), $params->at(1)]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateMemSQL(params:String[*]):String[1]
{
   assert( 2 - $params->size()  >= 0,'Incorrect number of parameters for convertDate: convertDate(column,[dateformat])');
   assert($params->size()==1 || dateFormatsMemSQL()->contains($params->at(1)->replace('\'', '')) , | $params->at(1) +' not supported ');
   let dateFormat = if( $params->size() == 1,|'\'YYYY-MM-DD\'' ,| $params->at(1););
   'cast( to_date('+$params->at(0)+','+$dateFormat +') as date)';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDatePresto(params:String[*]):String[1]
{
   assert( 2 - $params->size()  >= 0,'Incorrect number of parameters for convertDate: convertDate(column,[dateformat])');
   assert($params->size()==1 || dateFormatsMemSQL()->contains($params->at(1)->replace('\'', '')) , | $params->at(1) +' not supported ');
   let dateFormat = if( $params->size() == 1,|'\'%Y-%m-%d\'' ,| $params->at(1););
   'date( date_parse('+$params->at(0)+','+$dateFormat +') )';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateDatabricks(params:String[*]):String[1]
{
   assert( 2 - $params->size()  >= 0,'Incorrect number of parameters for convertDate: convertDate(column,[dateformat])');
   assert($params->size()==1 || dateFormatsDatabricks()->contains($params->at(1)->replace('\'', '')) , | $params->at(1) +' not supported ');
   let dateFormat = if( $params->size() == 1,|'\'%Y-%m-%d\'' ,| $params->at(1););
   'to_date('+$params->at(0)+','+$dateFormat +')';
}

function meta::relational::functions::sqlQueryToString::normalizeH2DateFormat(params:String[1]):String[1]
{
   [pair('YYYY', 'yyyy'), pair('DD', 'dd')]->fold({e, a| $a->replace($e.first,$e.second)}, $params);

}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateH2(params:String[*]):String[1]
{

      assert( 2 - $params->size()  >= 0,'Incorrect number of parameters for convertDate: convertDate(column,[dateformat])');
      let dateFormat = if( $params->size() == 1,|'\'yyyy-MM-dd\'' ,| let normalizedFormat = $params->at(1)->normalizeH2DateFormat();
                                                                     assert(dateFormatsH2()->contains($normalizedFormat->replace('\'', '')), $normalizedFormat +' not supported ');
                                                                     $normalizedFormat;
                                                                     );
      'cast( parseDateTime('+$params->at(0)+','+$dateFormat +') as date)';

}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateTimeH2(params:String[*]):String[1]
{
   $params->convertDateTimeFunctionHasCorrectParams();
   let dateTimeFormat = if( $params->size() == 1,|'\'yyyy-MM-dd hh:mm:ss[.nnnnnnnnn]\'',| $params->at(1););
   'parseDateTime('+$params->at(0)+','+$dateTimeFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateTimeDatabricks(params:String[*]):String[1]
{
   $params->convertDateTimeFunctionHasCorrectParams();
   let dateTimeFormat = if( $params->size() == 1,|'\'yyyy-MM-dd hh:mm:ss[.nnnnnnnnn]\'',| $params->at(1););
   'to_timestamp('+$params->at(0)+','+$dateTimeFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateTimePresto(params:String[*]):String[1]
{
   $params->convertDateTimeFunctionHasCorrectParams();
   let dateTimeFormat = if( $params->size() == 1,|'\'%Y-%m-%d %H:%i:%s\'',| $params->at(1););
   'date_parse('+$params->at(0)+','+$dateTimeFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateDB2(params:String[*]):String[1]
{
   $params->convertDateFunctionHasCorrectParams();
   let dateFormat = if( $params->size() == 1 ,|'\'YYYY-MM-DD\'',| $params->at(1));
   //http://www.ibm.com/support/knowledgecenter/SSEPEK_10.0.0/sqlref/src/tpc/db2z_bif_todate.html
   'to_date('+$params->at(0)+','+$dateFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateTimeDB2(params:String[*]):String[1]
{
   $params->convertDateTimeFunctionHasCorrectParams();
   let dateTimeFormat = if( $params->size() == 1,|'\'YYYY-MM-DD HH24:MI:SS\'',| $params->at(1));
   //http://www.ibm.com/support/knowledgecenter/SSEPGG_9.7.0/com.ibm.db2.luw.sql.ref.doc/doc/r0007107.html
   'timestamp_format('+$params->at(0)+','+$dateTimeFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateIQ(params:String[*]):String[1]
{
   $params->convertDateFunctionHasCorrectParams();
   let dateFormat = if( $params->size() == 1,| 120,| dateFormats()->get($params->at(1)->replace('\'', ''))->toOne(););
   if ($dateFormat == 106,
       |'convert ( date,(\'01 \' + ' + 'substring(' + $params->at(0) + ',1,3)' + ' + \' \' + ' + 'substring(' + $params->at(0) + ',4,4))' + ',' + $dateFormat->toString() + ')',
       |'convert ( date,'+$params->at(0)+','+$dateFormat->toString() +')';);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateTimeIQ(params:String[*]):String[1]
{
   $params->convertDateTimeFunctionHasCorrectParams();
   let dateTimeFormat = if( $params->size() == 1,| 120 ,| dateTimeFormats()->get($params->at(1)->replace('\'', ''))->toOne(););
   //http://infocenter.sybase.com/help/index.jsp?topic=/com.sybase.infocenter.dc38151.1520/html/iqrefbb/Dateformat.htm
   'convert( timestamp,'+$params->at(0)+','+$dateTimeFormat->toString() +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertDateFunctionHasCorrectParams(params:String[*]):Boolean[1]
{
  assert( 2 - $params->size()  >= 0,'Incorrect number of parameters for convertDate: convertDate(column,[dateformat])');
  let supportedDateFormat = if($params->size() == 2, |dateFormats()->get($params->at(1)->replace('\'', '')), |[]);
  assert($params->size()==1 || $supportedDateFormat->size() == 1 , | $params->at(1) +' not supported ');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertDateTimeFunctionHasCorrectParams(params:String[*]):Boolean[1]
{
  assert( 2 - $params->size()  >= 0,'Incorrect number of parameters for convertDateTime: convertDateTime(column,[dateTimeformat])');
  let supportedDateTimeFormat = if($params->size() == 2, |dateTimeFormats()->get($params->at(1)->replace('\'', '')), |[]);
  assert($params->size() ==1 || $supportedDateTimeFormat->size() == 1 , | $params->at(1) +' not supported ');
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateSnowflake(params:String[*]):String[1]
{
   assert(2 - $params->size()  >= 0,'Incorrect number of parameters for convertDate: convertDate(column,[dateformat])');
   assert($params->size()==1 || dateFormatsSnowFlake()->contains($params->at(1)->replace('\'', '')) , | $params->at(1) +' not supported ');
   let dateFormat = if( $params->size() == 1 ,|'\'YYYY-MM-DD\'',| $params->at(1));
   //https://docs.snowflake.net/manuals/sql-reference/data-types-datetime.html
   'to_date('+$params->at(0)+','+$dateFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::convertToDateTimeSnowflake(params:String[*]):String[1]
{
   assert(2 - $params->size()  >= 0,'Incorrect number of parameters for convertDateTime: convertDateTime(column,[dateTimeformat])');
   let supportedDateTimeFormat = if($params->size() == 2, |dateTimeFormatsSnowFlake()->get($params->at(1)->replace('\'', '')), |[]);
   assert($params->size() == 1 || $supportedDateTimeFormat->size() == 1 , | $params->at(1) +' not supported ');
   let dateTimeFormat = if( $params->size() == 1,|'\'YYYY-MM-DD HH24:MI:SS\'',| $params->at(1));
   //https://docs.snowflake.net/manuals/sql-reference/data-types-datetime.html
   'to_timestamp('+$params->at(0)+','+$dateTimeFormat +')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::dateFormats():Map<String,Integer>[1]
{
   newMap([pair('yyyy-MM-dd',120),
           pair('MMMyyyy', 106),
           pair('dd MMM yy',6),
           pair('yyyyMMdd', 112)]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::dateFormatsMemSQL():String[*]
{
   ['YYYY-MM-DD', 'MMMYYYY', 'YYYYMMDD'];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::dateFormatsH2():String[*]
{
   ['yyyy-MM-dd', 'MMMyyyy', 'yyyyMMdd'];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::dateFormatsDatabricks():String[*]
{
   ['yyyy-MM-dd', 'MMMyyyy', 'yyyyMMdd'];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::dateFormatsSnowFlake():String[*]
{
   ['yyyy-MM-dd', 'MMMyyyy', 'yyyyMMdd','DD/MM/YYYY', 'YYYY/MM/DD'];
}

function <<access.private>> meta::relational::functions::sqlQueryToString::dateTimeFormats():Map<String,Integer>[1]
{
   newMap([pair('yyyy-mm-dd hh:mi:ss',120),
           pair('yyyy-MM-dd hh:mm:ss',120),
           pair('yyyy-MM-dd hh:mm:ss.mmm',121)]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::dateTimeFormatsSnowFlake():Map<String,Integer>[1]
{
   newMap([pair('yyyy-mm-dd hh:mi:ss',120),
           pair('yyyy-MM-dd hh:mm:ss',120),
           pair('yyyy-MM-dd hh:mm:ss.mmm',121),
           pair('YYYY-MM-DDTHH:MI:SS',120),
           pair('YYYY-MM-DDTHH:MI:SS.FF', 121)]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::transformPercentile(args: String[*], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1]): String[1]
{
   let boolProc = $literalProcessor->eval(Boolean);
   let trueVal  = $boolProc.formatValue(true);
   let falseVal = $boolProc.formatValue(false);

   let column     = $args->at(0);
   let percentile = $args->at(1);
   let ascending  = if($args->size() > 2, | $args->at(2), | $trueVal);
   let continuous = if($args->size() > 3, | $args->at(3), | $trueVal);

   assert($ascending->in([$trueVal, $falseVal]), 'Ascending argument for percentile should be ' + $trueVal + ' or ' + $falseVal + '. Got: ' + $ascending);
   assert($continuous->in([$trueVal, $falseVal]), 'Continuous argument for percentile should be ' + $trueVal + ' or ' + $falseVal + '. Got: ' + $continuous);

   let func  = if($continuous == $trueVal, | 'percentile_cont', | 'percentile_disc');
   let order = if($ascending == $trueVal, | 'asc', | 'desc');

   $func + '(' + $percentile + ') within group (order by ' + $column + ' ' + $order + ')';
}
