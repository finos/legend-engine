import meta::relational::functions::sqlQueryToString::*;
import meta::relational::functions::pureToSqlQuery::metamodel::*;
import meta::relational::runtime::*;
import meta::relational::metamodel::*;
import meta::relational::metamodel::datatype::*;
import meta::relational::metamodel::operation::*;
import meta::relational::metamodel::relation::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::relational::mapping::*;

Enum meta::relational::functions::sqlQueryToString::GenerationSide
{
   Select,
   Where
}

Class meta::relational::functions::sqlQueryToString::GenerationState
{
  <<equality.Key>> generationSide : GenerationSide[1];
  <<equality.Key>> withinWhenClause : Boolean[0..1];
}

Class meta::relational::functions::sqlQueryToString::Config
{
   callingFromFilter : Boolean[0..1];
   useQuotesForTableAliasColumn : Boolean[0..1];
   generateJoin:Boolean[0..1];
   generateJoinTarget : TableAlias[0..1];
}

Class meta::relational::functions::sqlQueryToString::Format
{
   newLine:String[1];
   indent:String[1];

   indentStack:String[*];

   separator(){
      $this.newLine + $this.indentStack->makeString();
   }:String[1];
}

Class meta::relational::functions::sqlQueryToString::DbConfig
{
   dbType:DatabaseType[1];
   dbTimeZone:String[0..1];
   quoteIdentifiers:Boolean[1];

   dbExtension: DbExtension[1];

   isDbReservedIdentifier(str:String[1])
   {
     $this.dbExtension.isDbReservedIdentifier->eval($str);
   }: Boolean[1];

   literalProcessor(type:Type[1])
   {
     getLiteralProcessorForType($type, $this.dbExtension.literalProcessor);
   }: LiteralProcessor[1];

   windowColumnProcessor(w:WindowColumn[1], sgc:SqlGenerationContext[1])
   {
     assert($this.dbExtension.windowColumnProcessor->isNotEmpty(), '[unsupported-api] Window Columns not supported for Database Type: ' + $this.dbType->toString());
     $this.dbExtension.windowColumnProcessor->toOne()->eval($w, $sgc);
   }: String[1];

   semiStructuredElementProcessor(s:RelationalOperationElement[1], sgc:SqlGenerationContext[1])
   {
     assert($this.dbExtension.semiStructuredElementProcessor->isNotEmpty(), '[unsupported-api] Semi structured array element processing not supported for Database Type: ' + $this.dbType->toString());
     $this.dbExtension.semiStructuredElementProcessor->toOne()->eval($s, $sgc);
   }: String[1];

   joinStringsProcessor(j:JoinStrings[1], sgc:SqlGenerationContext[1])
   {
     assert($this.dbExtension.joinStringsProcessor->isNotEmpty(), '[unsupported-api] Join strings operation not supported for Database Type: ' + $this.dbType->toString());
     $this.dbExtension.joinStringsProcessor->toOne()->eval($j, $sgc);
   }: String[1];

   selectSQLQueryProcessor(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1])
   {
     $this.dbExtension.selectSQLQueryProcessor->eval($s, $sgc, $isSubSelect);
   }: String[1];

   upsertSQLQueryProcessor(u:UpsertSQLQuery[1], sgc:SqlGenerationContext[1])
   {
     $this.dbExtension.upsertSQLQueryProcessor->toOne('[unsupported-api] Upsert operation not supported for Database Type: ' + $this.dbType->toString())->eval($u, $sgc);
   }: String[1];

   schemaNameToIdentifier(s:String[1])
   {
     if($this.dbExtension.schemaNameToIdentifier->isEmpty(), |$s, |$this.dbExtension.schemaNameToIdentifier->toOne()->eval($s, $this));
   }: String[1];

   tableNameToIdentifier(s:String[1])
   {
     if($this.dbExtension.tableNameToIdentifier->isEmpty(), |$s, |$this.dbExtension.tableNameToIdentifier->toOne()->eval($s, $this));
   }: String[1];

   procesTempTableName(s:String[1])
   {
     if($this.dbExtension.processTempTableName->isEmpty(), |$s, |$this.dbExtension.processTempTableName->toOne()->eval($s));
   }: String[1];

   columnNameToIdentifier(s:String[1])
   {
     if($this.dbExtension.columnNameToIdentifier->isEmpty(), |$s, |$this.dbExtension.columnNameToIdentifier->toOne()->eval($s, $this));
   }: String[1];

   identifierProcessor(s:String[1])
   {
     $this.dbExtension.identifierProcessor->eval($s, $this);
   }: String[1];

   dynaFuncDispatch(dynaFn:DynaFunction[1], sgc:SqlGenerationContext[1])
   {
     assert(DynaFunctionRegistry->enumValues().name->contains($dynaFn.name), 'dyna function [' + $dynaFn.name + '] is not registered in meta::relational::functions::sqlQueryToString::DynaFunctionRegistry');
     $this.dbExtension.dynaFuncDispatch->eval($dynaFn, $sgc);
   }: DynaFunctionToSql[1];

   ddlCommandsTranslator()
   {
     assert($this.dbExtension.ddlCommandsTranslator->isNotEmpty(), '[unsupported-api] DDL commands translator not supported for Database Type: ' + $this.dbType->toString());
     $this.dbExtension.ddlCommandsTranslator->toOne();
   }: RelationalDDLCommandsTranslator[1];

   translateCreateSchema(c:CreateSchemaSQL[1])
   {
     let translator = $this.ddlCommandsTranslator;
     assert($translator.createSchema->isNotEmpty(), '[unsupported-api] Create schema translation not supported for Database Type: ' + $this.dbType->toString());
     $translator.createSchema->toOne()->eval($c, $this);
   }: String[*];

   translateDropSchema(d:DropSchemaSQL[1])
   {
     let translator = $this.ddlCommandsTranslator;
     assert($translator.dropSchema->isNotEmpty(), '[unsupported-api] Drop schema translation not supported for Database Type: ' + $this.dbType->toString());
     $translator.dropSchema->toOne()->eval($d, $this);
   }: String[*];

   translateCreateTable(c:CreateTableSQL[1])
   {
     let translator = $this.ddlCommandsTranslator;
     assert($translator.createTable->isNotEmpty(), '[unsupported-api] Create table translation not supported for Database Type: ' + $this.dbType->toString());
     $translator.createTable->toOne()->eval($c, $this);
   }: String[*];

   translateDropTable(d:DropTableSQL[1])
   {
     let translator = $this.ddlCommandsTranslator;
     assert($translator.dropTable->isNotEmpty(), '[unsupported-api] Drop table translation not supported for Database Type: ' + $this.dbType->toString());
     $translator.dropTable->toOne()->eval($d, $this);
   }: String[*];

   translateLoadTable(l:LoadTableSQL[1])
   {
     let translator = $this.ddlCommandsTranslator;
     assert($translator.loadTable->isNotEmpty(), '[unsupported-api] Load table translation not supported for Database Type: ' + $this.dbType->toString());
     $translator.loadTable->toOne()->eval($l, $this);
   }: String[*];
  
   preAndFinallyExecutionSQLQuery(ds: meta::pure::alloy::connections::alloy::specification::DatasourceSpecification[1])
   {
     assert($this.dbExtension.preAndFinallyExecutionSQLQuery->isNotEmpty(), 'Pre & Finally Execution SQL Queries are not set for Database Type: ' + $this.dbType->toString());
     $this.dbExtension.preAndFinallyExecutionSQLQuery->toOne()->eval($this, $ds);
   }: PreAndFinallyExecutionSQLQuery[*];
}

function meta::relational::functions::sqlQueryToString::createDbConfig(dbType:DatabaseType[1]):DbConfig[1]
{
   createDbConfig($dbType, []);
}

function meta::relational::functions::sqlQueryToString::createDbConfig( dbType:DatabaseType[1], dbTimeZone:String[0..1]):DbConfig[1]
{
   createDbConfig($dbType, $dbTimeZone, []);
}

function meta::relational::functions::sqlQueryToString::createDbConfig( dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1]):DbConfig[1]
{
   ^DbConfig(
      dbType = $dbType,
      dbTimeZone = $dbTimeZone,
      quoteIdentifiers = if($quoteIdentifiers->isEmpty(), |false, |$quoteIdentifiers->toOne()),
      dbExtension = $dbType->loadDbExtension()
   );
}

Class meta::relational::functions::sqlQueryToString::DbExtension
{
   isBooleanLiteralSupported: Boolean[1];
   collectionThresholdLimit: Integer[0..1];
   <<doc.deprecated>> extraTempTableCreationLogicSupplierForIn: meta::pure::metamodel::function::Function<{String[1] -> String[1]}>[0..1];
   aliasLimit: Integer[0..1];
   coreTypeToDbSpecificSqlTranslator: meta::pure::metamodel::function::Function<{CoreDataType[1] -> String[0..1]}>[0..1];
   isDbReservedIdentifier: meta::pure::metamodel::function::Function<{String[1] -> Boolean[1]}>[1];
   literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1];
   windowColumnProcessor: meta::pure::metamodel::function::Function<{WindowColumn[1], SqlGenerationContext[1] -> String[1]}>[0..1];
   semiStructuredElementProcessor: meta::pure::metamodel::function::Function<{RelationalOperationElement[1], SqlGenerationContext[1] -> String[1]}>[0..1];
   joinStringsProcessor: meta::pure::metamodel::function::Function<{JoinStrings[1], SqlGenerationContext[1] -> String[1]}>[0..1];
   selectSQLQueryProcessor: meta::pure::metamodel::function::Function<{SelectSQLQuery[1], SqlGenerationContext[1], Boolean[1] -> String[1]}>[1];
   upsertSQLQueryProcessor: meta::pure::metamodel::function::Function<{UpsertSQLQuery[1], SqlGenerationContext[1] -> String[1]}>[0..1];
   schemaNameToIdentifier: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[0..1];
   tableNameToIdentifier: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[0..1];
   columnNameToIdentifier: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[0..1];
   identifierProcessor: meta::pure::metamodel::function::Function<{String[1], DbConfig[1] -> String[1]}>[1];
   dynaFuncDispatch: meta::pure::metamodel::function::Function<{DynaFunction[1], SqlGenerationContext[1] -> DynaFunctionToSql[1]}>[1];
   ddlCommandsTranslator : RelationalDDLCommandsTranslator[0..1];
   preAndFinallyExecutionSQLQuery: meta::pure::metamodel::function::Function<{DbConfig[1], meta::pure::alloy::connections::alloy::specification::DatasourceSpecification[1] -> PreAndFinallyExecutionSQLQuery[*]}>[0..1];
   processTempTableName: meta::pure::metamodel::function::Function<{String[1] -> String[1]}>[0..1];
}

Class meta::relational::functions::sqlQueryToString::RelationalDDLCommandsTranslator
{
  createSchema: meta::pure::metamodel::function::Function<{CreateSchemaSQL[1], DbConfig[1] ->String[*]}>[0..1];
  dropSchema : meta::pure::metamodel::function::Function<{DropSchemaSQL[1], DbConfig[1] ->String[*]}>[0..1];
  dropTable : meta::pure::metamodel::function::Function<{DropTableSQL[1], DbConfig[1] -> String[*]}>[0..1];
  createTable : meta::pure::metamodel::function::Function<{CreateTableSQL[1], DbConfig[1] -> String[*]}>[0..1];
  loadTable: meta::pure::metamodel::function::Function<{LoadTableSQL[1], DbConfig[1] ->  String[*]}>[0..1];
}

Class meta::relational::functions::sqlQueryToString::DbExtensionLoader
{
   dbType: DatabaseType[1];
   loader: meta::pure::metamodel::function::Function<{->DbExtension[1]}>[1];
}

Class meta::relational::functions::sqlQueryToString::SqlGenerationContext
{
   dbConfig: DbConfig[1];
   format: Format[1];
   generationState: GenerationState[1];
   config: Config[1];
   extensions: Extension[*];
}

function meta::relational::functions::sqlQueryToString::literalTransform<K>(t: meta::pure::metamodel::function::Function<{K[1] -> String[1]}>[1]): meta::pure::metamodel::function::Function<{K[1], String[0..1] -> String[1]}>[1]
{
  {x:K[1], dbTimeZone:String[0..1]| $t->eval($x)};
}

Class meta::relational::functions::sqlQueryToString::LiteralReplacement
{
   old : String[1];
   new : String[1];
}

Class meta::relational::functions::sqlQueryToString::LiteralProcessor
{
   types:Type[*];
   format: String[1];
   transform: meta::pure::metamodel::function::Function<{Nil[1], String[0..1] -> String[1]}>[1];
   literalReplacements: LiteralReplacement[*];

   formatValue(value:Any[1], dbTimeZone:String[0..1]) {
      $this.format->format($this.transformValue($value, $dbTimeZone))
   }:String[1];

   transformValue(value:Any[1], dbTimeZone:String[0..1]) {
      $this.transform->eval($value, $dbTimeZone)
   }:String[1];
}

Profile meta::relational::functions::sqlQueryToString::db
{
   stereotypes: [ExtensionLoader];
}

function meta::relational::functions::sqlQueryToString::getDatabaseTypes():DatabaseType[*]
{
  getDbExtensionLoaders().dbType;
}

function meta::relational::functions::sqlQueryToString::loadDbExtension(dbType: DatabaseType[1]):DbExtension[1]
{
  let loader = getDbExtensionLoaders()->filter(l| $l.dbType == $dbType);
  assert($loader->size() > 0, 'No extension loaders found for dbType ' + $dbType->toString());
  assert($loader->size() < 2, 'Multiple extension loaders found for dbType ' + $dbType->toString());
  $loader->toOne().loader->eval();
}

function meta::relational::functions::sqlQueryToString::getDbExtensionLoaders():DbExtensionLoader[*]
{
  db->stereotype('ExtensionLoader').modelElements->cast(@meta::pure::metamodel::function::Function<{->DbExtensionLoader[1]}>)
    ->map(f| $f->eval())->sortBy(l| $l.dbType.name);
}

function meta::relational::functions::sqlQueryToString::sqlQueryToString(sqlQuery:SQLQuery[1], dbType:DatabaseType[1], extensions:Extension[*]):String[1]
{
   sqlQueryToString($sqlQuery, $dbType, [], [], $extensions);
}

function meta::relational::functions::sqlQueryToString::ddlSqlQueryToString(ddlSqlQuery:SQLQuery[1], dbConfig:DbConfig[1]):String[*]
{
   $ddlSqlQuery->match([ c:CreateTableSQL[1]| $dbConfig.translateCreateTable($c),
                         l:LoadTableSQL[1]| $dbConfig.translateLoadTable($l);,
                         d:DropTableSQL[1]| $dbConfig.translateDropTable($d)])
}

function meta::relational::functions::sqlQueryToString::sqlQueryToString(sqlQuery:SQLQuery[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:Extension[*]):String[1]
{
   sqlQueryToString($sqlQuery, $dbType, $dbTimeZone, $quoteIdentifiers, ^Format(newLine='', indent=''), $extensions);
}

function meta::relational::functions::sqlQueryToString::sqlQueryToStringPretty(sqlQuery:SQLQuery[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:Extension[*]):String[1]
{
   sqlQueryToString($sqlQuery, $dbType, $dbTimeZone, $quoteIdentifiers, ^Format(newLine='\n', indent='\t'), $extensions);
}

function meta::relational::functions::sqlQueryToString::sqlQueryToString(sqlQuery:SQLQuery[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], format:Format[1], extensions:Extension[*]):String[1]
{
   processOperation($sqlQuery, createDbConfig($dbType, $dbTimeZone, $quoteIdentifiers), $format, ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], extensions:Extension[*]):String[1]
{
   processOperation($relationalOperationElement, createDbConfig($dbType, []), ^Format(newLine='', indent=''), ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], dbTimeZone:String[0..1], quoteIdentifiers:Boolean[0..1], extensions:Extension[*]):String[1]
{
   processOperation($relationalOperationElement, createDbConfig($dbType, $dbTimeZone, $quoteIdentifiers), ^Format(newLine='', indent=''), ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbType:DatabaseType[1], config:Config[1], extensions:Extension[*]):String[1]
{
   processOperation($relationalOperationElement, createDbConfig($dbType, []), ^Format(newLine='', indent=''), $config, $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], extensions:Extension[*]):String[1]
{
   processOperation($relationalOperationElement, $dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Where, withinWhenClause = false), ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], config:Config[1], extensions:Extension[*]):String[1]
{
   processOperation($relationalOperationElement, $dbConfig, $format, ^GenerationState(generationSide = GenerationSide.Where, withinWhenClause = false), $config, $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], extensions:Extension[*]):String[1]
{
   processOperation($relationalOperationElement, $dbConfig, $format, $generationState, ^Config(), $extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], sgc:SqlGenerationContext[1]):String[1]
{
   $relationalOperationElement->processOperation($sgc.dbConfig, $sgc.format, $sgc.generationState, $sgc.config, $sgc.extensions);
}

function meta::relational::functions::sqlQueryToString::processOperation(relationalOperationElement:RelationalOperationElement[1], dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], config:Config[1], extensions:Extension[*]):String[1]
{
   let sgc = ^SqlGenerationContext(dbConfig=$dbConfig, format=$format, generationState=$generationState, config=$config, extensions=$extensions);
   $relationalOperationElement->match($extensions->map(e|$e.moduleExtension('relational')->cast(@RelationalExtension).sqlQueryToString_processOperation)->map(f | $f->eval($dbConfig, $format, $generationState, $config, $extensions))->concatenate(
                                       [
                                          v:VarPlaceHolder[1]| '${'+$v.name+'}',
                                          v:VarSetPlaceHolder[1]| '${'+$v.varName+'}',
                                          v:VarCrossSetPlaceHolder[1]| '${'+$v.varName+'}',
                                          w:WindowColumn[1]|$dbConfig.windowColumnProcessor($w, $sgc),
                                          s:ViewSelectSQLQuery[1]|'('+$s.selectSQLQuery->processOperation($dbConfig, $format, $generationState, $config, $extensions)+')',
                                          t:Table[1]|$t->tableToString($dbConfig),
                                          js:JoinStrings[1] | $dbConfig.joinStringsProcessor($js, ^$sgc(config=^Config())),
                                          alias:Alias[1]|
                                                let innerTerm = $alias.relationalElement->match([
                                                   r : VarSetPlaceHolder[1]|$r->processOperation($dbConfig, $format, $generationState, $config, $extensions),
                                                   s : SelectSQLQuery[1]|$s->processSelectSQLQuery($sgc, true),
                                                   r : RelationalOperationElement[1]|$r->processOperation($dbConfig, $format, $generationState, $config, $extensions)
                                                ]);

                                                let identifier = $dbConfig.identifierProcessor($alias.name);
                                            
                                                let sqlOp = $alias.relationalElement->instanceOf(SelectSQLQuery) || $alias.relationalElement->instanceOf(VarCrossSetPlaceHolder);

                                                '%s%s%s as %s'->format([
                                                      if ($sqlOp,|'(',|''),
                                                      $innerTerm,
                                                      if ($sqlOp,|')',|''),
                                                      $identifier
                                                      ]);
                                             ,
                                          c:TableAliasColumn[1]|let doubleQuote = if($config.useQuotesForTableAliasColumn == false, |'', |'"');
                                                                if(!$config.generateJoin->isEmpty() && $config.generateJoin->toOne(),|if ($config.generateJoinTarget == $c.alias,
                                                                                                                                          |'{target}.',
                                                                                                                                          |let schema = $c.alias.relationalElement->match([t:Table[1]|$t.schema.name, v:View[1]|$v.schema.name]);
                                                                                                                                           if ($schema == 'default',|'',|$schema+'.');
                                                                                                                                      )
                                                                                                                                    ,|''
                                                                ) + if ($config.generateJoinTarget == $c.alias, |'',|$dbConfig.identifierProcessor($doubleQuote+$c.alias.name->toOne()+$doubleQuote) + '.') + processColumnName($c.column.name->toOne(), $dbConfig);,
                                          l:Literal[1]| processLiteral($l, $dbConfig),
                                          ll:LiteralList[1] | $ll.values->map(e | $e->processOperation($dbConfig, $format, $generationState, $config, $extensions))->joinStrings('(', ', ', ')'),
                                          s:SelectSQLQuery[1]| $s->processSelectSQLQuery($sgc, false),
                                          u:UpsertSQLQuery[1]| $u->processUpsertSQLQuery($sgc),
                                          u:UnionAll[1]| '('+$u.queries->map(q|$q->processSelectSQLQuery($sgc, false))->makeString(' UNION ALL ')+')',
                                          u:Union[1]| '('+$u.queries->map(q|$q->processSelectSQLQuery($sgc, false))->makeString(' UNION ')+')',
                                          f:FreeMarkerOperationHolder[1]|processFreeMarkerOperationHolder($f, $dbConfig, $format, $generationState, $config, false, $extensions),
                                          d:DynaFunction[1]|processDynaFunction($d, $sgc),
                                          c:ColumnName[1]|$dbConfig.identifierProcessor($c.name->toOne()),
                                          s:SemiStructuredObjectNavigation[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
                                          s:SemiStructuredArrayFlatten[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
                                          s:SemiStructuredArrayFlattenOutput[1]|$dbConfig.semiStructuredElementProcessor($s, $sgc),
                                          {f:meta::relational::metamodel::operation::Function[1]| assert(false, 'Don\'t know how to handle %s', $f->type()); 'TO DO'; }
                                       ])->toOneMany()
                                     );
}

function meta::relational::functions::sqlQueryToString::tableToString(table:Table[1], dbConfig : DbConfig[1]):String[1]
{
   let schemaName = $dbConfig.schemaNameToIdentifier($table.schema.name);
   let tableName = $dbConfig.tableNameToIdentifier($table.name);
   if($schemaName == 'default', | $dbConfig.identifierProcessor($tableName), | $dbConfig.identifierProcessor($schemaName) + '.' + $dbConfig.identifierProcessor($tableName));
}

function meta::relational::functions::sqlQueryToString::indent(d:Format[1]):Format[1]
{
   ^$d(indentStack += $d.indent);
}

function meta::relational::functions::sqlQueryToString::processSelectSQLQuery(s:SelectSQLQuery[1], sgc:SqlGenerationContext[1], isSubSelect:Boolean[1]):String[1]
{
   if ($s.columns->isEmpty() && !$s.data->isEmpty() && $s.data.alias.relationalElement->toOne()->instanceOf(Union) && $s.data->map(x|$x->children())->isEmpty(),
      | $s.data.alias.relationalElement->toOne()->processOperation($sgc.dbConfig, $sgc.format->indent(), $sgc.config, $sgc.extensions),
      | $sgc.dbConfig.selectSQLQueryProcessor($s, $sgc, $isSubSelect)
   );
}

function meta::relational::functions::sqlQueryToString::processUpsertSQLQuery(u:UpsertSQLQuery[1], sgc:SqlGenerationContext[1]):String[1]
{
  $sgc.dbConfig.upsertSQLQueryProcessor($u, $sgc);
}

function meta::relational::functions::sqlQueryToString::processColumnName(name:String[1], dbConfig:DbConfig[1]):String[1]
{
   $dbConfig.identifierProcessor($dbConfig.columnNameToIdentifier($name));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processLiteral(literal:Literal[1], dbConfig : DbConfig[1]) : String[1]
{
   $literal.value->processLiteralValue($dbConfig);
}

function meta::relational::functions::sqlQueryToString::processLiteralValue(a:Any[1], dbConfig : DbConfig[1]) : String[1]
{
   let processor = $dbConfig.literalProcessor($a->type());
   $processor.formatValue($a, $dbConfig.dbTimeZone);
}

function meta::relational::functions::sqlQueryToString::getLiteralProcessorForType(type:Type[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1]): LiteralProcessor[1]
{
   if($type->equal(VarPlaceHolder),
      |^LiteralProcessor(format = '%s', transform = {v:VarPlaceHolder[1], dbTimeZone:String[0..1] | convertPlaceHolderToSQLString($v, $literalProcessor, $dbTimeZone)}),
      |$literalProcessor->eval($type));
}

function meta::relational::functions::sqlQueryToString::convertPlaceHolderToSQLString(v:VarPlaceHolder[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1], dbTimeZone:String[0..1]):String[1]
{
   let vType        = $v->getVariableType();

   let prefixSuffix = getPrefixAndSuffixForType($vType, $literalProcessor);
   let prefix       = $prefixSuffix.first;
   let suffix       = $prefixSuffix.second;

   let replacePairs = getReplacePairsForType($vType, $literalProcessor);
   processPlaceHolder($v, $vType, $prefix, $suffix, $replacePairs, $dbTimeZone);
}

function meta::relational::functions::sqlQueryToString::processPlaceHolder(v:VarPlaceHolder[1], type:Type[1], prefix:String[1], suffix:String[1], replacePairs:LiteralReplacement[*], dbTimeZone:String[0..1]): String[1]
{
   let noPropertyPath              = $v.propertyPath->isEmpty();
   let optionalHandler             = if($v->isOptionalPlaceHolder() && $noPropertyPath,|'![]',|'');
   let placeHolderWithPath         = $v.name+if($noPropertyPath,|'',|'.')+$v.propertyPath->map(p|$p.name)->joinStrings('.');
   let resolvedPlaceHolder         = if($type == String,
                                           | $placeHolderWithPath->convertStringToSQLString(),
                                           | $placeHolderWithPath) + $optionalHandler;

   let isPossibleDateTimeType      = [Date, DateTime]->contains($v.type);
   let possiblyApplyDateTzFunction = if($isPossibleDateTimeType,| processDatePlaceHolder($resolvedPlaceHolder, $dbTimeZone),| $resolvedPlaceHolder);

   if($v->isCollectionPlaceHolder(),
      |if($resolvedPlaceHolder == $possiblyApplyDateTzFunction,
         |'${renderCollection('+ $resolvedPlaceHolder + ' \",\" \"' + $prefix + '\" \"' + $suffix + '\" ' + $replacePairs->map(kv | '\"' + $kv.old + '\" : \"' + $kv.new + '\" ')->joinStrings('{', ', ', '} ') + placeHolderDefaultValue() +')}',
         |'${renderCollectionWithTz('+ $resolvedPlaceHolder + ' "['+ $dbTimeZone->toOne() + ']" ' + '\",\" \"' + $prefix + '\" \"' + $suffix + '\" ' + placeHolderDefaultValue() +')}'),
      |if($v->isOptionalPlaceHolder(),
          |if($type->instanceOf(Enumeration),
              |'${varPlaceHolderToString(' + $possiblyApplyDateTzFunction + ' \"\'\" \"\'\" {} '+ placeHolderDefaultValue()+')}',
              |'${varPlaceHolderToString(' + $possiblyApplyDateTzFunction + ' \"' + $prefix + '\" \"'+ $suffix + '\" ' + $replacePairs->map(kv | '\"' + $kv.old + '\" : \"' + $kv.new + '\"')->joinStrings('{', ', ', '} ') + placeHolderDefaultValue()+')}'),
          |if($type->instanceOf(Enumeration),
              |$prefix + '\'${'+$possiblyApplyDateTzFunction+'}\'' + $suffix,
              |$prefix + '${'+$possiblyApplyDateTzFunction+$replacePairs->map(kv | '?replace(\"' + $kv.old + '\", \"' + $kv.new + '\")')->joinStrings() + '}' + $suffix))
      );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getPrefixAndSuffixForType(type:Type[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1]):Pair<String, String>[1]
{
   let lp           = $literalProcessor->eval($type);
   // We need this replace here to mimic what we would have done if we had executed the format string on input.
   // %% is used in format to escape a required % symbol. We don't need to do this while building freemarker context
   let lpFormat     = $lp.format->replace('%%', '%');

   let index        = $lpFormat->indexOf('%s');
   let prefix       = $lpFormat->substring(0, $index);
   let suffix       = $lpFormat->substring($index+2);

   ^Pair<String, String>(first = $prefix, second = $suffix);
}

function meta::relational::functions::sqlQueryToString::getReplacePairsForType(type:Type[1], literalProcessor: meta::pure::metamodel::function::Function<{Type[1] -> LiteralProcessor[1]}>[1]):LiteralReplacement[*]
{
   $literalProcessor->eval($type).literalReplacements;
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processFreeMarkerOperationHolder(freeMarkerOp:FreeMarkerOperationHolder[1], dbConfig : DbConfig[1], format:Format[1], generationState:GenerationState[1], config: Config[1], nestedFreeMarkerOperationHolder: Boolean[1], extensions:Extension[*]):String[1]
{
   let freeMarkerOpMap = getFreeMarkerOperationMap();
   let opMapRes = $freeMarkerOpMap->get($freeMarkerOp.name);
   let res = if($opMapRes->isEmpty() && $freeMarkerOp.name->contains('enumMap_'),
                | ^ToSql(format= $freeMarkerOp.name + '(%s)'),
                | $opMapRes);

   assert($res->isNotEmpty(),  | $freeMarkerOp.name + 'freeMarker Operation is not supported!');

   let processedParams = $freeMarkerOp.parameters->map(p | $p->match([
                                                               f:FreeMarkerOperationHolder[1] | $f->processFreeMarkerOperationHolder($dbConfig, $format, $generationState, $config, true, $extensions);,
                                                               l:Literal[1]                   | $l.value->match([v:VarPlaceHolder[1] | if($v->isOptionalPlaceHolder(), |$v.name + '![]', |$v.name);,
                                                                                                                 a:Any[1]            | $a->toString();]),
                                                               a:RelationalOperationElement[1]| '\'' + $a->processOperation($dbConfig, $format, $generationState, $config, $extensions)->replace('\'', '\\\'') + '\'';
   ]));
   let params = if($res.transform->isEmpty(), | $processedParams, | $res.transform->toOne()->eval($processedParams));

   if($nestedFreeMarkerOperationHolder,
      |format($res->toOne().format, $params),
      |if($freeMarkerOp.name->contains('enumMap_') || $freeMarkerOp.name == 'equalEnumOpSelector',
        |'${' + format($res->toOne().format, $params) + '}',
        |'(${' + format($res->toOne().format, $params) + '})'));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::getFreeMarkerOperationMap():Map<String, ToSql>[1]
{
   let freeMarkerOpMap = [
      pair('variableCollectionSize', ^ToSql(format='collectionSize(%s)')),
      pair('optionalVarPlaceHolderOpSelector', ^ToSql(format='optionalVarPlaceHolderOperationSelector(%s, %s, %s)')),
      pair('equalEnumOpSelector', ^ToSql(format='equalEnumOperationSelector(%s, %s, %s)'))
   ]->newMap();
}

function meta::relational::functions::sqlQueryToString::getVariableType(v:VarPlaceHolder[1]):Type[1]
{
   if ($v.propertyPath->isNotEmpty(),
       | $v.propertyPath->last().genericType.rawType->toOne(),
       | $v.type);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processDatePlaceHolder(dateParameter:String[1], dbTimeZone:String[0..1]): String[1]
{
   let isNonSystemTz = $dbTimeZone->isNotEmpty() && !meta::pure::functions::date::systemDefaultTimeZones()->contains($dbTimeZone->toOne());
   if($isNonSystemTz,|'GMTtoTZ( "['+$dbTimeZone->toOne()+']" '+$dateParameter+')'
                    ,| $dateParameter);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isOptionalPlaceHolder(v:VarPlaceHolder[1]):Boolean[1]
{
   $v.multiplicity->isNotEmpty() && eq($v.multiplicity->toOne()->meta::pure::functions::meta::getLowerBound(), 0);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isCollectionPlaceHolder(v:VarPlaceHolder[1]):Boolean[1]
{
   $v.multiplicity->isNotEmpty() && $v.multiplicity == ZeroMany;
}

function <<access.private>> meta::relational::functions::sqlQueryToString::placeHolderDefaultValue():String[1]
{
   '\"' + convertSQLNullToSQLString(^SQLNull()) +'\"';
}

function meta::relational::functions::sqlQueryToString::convertStringToSQLString(s:String[1]):String[1]
{  
   convertStringToSQLString(^LiteralReplacement(old='\'',new='\'\''))->eval($s);
}

function meta::relational::functions::sqlQueryToString::convertStringToSQLString(literalReplacements:LiteralReplacement[*]):meta::pure::metamodel::function::Function<{String[1] -> String[1]}>[1]
{
   //TODO: Clean up this hack
   let updatedLiteralReplacements = $literalReplacements->concatenate(^LiteralReplacement(old='\@@',new='\''));
   {s:String[1] | $updatedLiteralReplacements->fold({replacement, input | $input->replace($replacement.old, $replacement.new)}, $s)};
}

function meta::relational::functions::sqlQueryToString::convertSQLNullToSQLString(s:SQLNull[1]):String[1]
{
   'null'
}

function meta::relational::functions::sqlQueryToString::maybeWrapAsBooleanOperation(e:RelationalOperationElement[1], sgc:SqlGenerationContext[1]):RelationalOperationElement[1]
{
   if ($sgc.dbConfig.dbExtension.isBooleanLiteralSupported, |$e, |$e->wrapAsBooleanOperation($sgc.extensions));
}

function meta::relational::functions::sqlQueryToString::wrapAsBooleanOperation(e:RelationalOperationElement[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   if ($e->isBooleanOperation($extensions), | $e, | ^DynaFunction(name ='equal', parameters=[$e, ^Literal(value=true)]););
}

function meta::relational::functions::sqlQueryToString::isBooleanOperation(relationalElement:RelationalOperationElement[1], extensions:Extension[*]):Boolean[1]
{
   $relationalElement->match($extensions.moduleExtension('relational')->cast(@RelationalExtension).sqlQueryToString_isBooleanOperation->concatenate([
      d:DynaFunction[1] | $d.name->in(['or', 'and', 'lessThan', 'lessThanEqual', 'greaterThan', 'greaterThanEqual', 'equal', 'notEqual', 'notEqualAnsi', 'startsWith', 'endsWith', 'contains', 'isEmpty', 'isNotEmpty', 'isNull', 'isNotNull','isAlphaNumeric', 'exists', 'not', 'in', 'isNumeric', 'matches', 'isDistinct'])
                                       || ($d.name == 'group' && $d.parameters->toOne()->isBooleanOperation($extensions));,
      f:FreeMarkerOperationHolder[1] | $f.name->in(['optionalVarPlaceHolderOpSelector']);,
      a:Any[1] | false
   ])->toOneMany()
   )
}

function <<access.private>> meta::relational::functions::sqlQueryToString::extractSemiStructuredDotPathAccess(jsonPath: String[1], startIndex: Integer[1]): String[1]
{
   let nextDotIndex = if($jsonPath->indexOf('.', $startIndex+1) == -1, | $jsonPath->length(), | $jsonPath->indexOf('.', $startIndex+1));
   let nextBracketIndex = if($jsonPath->indexOf('[', $startIndex+1) == -1, | $jsonPath->length(), | $jsonPath->indexOf('[', $startIndex+1));
   let field = $jsonPath->substring($startIndex+1, min($nextDotIndex, $nextBracketIndex));
   '"' + $field + '"';   // wrap around quotes
}

function <<access.private>> meta::relational::functions::sqlQueryToString::extractSemiStructuredBracketPathAccess(jsonPath: String[1], startIndex: Integer[1]): String[1]
{
   let quoted = $jsonPath->substring($startIndex+1, $startIndex+2) == '"';
   if($quoted, 
      | let quoteEnd = $jsonPath->indexOf('"', $startIndex+2);
        assert($quoteEnd != $jsonPath->length(), 'unmatched " at ' + toString($startIndex+1));
        $jsonPath->substring($startIndex+1, $quoteEnd+1);, // include quotes too
      | let bracketEnd = $jsonPath->indexOf(']', $startIndex+1);
        assert($bracketEnd != $jsonPath->length(), 'unmatched [ at ' + $startIndex->toString());
        let property = $jsonPath->substring($startIndex+1, $bracketEnd);
        assert($property->isDigit(), 'expected ' + $property + ' to be numeric');
        $property;         
   );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::parseSemiStructuredPathNavigationHelper(jsonPath: String[1], startIndex: Integer[1]): String[*]
{
   if($startIndex < $jsonPath->length(), 
      |
         let char = $jsonPath->substring($startIndex, $startIndex+1);
         assert($char->in(['.', '[']), 'invalid token ' + $char);
         if($char == '.', 
            | let field = $jsonPath->extractSemiStructuredDotPathAccess($startIndex);
              $field->concatenate($jsonPath->parseSemiStructuredPathNavigationHelper($startIndex+$field->length()-1));, 
            | let field = $jsonPath->extractSemiStructuredBracketPathAccess($startIndex);
              $field->concatenate($jsonPath->parseSemiStructuredPathNavigationHelper($startIndex+$field->length()+2));       
         );,
      | []         
   );
}

function meta::relational::functions::sqlQueryToString::parseSemiStructuredPathNavigation(jsonPath: String[1]): String[*]
{
   let dotIndex = if($jsonPath->indexOf('.') == -1, | $jsonPath->length(), | $jsonPath->indexOf('.'));
   let bracketIndex = if($jsonPath->indexOf('[') == -1, | $jsonPath->length(), | $jsonPath->indexOf('['));
   let prefix = $jsonPath->substring(0, min($dotIndex, $bracketIndex));
   if($prefix->length() > 0, 
      | concatenate('"' + $prefix + '"', $jsonPath->parseSemiStructuredPathNavigationHelper(min($dotIndex, $bracketIndex)));,
      | $jsonPath->parseSemiStructuredPathNavigationHelper(0);
   );
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processDynaFunction(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   if ($func->isEqualsFromFilter($sgc.config),
      | processEqualFromFilter($func,$sgc),
      |
   if ($func.name == 'case',
      | processCase($func,$sgc),
      |
   if ($func.name == 'not',
      | processNot($func,$sgc),
      |
    if($func.name == 'extractFromSemiStructured',
      | processExtractFromSemiStructured($func, $sgc),
      | let result = $sgc.dbConfig.dynaFuncDispatch($func, $sgc);

        let params = if ($func.name->in(['and', 'or']),
                        | $func.parameters->map(p | $p->maybeWrapAsBooleanOperation($sgc)),
                        |
                     if($func.name == 'if',
                        | $func.parameters->head()->map(p | $p->maybeWrapAsBooleanOperation($sgc))->concatenate($func.parameters->tail()),
                        | $func.parameters
                     ));
        let config = $sgc.config;
        let generationState = $sgc.generationState;
        let newSgc = if($func.name->in(['and', 'or']), | $sgc, | ^$sgc(config = ^$config(callingFromFilter = [])));
        let paramWiseSgcs = if($result.toSql.parametersWithinWhenClause->isEmpty(),|range(0,$params->size(),1)->map(i|$newSgc),|$result.toSql.parametersWithinWhenClause->map(b|^$newSgc(generationState = ^$generationState(withinWhenClause=$b))));
        $result->toOne().toSql($params, $paramWiseSgcs);
   ))));
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processExtractFromSemiStructured(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
  let params = $func.parameters;
  assertSize($params, 3, $func.name + ' takes 3 arguments, was called with ' + $params->size()->toString() + ' instead');
  let config = $sgc.config;
  let newSgc = ^$sgc(config = ^$config(callingFromFilter = []));
  let result = $sgc.dbConfig.dynaFuncDispatch($func, $sgc)->toOne();
  let p0 = $params->at(0)->processOperation($newSgc);
  let p1 = $params->at(1)->cast(@Literal).value->cast(@String);
  assert($p1->matches(extractFromSemiStructuredPathRegex()), 'path specfication must follow regex: ' + extractFromSemiStructuredPathRegex());
  let p2 = $params->at(2)->cast(@Literal).value->cast(@String);
  let supportedTypes = ['BOOLEAN', 'CHAR', 'VARCHAR', 'STRING', 'INTEGER', 'DECIMAL', 'FLOAT', 'DATE', 'DATETIME', 'TIMESTAMP'];
  assertContains($supportedTypes, $p2, $p2 + ' must be one of ' + $supportedTypes->joinStrings(', '));  
  let processedParams = $result.toSql.transform->toOne()->eval([$p0, $p1, $p2]);
  format($result.toSql.format, $processedParams);  
}

function <<access.private>> meta::relational::functions::sqlQueryToString::extractFromSemiStructuredPathRegex(): String[1]
{
  '([a-zA-Z_][a-zA-Z_0-9]*|\\[[0-9]+\]|\\["[^"]+"\])(\\.[a-zA-Z_][a-zA-Z_0-9]*|\\[[0-9]+\]|\\["[^"]+"\])*$';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processCase(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let params = $func.parameters;
   let size = ($params->size()-1)/2;
   let range = range(0, $size->floor()*2, 2);
   let sgcNoConfig = ^$sgc(config=^Config());
   let generationState = $sgc.generationState;
   let sgcWithinWhen = ^$sgcNoConfig(generationState=^$generationState(withinWhenClause = true));
   'case '+ $range->map(o| $sgc.format.separator + 'when '+$params->at($o)->processOperation($sgcWithinWhen)+ ' ' + $sgc.format.separator + 'then '+$params->at($o+1)->processOperation($sgcNoConfig))->makeString(' ')+ ' ' + $sgc.format.separator + 'else '+$params->at($params->size()-1)->processOperation($sgcNoConfig)+' end';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isEqualsFromFilter(func:DynaFunction[1], config: Config[1]):Boolean[1]
{
   $func.name == 'equal' && $config.callingFromFilter == true &&
      $func.parameters->forAll(p | $p->instanceOf(TableAliasColumn) && $p->cast(@TableAliasColumn).column.nullable != false);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isAndOr(func:DynaFunction[1]):Boolean[1]
{
   $func.name == 'and' || $func.name == 'or';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::isNot(func:DynaFunction[1]):Boolean[1]
{
   $func.name == 'not';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processEqualFromFilter(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let params = $func.parameters->map(p | $p->processOperation($sgc));
   let left = $params->at(0);
   let right = $params->at(1);
   '(' + $left + ' = ' + $right + ' OR (' + $left + ' is null AND ' + $right + ' is null))';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processNot(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let parameter = $func.parameters->at(0);
   $parameter->match([
                       dynaFunction:DynaFunction[1] |  let functionName = $dynaFunction.name;
                                                       if($functionName == 'equal', | $dynaFunction->processNotEqual($sgc),
                                                                                    | if($functionName == 'in', | $dynaFunction->processNotIn($sgc),
                                                                                                                | if($dynaFunction->isAndOr() || $dynaFunction->isNot(), | 'not ('+$dynaFunction->processOperation($sgc) +')';,
                                                                                                                                                                         | 'not ' + $dynaFunction->maybeWrapAsBooleanOperation($sgc)->processOperation($sgc);
                                                                                                                     );
                                                                                         );
                                                          );,
                       rOp: RelationalOperationElement[1] | if($rOp->instanceOf(FreeMarkerOperationHolder) && $rOp->cast(@FreeMarkerOperationHolder).name == 'equalEnumOpSelector',
                                                                | let params = $rOp->cast(@FreeMarkerOperationHolder).parameters;
                                                                  '${equalEnumOperationSelector(' + $params->at(0)->cast(@FreeMarkerOperationHolder).name + '(' + $params->at(0)->cast(@FreeMarkerOperationHolder).parameters->cast(@Literal).value->cast(@VarPlaceHolder).name->toOne() + '), \'' + processNotIn($params->at(1)->cast(@DynaFunction), $sgc) + '\', \'' + processNotEqual($params->at(2)->cast(@DynaFunction), $sgc) + '\')}';,
                                                                | 'not ' + $rOp->maybeWrapAsBooleanOperation($sgc)->processOperation($sgc));
                    ]);
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processNotEqual(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let processedParams = $func.parameters->map(p | $p->processOperation($sgc));
   let left = $func.parameters->at(0);
   let right = $func.parameters->at(1);
   let processedLeft = $processedParams->at(0);
   let processedRight = $processedParams->at(1);
   let orNull =   if($left->instanceOf(Literal) && $right->instanceOf(Literal),
                     | '',
                     | if(!$left->instanceOf(Literal) && ($right->instanceOf(Literal) || $right->instanceOf(FreeMarkerOperationHolder)),
                          |' OR ' + $processedLeft + ' is null',
                          |if (($left->instanceOf(Literal) || $left->instanceOf(FreeMarkerOperationHolder)) && !$right->instanceOf(Literal),
                               |' OR ' + $processedRight + ' is null',
                               | ' OR ' + $processedLeft + ' is null' + ' AND ' + $processedRight + ' is not null' + ' OR ' + $processedLeft + ' is not null' + ' AND ' + $processedRight + ' is null'
                              )
                         )
                   );
   '(' + $processedLeft + ' <> ' + $processedRight + $orNull + ')';
}

function <<access.private>> meta::relational::functions::sqlQueryToString::processNotIn(func:DynaFunction[1], sgc:SqlGenerationContext[1]):String[1]
{
   let processedParams = $func.parameters->map(p | $p->processOperation($sgc));
   let processedLeft = $processedParams->at(0);
   let processedRight = $processedParams->at(1);
   '(' + $processedLeft + ' not in ' + if($processedRight->startsWith('(') && $processedRight->endsWith(')'), | $processedRight, | '(' + $processedRight + ')') + ' OR ' + $processedLeft + ' is null)';
}

function meta::relational::functions::sqlQueryToString::sqlNull():SQLNull[1]
{
    ^SQLNull();
}

function meta::relational::functions::sqlQueryToString::sqlTrue():Boolean[1]
{
    true;
}

function meta::relational::functions::sqlQueryToString::sqlFalse():Boolean[1]
{
    false;
}

function meta::relational::functions::sqlQueryToString::allGenerationStates(): GenerationState[*]
{
  let selectInsideWhen  = ^GenerationState(generationSide=GenerationSide.Select, withinWhenClause=true);
  let selectOutsideWhen = ^GenerationState(generationSide=GenerationSide.Select, withinWhenClause=false);
  let whereInsideWhen   = ^GenerationState(generationSide=GenerationSide.Where,  withinWhenClause=true);
  let whereOutsideWhen  = ^GenerationState(generationSide=GenerationSide.Where,  withinWhenClause=false);
  [$selectInsideWhen, $selectOutsideWhen, $whereInsideWhen, $whereOutsideWhen];
}

function meta::relational::functions::sqlQueryToString::selectOutsideWhenGenerationState(): GenerationState[1]
{
  ^GenerationState(generationSide=GenerationSide.Select, withinWhenClause=false);
}

function meta::relational::functions::sqlQueryToString::notSelectOutsideWhenGenerationStates(): GenerationState[*]
{
  let selectInsideWhen  = ^GenerationState(generationSide=GenerationSide.Select, withinWhenClause=true);
  let whereInsideWhen   = ^GenerationState(generationSide=GenerationSide.Where,  withinWhenClause=true);
  let whereOutsideWhen  = ^GenerationState(generationSide=GenerationSide.Where,  withinWhenClause=false);
  [$selectInsideWhen, $whereInsideWhen, $whereOutsideWhen];
}

function meta::relational::functions::sqlQueryToString::dynaFnToSql(dynafunctionName: String[1], generationStates:GenerationState[*], toSql:ToSql[1]): DynaFunctionToSql[1]
{
   ^DynaFunctionToSql(funcName=$dynafunctionName, stateMatch=$generationStates, toSql=$toSql);
}

function meta::relational::functions::sqlQueryToString::getDynaFunctionDispatcher(dispatch: Map<String, List<DynaFunctionToSql>>[1]): meta::pure::metamodel::function::Function<{DynaFunction[1], SqlGenerationContext[1]->DynaFunctionToSql[1]}>[1]
{
   { func:DynaFunction[1], sgc:SqlGenerationContext[1] |
        let result = $dispatch->get($func.name)->cast(@List<DynaFunctionToSql>).values->filter(d | $d.stateMatch->isEmpty() || $sgc.generationState->in($d.stateMatch));
        assertSize($result, 1, | '[unsupported-api] The function \''+$func.name+'\' (state: ['+$sgc.generationState.generationSide->id()+', '+if($sgc.generationState->isEmpty(),|'empty',|$sgc.generationState.withinWhenClause->toOne()->toString())+']) is not supported yet');
        assert($result.toSql.parametersWithinWhenClause->isEmpty() || ($result.toSql.parametersWithinWhenClause->size() >= $func.parameters->size()),|'Error generating \''+$func.name+'\' The function takes '+$func.parameters->size()->toString()+' parameters but '+$result.toSql.parametersWithinWhenClause->size()->toString()+' within where clause flag were provided.');
        $result->toOne();
   };
}

Class meta::relational::functions::sqlQueryToString::DynaFunctionToSql
{
   funcName:String[1];
   stateMatch:GenerationState[*];
   toSql: ToSql[1];

   toSql(parameters:RelationalOperationElement[*], sgcs:SqlGenerationContext[*])
   {
      let processedParams = $parameters->zip($sgcs)->map(p | $p.first->processOperation($p.second));
      let params = if($this.toSql.transform->isEmpty(), | $processedParams, | $this.toSql.transform->toOne()->eval($processedParams));

      format($this.toSql.format, $params);
   }:String[1];
}

Class meta::relational::functions::sqlQueryToString::ToSql
[
    !$this.format->contains(' when ') || !$this.parametersWithinWhenClause->isEmpty()
]
{
   format:String[1];
   transform:meta::pure::metamodel::function::Function<{String[*]->String[*]}>[0..1];
   parametersWithinWhenClause : Boolean[*];
}

Enum meta::relational::functions::sqlQueryToString::DynaFunctionRegistry
{
  abs,
  acos,
  add,
  adjust,
  and,
  asin,
  atan,
  atan2,
  average,
  averageRank,
  case,
  castBoolean,
  ceiling,
  coalesce,
  concat,
  contains,
  convertDate,
  convertDateTime,
  convertVarchar128,
  cos,
  count,
  dateDiff,
  datePart,
  dayOfMonth,
  dayOfWeek,
  dayOfWeekNumber,
  decodeBase64,
  denseRank,
  distinct,
  divide,
  encodeBase64,
  endsWith,
  equal,
  exists,
  exp,
  firstDayOfMonth,
  firstDayOfQuarter,
  firstDayOfThisMonth,
  firstDayOfThisQuarter,
  firstDayOfThisYear,
  firstDayOfWeek,
  firstDayOfYear,
  floor,
  extractFromSemiStructured,
  greaterThan,
  greaterThanEqual,
  group,
  hour,
  if,
  in,
  indexOf,
  isAlphaNumeric,
  isDistinct,
  isEmpty,
  isNotEmpty,
  isNotNull,
  isNull,
  isNumeric,
  joinStrings,
  left,
  length,
  lessThan,
  lessThanEqual,
  log,
  ltrim,
  matches,
  max,
  min,
  minus,
  minute,
  mod,
  month,
  monthNumber,
  mostRecentDayOfWeek,
  not,
  notEqual,
  notEqualAnsi,
  now,
  objectReferenceIn,
  or,
  parseDate,
  parseDecimal,
  parseFloat,
  parseInteger,
  parseJson,
  percentile,
  plus,
  position,
  pow,
  previousDayOfWeek,
  quarter,
  quarterNumber,
  rank,
  rem,
  replace,
  right,
  round,
  rowNumber,
  rtrim,
  second,
  sin,
  size,
  sqlFalse,
  sqlNull,
  sqlTrue,
  sqrt,
  startsWith,
  stdDevPopulation,
  stdDevSample,
  sub,
  substring,
  sum,
  tan,
  times,
  toLower,
  toOne,
  toString,
  toTimestamp,
  toUpper,
  today,
  trim,
  weekOfYear,
  year
}
