// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::relational::mapping::*;
import meta::relational::runtime::*;
import meta::relational::validation::*;
import meta::relational::tests::model::simple::*;
import meta::relational::tests::*;
import meta::pure::profiles::*;
import meta::pure::metamodel::tds::*;


function <<test.Test, test.ExcludeAlloy>> meta::relational::tests::tds::groupBy::testValidateTdsGroupByWithIsNotEmpty():Boolean[1]
{
   let runtime = testRuntime();
   let connection = $runtime.connections->at(0)->cast(@DatabaseConnection);
   meta::relational::metamodel::execute::executeInDb('insert into tradeTable (id, prodid, accountId, quantity, tradeDate, settlementDateTime) values (9, 3, 2, 45, \'2014-12-04\', \'2014-12-05 22:00:00\');', $connection);
   
   let result = validate(|AccountWithConstraints.all(), simpleRelationalMappingWithConstraints, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(1, $tds.rows->size());
   assertEquals(['tradesNotDoubleBooked', 'Error', 'Account has more than one trade with the same id', 2], $tds.rows->at(0).values);
   assertEquals('select \'tradesNotDoubleBooked\' as "CONSTRAINT_ID", \'Error\' as "ENFORCEMENT_LEVEL", \'Account has more than one trade with the same id\' as "MESSAGE", "root".ID as "ID" from accountTable as "root" left outer join (select distinct "tradetable_0".accountID, "tradetable_0".ID as "tradeId" from accountTable as "root" left outer join tradeTable as "tradetable_0" on ("tradetable_0".accountID = "root".ID) group by "tradetable_0".accountID,"tradeId" having count(*) > 1) as "accounttable_1" on ("accounttable_1".accountID = "root".ID) where not "accounttable_1".accountID is null', $result->sqlRemoveFormatting());
}


function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupCount():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', agg('cnt', x|$x, y| $y->count()))
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals([String, Integer], $result.values.columns.type);
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 2], $tds.rows->at(0).values);
   assertEquals(['Firm C', 5], $tds.rows->at(1).values);
   assertEquals(['Firm A', 3], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 1], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", count(*) as "cnt" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

// Alloy exclusion reason: 10. Tricky usage of variables
function <<test.Test, test.ExcludeAlloy>> meta::relational::tests::tds::groupBy::simpleGroupCountUsingVariables():Boolean[1]
{
   let aggFunc = agg('cnt', x|$x, y| $y->count());
   let columnName = 'prodName';
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy($columnName, $aggFunc)
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 2], $tds.rows->at(0).values);
   assertEquals(['Firm C', 5], $tds.rows->at(1).values);
   assertEquals(['Firm A', 3], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 1], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", count(*) as "cnt" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}


function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupDistinctCount():Boolean[1]
{
   let result = execute(|Interaction.all()->project([#/Interaction/source/name!sourceName#, #/Interaction/id!myId#])->groupBy(['sourceName'], agg('count', a|$a.getInteger('myId'), b|$b->distinct()->count()))->sort([desc('count'), asc('sourceName')]), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertSize($tds.rows, 4);
   assertEquals(['Anthony Allen', 3], $tds.rows->at(0).values);
   assertEquals(['John Hill', 2], $tds.rows->at(1).values);
   assertEquals(['Peter Smith', 2], $tds.rows->at(2).values);
   assertEquals(['Fabrice Roberts', 1], $tds.rows->at(3).values);
   assertEquals('select concat("persontable_0".FIRSTNAME, \' \', "persontable_0".LASTNAME) as "sourceName", count(distinct("root".ID)) as "count" from interactionTable as "root" left outer join personTable as "persontable_0" on ("root".sourceId = "persontable_0".ID) group by "sourceName" order by "count" desc,"sourceName"', $result->sqlRemoveFormatting());
}


function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupBySum():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', agg('sum', x|$x.getFloat('quantity'), y| $y->sum()))
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 345.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 176.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 66.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 5.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", sum("root".quantity) as "sum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupConstantAggregates():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', [
                          agg('sum', x|1, y| $y->sum()),
                          agg('count', x|$x, y| $y->count())
                         ])
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 2, 2], $tds.rows->at(0).values);
   assertEquals(['Firm C', 5, 5], $tds.rows->at(1).values);
   assertEquals(['Firm A', 3, 3], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 1, 1], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", sum(1) as "sum", count(*) as "count" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

// Alloy exclusion reason: 10. Tricky usage of variables
function <<test.Test, test.ExcludeAlloy>> meta::relational::tests::tds::groupBy::simpleGroupByAggFuncAsVariable():Boolean[1]
{
   let aggFunc = agg('sum', x|$x.getFloat('quantity'), y| $y->sum());
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', $aggFunc)
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 345.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 176.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 66.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 5.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", sum("root".quantity) as "sum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

// Alloy exclusion reason: 10. Tricky usage of variables
function <<test.Test, test.ExcludeAlloy>> meta::relational::tests::tds::groupBy::simpleGroupByAggFuncAsLambda():Boolean[1]
{
   let fn = {| let aggFunc = agg('sum', x|$x.getFloat('quantity'), y| $y->sum());
              Trade.all()->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', $aggFunc)
                         ->sort(desc('prodName'));};
   let result = execute($fn, simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 345.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 176.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 66.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 5.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", sum("root".quantity) as "sum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupByAggFuncAsLambdaWithTake():Boolean[1]
{
   let fn = {| 
              Trade.all()->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', agg('sum', x|$x.getFloat('quantity'), y| $y->sum()))
                         ->sort(desc('prodName'))
                         ->take(100)
                         ;};
   let result = execute($fn, simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 345.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 176.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 66.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 5.0], $tds.rows->at(3).values);
   assertEquals('select top 100 "producttable_0".NAME as "prodName", sum("root".quantity) as "sum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}


function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupByAverage():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!qty#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', agg('avg', x|$x.getFloat('qty'), y| $y->average()))
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 172.5], $tds.rows->at(0).values);
   assertEquals(['Firm C', 35.2], $tds.rows->at(1).values);
   assertEquals(['Firm A', 22.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 5.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", avg(1.0 * "root".quantity) as "avg" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}



function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupByTwo():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', [agg('count', x|$x, y| $y->count()), agg('sum', x|$x.getFloat('quantity'), y| $y->sum())])
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 2, 345.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 5, 176.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 3, 66.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 1, 5.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", count(*) as "count", sum("root".quantity) as "sum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}


function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupByMax():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', agg('max', x|$x.getFloat('quantity'), y| $y->max()->toOne()))
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 320.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 45.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 32.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 5.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", max("root".quantity) as "max" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupByMin():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', agg('min', x|$x.getFloat('quantity'), y| $y->min()->toOne()))
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 25.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 22.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 11.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 5.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", min("root".quantity) as "min" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::GroupByWithMapFnConstant():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', agg('sum', x|$x.getFloat('quantity')*3, y| $y->sum()))
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 1035.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 528.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 198.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 15.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", sum(("root".quantity * 3)) as "sum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::GroupByWithMapFnColumns():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', agg('sum', x|$x.getFloat('quantity')*$x.getInteger('quantity'), y| $y->sum()))
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 103025.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 6618.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 1674.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 25.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", sum(("root".quantity * "root".quantity)) as "sum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::GroupByWithIfInMap():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', agg('sum', x|if($x.getFloat('quantity') > 2.0,|$x.getFloat('quantity'),|$x.getFloat('quantity')/2), y| $y->sum()))
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 345.0], $tds.rows->at(0).values);
   assertEquals(['Firm C', 176.0], $tds.rows->at(1).values);
   assertEquals(['Firm A', 66.0], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), 5.0], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", sum(case when "root".quantity > 2.0 then "root".quantity else ((1.0 * "root".quantity) / 2) end) as "sum" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupByWithJoinStrings():Boolean[1]
{
   let result = execute(|Person.all()
                         ->project([#/Person/firstName!firstName#,#/Person/lastName!lastName#])
                         ->groupBy('firstName', agg('lastNames', x|$x.getString('lastName'), y|$y->joinStrings('*'))), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(6, $tds.rows->size());
   assertEquals(['Smith'], $tds.rows->filter(p | $p.getString('firstName') == 'Peter')->first()->toOne().getString('lastNames'));
   assertEquals(['Johnson*Hill'], $tds.rows->filter(p | $p.getString('firstName') == 'John')->first()->toOne().getString('lastNames'));
   assertEquals([], $tds.rows->filter(p | $p.getString('firstName') == 'Unknown'));
   assertEquals('select "root".FIRSTNAME as "firstName", group_concat("root".LASTNAME separator \'*\') as "lastNames" from personTable as "root" group by "firstName"', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::simpleGroupByWithAssociationWithJoinStrings():Boolean[1]
{
   let result = execute(|Firm.all()
                         ->project([#/Firm/legalName!legalName#,#/Firm/employees/lastName!lastName#])
                         ->groupBy('legalName', agg('lastNames', x|$x.getString('lastName'), y|$y->joinStrings('*'))), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Smith*Johnson*Hill*Allen'], $result.values->first().rows->filter(r | $r.getString('legalName') == 'Firm X')->first()->toOne().getString('lastNames'));
   assertEquals(['Harris'], $result.values->first().rows->filter(r | $r.getString('legalName') == 'Firm C')->first()->toOne().getString('lastNames'));
   assertEquals('select "root".LEGALNAME as "legalName", group_concat("persontable_0".LASTNAME separator \'*\') as "lastNames" from firmTable as "root" left outer join personTable as "persontable_0" on ("root".ID = "persontable_0".FIRMID) group by "legalName"', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::groupByAfterASortOnColumnInGroupBy():Boolean[1]
{
   let result = execute(|Firm.all()
                         ->project([#/Firm/legalName!legalName#,#/Firm/employees/lastName!lastName#])
                         ->sort('legalName')
                         ->groupBy('legalName', agg('lastNames', x|$x.getString('lastName'), y|$y->joinStrings('*'))), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Smith*Johnson*Hill*Allen'], $result.values->first().rows->filter(r | $r.getString('legalName') == 'Firm X')->first()->toOne().getString('lastNames'));
   assertEquals(['Harris'], $result.values->first().rows->filter(r | $r.getString('legalName') == 'Firm C')->first()->toOne().getString('lastNames'));
   assertEquals('select "root".LEGALNAME as "legalName", group_concat("persontable_0".LASTNAME separator \'*\') as "lastNames" from firmTable as "root" left outer join personTable as "persontable_0" on ("root".ID = "persontable_0".FIRMID) group by "legalName" order by "legalName"', $result->sqlRemoveFormatting());
}


function <<test.Test>> meta::relational::tests::tds::groupBy::groupByAfterASortOnColumnNotInGroupBy():Boolean[1]
{
   let result = execute(|Firm.all()
                         ->project([#/Firm/legalName!legalName#,#/Firm/employees/lastName!lastName#])
                         ->sort('lastName')
                         ->groupBy('legalName', agg('lastNames', x|$x.getString('lastName'), y|$y->joinStrings('*'))), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Allen*Hill*Johnson*Smith'], $result.values->first().rows->filter(r | $r.getString('legalName') == 'Firm X')->first()->toOne().getString('lastNames'));
   assertEquals(['Harris'], $result.values->first().rows->filter(r | $r.getString('legalName') == 'Firm C')->first()->toOne().getString('lastNames'));
   assertEquals('select "firmtable_0"."legalName" as "legalName", group_concat("lastName" separator \'*\') as "lastNames" from (select "root".LEGALNAME as "legalName", "persontable_0".LASTNAME as "lastName" from firmTable as "root" left outer join personTable as "persontable_0" on ("root".ID = "persontable_0".FIRMID) order by "lastName") as "firmtable_0" group by "legalName"', $result->sqlRemoveFormatting());
}

// Alloy exclusion reason: 10. Tricky usage of variables
function <<test.Test, test.ExcludeAlloy>> meta::relational::tests::tds::groupBy::simpleGroupByAggFuncNotStopFunc():Boolean[1]
{
   //agg deliberately instantiated here, and has to use a non stop function, e.g. uniqueValueOnly
   let aggFunc = agg('unique', x|$x.getFloat('prodName'), y| $y->uniqueValueOnly()->toOne());
   let result = execute(|Trade.all()
                         ->project([#/Trade/product/name!prodName#])
                         ->groupBy('prodName', $aggFunc)
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(['Firm X', 'Firm X'], $tds.rows->at(0).values);
   assertEquals(['Firm C', 'Firm C'], $tds.rows->at(1).values);
   assertEquals(['Firm A', 'Firm A'], $tds.rows->at(2).values);
   assertEquals([^TDSNull(), ^TDSNull()], $tds.rows->at(3).values);
   assertEquals('select "producttable_0".NAME as "prodName", case when count(distinct("producttable_0".NAME)) = 1 then max("producttable_0".NAME) else null end as "unique" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::groupByAfterConcatenate():Boolean[1]
{
   let result = execute(|Firm.all()
                         ->project([#/Firm/legalName!legalName#,#/Firm/employees/lastName!lastName#])
                         ->concatenate(
                            Firm.all()
                               ->project([#/Firm/legalName!legalName#,#/Firm/employees/lastName!lastName#])
                         )
                         ->distinct()
                         ->groupBy('legalName', agg('lastNamesCount', x|$x.getString('lastName'), y|$y->distinct()->count())), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   let tds = $result.values->at(0);
   assertEquals(4, $tds.rows->size());
   assertEquals(4, $result.values->first().rows->filter(r | $r.getString('legalName') == 'Firm X')->first()->toOne().getInteger('lastNamesCount')->sort());
   assertEquals('select "unionalias_0"."legalName" as "legalName", count(distinct("lastName")) as "lastNamesCount" from (select distinct "unionalias_1"."legalName" as "legalName", "unionalias_1"."lastName" as "lastName" from (select "root".LEGALNAME as "legalName", "persontable_0".LASTNAME as "lastName" from firmTable as "root" left outer join personTable as "persontable_0" on ("root".ID = "persontable_0".FIRMID) UNION ALL select "root".LEGALNAME as "legalName", "persontable_0".LASTNAME as "lastName" from firmTable as "root" left outer join personTable as "persontable_0" on ("root".ID = "persontable_0".FIRMID)) as "unionalias_1") as "unionalias_0" group by "legalName"', $result->sqlRemoveFormatting());
}

function <<test.Test>> meta::relational::tests::tds::groupBy::testTableToTDSWithQuotedColumns():Boolean[1]
{
   let queryWithoutQuotes = {|tableToTDS(meta::relational::functions::database::tableReference(meta::relational::tests::db, 'default', 'tableWithQuotedColumns'))
                                   ->project([
                               col({r:TDSRow[1]|$r.getString('FIRST NAME')}, 'FIRST NAME'),
                               col({r:TDSRow[1]|$r.getString('LAST NAME')}, 'LAST NAME'),
                               col({r:TDSRow[1]|$r.getString('1columnStartsWithNumber')}, '1columnStartsWithNumber')


                              ])
                                 ->restrict(['FIRST NAME'])
                                 ->groupBy(['FIRST NAME'], agg('cnt', x|$x.getString('FIRST NAME'), y|$y->count()))
                            };
   
   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();
   let resWithoutQuotes = execute($queryWithoutQuotes, $mapping, $runtime, meta::relational::extension::relationalExtensions());
   
   let expectedSql = 'select "root"."FIRST NAME" as "FIRST NAME", count("root"."FIRST NAME") as "cnt" from tableWithQuotedColumns as "root" group by "FIRST NAME"';
   
   assertEquals($expectedSql, $resWithoutQuotes->sqlRemoveFormatting());
   
   let queryWithQuotes = {|tableToTDS(meta::relational::functions::database::tableReference(meta::relational::tests::db, 'default', 'tableWithQuotedColumns'))
                                    ->project([
                               col({r:TDSRow[1]|$r.getString('FIRST NAME')}, 'FIRST NAME'),
                               col({r:TDSRow[1]|$r.getString('LAST NAME')}, 'LAST NAME'),
                               col({r:TDSRow[1]|$r.getString('1columnStartsWithNumber')}, '1columnStartsWithNumber')


                              ])
                                 ->restrict(['"FIRST NAME"'])
                                 ->groupBy(['"FIRST NAME"'], agg('cnt', x|$x.getString('"FIRST NAME"'), y|$y->count()))
                            };
   
   let resWithQuotes = execute($queryWithoutQuotes, $mapping, $runtime, meta::relational::extension::relationalExtensions());
   
   assertEquals($expectedSql, $resWithQuotes->sqlRemoveFormatting());   
}

function <<test.Test, test.AlloyOnly>> meta::relational::tests::tds::groupBy::testTDSGroupByPercentile():Boolean[1]
{
   let result = execute(|Trade.all()
                         ->project([#/Trade/quantity!quantity#, #/Trade/product/name!prodName#])
                         ->groupBy('prodName', [agg('p1', x|$x.getFloat('quantity')+2, y|$y->percentile(0.9)->toOne()), agg('p2', x|$x.getFloat('quantity')+2, y|$y->percentile(0.5, false, false)->toOne()), agg('p3', x|$x.getFloat('quantity')+2, y|$y->percentile(0.75, true, true)->toOne())])
                         ->sort(desc('prodName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals(['Firm X|292.5|322.0|248.25', 'Firm C|46.6|40.0|46.0', 'Firm A|32.2|25.0|29.5', 'TDSNull|7.0|7.0|7.0'], $result.values.rows->map(r|$r.values->makeString('|')));
   meta::relational::functions::asserts::assertSameSQL('select "producttable_0".NAME as "prodName", percentile_cont(0.9) within group (order by ("root".quantity + 2) asc) as "p1", percentile_disc(0.5) within group (order by ("root".quantity + 2) desc) as "p2", percentile_cont(0.75) within group (order by ("root".quantity + 2) asc) as "p3" from tradeTable as "root" left outer join productSchema.productTable as "producttable_0" on ("root".prodId = "producttable_0".ID) group by "prodName" order by "prodName" desc', $result);
}

function <<test.Test>> meta::relational::tests::tds::groupBy::testTDSGroupByIsDistinct():Boolean[1]
{
   let result = execute(|Firm.all()
                         ->project([#/Firm/legalName!LegalName#, #/Firm/employees/firstName!firstName#, #/Firm/employees/lastName!lastName#])
                         ->groupBy('LegalName', [agg('FirstNameIsDistinct', x|$x.getString('firstName'), y|$y->isDistinct()), agg('LastNameIsDistinct', x|$x.getString('lastName'), y|$y->isDistinct())])
                         ->sort(desc('LegalName')), simpleRelationalMapping, testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals(['Firm X|false|true', 'Firm C|true|true', 'Firm B|true|true', 'Firm A|true|true'], $result.values.rows->map(r|$r.values->makeString('|')));
   meta::relational::functions::asserts::assertSameSQL('select "root".LEGALNAME as "LegalName", count(distinct("persontable_0".FIRSTNAME)) = count("persontable_0".FIRSTNAME) as "FirstNameIsDistinct", count(distinct("persontable_0".LASTNAME)) = count("persontable_0".LASTNAME) as "LastNameIsDistinct" from firmTable as "root" left outer join personTable as "persontable_0" on ("root".ID = "persontable_0".FIRMID) group by "LegalName" order by "LegalName" desc', $result);
}

function <<test.Test>> meta::relational::tests::tds::groupBy::testTDSGroupByEmptyColsTerminalOperation():Boolean[1]
{
   let result = execute(
      |Firm.all()
         ->project([col(x | $x.legalName, 'Legal Name')])
         ->groupBy([], [agg('Firm Count', x|$x, y|$y->count())]),
      simpleRelationalMapping,
      meta::relational::tests::testRuntime(),
      meta::relational::extension::relationalExtensions());
   
   assertEquals(['4'], $result.values.rows->map(r|$r.values->makeString('|')));
   meta::relational::functions::asserts::assertSameSQL('select count(*) as "Firm Count" from firmTable as "root"', $result);
}

function <<test.Test>> meta::relational::tests::tds::groupBy::testTDSGroupByEmptyColsNonTerminalOperation():Boolean[1]
{
   let result = execute(
      |Firm.all()
         ->project([col(x | $x.legalName, 'Legal Name')])
         ->groupBy([], [agg('Firm Count', x|$x, y|$y->count())])
         ->filter(r | $r.getInteger('Firm Count') > 10),
      simpleRelationalMapping,
      meta::relational::tests::testRuntime(),
      meta::relational::extension::relationalExtensions());
   
   assertEquals([], $result.values.rows->map(r|$r.values->makeString('|')));
   meta::relational::functions::asserts::assertSameSQL('select "Firm Count" as "Firm Count" from (select count(*) as "Firm Count" from firmTable as "root") as "subselect" where "Firm Count" > 10', $result);
}
