// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::modelToModel::test::createInstances::*;
import meta::relational::postProcessor::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::pure::mapping::modelToModel::test::shared::*;
import meta::pure::mapping::modelToModel::test::enumerationMapping::enumToEnum::mapping::*;
import meta::pure::mapping::modelToModel::test::enumerationMapping::enumToEnum::model::*;
import meta::pure::mapping::modelToModel::test::enumeration::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::executionPlan::tests::datetime::*;
import meta::relational::tests::tds::tabletds::*;
import meta::pure::mapping::*;
import meta::relational::mapping::*;
import meta::relational::runtime::*;
import meta::relational::tests::mapping::inheritance::relational::*;
import meta::relational::metamodel::join::*;
import meta::relational::tests::tds::tdsJoin::*;
import meta::pure::executionPlan::toString::*;
import meta::pure::executionPlan::tests::*;
import meta::relational::tests::groupBy::datePeriods::mapping::*;
import meta::relational::tests::groupBy::datePeriods::*;
import meta::relational::tests::groupBy::datePeriods::domain::*;
import meta::pure::executionPlan::*;
import meta::relational::tests::*;
import meta::relational::tests::model::simple::*;
import meta::pure::runtime::*;
import meta::pure::mapping::modelToModel::test::shared::src::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::pure::graphFetch::routing::*;

function meta::pure::executionPlan::tests::templateFunctionsList():String[*]
{
   ['<#function renderCollection collection separator prefix suffix defaultValue><#if collection?size == 0><#return defaultValue></#if><#return prefix + collection?join(suffix + separator + prefix) + suffix></#function>',
    '<#function collectionSize collection> <#return collection?size?c> </#function>',
    '<#function optionalVarPlaceHolderOperationSelector optionalParameter trueClause falseClause><#if optionalParameter?has_content || optionalParameter?is_string><#return trueClause><#else><#return falseClause></#if></#function>',
    '<#function varPlaceHolderToString optionalParameter prefix suffix defaultValue><#if optionalParameter?is_enumerable && !optionalParameter?has_content><#return defaultValue><#else><#return prefix + optionalParameter + suffix></#if></#function>'];
}

function meta::pure::executionPlan::tests::assertPlanGenerationForOptionalParameter(dbType:DatabaseType[1], expectedPlan:String[1]):Boolean[1]
{
   let generatedPlan = executionPlan({optionalID: String[0..1], optionalActive: Boolean[0..1]|Interaction.all()->filter(i|$i.id==$optionalID && $i.active==$optionalActive)->project(col(i|$i.time, 'Time'))}, simpleRelationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=$dbType)), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   assertEquals($expectedPlan, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function meta::pure::executionPlan::tests::assertPlanGenerationForOptionalParameterWithGreaterThanLessThan(func:FunctionDefinition<Any>[1], dbType:DatabaseType[1], expectedPlan:String[1]):Boolean[1]
{
   let generatedPlan = executionPlan($func, simpleRelationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=$dbType)), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   assertEquals($expectedPlan, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_SybaseIQ():Boolean[1]      
{  
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root"."time" as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root"."active" = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when "root"."active" = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "SybaseIQ")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameter(DatabaseType.SybaseIQ, $expectedPlan);                     
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_DB2():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root".time as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "DB2")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
                                   
   assertPlanGenerationForOptionalParameter(DatabaseType.DB2, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_Sybase():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root".time as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "Sybase")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n'; 
   
   assertPlanGenerationForOptionalParameter(DatabaseType.Sybase, $expectedPlan); 
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_MemSQL():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select `root`.time as `Time` from interactionTable as `root` where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'`root`.ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'`root`.ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when `root`.active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when `root`.active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "MemSQL")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n'; 
   
   assertPlanGenerationForOptionalParameter(DatabaseType.MemSQL, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_Snowflake():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root".time as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "Snowflake")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameter(DatabaseType.Snowflake, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_Presto():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root".time as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "" "" "null")}\', \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "Presto")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameter(DatabaseType.Presto, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_Redshift():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root".time as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "Redshift")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameter(DatabaseType.Redshift, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_BigQuery():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select `root`.time as `Time` from interactionTable as `root` where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'`root`.ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'`root`.ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when `root`.active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when `root`.active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "BigQuery")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n'; 
   
   assertPlanGenerationForOptionalParameter(DatabaseType.BigQuery, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_Composite():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root".time as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "Composite")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameter(DatabaseType.Composite, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_Hive():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root".time as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "Hive")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameter(DatabaseType.Hive, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_Postgres():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root".time as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "Text\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root".active = Text\\\'Y\\\' then Text\\\'true\\\' else Text\\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "Boolean\\\'" "\\\'" "null")}\', \'case when "root".active = Text\\\'Y\\\' then Text\\\'true\\\' else Text\\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "Postgres")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameter(DatabaseType.Postgres, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameter_H2():Boolean[1]      
{
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(Time, Integer, INT, "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalID:String[0..1], optionalActive:Boolean[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(Time, Integer, INT, "")]\n'+
                     '      resultColumns = [("Time", INT)]\n'+
                     '      sql = select "root".time as "Time" from interactionTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalID![], \'"root".ID = ${varPlaceHolderToString(optionalID![]  "\\\'" "\\\'" "null")}\', \'"root".ID is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalActive![], \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end = ${varPlaceHolderToString(optionalActive![]  "\\\'" "\\\'" "null")}\', \'case when "root".active = \\\'Y\\\' then \\\'true\\\' else \\\'false\\\' end is null\')}))\n'+
                     '      connection = DatabaseConnection(type = "H2")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameter(DatabaseType.H2, $expectedPlan);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameterString():Boolean[1]{
   let generatedPlan = executionPlan({optionalStreet: String[0..1]|Address.all()->filter(a|$a.street==$optionalStreet && $optionalStreet == $a.street)->project(col(a|$a.name, 'Name'))}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = TDS[(Name, String, VARCHAR(200), "")]\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalStreet:String[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = TDS[(Name, String, VARCHAR(200), "")]\n'+
                  '      resultColumns = [("Name", VARCHAR(200))]\n'+
                  '      sql = select "root".NAME as "Name" from addressTable as "root" where ((${optionalVarPlaceHolderOperationSelector(optionalStreet![], \'"root".STREET = ${varPlaceHolderToString(optionalStreet![]  "\\\'" "\\\'" "null")}\', \'"root".STREET is null\')}) and (${optionalVarPlaceHolderOperationSelector(optionalStreet![], \'${varPlaceHolderToString(optionalStreet![]  "\\\'" "\\\'" "null")} = "root".STREET\', \'"root".STREET is null\')}))\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';

   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameterFloat():Boolean[1]
{
   let generatedPlan = executionPlan({optionalPnl: Float[0..1]|Order.all()->filter(x|$x.pnl==$optionalPnl)}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]\n'+
                  '  resultSizeRange = *\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalPnl:Float[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]\n'+
                  '      resultSizeRange = *\n'+
                  '      resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]\n'+
                  '      sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where (${optionalVarPlaceHolderOperationSelector(optionalPnl![], \'"orderPnlView_d#2_d#2_m5".pnl = ${varPlaceHolderToString(optionalPnl![]  "" "" "null")}\', \'"orderPnlView_d#2_d#2_m5".pnl is null\')})\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';

   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameterInteger():Boolean[1]
{
   let generatedPlan = executionPlan({optionalAge: Integer[0..1]|Person.all()->filter(p|$p.age==$optionalAge)}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                  '  resultSizeRange = *\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalAge:Integer[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                  '      resultSizeRange = *\n'+
                  '      resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("age", INT), ("lastName", VARCHAR(200))]\n'+
                  '      sql = select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" where (${optionalVarPlaceHolderOperationSelector(optionalAge![], \'"root".AGE = ${varPlaceHolderToString(optionalAge![]  "" "" "null")}\', \'"root".AGE is null\')})\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';


   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameterDate():Boolean[1]
{
   let generatedPlan = executionPlan({optionalCensusDate: Date[0..1]|Location.all()->filter(t|$t.censusdate==$optionalCensusDate)}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = Class[impls=(meta::relational::tests::model::simple::Location | simpleRelationalMappingInc.meta_relational_tests_model_simple_Location)]\n'+
                  '  resultSizeRange = *\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalCensusDate:Date[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = Class[impls=(meta::relational::tests::model::simple::Location | simpleRelationalMappingInc.meta_relational_tests_model_simple_Location)]\n'+
                  '      resultSizeRange = *\n'+
                  '      resultColumns = [("pk_0", INT), ("place", VARCHAR(200)), ("censusdate", DATE)]\n'+
                  '      sql = select "root".ID as "pk_0", "root".PLACE as "place", "root".date as "censusdate" from locationTable as "root" where (${optionalVarPlaceHolderOperationSelector(optionalCensusDate![], \'"root".date = ${varPlaceHolderToString(optionalCensusDate![]  "\\\'" "\\\'" "null")}\', \'"root".date is null\')})\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';

   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameterDateTimeWithNoTimeZone():Boolean[1]
{
   let connectionWithNoTimeZone = ^TestDatabaseConnection(element = db, type=DatabaseType.H2);
   let runtime = ^Runtime(connections = $connectionWithNoTimeZone);
   let generatedPlan = executionPlan({optionalSettlementDateTime:DateTime[0..1]|Order.all()->filter(o|$o.settlementDateTime == $optionalSettlementDateTime)}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]\n'+
                  '  resultSizeRange = *\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalSettlementDateTime:DateTime[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]\n'+
                  '      resultSizeRange = *\n'+
                  '      resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]\n'+
                  '      sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where (${optionalVarPlaceHolderOperationSelector(optionalSettlementDateTime![], \'"root".settlementDateTime = ${varPlaceHolderToString(optionalSettlementDateTime![]  "\\\'" "\\\'" "null")}\', \'"root".settlementDateTime is null\')})\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';

   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test, test.ToFix>> meta::pure::executionPlan::tests::testFilterEqualsWithOptionalParameterDateTimeWithTimeZone():Boolean[1]
{
   // VarPlaceHolder logic for DateTime datatype when timeZone is provided is not handled when its multiplicity has lowerBound as Zero.
   // Should return a SQL that can handle the case when DateTime variable with TimeZone does not have a value during execution.
   let connectionEST = ^TestDatabaseConnection(element = db, type=DatabaseType.H2, timeZone='US/Arizona');
   let runtime = ^Runtime(connections = $connectionEST);
   let generatedPlan = executionPlan({optionalSettlementDateTime:DateTime[0..1]|Order.all()->filter(o|$o.settlementDateTime == $optionalSettlementDateTime)}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   false;
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithTwoOptionalParametersString():Boolean[1]
{
   let generatedPlan = executionPlan({optionalLeft: String[0..1], optionalRight :String[0..1]|Address.all()->filter(a|$optionalLeft==$optionalRight)}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '  resultSizeRange = *\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalLeft:String[0..1], optionalRight:String[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '      resultSizeRange = *\n'+
                  '      resultColumns = [("pk_0", INT), ("name", VARCHAR(200)), ("street", VARCHAR(100)), ("type", INT), ("comments", VARCHAR(100))]\n'+
                  '      sql = select "root".ID as "pk_0", "root".NAME as "name", "root".STREET as "street", "root".TYPE as "type", "root".COMMENTS as "comments" from addressTable as "root" where (${optionalVarPlaceHolderOperationSelector(optionalLeft![], optionalVarPlaceHolderOperationSelector(optionalRight![], \'${varPlaceHolderToString(optionalLeft![]  "\\\'" "\\\'" "null")} = ${varPlaceHolderToString(optionalRight![]  "\\\'" "\\\'" "null")}\', \'1 = 0\'), optionalVarPlaceHolderOperationSelector(optionalRight![], \'1 = 0\', \'1 = 1\'))})\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';
   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithTwoOptionalParametersInteger():Boolean[1]
{
   let generatedPlan = executionPlan({optionalIntLeft: Integer[0..1], optionalIntRight :Integer[0..1]|Address.all()->filter(a|$optionalIntLeft==$optionalIntRight)}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '  resultSizeRange = *\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalIntLeft:Integer[0..1], optionalIntRight:Integer[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '      resultSizeRange = *\n'+
                  '      resultColumns = [("pk_0", INT), ("name", VARCHAR(200)), ("street", VARCHAR(100)), ("type", INT), ("comments", VARCHAR(100))]\n'+
                  '      sql = select "root".ID as "pk_0", "root".NAME as "name", "root".STREET as "street", "root".TYPE as "type", "root".COMMENTS as "comments" from addressTable as "root" where (${optionalVarPlaceHolderOperationSelector(optionalIntLeft![], optionalVarPlaceHolderOperationSelector(optionalIntRight![], \'${varPlaceHolderToString(optionalIntLeft![]  "" "" "null")} = ${varPlaceHolderToString(optionalIntRight![]  "" "" "null")}\', \'1 = 0\'), optionalVarPlaceHolderOperationSelector(optionalIntRight![], \'1 = 0\', \'1 = 1\'))})\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';
   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithTwoOptionalParametersFloat():Boolean[1]
{
   let generatedPlan = executionPlan({optionalFloatLeft: Float[0..1], optionalFloatRight :Float[0..1]|Address.all()->filter(a|$optionalFloatLeft==$optionalFloatRight)}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '  resultSizeRange = *\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalFloatLeft:Float[0..1], optionalFloatRight:Float[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '      resultSizeRange = *\n'+
                  '      resultColumns = [("pk_0", INT), ("name", VARCHAR(200)), ("street", VARCHAR(100)), ("type", INT), ("comments", VARCHAR(100))]\n'+
                  '      sql = select "root".ID as "pk_0", "root".NAME as "name", "root".STREET as "street", "root".TYPE as "type", "root".COMMENTS as "comments" from addressTable as "root" where (${optionalVarPlaceHolderOperationSelector(optionalFloatLeft![], optionalVarPlaceHolderOperationSelector(optionalFloatRight![], \'${varPlaceHolderToString(optionalFloatLeft![]  "" "" "null")} = ${varPlaceHolderToString(optionalFloatRight![]  "" "" "null")}\', \'1 = 0\'), optionalVarPlaceHolderOperationSelector(optionalFloatRight![], \'1 = 0\', \'1 = 1\'))})\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';

   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithTwoOptionalParametersDate():Boolean[1]
{
   let generatedPlan = executionPlan({optionalDateLeft: Date[0..1], optionalDateRight :Date[0..1]|Address.all()->filter(a|$optionalDateLeft==$optionalDateRight)}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '  resultSizeRange = *\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalDateLeft:Date[0..1], optionalDateRight:Date[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '      resultSizeRange = *\n'+
                  '      resultColumns = [("pk_0", INT), ("name", VARCHAR(200)), ("street", VARCHAR(100)), ("type", INT), ("comments", VARCHAR(100))]\n'+
                  '      sql = select "root".ID as "pk_0", "root".NAME as "name", "root".STREET as "street", "root".TYPE as "type", "root".COMMENTS as "comments" from addressTable as "root" where (${optionalVarPlaceHolderOperationSelector(optionalDateLeft![], optionalVarPlaceHolderOperationSelector(optionalDateRight![], \'${varPlaceHolderToString(optionalDateLeft![]  "\\\'" "\\\'" "null")} = ${varPlaceHolderToString(optionalDateRight![]  "\\\'" "\\\'" "null")}\', \'1 = 0\'), optionalVarPlaceHolderOperationSelector(optionalDateRight![], \'1 = 0\', \'1 = 1\'))})\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';

   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testFilterEqualsWithTwoOptionalParametersDateTimeWithNoTimeZone():Boolean[1]
{
   let connectionWithNoTimeZone = ^TestDatabaseConnection(element = db, type=DatabaseType.H2);
   let runtime = ^Runtime(connections = $connectionWithNoTimeZone);
   let generatedPlan = executionPlan({optionalLeft: DateTime[0..1], optionalRight :DateTime[0..1]|Address.all()->filter(a|$optionalLeft==$optionalRight)}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
   let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions());
   let expected = 'Sequence\n'+
                  '(\n'+
                  '  type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '  resultSizeRange = *\n'+
                  '  (\n'+
                  '    FunctionParametersValidationNode\n'+
                  '    (\n'+
                  '      functionParameters = [optionalLeft:DateTime[0..1], optionalRight:DateTime[0..1]]\n'+
                  '    )\n'+
                  '    Relational\n'+
                  '    (\n'+
                  '      type = Class[impls=(meta::relational::tests::model::simple::Address | simpleRelationalMappingInc.meta_relational_tests_model_simple_Address)]\n'+
                  '      resultSizeRange = *\n'+
                  '      resultColumns = [("pk_0", INT), ("name", VARCHAR(200)), ("street", VARCHAR(100)), ("type", INT), ("comments", VARCHAR(100))]\n'+
                  '      sql = select "root".ID as "pk_0", "root".NAME as "name", "root".STREET as "street", "root".TYPE as "type", "root".COMMENTS as "comments" from addressTable as "root" where (${optionalVarPlaceHolderOperationSelector(optionalLeft![], optionalVarPlaceHolderOperationSelector(optionalRight![], \'${varPlaceHolderToString(optionalLeft![]  "\\\'" "\\\'" "null")} = ${varPlaceHolderToString(optionalRight![]  "\\\'" "\\\'" "null")}\', \'1 = 0\'), optionalVarPlaceHolderOperationSelector(optionalRight![], \'1 = 0\', \'1 = 1\'))})\n'+
                  '      connection = TestDatabaseConnection(type = "H2")\n'+
                  '    )\n'+
                  '  )\n'+
                  ')\n';

   assertEquals($expected, $result);
   assertSameElements(templateFunctionsList(),$generatedPlan.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::testGreaterThanLessThanEqualsWithOptionalParameter_SybaseIQ():Boolean[1]      
{  
   let func = {optionalAgeLowerLimit: Integer[0..1], optionalAgeHigherLimit: Integer[0..1]|Person.all()->filter(p|$p.age>$optionalAgeLowerLimit && ($p.age<=$optionalAgeHigherLimit))->project(col(a|$a.firstName, 'firstName'))};
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalAgeLowerLimit:Integer[0..1], optionalAgeHigherLimit:Integer[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
                     '      resultColumns = [("firstName", VARCHAR(200))]\n'+
                     '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where ((("root".AGE is not null and ${varPlaceHolderToString(optionalAgeLowerLimit![]  "" "" "null")} is not null) and "root".AGE > ${varPlaceHolderToString(optionalAgeLowerLimit![]  "" "" "null")}) and (("root".AGE is not null and ${varPlaceHolderToString(optionalAgeHigherLimit![]  "" "" "null")} is not null) and "root".AGE <= ${varPlaceHolderToString(optionalAgeHigherLimit![]  "" "" "null")}))\n'+
                     '      connection = DatabaseConnection(type = "SybaseIQ")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameterWithGreaterThanLessThan($func, DatabaseType.SybaseIQ, $expectedPlan); 
}

function <<test.Test>> meta::pure::executionPlan::tests::testGreaterThanLessThanEqualsWithOptionalParameter_H2():Boolean[1]      
{  
   let func = {optionalAgeLowerLimit: Integer[0..1], optionalAgeHigherLimit: Integer[0..1]|Person.all()->filter(p|$p.age>$optionalAgeLowerLimit && ($p.age<=$optionalAgeHigherLimit))->project(col(a|$a.firstName, 'firstName'))};
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalAgeLowerLimit:Integer[0..1], optionalAgeHigherLimit:Integer[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
                     '      resultColumns = [("firstName", VARCHAR(200))]\n'+
                     '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where ((("root".AGE is not null and ${varPlaceHolderToString(optionalAgeLowerLimit![]  "" "" "null")} is not null) and "root".AGE > ${varPlaceHolderToString(optionalAgeLowerLimit![]  "" "" "null")}) and (("root".AGE is not null and ${varPlaceHolderToString(optionalAgeHigherLimit![]  "" "" "null")} is not null) and "root".AGE <= ${varPlaceHolderToString(optionalAgeHigherLimit![]  "" "" "null")}))\n'+
                     '      connection = DatabaseConnection(type = "H2")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameterWithGreaterThanLessThan($func, DatabaseType.H2, $expectedPlan); 
}

function <<test.Test>> meta::pure::executionPlan::tests::testLessThanGreaterThanEqualsWithOptionalParameter_SybaseIQ():Boolean[1]      
{  
   let func = {optionalAgeLowerLimit: Integer[0..1], optionalAgeHigherLimit: Integer[0..1]|Person.all()->filter(p|$p.age<$optionalAgeLowerLimit && ($p.age>=$optionalAgeHigherLimit))->project(col(a|$a.firstName, 'firstName'))};
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalAgeLowerLimit:Integer[0..1], optionalAgeHigherLimit:Integer[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
                     '      resultColumns = [("firstName", VARCHAR(200))]\n'+
                     '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where ((("root".AGE is not null and ${varPlaceHolderToString(optionalAgeLowerLimit![]  "" "" "null")} is not null) and "root".AGE < ${varPlaceHolderToString(optionalAgeLowerLimit![]  "" "" "null")}) and (("root".AGE is not null and ${varPlaceHolderToString(optionalAgeHigherLimit![]  "" "" "null")} is not null) and "root".AGE >= ${varPlaceHolderToString(optionalAgeHigherLimit![]  "" "" "null")}))\n'+
                     '      connection = DatabaseConnection(type = "SybaseIQ")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameterWithGreaterThanLessThan($func, DatabaseType.SybaseIQ, $expectedPlan); 
}

function <<test.Test>> meta::pure::executionPlan::tests::testLessThanGreaterThanEqualsWithOptionalParameter_H2():Boolean[1]      
{  
   let func = {optionalAgeLowerLimit: Integer[0..1], optionalAgeHigherLimit: Integer[0..1]|Person.all()->filter(p|$p.age<$optionalAgeLowerLimit && ($p.age>=$optionalAgeHigherLimit))->project(col(a|$a.firstName, 'firstName'))};
   let expectedPlan ='Sequence\n'+
                     '(\n'+
                     '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
                     '  (\n'+
                     '    FunctionParametersValidationNode\n'+
                     '    (\n'+
                     '      functionParameters = [optionalAgeLowerLimit:Integer[0..1], optionalAgeHigherLimit:Integer[0..1]]\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
                     '      resultColumns = [("firstName", VARCHAR(200))]\n'+
                     '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where ((("root".AGE is not null and ${varPlaceHolderToString(optionalAgeLowerLimit![]  "" "" "null")} is not null) and "root".AGE < ${varPlaceHolderToString(optionalAgeLowerLimit![]  "" "" "null")}) and (("root".AGE is not null and ${varPlaceHolderToString(optionalAgeHigherLimit![]  "" "" "null")} is not null) and "root".AGE >= ${varPlaceHolderToString(optionalAgeHigherLimit![]  "" "" "null")}))\n'+
                     '      connection = DatabaseConnection(type = "H2")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   
   assertPlanGenerationForOptionalParameterWithGreaterThanLessThan($func, DatabaseType.H2, $expectedPlan); 
}

function <<test.Test>> meta::pure::executionPlan::tests::testPlanGenerationForMultipleExpressionsWithPropertyPath():Boolean[1]
{
  let query = {|
            let endDateCalendar = FiscalCalendarDate.all()->filter(x|$x.fiscalYear.value == 2015)->toOne();
            IncomeFunction.all()->filter(x|$x.incomeYear == $endDateCalendar->toOne().fiscalYear.value);
            };
  let generatedPlan = executionPlan($query, myMapping,meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
  let result = $generatedPlan->planToString(meta::relational::extension::relationalExtensions()); 

  let expectedPlan = 'Sequence\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::IncomeFunction | myMapping.meta_relational_tests_groupBy_datePeriods_domain_IncomeFunction)]\n'+
                '  resultSizeRange = *\n'+
                '  (\n'+
                '    Allocation\n'+
                '    (\n'+
                '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
                '      resultSizeRange = 1\n'+
                '      name = endDateCalendar\n'+
                '      value = \n'+
                '        (\n'+
                '          Relational\n'+
                '          (\n'+
                '            type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
                '            resultSizeRange = 1\n'+
                '            resultColumns = [("pk_0", DATE), ("pk_1", VARCHAR(15)), ("date", DATE), ("weekStart", DATE), ("weekEnd", DATE), ("day", INT), ("week", INT), ("dayOfWeekNumber", INT), ("yearEnd", DATE), ("yearStart", DATE)]\n'+
                '            sql = select "root"."date" as "pk_0", "root"."calendar name" as "pk_1", "root"."date" as "date", "root"."fiscal week start" as "weekStart", "root"."fiscal week end" as "weekEnd", "root"."fiscal day" as "day", "root"."fiscal week" as "week", "root"."fiscal day of week" as "dayOfWeekNumber", "root"."fiscal year end" as "yearEnd", "root"."fiscal year start" as "yearStart" from calendar as "root" where "root"."fiscal year" = 2015\n'+
                '            connection = TestDatabaseConnection(type = "H2")\n'+
                '          )\n'+
                '        )\n'+
                '    )\n'+
                '    Relational\n'+
                '    (\n'+
                '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::IncomeFunction | myMapping.meta_relational_tests_groupBy_datePeriods_domain_IncomeFunction)]\n'+
                '      resultSizeRange = *\n'+
                '      resultColumns = [("pk_0", INT), ("code", INT), ("name", VARCHAR(30)), ("incomeYear", INT)]\n'+
                '      sql = select "root".code as "pk_0", "root".code as "code", "root".name as "name", "root".year as "incomeYear" from INCOME_FUNCTION as "root" where "root".year = ${endDateCalendar.fiscalYear.value}\n'+
                '      connection = TestDatabaseConnection(type = "H2")\n'+
                '    )\n'+
                '  )\n'+
               ')\n';
   assertEquals($expectedPlan, $result);
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeConstantParameterNoTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeConstantForDatabaseConnectionTimeZone(%2019-4-8T18:00:00, []);
   let planAsString = $planWithString.second;
   let expected = 'Relational (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]   sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'2019-04-08 18:00:00\'   connection = TestDatabaseConnection(type = "H2") ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'2019-04-08 18:00:00\'') != -1);
   assertSameElements(templateFunctionsList(),$planWithString.first.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeConstantParameterGMTTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeConstantForDatabaseConnectionTimeZone(%2019-4-8T18:00:00, 'GMT');
   let planAsString = $planWithString.second;
   let expected = 'Relational (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]   sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'2019-04-08 18:00:00\'   connection = TestDatabaseConnection(type = "H2") ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'2019-04-08 18:00:00\'') != -1);
   assertSameElements(templateFunctionsList(),$planWithString.first.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeConstantParameterESTTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeConstantForDatabaseConnectionTimeZone(%2019-4-8T18:00:00, 'EST');
   let planAsString = $planWithString.second;
   let expected = 'Relational (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]   sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'2019-04-08 13:00:00\'   connection = TestDatabaseConnection(type = "H2") ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'2019-04-08 13:00:00\'') != -1);
   assertSameElements(['<#function GMTtoTZ tz paramDate><#return (tz+" "+paramDate)?date.@alloyDate></#function><#function renderCollectionWithTz collection timeZone separator prefix suffix defaultValue><#assign result = [] /><#list collection as c><#assign result = [prefix + (timeZone+" "+c)?date.@alloyDate + suffix] + result></#list><#return result?reverse?join(separator, defaultValue)></#function>',
                       '<#function renderCollection collection separator prefix suffix defaultValue><#if collection?size == 0><#return defaultValue></#if><#return prefix + collection?join(suffix + separator + prefix) + suffix></#function>',
                       '<#function collectionSize collection> <#return collection?size?c> </#function>',
                       '<#function optionalVarPlaceHolderOperationSelector optionalParameter trueClause falseClause><#if optionalParameter?has_content || optionalParameter?is_string><#return trueClause><#else><#return falseClause></#if></#function>',
                       '<#function varPlaceHolderToString optionalParameter prefix suffix defaultValue><#if optionalParameter?is_enumerable && !optionalParameter?has_content><#return defaultValue><#else><#return prefix + optionalParameter + suffix></#if></#function>']
                       ,$planWithString.first.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeVariableNoTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeVariableForDatabaseConnectionTimeZone([]);
   let planAsString = $planWithString.second;
   let expected = 'Sequence (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   (     FunctionParametersValidationNode     (       functionParameters = [dt:DateTime[1]]     )     Relational     (       type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]       resultSizeRange = *       resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]       sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'${dt}\'       connection = TestDatabaseConnection(type = "H2")     )   ) ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'${dt}\'') != -1);
   assertSameElements(templateFunctionsList(),$planWithString.first.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeVariableESTTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeVariableForDatabaseConnectionTimeZone('US/Arizona');
   let planAsString = $planWithString.second;
   let expected = 'Sequence (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   (     FunctionParametersValidationNode     (       functionParameters = [dt:DateTime[1]]     )     Relational     (       type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]       resultSizeRange = *       resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]       sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'${GMTtoTZ( "[US/Arizona]" dt)}\'       connection = TestDatabaseConnection(type = "H2")     )   ) ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'${GMTtoTZ( "[US/Arizona]" dt)}\'') != -1);
   assertSameElements(['<#function GMTtoTZ tz paramDate><#return (tz+" "+paramDate)?date.@alloyDate></#function><#function renderCollectionWithTz collection timeZone separator prefix suffix defaultValue><#assign result = [] /><#list collection as c><#assign result = [prefix + (timeZone+" "+c)?date.@alloyDate + suffix] + result></#list><#return result?reverse?join(separator, defaultValue)></#function>',
                       '<#function renderCollection collection separator prefix suffix defaultValue><#if collection?size == 0><#return defaultValue></#if><#return prefix + collection?join(suffix + separator + prefix) + suffix></#function>',
                       '<#function collectionSize collection> <#return collection?size?c> </#function>',
                       '<#function optionalVarPlaceHolderOperationSelector optionalParameter trueClause falseClause><#if optionalParameter?has_content || optionalParameter?is_string><#return trueClause><#else><#return falseClause></#if></#function>',
                       '<#function varPlaceHolderToString optionalParameter prefix suffix defaultValue><#if optionalParameter?is_enumerable && !optionalParameter?has_content><#return defaultValue><#else><#return prefix + optionalParameter + suffix></#if></#function>']
                       ,$planWithString.first.processingTemplateFunctions);
}

function meta::pure::executionPlan::tests::datetime::executionPlanForQueryWithDateTimeVariableForDatabaseConnectionTimeZone(timeZone:String[0..1]):Pair<ExecutionPlan, String>[1]
{
    let connectionWithTimeZone = ^TestDatabaseConnection(element = db, type=DatabaseType.H2, timeZone=$timeZone);
    let runtime = ^Runtime(connections = $connectionWithTimeZone);
    let q = {dt:DateTime[1]|Order.all()->filter(o|$o.settlementDateTime == $dt)};
    let plan = executionPlan($q, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
    pair($plan, $plan->planToString(meta::relational::extension::relationalExtensions())->replace('\n',' '));
}

function meta::pure::executionPlan::tests::datetime::executionPlanForQueryWithDateTimeConstantForDatabaseConnectionTimeZone(dt:DateTime[1], timeZone:String[0..1]):Pair<ExecutionPlan, String>[1]
{
    let connectionEST = ^TestDatabaseConnection(element = db, type=DatabaseType.H2, timeZone=$timeZone);
    let runtime = ^Runtime(connections = $connectionEST);
    let q = {|Order.all()->filter(o|$o.settlementDateTime == $dt)};
    let plan = executionPlan($q, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
    pair($plan, $plan->planToString(meta::relational::extension::relationalExtensions())->replace('\n',' '));
}

function <<test.Test>> meta::pure::executionPlan::tests::simpleExpression():Boolean[1]
{
   let result = executionPlan({|Person.all()->filter(p|$p.firstName == 'bla')}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '  resultSizeRange = *\n'+
                '  resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("age", INT), ("lastName", VARCHAR(200))]\n'+
                '  sql = select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" where "root".FIRSTNAME = \'bla\'\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::inheritance():Boolean[1]
{
   let result = executionPlan(|meta::relational::tests::model::inheritance::RoadVehicle.all(), inheritanceMappingDB, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::inheritance::Bicycle | inheritanceMain.map2),(meta::relational::tests::model::inheritance::Car | inheritanceMain.map1)]\n'+
                '  resultSizeRange = *\n'+
                '  resultColumns = [(u_type, INT), ("pk_0_0", INT), ("pk_0_1", INT), ("id", INT), ("wheelCount", INT), ("description", INT), ("engineType", INT)]\n'+
                '  sql = select "unionBase".u_type as u_type, "unionBase"."pk_0_0" as "pk_0_0", "unionBase"."pk_0_1" as "pk_0_1", "unionBase"."id" as "id", "unionBase"."wheelCount" as "wheelCount", "unionBase"."description" as "description", "unionBase"."engineType" as "engineType" from (select \'0\' as u_type, "root".ID as "pk_0_0", null as "pk_0_1", "root".ID as "id", "root".db_bic_wheelCount as "wheelCount", "root".b_Description as "description", null as "engineType" from Bicycle as "root" UNION ALL select \'1\' as u_type, null as "pk_0_0", "root".ID as "pk_0_1", "root".ID as "id", "root".db_car_wheelCount as "wheelCount", "root".c_Description as "description", "root".engineType as "engineType" from Car as "root") as "unionBase"\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::relational::extension::relationalExtensions()));
}


function <<test.Test>> meta::pure::executionPlan::tests::simpleExpressionWithVariable():Boolean[1]
{
   let result = executionPlan({var:String[1]|Person.all()->filter(p|$p.firstName == $var)}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   assertEquals('Sequence\n' +
                '(\n' +
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '  resultSizeRange = *\n' +
                '  (\n' +
                '    FunctionParametersValidationNode\n' +
                '    (\n' +
                '      functionParameters = [var:String[1]]\n' +
                '    )\n' +
                '    Relational\n' +
                '    (\n' +
                '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '      resultSizeRange = *\n' +
                '      resultColumns = [(\"pk_0\", INT), (\"firstName\", VARCHAR(200)), (\"age\", INT), (\"lastName\", VARCHAR(200))]\n' +
                '      sql = select \"root\".ID as \"pk_0\", \"root\".FIRSTNAME as \"firstName\", \"root\".AGE as \"age\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\" where \"root\".FIRSTNAME = \'${var}\'\n' +
                '      connection = TestDatabaseConnection(type = \"H2\")\n' +
                '    )\n' +
                '  )\n' +
                ')\n', $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::simpleExpressionWithMultipleVariables():Boolean[1]
{
   let result = executionPlan({var:String[1], age:Integer[1]|Person.all()->filter(p| ($p.firstName == $var) && ($p.age > $age))}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('Sequence\n' +
                '(\n' +
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '  resultSizeRange = *\n' +
                '  (\n' +
                '    FunctionParametersValidationNode\n' +
                '    (\n' +
                '      functionParameters = [var:String[1], age:Integer[1]]\n' +
                '    )\n' +
                '    Relational\n' +
                '    (\n' +
                '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '      resultSizeRange = *\n' +
                '      resultColumns = [(\"pk_0\", INT), (\"firstName\", VARCHAR(200)), (\"age\", INT), (\"lastName\", VARCHAR(200))]\n' +
                '      sql = select \"root\".ID as \"pk_0\", \"root\".FIRSTNAME as \"firstName\", \"root\".AGE as \"age\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\" where (\"root\".FIRSTNAME = \'${var}\' and (\"root\".AGE is not null and \"root\".AGE > ${age}))\n' +
                '      connection = TestDatabaseConnection(type = \"H2\")\n' +
                '    )\n' +
                '  )\n' +
                ')\n', $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testClassPropertyOpenVariable():Boolean[1]
{
    let result = executionPlan({|
                                 let reportEndDate = FiscalCalendarDate.all()->filter(d|$d.date == %2005-10-10)->toOne();
                                 SalesCredit.all()->filter(s|$s.tradeDate.date<$reportEndDate.date);}, myMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   assertEquals(
            'Sequence\n(\n' +
            '  type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::SalesCredit | myMapping.meta_relational_tests_groupBy_datePeriods_domain_SalesCredit)]\n' +
            '  resultSizeRange = *\n'+
            '  (\n' +
            '    Allocation\n' +
            '    (\n' +
            '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n' +
            '      resultSizeRange = 1\n'+
            '      name = reportEndDate\n' +
            '      value = \n' +
            '        (\n' +
            '          Relational\n' +
            '          (\n' +
            '            type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n' +
            '            resultSizeRange = 1\n'+
            '            resultColumns = [("pk_0", DATE), ("pk_1", VARCHAR(15)), ("date", DATE), ("weekStart", DATE), ("weekEnd", DATE), ("day", INT), ("week", INT), ("dayOfWeekNumber", INT), ("yearEnd", DATE), ("yearStart", DATE)]\n'+
            '            sql = select \"root\".\"date\" as \"pk_0\", \"root\".\"calendar name\" as \"pk_1\", \"root\".\"date\" as \"date\", \"root\".\"fiscal week start\" as \"weekStart\", \"root\".\"fiscal week end\" as \"weekEnd\", \"root\".\"fiscal day\" as \"day\", \"root\".\"fiscal week\" as \"week\", \"root\".\"fiscal day of week\" as \"dayOfWeekNumber\", \"root\".\"fiscal year end\" as \"yearEnd\", \"root\".\"fiscal year start\" as \"yearStart\" from calendar as \"root\" where \"root\".\"date\" = \'2005-10-10\'\n' +
            '            connection = TestDatabaseConnection(type = \"H2\")\n' +
            '          )\n' +
            '        )\n' +
            '    )\n' +
            '    Relational\n' +
            '    (\n' +
            '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::SalesCredit | myMapping.meta_relational_tests_groupBy_datePeriods_domain_SalesCredit)]\n' +
            '      resultSizeRange = *\n'+
            '      resultColumns = [("pk_0", INT), ("grossValue", DOUBLE)]\n'+
            '      sql = select \"root\".key as \"pk_0\", \"root\".credits as \"grossValue\" from SALES_GCS as \"root\" left outer join calendar as \"calendar_0\" on (\"root\".tradeDate = \"calendar_0\".\"date\") where \"calendar_0\".\"date\" < \'${reportEndDate.date}\'\n' +
            '      connection = TestDatabaseConnection(type = \"H2\")\n' +
            '    )\n' +
            '  )\n' +
            ')\n', $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testGroupByWithOpenVariableInAgg():Boolean[1]
{
   let result = executionPlan({|
                                 let reportEndDate = FiscalCalendarDate.all()->filter(d|$d.date == %2005-10-10)->toOne();
                                 SalesCredit.all()
                                    ->groupBy([
                                       #/SalesCredit/salesDivision/name#
                                     ],
                                     [
                                        agg(s| ytd($s, #/SalesCredit/grossValue#, #/SalesCredit/tradeDate#, $reportEndDate), r|$r->sum())
                                     ]
                                     ,
                                     ['Sales Division', 'Income Function']);
                              }, myMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   assertEquals(
      'Sequence\n'+
      '(\n'+
      '  type = TDS[(Sales Division, String, VARCHAR(30), ""), (Income Function, Number, FLOAT, "")]\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
      '      resultSizeRange = 1\n'+
      '      name = reportEndDate\n'+
      '      value = \n'+
      '        (\n'+
      '          Relational\n'+
      '          (\n'+
      '            type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
      '            resultSizeRange = 1\n'+
      '            resultColumns = [("pk_0", DATE), ("pk_1", VARCHAR(15)), ("date", DATE), ("weekStart", DATE), ("weekEnd", DATE), ("day", INT), ("week", INT), ("dayOfWeekNumber", INT), ("yearEnd", DATE), ("yearStart", DATE)]\n'+
      '            sql = select "root"."date" as "pk_0", "root"."calendar name" as "pk_1", "root"."date" as "date", "root"."fiscal week start" as "weekStart", "root"."fiscal week end" as "weekEnd", "root"."fiscal day" as "day", "root"."fiscal week" as "week", "root"."fiscal day of week" as "dayOfWeekNumber", "root"."fiscal year end" as "yearEnd", "root"."fiscal year start" as "yearStart" from calendar as "root" where "root"."date" = \'2005-10-10\'\n'+
      '            connection = TestDatabaseConnection(type = "H2")\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = TDS[(Sales Division, String, VARCHAR(30), ""), (Income Function, Number, FLOAT, "")]\n'+
      '      resultColumns = [("Sales Division", VARCHAR(30)), ("Income Function", "")]\n'+
      '      sql = select "org_chart_entity_0".name as "Sales Division", sum(case when "calendar_0"."fiscal day" <= ${reportEndDate.day} then "root".credits else 0.0 end) as "Income Function" from SALES_GCS as "root" left outer join ORG_CHART_ENTITY as "org_chart_entity_0" on ("root".division_id = "org_chart_entity_0".oe_id) left outer join calendar as "calendar_0" on ("root".tradeDate = "calendar_0"."date") group by "Sales Division"\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));}


function <<test.Test>> meta::pure::executionPlan::tests::testGroupByWithTwoOpenVariablesInAggAndFilter():Boolean[1]
{
   let result = executionPlan({|
                                 let startDate = %2015-02-25;
                                 let reportEndDate = FiscalCalendarDate.all()->filter(d|$d.date == %2005-10-10)->toOne();
                                 SalesCredit.all()
                                    ->filter(gc | $gc.tradeDate.date > $startDate && ($gc.tradeDate.date <= $reportEndDate.date))
                                    ->groupBy([
                                       #/SalesCredit/salesDivision/name#
                                     ],
                                     [
                                        agg(s| ytd($s, #/SalesCredit/grossValue#, #/SalesCredit/tradeDate#, $reportEndDate), r|$r->sum())
                                     ]
                                     ,
                                     ['Sales Division', 'Income Function']);
                              }, myMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   assertEquals(
      'Sequence\n'+
      '(\n'+
      '  type = TDS[(Sales Division, String, VARCHAR(30), ""), (Income Function, Number, FLOAT, "")]\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = StrictDate\n'+
      '      resultSizeRange = 1\n'+
      '      name = startDate\n'+
      '      value = \n'+
      '        (\n'+
      '          Constant\n'+
      '          (\n'+
      '            type = StrictDate\n'+
      '            resultSizeRange = 1\n'+
      '            values=[2015-02-25]\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
      '      resultSizeRange = 1\n'+
      '      name = reportEndDate\n'+
      '      value = \n'+
      '        (\n'+
      '          Relational\n'+
      '          (\n'+
      '            type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
      '            resultSizeRange = 1\n'+
      '            resultColumns = [("pk_0", DATE), ("pk_1", VARCHAR(15)), ("date", DATE), ("weekStart", DATE), ("weekEnd", DATE), ("day", INT), ("week", INT), ("dayOfWeekNumber", INT), ("yearEnd", DATE), ("yearStart", DATE)]\n'+
      '            sql = select "root"."date" as "pk_0", "root"."calendar name" as "pk_1", "root"."date" as "date", "root"."fiscal week start" as "weekStart", "root"."fiscal week end" as "weekEnd", "root"."fiscal day" as "day", "root"."fiscal week" as "week", "root"."fiscal day of week" as "dayOfWeekNumber", "root"."fiscal year end" as "yearEnd", "root"."fiscal year start" as "yearStart" from calendar as "root" where "root"."date" = \'2005-10-10\'\n'+
      '            connection = TestDatabaseConnection(type = "H2")\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = TDS[(Sales Division, String, VARCHAR(30), ""), (Income Function, Number, FLOAT, "")]\n'+
      '      resultColumns = [("Sales Division", VARCHAR(30)), ("Income Function", "")]\n'+
      '      sql = select "org_chart_entity_0".name as "Sales Division", sum(case when "calendar_0"."fiscal day" <= ${reportEndDate.day} then "root".credits else 0.0 end) as "Income Function" from SALES_GCS as "root" left outer join ORG_CHART_ENTITY as "org_chart_entity_0" on ("root".division_id = "org_chart_entity_0".oe_id) left outer join calendar as "calendar_0" on ("root".tradeDate = "calendar_0"."date") where ("calendar_0"."date" > \'${startDate}\' and "calendar_0"."date" <= \'${reportEndDate.date}\') group by "Sales Division"\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testMapWithOpenVariable():Boolean[1]
{
   let result = executionPlan({|let a = 10;
                                Firm.all()->map(f|$f.employees->count() + $a);}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   assertEquals(
      'Sequence\n'+
      '(\n'+
      '  type = Integer\n'+
      '  resultSizeRange = *\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = Integer\n'+
      '      resultSizeRange = 1\n'+
      '      name = a\n'+
      '      value = \n'+
      '        (\n'+
      '          Constant\n'+
      '          (\n'+
      '            type = Integer\n'+
      '            resultSizeRange = 1\n'+
      '            values=[10]\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = Integer\n'+
      '      resultSizeRange = *\n'+
      '      resultColumns = [(("firmtable_1".aggCol + ${a}), "")]\n'+
      '      sql = select ("firmtable_1".aggCol + ${a}) from firmTable as "root" left outer join (select "firmtable_1".ID as ID, count(*) as aggCol from firmTable as "firmtable_1" left outer join personTable as "persontable_0" on ("firmtable_1".ID = "persontable_0".FIRMID) group by "firmtable_1".ID) as "firmtable_1" on ("root".ID = "firmtable_1".ID)\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));
}


function <<test.Test>> meta::pure::executionPlan::tests::testFilterWithOpenVariable():Boolean[1]
{
   let result = executionPlan({|let name = 'ok';
                                Firm.all()->filter(f|$f.legalName == $name);}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   assertEquals(
      'Sequence\n'+
      '(\n'+
      '  type = Class[impls=(meta::relational::tests::model::simple::Firm | simpleRelationalMappingInc.meta_relational_tests_model_simple_Firm)]\n'+
      '  resultSizeRange = *\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = String\n'+
      '      resultSizeRange = 1\n'+
      '      name = name\n'+
      '      value = \n'+
      '        (\n'+
      '          Constant\n'+
      '          (\n'+
      '            type = String\n'+
      '            resultSizeRange = 1\n'+
      '            values=[ok]\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = Class[impls=(meta::relational::tests::model::simple::Firm | simpleRelationalMappingInc.meta_relational_tests_model_simple_Firm)]\n'+
      '      resultSizeRange = *\n'+
      '      resultColumns = [("pk_0", INT), ("legalName", VARCHAR(200))]\n'+
      '      sql = select "root".ID as "pk_0", "root".LEGALNAME as "legalName" from firmTable as "root" where "root".LEGALNAME = \'${name}\'\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));
}

Class meta::pure::executionPlan::tests::DummyExecutionOption extends ExecutionOption
{
   paramsRequired(){ ^PlanVarPlaceHolder(name = 'dummyOptionParam', type = String, multiplicity = PureOne) }:PlanVarPlaceHolder[1];
}

Class meta::pure::executionPlan::tests::OtherDummyExecutionOption extends ExecutionOption
{
   paramsRequired(){ ^PlanVarPlaceHolder(name = 'OtherDummyOptionParam', type = String, multiplicity = PureOne) }:PlanVarPlaceHolder[1];
}

function <<test.Test>> meta::pure::executionPlan::tests::testPlanForExecutionOption():Boolean[1]
{
   let dummyExtension = ^Extension(
                            type = 'dummy',
                            serializerExtension =  meta::relational::extension::relationalSerializerExtension_String_1__String_1_,
                            availableFeatures = ^meta::pure::extension::FeatureExtension(
                                                  id='dummy',
                                                  extractVariablesFromExecutionOption={s:ExecutionOption[1]|$s->match([ d: DummyExecutionOption[1] | $d.paramsRequired, a:Any[*] | [] ]);}
                                              )
                         );
   let executionOptionContext = ^ExecutionOptionContext(executionOptions = [^DummyExecutionOption()]);
   let extensions = meta::relational::extension::relationalExtensions()->add($dummyExtension);
   let result = executionPlan({|let name = 'ok';
                                Firm.all()->filter(f|$f.legalName == $name);}, simpleRelationalMapping, meta::relational::tests::testRuntime(), $executionOptionContext, $extensions);

   assertEquals(true, isExecutionOptionPresent($executionOptionContext, DummyExecutionOption));
   assertEquals(false, isExecutionOptionPresent($executionOptionContext, OtherDummyExecutionOption));

   assertEquals(
      'Sequence\n'+
      '(\n'+
      '  type = Class[impls=(meta::relational::tests::model::simple::Firm | simpleRelationalMappingInc.meta_relational_tests_model_simple_Firm)]\n'+
      '  resultSizeRange = *\n'+
      '  (\n'+
      '    FunctionParametersValidationNode\n'+
      '    (\n'+
      '      functionParameters = [dummyOptionParam:String[1]]\n'+
      '    )\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = String\n'+
      '      resultSizeRange = 1\n'+
      '      name = name\n'+
      '      value = \n'+
      '        (\n'+
      '          Constant\n'+
      '          (\n'+
      '            type = String\n'+
      '            resultSizeRange = 1\n'+
      '            values=[ok]\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = Class[impls=(meta::relational::tests::model::simple::Firm | simpleRelationalMappingInc.meta_relational_tests_model_simple_Firm)]\n'+
      '      resultSizeRange = *\n'+
      '      resultColumns = [("pk_0", INT), ("legalName", VARCHAR(200))]\n'+
      '      sql = select "root".ID as "pk_0", "root".LEGALNAME as "legalName" from firmTable as "root" where "root".LEGALNAME = \'${name}\'\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));
}

Class meta::pure::executionPlan::tests::Struct
{
   val : Integer[1];
}

function <<test.Test>> meta::pure::executionPlan::tests::testMapWithOpenVariableOutsideBlock():Boolean[1]
{
   let a = ^Struct(val = 10);
   let result = executionPlan({|Firm.all()->map(f|$f.employees->count() + $a.val);}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = Integer\n'+
                '  resultSizeRange = *\n'+
                '  resultColumns = [(("firmtable_1".aggCol + 10), "")]\n'+
                '  sql = select ("firmtable_1".aggCol + 10) from firmTable as "root" left outer join (select "firmtable_1".ID as ID, count(*) as aggCol from firmTable as "firmtable_1" left outer join personTable as "persontable_0" on ("firmtable_1".ID = "persontable_0".FIRMID) group by "firmtable_1".ID) as "firmtable_1" on ("root".ID = "firmtable_1".ID)\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));

}

function <<test.Test>> meta::pure::executionPlan::tests::twoRoutedExpressions():Boolean[1]
{
   let result = executionPlan({| let personName = Person.all()->filter(p|$p.firstName == 'ok')->toOne().lastName;
                                 Person.all()->filter(p|$p.firstName == $personName);
                              }
                              , simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('Sequence\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '  resultSizeRange = *\n'+
                '  (\n'+
                '    Allocation\n'+
                '    (\n'+
                '      type = String\n'+
                '      resultSizeRange = 1\n'+
                '      name = personName\n'+
                '      value = \n'+
                '        (\n'+
                '          Relational\n'+
                '          (\n'+
                '            type = String\n'+
                '            resultSizeRange = 1\n'+
                '            resultColumns = [("root".LASTNAME, VARCHAR(200))]\n'+
                '            sql = select "root".LASTNAME from personTable as "root" where "root".FIRSTNAME = \'ok\'\n'+
                '            connection = TestDatabaseConnection(type = "H2")\n'+
                '          )\n'+
                '        )\n'+
                '    )\n'+
                '    Relational\n'+
                '    (\n'+
                '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '      resultSizeRange = *\n'+
                '      resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("age", INT), ("lastName", VARCHAR(200))]\n'+
                '      sql = select \"root\".ID as \"pk_0\", \"root\".FIRSTNAME as \"firstName\", \"root\".AGE as \"age\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\" where \"root\".FIRSTNAME = \'${personName}\'\n'+
                '      connection = TestDatabaseConnection(type = "H2")\n'+
                '    )\n'+
                '  )\n'+
                ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::twoExpressionWithConstant():Boolean[1]
{
   let result = executionPlan({|let personName = 'test';
                                Person.all()->filter(p|$p.firstName == $personName);
                              }
                              , simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('Sequence\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '  resultSizeRange = *\n'+
                '  (\n'+
                '    Allocation\n'+
                '    (\n'+
                '      type = String\n'+
                '      resultSizeRange = 1\n'+
                '      name = personName\n'+
                '      value = \n'+
                '        (\n'+
                '          Constant\n'+
                '          (\n'+
                '            type = String\n'+
                '            resultSizeRange = 1\n'+
                '            values=[test]\n'+
                '          )\n'+
                '        )\n'+
                '    )\n'+
                '    Relational\n'+
                '    (\n'+
                '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '      resultSizeRange = *\n'+
                '      resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("age", INT), ("lastName", VARCHAR(200))]\n'+
                '      sql = select \"root\".ID as \"pk_0\", \"root\".FIRSTNAME as \"firstName\", \"root\".AGE as \"age\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\" where \"root\".FIRSTNAME = \'${personName}\'\n'+
                '      connection = TestDatabaseConnection(type = "H2")\n'+
                '    )\n'+
                '  )\n'+
                ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsReturn():Boolean[1]
{
   let result = executionPlan({|Person.all()->project([col(p|$p.firstName, '"firstName"', 'doc1'), col(p|$p.lastName, 'lastName')]);}
                              , simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = TDS[("firstName", String, VARCHAR(200), "doc1"), (lastName, String, VARCHAR(200), "")]\n'+
                '  resultColumns = [("firstName", VARCHAR(200)), ("lastName", VARCHAR(200))]\n'+
                '  sql = select \"root\".FIRSTNAME as \"firstName\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\"\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsWithEnumReturn():Boolean[1]
{
   let result = executionPlan({|meta::relational::tests::mapping::enumeration::model::domain::Product.all()->project([p|$p.description, p|if($p.description == 'My Product 2',|$p.synonyms.type,|$p.synonyms.type)], ['description','type'])}, meta::relational::tests::mapping::enumeration::model::mapping::productMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = TDS[(description, String, VARCHAR(200), ""), (type, meta::relational::tests::mapping::enumeration::model::domain::ProductSynonymType, VARCHAR(10), "", synonym)]\n'+
                '  resultColumns = [("description", VARCHAR(200)), ("type", "")]\n'+
                '  sql = select "root".prod_desc as "description", case when "root".prod_desc = \'My Product 2\' then "product_synonym_0".type else "product_synonym_0".type end as "type" from Product as "root" left outer join Product_Synonym as "product_synonym_0" on ("root".id = "product_synonym_0".product_id)\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::withPlatform():Boolean[1]
{
   let result = executionPlan({|Person.all()->filter(p|($p.firstName == 'John' && $p.lastName == 'Johnson') || $p.lastName == 'Allen').lastName->makeString(', ')}
                              , simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   assertEquals('PureExp\n' +
                '(\n' +
                '  type = String\n' +
                '  expression = [Node Index:0] -> makeString(\', \')\n' +
                '  (\n' +
                '    Relational\n' +
                '    (\n' +
                '      type = String\n' +
                '      resultSizeRange = *\n'+
                '      resultColumns = [("root".LASTNAME, VARCHAR(200))]\n'+
                '      sql = select \"root\".LASTNAME from personTable as \"root\" where ((\"root\".FIRSTNAME = \'John\' and \"root\".LASTNAME = \'Johnson\') or \"root\".LASTNAME = \'Allen\')\n' +
                '      connection = TestDatabaseConnection(type = "H2")\n'+
                '    )\n' +
                '  )\n' +
                ')\n',$result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testDatabaseConnectionSQLPopulationLegacy():Boolean[1]
{
   let runtime = ^Runtime(
      connections = ^TestDatabaseConnection(type = DatabaseType.H2, element = meta::relational::tests::db, testDataSetupCsv = '')
   );
   let result = executionPlan({|Person.all()->project(c | $c.firstName, 'firstName')}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());

   let resultConnection = $result.rootExecutionNode->cast(@RelationalInstantiationExecutionNode).executionNodes->at(0)->cast(@SQLExecutionNode).connection->cast(@TestDatabaseConnection);

   assertSize($resultConnection.testDataSetupSqls, 44);
}

function <<test.Test>> meta::pure::executionPlan::tests::testDatabaseConnectionSQLPopulation():Boolean[1]
{
   let runtime = ^Runtime(
      connections = ^meta::pure::alloy::connections::RelationalDatabaseConnection(
         type = DatabaseType.H2,
         element = meta::relational::tests::db,
         datasourceSpecification = ^meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification(testDataSetupCsv = ''),
         authenticationStrategy = ^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy()
      ));

   let result = executionPlan({|Person.all()->project(c | $c.firstName, 'firstName')}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());

   let resultConnection = $result.rootExecutionNode->cast(@RelationalInstantiationExecutionNode).executionNodes->at(0)->cast(@SQLExecutionNode)
      .connection->cast(@meta::pure::alloy::connections::RelationalDatabaseConnection).datasourceSpecification
                 ->cast(@meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification);

   assertSize($resultConnection.testDataSetupSqls, 44);
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsJoinOneDBOneExpression():Boolean[1]
{
    let result = executionPlan({|
    testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])
    ->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'), col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');});},testJoinTDSMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

    assertEquals('Relational\n'+
    '(\n'+
    '  type = TDS[(firstName, String, VARCHAR(200), ""), (eID, Integer, INT, ""), (fID, Integer, INT, ""), (legalName, String, VARCHAR(200), "")]\n'+
    '  resultColumns = [("firstName", VARCHAR(200)), ("eID", INT), ("fID", INT), ("legalName", VARCHAR(200))]\n'+
    '  sql = select \"persontable_0\".\"firstName\" as \"firstName\", \"persontable_0\".\"eID\" as \"eID\", \"persontable_0\".\"fID\" as \"fID\", \"persontable_0\".\"legalName\" as \"legalName\" from (select \"persontable_1\".\"firstName\" as \"firstName\", \"persontable_1\".\"eID\" as \"eID\", \"firmtable_0\".\"fID\" as \"fID\", \"firmtable_0\".\"legalName\" as \"legalName\" from (select \"root\".FIRSTNAME as \"firstName\", \"root\".FIRMID as \"eID\" from personTable as \"root\") as \"persontable_1\" inner join (select \"root\".ID as \"fID\", \"root\".LEGALNAME as \"legalName\" from firmTable as \"root\") as \"firmtable_0\" on (\"persontable_1\".\"eID\" = \"firmtable_0\".\"fID\")) as \"persontable_0\"\n'+
    '  connection = TestDatabaseConnection(type = "H2")\n'+
    ')\n', $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsJoinTwoDBWithColumnMappedViaJoins():Boolean[1]
{
    let result = executionPlan({|testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID'), col(p|$p.managerID, 'managerID')])
                                     ->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'), col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');});},
                               meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabaseWithColumnsMappedViaJoinsAndDynaFunction, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::relational::extension::relationalExtensions());
    let actualPlan = $result->planToString(meta::relational::extension::relationalExtensions());
    let expected =   'Sequence\n'+
                     '(\n'+
                     '  type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (managerID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
                     '  (\n'+
                     '    Allocation\n'+
                     '    (\n'+
                     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (managerID, Integer, INT, \"\")]\n'+
                     '      name = tdsVar0_0\n'+
                     '      value = \n'+
                     '        (\n'+
                     '          Relational\n'+
                     '          (\n'+
                     '            type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (managerID, Integer, INT, \"\")]\n'+
                     '            resultColumns = [(\"firstName\", VARCHAR(200)), (\"eID\", INT), (\"managerID\", \"\")]\n'+
                     '            sql = select \"root\".FIRSTNAME as \"firstName\", \"firmtable_0\".ID as \"eID\", case when \"root\".MANAGERID = 0 then 0 else \"root\".MANAGERID end as \"managerID\" from personTable as \"root\" left outer join firmTable as \"firmtable_0\" on (\"firmtable_0\".ID = \"root\".FIRMID)\n'+
                     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
                     '          )\n'+
                     '        )\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (managerID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
                     '      resultColumns = [(\"firstName\", INT), (\"eID\", INT), (\"managerID\", INT), (\"fID\", INT), (\"legalName\", VARCHAR(200))]\n'+
                     '      sql = select \"tdsvar0_0_0\".firstName as \"firstName\", \"tdsvar0_0_0\".eID as \"eID\", \"tdsvar0_0_0\".managerID as \"managerID\", \"tdsvar0_0_0\".\"fID\" as \"fID\", \"tdsvar0_0_0\".\"legalName\" as \"legalName\" from (select * from (${tdsVar0_0}) as \"tdsvar0_0_1\" inner join (select \"root\".ID as \"fID\", \"root\".LEGALNAME as \"legalName\" from firmTable as \"root\") as \"firmtable_0\" on (\"tdsvar0_0_1\".eID = \"firmtable_0\".\"fID\")) as \"tdsvar0_0_0\"\n'+
                     '      connection = TestDatabaseConnection(type = \"H2\")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   assertEquals($expected, $actualPlan);
}

function <<test.ToFix>> meta::pure::executionPlan::tests::tdsJoinTwoDBWithFilter():Boolean[1]
{
    //TODO: Push filters down to relevant cluster
    let result = executionPlan({|
    testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'),
    col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');})->filter( f| $f.getString('firstName')=='Adam' &&   $f.getString('legalName')=='Firm X')

    ;}, meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::relational::extension::relationalExtensions());
    $result->planToString(meta::relational::extension::relationalExtensions())->println();
      true;
}

function <<test.Test>> meta::pure::executionPlan::tests::twoDBRenameColumns():Boolean[1]
{
    let result = executionPlan({|
    meta::relational::tests::tds::tdsJoin::testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName2'), col(p|$p.employerID, 'eID2')])
     ->join(meta::relational::tests::tds::tdsJoin::testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID2'), col(p|$p.legalName, 'legalName2')]), JoinType.INNER, {a,b|$a.getInteger('eID2') == $b.getInteger('fID2');})

    ;}, meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::relational::extension::relationalExtensions());
   $result->planToString(meta::relational::extension::relationalExtensions())->println();
   true;
}

function <<test.Test>> meta::pure::executionPlan::tests::twoDBTestSpaceQuoting():Boolean[1]
{
    let result = executionPlan({|
        testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'first name'), col(p|$p.employerID, 'eID')])->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'),
        col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');})->filter( f| $f.getString('first name')=='Adam' &&   $f.getString('legalName')=='Firm X')
        ;}, meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::relational::extension::relationalExtensions());
    assertEquals('Sequence\n'+
    '(\n'+
     '  type = TDS[(first name, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
     '  (\n'+
     '    Allocation\n'+
     '    (\n'+
     '      type = TDS[(first name, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '      name = tdsVar1_0\n'+
     '      value = \n'+
     '        (\n'+
     '          Relational\n'+
     '          (\n'+
     '            type = TDS[(first name, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '            resultColumns = [("first name", VARCHAR(200)), ("eID", INT)]\n'+
     '            sql = select \"root\".FIRSTNAME as \"first name\", \"root\".FIRMID as \"eID\" from personTable as \"root\"\n'+
     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
     '          )\n'+
     '        )\n'+
     '    )\n'+
     '    Relational\n'+
     '    (\n'+
     '      type = TDS[(first name, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
     '      resultColumns = [("first name", INT), ("eID", INT), ("fID", INT), ("legalName", VARCHAR(200))]\n'+
     '      sql = select "tdsvar1_0_0"."first name" as "first name", "tdsvar1_0_0".eID as "eID", "tdsvar1_0_0"."fID" as "fID", "tdsvar1_0_0"."legalName" as "legalName" from (select * from (${tdsVar1_0}) as "tdsvar1_0_1" inner join (select "root".ID as "fID", "root".LEGALNAME as "legalName" from firmTable as "root") as "firmtable_0" on ("tdsvar1_0_1".eID = "firmtable_0"."fID")) as "tdsvar1_0_0" where ("tdsvar1_0_0"."first name" = \'Adam\' and "tdsvar1_0_0"."legalName" = \'Firm X\')\n'+
     '      connection = TestDatabaseConnection(type = \"H2\")\n'+
     '    )\n'+
     '  )\n'+
    ')\n'
    , $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::twoDBTestNonAlphaNumericQuoting():Boolean[1]
{
    let result = executionPlan({|
        testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'first#name'), col(p|$p.employerID, 'eID')])->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'),
        col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');})->filter( f| $f.getString('first#name')=='Adam' &&   $f.getString('legalName')=='Firm X')
        ;}, meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::relational::extension::relationalExtensions());
    assertEquals('Sequence\n'+
    '(\n'+
     '  type = TDS[(first#name, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
     '  (\n'+
     '    Allocation\n'+
     '    (\n'+
     '      type = TDS[(first#name, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '      name = tdsVar1_0\n'+
     '      value = \n'+
     '        (\n'+
     '          Relational\n'+
     '          (\n'+
     '            type = TDS[(first#name, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '            resultColumns = [("first#name", VARCHAR(200)), ("eID", INT)]\n'+
     '            sql = select \"root\".FIRSTNAME as \"first#name\", \"root\".FIRMID as \"eID\" from personTable as \"root\"\n'+
     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
     '          )\n'+
     '        )\n'+
     '    )\n'+
     '    Relational\n'+
     '    (\n'+
     '      type = TDS[(first#name, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
     '      resultColumns = [("first#name", INT), ("eID", INT), ("fID", INT), ("legalName", VARCHAR(200))]\n'+
     '      sql = select "tdsvar1_0_0"."first#name" as "first#name", "tdsvar1_0_0".eID as "eID", "tdsvar1_0_0"."fID" as "fID", "tdsvar1_0_0"."legalName" as "legalName" from (select * from (${tdsVar1_0}) as "tdsvar1_0_1" inner join (select "root".ID as "fID", "root".LEGALNAME as "legalName" from firmTable as "root") as "firmtable_0" on ("tdsvar1_0_1".eID = "firmtable_0"."fID")) as "tdsvar1_0_0" where ("tdsvar1_0_0"."first#name" = \'Adam\' and "tdsvar1_0_0"."legalName" = \'Firm X\')\n'+
     '      connection = TestDatabaseConnection(type = \"H2\")\n'+
     '    )\n'+
     '  )\n'+
    ')\n'
    , $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsJoinTwoDBExtend():Boolean[1]
{
    let result = executionPlan({|
    meta::relational::tests::tds::tdsJoin::testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])->join(meta::relational::tests::tds::tdsJoin::testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'),
    col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');})

    ;}, meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::relational::extension::relationalExtensions());
    assertEquals('Sequence\n'+
    '(\n'+
     '  type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
     '  (\n'+
     '    Allocation\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '      name = tdsVar0_0\n'+
     '      value = \n'+
     '        (\n'+
     '          Relational\n'+
     '          (\n'+
     '            type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '            resultColumns = [("firstName", VARCHAR(200)), ("eID", INT)]\n'+
     '            sql = select \"root\".FIRSTNAME as \"firstName\", \"root\".FIRMID as \"eID\" from personTable as \"root\"\n'+
     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
     '          )\n'+
     '        )\n'+
     '    )\n'+
     '    Relational\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
     '      resultColumns = [("firstName", INT), ("eID", INT), ("fID", INT), ("legalName", VARCHAR(200))]\n'+
     '      sql = select \"tdsvar0_0_0\".firstName as "firstName", \"tdsvar0_0_0\".eID as "eID", \"tdsvar0_0_0\".\"fID\" as \"fID\", \"tdsvar0_0_0\".\"legalName\" as \"legalName\" from (select * from (${tdsVar0_0}) as \"tdsvar0_0_1\" inner join (select \"root\".ID as \"fID\", \"root\".LEGALNAME as \"legalName\" from firmTable as \"root\") as \"firmtable_0\" on (\"tdsvar0_0_1\".eID = \"firmtable_0\".\"fID\")) as \"tdsvar0_0_0\"\n'+
     '      connection = TestDatabaseConnection(type = \"H2\")\n'+
     '    )\n'+
     '  )\n'+
    ')\n'
    , $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsTwoJoinThreeDB():Boolean[1]
{
    let resultOneExpression = executionPlan({|
    testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])
    ->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'),col(p|$p.firmAddrID, 'firmAddrID')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');})
    ->join(testJoinTDS_Address.all()->project([col(p|$p.addrName, 'addrName'), col(p|$p.addrID, 'addrID')]), JoinType.INNER, {a,b |$a.getInteger('firmAddrID')  == $b.getInteger('addrID');});}
    , meta::relational::tests::tds::tdsJoin::testJoinTDSMappingThreeDatabase, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());


    let expected ='Sequence\n'+
    '(\n'+
    '  type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (firmAddrID, Integer, INT, \"\"), (addrName, String, VARCHAR(200), \"\"), (addrID, Integer, INT, \"\")]\n'+
     '  (\n'+
     '    Allocation\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '      name = tdsVar1_0\n'+
     '      value = \n'+
     '        (\n'+
     '          Relational\n'+
     '          (\n'+
     '            type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '            resultColumns = [("firstName", VARCHAR(200)), ("eID", INT)]\n'+
     '            sql = select \"root\".FIRSTNAME as \"firstName\", \"root\".FIRMID as \"eID\" from personTable as \"root\"\n'+
     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
     '          )\n'+
     '        )\n'+
     '    )\n'+
     '    Allocation\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (firmAddrID, Integer, INT, \"\")]\n'+
     '      name = tdsVar0_0\n'+
     '      value = \n'+
     '        (\n'+
     '          Relational\n'+
     '          (\n'+
     '            type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (firmAddrID, Integer, INT, \"\")]\n'+
     '            resultColumns = [("firstName", INT), ("eID", INT), ("fID", INT), ("firmAddrID", INT)]\n'+
     '            sql = select \"tdsvar1_0_0\".firstName as "firstName", \"tdsvar1_0_0\".eID as "eID", \"tdsvar1_0_0\".\"fID\" as \"fID\", \"tdsvar1_0_0\".\"firmAddrID\" as \"firmAddrID\" from (select * from (${tdsVar1_0}) as \"tdsvar1_0_1\" inner join (select \"root\".ID as \"fID\", \"root\".ADDRESSID as \"firmAddrID\" from firmTable as \"root\") as \"firmtable_0\" on (\"tdsvar1_0_1\".eID = \"firmtable_0\".\"fID\")) as \"tdsvar1_0_0\"\n'+
     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
     '          )\n'+
     '        )\n'+
     '    )\n'+
     '    Relational\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (firmAddrID, Integer, INT, \"\"), (addrName, String, VARCHAR(200), \"\"), (addrID, Integer, INT, \"\")]\n'+
     '      resultColumns = [("firstName", INT), ("eID", INT), ("fID", INT), ("firmAddrID", INT), ("addrName", VARCHAR(200)), ("addrID", INT)]\n'+
     '      sql = select \"tdsvar0_0_0\".firstName as "firstName", \"tdsvar0_0_0\".eID as "eID", \"tdsvar0_0_0\".fID as "fID", \"tdsvar0_0_0\".firmAddrID as "firmAddrID", \"tdsvar0_0_0\".\"addrName\" as \"addrName\", \"tdsvar0_0_0\".\"addrID\" as \"addrID\" from (select * from (${tdsVar0_0}) as \"tdsvar0_0_1\" inner join (select \"root\".NAME as \"addrName\", \"root\".ID as \"addrID\" from addressTable as \"root\") as \"addresstable_0\" on (\"tdsvar0_0_1\".firmAddrID = \"addresstable_0\".\"addrID\")) as \"tdsvar0_0_0\"\n'+
     '      connection = TestDatabaseConnection(type = \"H2\")\n'+
    '    )\n'+
    '  )\n'+
    ')\n';

    assertEquals($expected,$resultOneExpression->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testTwoMappingsOneRuntime():Boolean[1]
{

  let plan =  executionPlan({|
     Person.all().firm->project([col(p|$p.legalName, 'legalName'), col(p|$p.legalName, 'legalNameSimple')])->from(alternateSimpleMapping, meta::relational::tests::testRuntime())
     ->join(Person.all().firm->project([col(p|$p.legalName, 'legalName'),col(p|$p.legalName, 'legalNameALT')])->from(alternateSimpleMapping2, meta::relational::tests::testRuntime()), JoinType.INNER, ['legalName'])},^Mapping(name = ''), ^meta::pure::runtime::Runtime(), meta::relational::extension::relationalExtensions());
 assertEquals('Relational\n'+
'(\n'+
'  type = TDS[(legalName, String, VARCHAR(200), ""), (legalNameSimple, String, VARCHAR(200), ""), (legalNameALT, String, VARCHAR(200), "")]\n'+
'  resultColumns = [("legalName", VARCHAR(200)), ("legalNameSimple", VARCHAR(200)), ("legalNameALT", VARCHAR(200))]\n'+
'  sql = select "persontable_0"."legalName" as "legalName", "persontable_0"."legalNameSimple" as "legalNameSimple", "persontable_0"."legalNameALT" as "legalNameALT" from (select "persontable_1"."legalName" as "legalName", "persontable_1"."legalNameSimple" as "legalNameSimple", "persontable_3"."legalNameALT" as "legalNameALT" from (select "otherfirmtable_0".LEGALNAME as "legalName", "otherfirmtable_0".LEGALNAME as "legalNameSimple" from personTable as "root" left outer join otherFirmTable as "otherfirmtable_0" on ("root".FIRMID = "otherfirmtable_0".ID)) as "persontable_1" inner join (select "firmtable_0".LEGALNAME as "legalName", "firmtable_0".LEGALNAME as "legalNameALT" from personTable as "root" left outer join firmTable as "firmtable_0" on ("firmtable_0".ID = "root".FIRMID)) as "persontable_3" on ("persontable_1"."legalName" = "persontable_3"."legalName")) as "persontable_0"\n'+
'  connection = TestDatabaseConnection(type = "H2")\n'+
')\n',$plan->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::letVariableFunctionNow() : Boolean[1]
{
    let lambda = {| let x = now();
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>now()->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};

   let res = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   let expected =
   'Sequence\n'+
   '(\n'+
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '  (\n'+
   '    Allocation\n'+
   '    (\n'+
   '      type = DateTime\n'+
   '      name = x\n'+
   '      value = \n'+
   '        (\n'+
   '          PureExp\n'+
   '          (\n'+
   '            type = DateTime\n'+
   '            expression = now()\n'+
   '          )\n'+
   '        )\n'+
   '    )\n'+
   '    Relational\n'+
   '    (\n'+
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n'+
   '      connection = TestDatabaseConnection(type = "H2")\n'+
   '    )\n'+
   '  )\n'+
   ')\n';

   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));

   let withJava = $res->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), relationalExtensions());

   let expectedJava =
   'Sequence\n' +
   '(\n' +
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '  (\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = DateTime\n' +
   '      name = x\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = DateTime\n' +
   '            expression = now()\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = org.finos.legend.engine.plan.dependencies.store.platform.PredefinedExpressions.now\n' +
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n' +
   '      connection = TestDatabaseConnection(type = "H2")\n' +
   '    )\n' +
   '  )\n' +
   ')\n';

   assertEquals($expectedJava, $withJava->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::letVariableFunctionAdjustNow() : Boolean[1]
{
   let lambda = {| let x = adjust(now(),1,DurationUnit.DAYS);
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>now()->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};
   let res = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let expected =
   'Sequence\n'+
   '(\n'+
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '  (\n'+
   '    Allocation\n'+
   '    (\n'+
   '      type = Date\n'+
   '      name = x\n'+
   '      value = \n'+
   '        (\n'+
   '          PureExp\n'+
   '          (\n'+
   '            type = Date\n'+
   '            expression = now() -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n'+
   '          )\n'+
   '        )\n'+
   '    )\n'+
   '    Relational\n'+
   '    (\n'+
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n'+
   '      connection = TestDatabaseConnection(type = "H2")\n'+
   '    )\n'+
   '  )\n'+
   ')\n';

   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));

   let withJava = $res->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), relationalExtensions());

   let expectedJava =
   'Sequence\n' +
   '(\n' +
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '  (\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = Date\n' +
   '      name = x\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = Date\n' +
   '            expression = now() -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = _pure.plan.root.n1.n1.Execute.execute\n' +
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n' +
   '      connection = TestDatabaseConnection(type = "H2")\n' +
   '    )\n' +
   '  )\n' +
   ')\n' +
   'globalImplementationSupport\n' +
   '(\n' +
   '  classes =\n' +
   '      _pure.plan.root.n1.n1.Execute\n' +
   '      0001 package _pure.plan.root.n1.n1;\n' +
   '      0002 \n' +
   '      0003 import java.util.Date;\n' +
   '      0004 import org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\n' +
   '      0005 import org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n' +
   '      0006 import org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n' +
   '      0007 import org.finos.legend.engine.plan.dependencies.util.Library;\n' +
   '      0008 \n' +
   '      0009 public class Execute\n' +
   '      0010 {\n' +
   '      0011     public static PureDate execute(IExecutionNodeContext context)\n' +
   '      0012     {\n' +
   '      0013         try\n' +
   '      0014         {\n' +
   '      0015             return Library.adjustDate(PureDate.fromDate(new Date()),\n' +
   '      0016                                       1L,\n' +
   '      0017                                       DurationUnit.DAYS);\n' +
   '      0018         }\n' +
   '      0019         catch (Exception e)\n' +
   '      0020         {\n' +
   '      0021             throw new RuntimeException("Failed in node: root.n1.n1", e);\n' +
   '      0022         }\n' +
   '      0023     }\n' +
   '      0024 }\n' +
   ')\n';
   assertEquals($expectedJava, $withJava->planToString(true, meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::letVariableFunctionAdjustDateLiteral() : Boolean[1]
{
   let lambda = {| let x = adjust(%2005-10-10,1,DurationUnit.DAYS);
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>%2005-10-10->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};

   let res = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let expected =
   'Sequence\n'+
   '(\n'+
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '  (\n'+
   '    Allocation\n'+
   '    (\n'+
   '      type = Date\n'+
   '      name = x\n'+
   '      value = \n'+
   '        (\n'+
   '          PureExp\n'+
   '          (\n'+
   '            type = Date\n'+
   '            expression = 2005-10-10 -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n'+
   '          )\n'+
   '        )\n'+
   '    )\n'+
   '    Relational\n'+
   '    (\n'+
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, \'2005-10-10\')\n'+
   '      connection = TestDatabaseConnection(type = "H2")\n'+
   '    )\n'+
   '  )\n'+
   ')\n';

   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));

   let withJava = $res->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), relationalExtensions());

   let expectedJava =
   'Sequence\n' +
   '(\n' +
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '  (\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = Date\n' +
   '      name = x\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = Date\n' +
   '            expression = 2005-10-10 -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = _pure.plan.root.n1.n1.Execute.execute\n' +
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, \'2005-10-10\')\n' +
   '      connection = TestDatabaseConnection(type = "H2")\n' +
   '    )\n' +
   '  )\n' +
   ')\n' +
   'globalImplementationSupport\n' +
   '(\n' +
   '  classes =\n' +
   '      _pure.plan.root.n1.n1.Execute\n' +
   '      0001 package _pure.plan.root.n1.n1;\n' +
   '      0002 \n' +
   '      0003 import org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\n' +
   '      0004 import org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n' +
   '      0005 import org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n' +
   '      0006 import org.finos.legend.engine.plan.dependencies.util.Library;\n' +
   '      0007 \n' +
   '      0008 public class Execute\n' +
   '      0009 {\n' +
   '      0010     public static PureDate execute(IExecutionNodeContext context)\n' +
   '      0011     {\n' +
   '      0012         try\n' +
   '      0013         {\n' +
   '      0014             return Library.adjustDate(PureDate.parsePureDate("2005-10-10"),\n' +
   '      0015                                       1L,\n' +
   '      0016                                       DurationUnit.DAYS);\n' +
   '      0017         }\n' +
   '      0018         catch (Exception e)\n' +
   '      0019         {\n' +
   '      0020             throw new RuntimeException("Failed in node: root.n1.n1", e);\n' +
   '      0021         }\n' +
   '      0022     }\n' +
   '      0023 }\n' +
   ')\n';
   assertEquals($expectedJava, $withJava->planToString(true, meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::javaGenerationLetVariablePureExpression() : Boolean[1]
{
   let lambda = {businessDate: StrictDate[0..1], CLSFtype: String[1]| let asOf = if($businessDate->isNotEmpty(), |$businessDate->toOne(), |now());
                                                                      meta::relational::tests::milestoning::Product.all($asOf)
                                                                      ->filter(p|$p.classification($asOf).type==$CLSFtype)
                                                                      ->project([x|$x.classification($asOf).type], ['classificationType'])->distinct();};

   let res = meta::pure::executionPlan::executionPlan($lambda,meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let withJava = $res->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), relationalExtensions());

   let expectedJava =
   'Sequence\n'+
   '(\n' +
   '  type = TDS[(classificationType, String, VARCHAR(200), \"\")]\n' +
   '  (\n' +
   '    FunctionParametersValidationNode\n' +
   '    (\n' +
   '      functionParameters = [businessDate:StrictDate[0..1], CLSFtype:String[1]]\n' +
   '    )\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = Date\n' +
   '      name = asOf\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = Date\n' +
   '            requires = [businessDate(StrictDate[0..1])]\n' +
   '            expression = $businessDate -> isNotEmpty() -> if([Routed Func: | $businessDate -> toOne();], [Routed Func: | now();])\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = _pure.plan.root.n2.n1.Execute.execute\n'+
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(classificationType, String, VARCHAR(200), \"\")]\n' +
   '      resultColumns = [(\"classificationType\", VARCHAR(200))]\n' +
   '      sql = select distinct \"productclassificationtable_0\".type as \"classificationType\" from ProductTable as \"root\" left outer join ProductClassificationTable as \"productclassificationtable_0\" on (\"root\".type = \"productclassificationtable_0\".type and \"productclassificationtable_0\".from_z <= \'${asOf}\' and \"productclassificationtable_0\".thru_z > \'${asOf}\') where \"productclassificationtable_0\".type = \'${CLSFtype}\' and \"root\".from_z <= \'${asOf}\' and \"root\".thru_z > \'${asOf}\'\n' +
   '      connection = TestDatabaseConnection(type = \"H2\")\n' +
   '    )\n' +
   '  )\n' +
   ')\n' +
   'globalImplementationSupport\n' +
   '(\n' +
   '  classes =\n' +
   '      _pure.plan.root.n2.n1.Execute\n' +
   '      0001 package _pure.plan.root.n2.n1;\n' +
   '      0002 \n' +
   '      0003 import java.util.Date;\n' +
   '      0004 import java.util.function.Supplier;\n' +
   '      0005 import org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n' +
   '      0006 import org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n' +
   '      0007 import org.finos.legend.engine.plan.dependencies.util.Library;\n' +
   '      0008 \n' +
   '      0009 public class Execute\n' +
   '      0010 {\n' +
   '      0011     public static PureDate execute(IExecutionNodeContext context)\n' +
   '      0012     {\n' +
   '      0013         try\n' +
   '      0014         {\n' +
   '      0015             PureDate businessDate = context.getResult(\"businessDate\", PureDate.class);\n' +
   '      0016             return businessDate != null ? ((Supplier<PureDate>) () -> Library.toOne(businessDate))\n' +
   '      0017                                                                              .get()\n' +
   '      0018                                         : ((Supplier<PureDate>) () -> PureDate.fromDate(new Date()))\n' +
   '      0019                                                                               .get();\n' +
   '      0020         }\n' +
   '      0021         catch (Exception e)\n' +
   '      0022         {\n' +
   '      0023             throw new RuntimeException(\"Failed in node: root.n2.n1\", e);\n' +
   '      0024         }\n' +
   '      0025     }\n' +
   '      0026 }\n' +
   ')\n';
   assertEquals($expectedJava, $withJava->planToString(true, meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testTemporalDateVariableAtRoot():Boolean[1]
{
   let l = {bd:Date[1]|meta::relational::tests::milestoning::Product.all($bd)->project(col(t|$t.id, 'id'))};
   let result = executionPlan($l, meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let rlnNode = $result.rootExecutionNode.executionNodes->filter(n|$n->instanceOf(RelationalInstantiationExecutionNode))->at(0).executionNodes->at(0)->cast(@SQLExecutionNode);
   let rlnNodeSQL = $rlnNode.sqlQuery;
   assertEquals('select "root".id as "id" from ProductTable as "root" where "root".from_z <= \'${bd}\' and "root".thru_z > \'${bd}\'', $rlnNodeSQL);
}

function <<test.Test>> meta::pure::executionPlan::tests::testTemporalDateVariableInPropertySequence():Boolean[1]
{
   let l = {bd:Date[1]|meta::relational::tests::milestoning::Product.all($bd)->project(t|$t.classification($bd).type, 'classificationType')};
   let result = executionPlan($l, meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let rlnNode = $result.rootExecutionNode.executionNodes->filter(n|$n->instanceOf(RelationalInstantiationExecutionNode))->at(0).executionNodes->at(0)->cast(@SQLExecutionNode);
   let rlnNodeSQL = $rlnNode.sqlQuery;
   assertEquals('select "productclassificationtable_0".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'${bd}\' and "productclassificationtable_0".thru_z > \'${bd}\') where "root".from_z <= \'${bd}\' and "root".thru_z > \'${bd}\'', $rlnNodeSQL);
}

function <<test.Test>> meta::pure::executionPlan::tests::testTemporalDateVariableInFunctionExpression():Boolean[1]
{
   let l = {bd:Date[1]|meta::relational::tests::milestoning::Product.all($bd)->project(t|$t.classification($bd->adjust(1, DurationUnit.DAYS)).type, 'classificationType')};
   let result = executionPlan($l, meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let rlnNode = $result.rootExecutionNode.executionNodes->filter(n|$n->instanceOf(RelationalInstantiationExecutionNode))->at(0).executionNodes->at(0)->cast(@SQLExecutionNode);
   let rlnNodeSQL = $rlnNode.sqlQuery;
   assertEquals('select "productclassificationtable_0".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= dateadd(DAY, 1, \'${bd}\') and "productclassificationtable_0".thru_z > dateadd(DAY, 1, \'${bd}\')) where "root".from_z <= \'${bd}\' and "root".thru_z > \'${bd}\'', $rlnNodeSQL);
}

function <<test.Test>> meta::pure::executionPlan::tests::testTemporalDateVariableInFunctionExpressionWithPropagation():Boolean[1]
{
   let l = {bd:Date[1]|meta::relational::tests::milestoning::Product.all($bd)->project(t|$t.classification($bd->adjust(1, DurationUnit.DAYS)).exchange.name, 'exchangeName')};
   let result = executionPlan($l, meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let rlnNode = $result.rootExecutionNode.executionNodes->filter(n|$n->instanceOf(RelationalInstantiationExecutionNode))->at(0).executionNodes->at(0)->cast(@SQLExecutionNode);
   let rlnNodeSQL = $rlnNode.sqlQuery;
   assertEquals('select "productexchangetable_0".name as "exchangeName" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= dateadd(DAY, 1, \'${bd}\') and "productclassificationtable_0".thru_z > dateadd(DAY, 1, \'${bd}\')) left outer join (select "productexchangetable_1".name as name from ProductExchangeTable as "productexchangetable_1" where "productexchangetable_1".from_z <= dateadd(DAY, 1, \'${bd}\') and "productexchangetable_1".thru_z > dateadd(DAY, 1, \'${bd}\')) as "productexchangetable_0" on ("productclassificationtable_0".exchange = "productexchangetable_0".name) where "root".from_z <= \'${bd}\' and "root".thru_z > \'${bd}\'', $rlnNodeSQL);
}

function <<test.Test>> meta::pure::executionPlan::tests::testModelConnectionSimple() : Boolean[1]
{
   let res = executionPlan(
                  |meta::pure::mapping::modelToModel::test::shared::dest::Firm.all()->project([f|$f.legalName], ['legalName']),
                  meta::pure::mapping::modelToModel::test::simple::simpleModelMappingWithAssociation,
                  ^Runtime(connections = [^meta::pure::mapping::modelToModel::ModelChainConnection(element = ^meta::pure::mapping::modelToModel::ModelStore(),
                                                                                                   mappings = meta::pure::mapping::modelToModel::test::shared::relationalMapping),
                     getConnection()]), meta::relational::extension::relationalExtensions());

   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(legalName, String, "", "")]\n'+
      '  resultColumns = [("legalName", VARCHAR(200))]\n'+
      '  sql = select "root".name as "legalName" from Firm as "root"\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testModelConnectionDeepFunction() : Boolean[1]
{
   let res = executionPlan(
                  |meta::pure::mapping::modelToModel::test::shared::dest::Person.all()->project([p|$p.firstName, p|$p.lastName], ['firstName','lastName']),
                     meta::pure::mapping::modelToModel::test::simple::simpleModelMappingO,
                     ^Runtime(connections = [
                        ^meta::pure::mapping::modelToModel::ModelChainConnection(element = ^meta::pure::mapping::modelToModel::ModelStore(),
                                                                                 mappings = [meta::pure::mapping::modelToModel::test::simple::simpleModelMapping,
                                                                                             meta::pure::mapping::modelToModel::test::shared::relationalMapping]
                                                                                  ),
                        getConnection()]
                        )
            , meta::relational::extension::relationalExtensions());

   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(firstName, String, "", ""), (lastName, String, "", "")]\n'+
      '  resultColumns = [("firstName", ""), ("lastName", "")]\n'+
      '  sql = select concat(substring("root".fullname, 0, LOCATE(\' \', "root".fullname)), \'XX\') as "firstName", concat(substring("root".fullname, (LOCATE(\' \', "root".fullname) + 1), char_length("root".fullname)), \'ZZ\') as "lastName" from SPerson as "root"\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testModelConnectionJoin() : Boolean[1]
{
   let res = executionPlan(
                  |meta::pure::mapping::modelToModel::test::shared::dest::Firm.all()->project([f|$f.legalName, f|$f.employees.lastName], ['legalName', 'lastName']),
                  meta::pure::mapping::modelToModel::test::simple::simpleModelMappingWithAssociation,
                  ^Runtime(connections = [^meta::pure::mapping::modelToModel::ModelChainConnection(element = ^meta::pure::mapping::modelToModel::ModelStore(),
                                                                                                   mappings = meta::pure::mapping::modelToModel::test::shared::relationalMapping),
                     getConnection()]), meta::relational::extension::relationalExtensions());
   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(legalName, String, "", ""), (lastName, String, "", "")]\n'+
      '  resultColumns = [("legalName", VARCHAR(200)), ("lastName", "")]\n'+
      '  sql = select "root".name as "legalName", substring("person_0".fullname, (LOCATE(\' \', "person_0".fullname) + 1), char_length("person_0".fullname)) as "lastName" from Firm as "root" left outer join Person as "person_0" on ("person_0".firm = "root".name)\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testModelConnectionAgg() : Boolean[1]
{
   let g = agg(x:meta::pure::mapping::modelToModel::test::shared::dest::Person[1] | $x.lastName,  y:String[*] | $y->count());
   let res = executionPlan(|meta::pure::mapping::modelToModel::test::shared::dest::Person.all()->groupBy([x | $x.firstName], $g, ['FirstName', 'PersonCount' ]),
            meta::pure::mapping::modelToModel::test::simple::simpleModelMapping,
            ^Runtime(connections = [^meta::pure::mapping::modelToModel::ModelChainConnection(element = ^meta::pure::mapping::modelToModel::ModelStore(),
                                                                                             mappings = meta::pure::mapping::modelToModel::test::shared::relationalMapping),
                                       meta::pure::mapping::modelToModel::test::shared::getConnection()
                                   ]
             ), meta::relational::extension::relationalExtensions());
   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(FirstName, String, "", ""), (PersonCount, Integer, INT, "")]\n'+
      '  resultColumns = [("FirstName", ""), ("PersonCount", "")]\n'+
      '  sql = select substring("root".fullname, 0, LOCATE(\' \', "root".fullname)) as "FirstName", count(substring("root".fullname, (LOCATE(\' \', "root".fullname) + 1), char_length("root".fullname))) as "PersonCount" from SPerson as "root" group by "FirstName"\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPLanGenerationForFrom() : Boolean[1]
{
   let res = executionPlan(
      |_Firm.all()->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=meta::pure::mapping::modelToModel::test::shared::getConnection()));, meta::relational::extension::relationalExtensions()
   );
   let expected =
      'Relational\n'+
      '(\n'+
      '  type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '  resultSizeRange = *\n'+
      '  resultColumns = [("pk_0", VARCHAR(200)), ("name", VARCHAR(200))]\n'+
      '  sql = select "root".name as "pk_0", "root".name as "name" from Firm as "root"\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPLanGenerationForFromInAllocation() : Boolean[1]
{
   let res = executionPlan(
      | let var = _Firm.all()->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=meta::pure::mapping::modelToModel::test::shared::getConnection()));, meta::relational::extension::relationalExtensions()
   );
   let expected =
      'Allocation\n'+
      '(\n'+
      '  type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '  resultSizeRange = *\n'+
      '  name = var\n'+
      '  value = \n'+
      '    (\n'+
      '      Relational\n'+
      '      (\n'+
      '        type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '        resultSizeRange = *\n'+
      '        resultColumns = [("pk_0", VARCHAR(200)), ("name", VARCHAR(200))]\n'+
      '        sql = select "root".name as "pk_0", "root".name as "name" from Firm as "root"\n'+
      '        connection = TestDatabaseConnection(type = "H2")\n'+
      '      )\n'+
      '    )\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPLanGenerationForFromWithMultiClusters() : Boolean[1]
{
   let res = executionPlan(
      {|  let var = _Firm.all()->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=meta::pure::mapping::modelToModel::test::shared::getConnection()));
         _Firm.all()->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=meta::pure::mapping::modelToModel::test::shared::getConnection()));}, meta::relational::extension::relationalExtensions()
   );
   let expected =
      'Sequence\n'+
      '(\n'+
      '  type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '  resultSizeRange = *\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '      resultSizeRange = *\n'+
      '      name = var\n'+
      '      value = \n'+
      '        (\n'+
      '          Relational\n'+
      '          (\n'+
      '            type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '            resultSizeRange = *\n'+
      '            resultColumns = [("pk_0", VARCHAR(200)), ("name", VARCHAR(200))]\n'+
      '            sql = select "root".name as "pk_0", "root".name as "name" from Firm as "root"\n'+
      '            connection = TestDatabaseConnection(type = "H2")\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '      resultSizeRange = *\n'+
      '      resultColumns = [("pk_0", VARCHAR(200)), ("name", VARCHAR(200))]\n'+
      '      sql = select "root".name as "pk_0", "root".name as "name" from Firm as "root"\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForInWithCollectionInput() : Boolean[1]
{
   let res = executionPlan(
      {name:String[*] |_Person.all()->filter(x | $x.fullName->in($name))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.MemSQL)), meta::relational::extension::relationalExtensions()
   );
   let expected = 'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[*]])Allocation(type=Stringname=inFilterClause_namevalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name,"Stream")||((collectionSize(name)?number)>1048576))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name]tempTableName=tempTableForIn_nametempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="MemSQL"))Constant(type=Stringvalues=[select`temptableforin_name_0`.ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_nameas`temptableforin_name_0`]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(name",""\'""\'""null")}])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select`root`.fullnameas`fullName`fromPersonas`root`where`root`.fullnamein(${inFilterClause_name})connection=DatabaseConnection(type="MemSQL"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForNotInWithCollectionInputForSnowflake() : Boolean[1]
{
   let res = executionPlan(
      {name:String[*] |_Person.all()->filter(x | !$x.fullName->in($name))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.Snowflake)), meta::relational::extension::relationalExtensions()
   );
   let expected = 'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[*]])Allocation(type=Stringname=inFilterClause_namevalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name,"Stream")||((collectionSize(name)?number)>16348))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name]tempTableName=tempTableForIn_nametempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="Snowflake"))Constant(type=Stringvalues=[select"temptableforin_name_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_nameas"temptableforin_name_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(name",""\'""\'""null")}])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"where("root".fullnamenotin(${inFilterClause_name})OR"root".fullnameisnull)connection=DatabaseConnection(type="Snowflake"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForInWithIntegerCollection():Boolean[1]
{
   let res = executionPlan(
      {lengths:Integer[*] |_Person.all()->filter(x | $x.fullName->length()->in($lengths))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.H2)), meta::relational::extension::relationalExtensions()
   );
   let expected = 'Sequence(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[lengths:Integer[*]])Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"wherechar_length("root".fullname)in(${renderCollection(lengths",""""""null")})connection=DatabaseConnection(type="H2"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForInWithCollectionIntegerInput():Boolean[1]
{
   let res = executionPlan(
      {lengths:Integer[*] |_Person.all()->filter(x | $x.fullName->length()->in($lengths))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.MemSQL)), meta::relational::extension::relationalExtensions()
   );
   let expected = 'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[lengths:Integer[*]])Allocation(type=Stringname=inFilterClause_lengthsvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(lengths,"Stream")||((collectionSize(lengths)?number)>1048576))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[lengths]tempTableName=tempTableForIn_lengthstempTableColumns=[(ColumnForStoringInCollection,INT)]connection=DatabaseConnection(type="MemSQL"))Constant(type=Stringvalues=[select`temptableforin_lengths_0`.ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_lengthsas`temptableforin_lengths_0`]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(lengths",""""""null")}])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select`root`.fullnameas`fullName`fromPersonas`root`wherechar_length(`root`.fullname)in(${inFilterClause_lengths})connection=DatabaseConnection(type="MemSQL"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForMultipleInWithCollectionAndConstantInputs() : Boolean[1]
{
   let res = executionPlan(
      {name:String[*] |_Person.all()->filter(x | $x.fullName->in($name))->filter(x | $x.fullName->in(['A', 'B']))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.SybaseIQ)), meta::relational::extension::relationalExtensions()
   );
   let expected = 'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[*]])Allocation(type=Stringname=inFilterClause_namevalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name,"Stream")||((collectionSize(name)?number)>250000))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name]tempTableName=tempTableForIn_nametempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="SybaseIQ"))Constant(type=Stringvalues=[select"temptableforin_name_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_nameas"temptableforin_name_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(name",""\'""\'""null")}])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"where"root".fullnamein(${inFilterClause_name})and"root".fullnamein(\'A\',\'B\')connection=DatabaseConnection(type="SybaseIQ"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForMultipleInWithTwoCollectionInputs() : Boolean[1]
{
   let res = executionPlan(
      {name:String[*], name1:String[*]|_Person.all()->filter(x | $x.fullName->in($name))->filter(x | $x.fullName->in($name1))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.DB2)), meta::relational::extension::relationalExtensions()
   );
   let expected = ['RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[*],name1:String[*]])Allocation(type=Stringname=inFilterClause_name1value=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name1,"Stream")||((collectionSize(name1)?number)>32767))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name1]tempTableName=tempTableForIn_name1tempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="DB2"))Constant(type=Stringvalues=[select"temptableforin_name1_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_name1as"temptableforin_name1_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(name1",""\'""\'""null")}])))))Allocation(type=Stringname=inFilterClause_namevalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name,"Stream")||((collectionSize(name)?number)>32767))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name]tempTableName=tempTableForIn_nametempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="DB2"))Constant(type=Stringvalues=[select"temptableforin_name_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_nameas"temptableforin_name_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(name",""\'""\'""null")}])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"where"root".fullnamein(${inFilterClause_name})and"root".fullnamein(${inFilterClause_name1})connection=DatabaseConnection(type="DB2"))))',
      'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[*],name1:String[*]])Allocation(type=Stringname=inFilterClause_namevalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name,"Stream")||((collectionSize(name)?number)>32767))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name]tempTableName=tempTableForIn_nametempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="DB2"))Constant(type=Stringvalues=[select"temptableforin_name_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_nameas"temptableforin_name_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(name",""\'""\'""null")}])))))Allocation(type=Stringname=inFilterClause_name1value=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name1,"Stream")||((collectionSize(name1)?number)>32767))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name1]tempTableName=tempTableForIn_name1tempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="DB2"))Constant(type=Stringvalues=[select"temptableforin_name1_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_name1as"temptableforin_name1_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(name1",""\'""\'""null")}])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"where"root".fullnamein(${inFilterClause_name})and"root".fullnamein(${inFilterClause_name1})connection=DatabaseConnection(type="DB2"))))'];
   assert($expected->contains($res->planToStringWithoutFormatting(meta::relational::extension::relationalExtensions())));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForMultipleInWithTwoCollectionInputsForSnowflake() : Boolean[1]
{
   let res = executionPlan({ids:Integer[*], dates:Date[*]|Trade.all()->filter(t|$t.settlementDateTime->in($dates) && $t.id->in($ids))->project([x | $x.id], ['TradeId'])},
                           simpleRelationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.Snowflake)), meta::relational::extension::relationalExtensions());
   let expected = ['RelationalBlockExecutionNode(type=TDS[(TradeId,Integer,INT,"")](FunctionParametersValidationNode(functionParameters=[ids:Integer[*],dates:Date[*]])Allocation(type=Stringname=inFilterClause_datesvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(dates,"Stream")||((collectionSize(dates)?number)>16348))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[dates]tempTableName=tempTableForIn_datestempTableColumns=[(ColumnForStoringInCollection,TIMESTAMP)]connection=DatabaseConnection(type="Snowflake"))Constant(type=Stringvalues=[select"temptableforin_dates_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_datesas"temptableforin_dates_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(dates",""\'""\'""null")}])))))Allocation(type=Stringname=inFilterClause_idsvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(ids,"Stream")||((collectionSize(ids)?number)>16348))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[ids]tempTableName=tempTableForIn_idstempTableColumns=[(ColumnForStoringInCollection,INT)]connection=DatabaseConnection(type="Snowflake"))Constant(type=Stringvalues=[select"temptableforin_ids_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_idsas"temptableforin_ids_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(ids",""""""null")}])))))Relational(type=TDS[(TradeId,Integer,INT,"")]resultColumns=[("TradeId",INT)]sql=select"root".IDas"TradeId"fromtradeTableas"root"where("root".settlementDateTimein(${inFilterClause_dates})and"root".IDin(${inFilterClause_ids}))connection=DatabaseConnection(type="Snowflake"))))',
      'RelationalBlockExecutionNode(type=TDS[(TradeId,Integer,INT,"")](FunctionParametersValidationNode(functionParameters=[ids:Integer[*],dates:Date[*]])Allocation(type=Stringname=inFilterClause_idsvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(ids,"Stream")||((collectionSize(ids)?number)>16348))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[ids]tempTableName=tempTableForIn_idstempTableColumns=[(ColumnForStoringInCollection,INT)]connection=DatabaseConnection(type="Snowflake"))Constant(type=Stringvalues=[select"temptableforin_ids_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_idsas"temptableforin_ids_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(ids",""""""null")}])))))Allocation(type=Stringname=inFilterClause_datesvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(dates,"Stream")||((collectionSize(dates)?number)>16348))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[dates]tempTableName=tempTableForIn_datestempTableColumns=[(ColumnForStoringInCollection,TIMESTAMP)]connection=DatabaseConnection(type="Snowflake"))Constant(type=Stringvalues=[select"temptableforin_dates_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_datesas"temptableforin_dates_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(dates",""\'""\'""null")}])))))Relational(type=TDS[(TradeId,Integer,INT,"")]resultColumns=[("TradeId",INT)]sql=select"root".IDas"TradeId"fromtradeTableas"root"where("root".settlementDateTimein(${inFilterClause_dates})and"root".IDin(${inFilterClause_ids}))connection=DatabaseConnection(type="Snowflake"))))'];
   assert($expected->contains($res->planToStringWithoutFormatting(meta::relational::extension::relationalExtensions())));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForInWithVarAndConstantInputs():Boolean[1]
{
   let res = executionPlan({name:String[1] |_Person.all()->filter(x | $x.fullName->in([$name, 'John', 'Peter', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50']))->project([x | $x.fullName], ['fullName']);},
                           meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^TestDatabaseConnection(element = relationalDB, type=DatabaseType.H2)), meta::relational::extension::relationalExtensions());
   let expected = 'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[1]])Allocation(type=meta::pure::functions::collection::Listname=tempVarForIn_4value=(Constant(type=meta::pure::functions::collection::Listvalues=[[[John,Peter,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]]])))CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name,tempVarForIn_4]tempTableName=tempTableForIn_4tempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=TestDatabaseConnection(type="H2"))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"where"root".fullnamein(select"temptableforin_4_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_4as"temptableforin_4_0")connection=TestDatabaseConnection(type="H2"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForInWithTimeZone():Boolean[1]
{
   let res = executionPlan({dates:DateTime[*] |Trade.all()->filter(t|$t.settlementDateTime->in($dates))->project([x | $x.id], ['TradeId'])},
                           simpleRelationalMapping,
                           ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.Presto, timeZone='US/Arizona')),
                           meta::relational::extension::relationalExtensions());
   let expected =
      'Sequence\n'+
      '(\n'+
      '  type = TDS[(TradeId, Integer, INT, \"\")]\n'+
      '  (\n'+
      '    FunctionParametersValidationNode\n'+
      '    (\n'+
      '      functionParameters = [dates:DateTime[*]]\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = TDS[(TradeId, Integer, INT, \"\")]\n'+
      '      resultColumns = [(\"TradeId\", INT)]\n'+
      '      sql = select \"root\".ID as \"TradeId\" from tradeTable as \"root\" where \"root\".settlementDateTime in (${renderCollectionWithTz(dates \"[US/Arizona]\" \",\" \"Timestamp\'\" \"\'\" \"null\")})\n'+
      '      connection = DatabaseConnection(type = \"Presto\")\n'+
      '    )\n'+
      '  )\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForInWithStrictDate():Boolean[1]
{
   let res = executionPlan({dates:StrictDate[*] |Trade.all()->filter(t|$t.date->in($dates))->project([x | $x.id], ['TradeId'])},
                           simpleRelationalMapping,
                           ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.Sybase)),
                           meta::relational::extension::relationalExtensions());
   let expected =
      'Sequence\n'+
      '(\n'+
      '  type = TDS[(TradeId, Integer, INT, \"\")]\n'+
      '  (\n'+
      '    FunctionParametersValidationNode\n'+
      '    (\n'+
      '      functionParameters = [dates:StrictDate[*]]\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = TDS[(TradeId, Integer, INT, \"\")]\n'+
      '      resultColumns = [(\"TradeId\", INT)]\n'+
      '      sql = select \"root\".ID as \"TradeId\" from tradeTable as \"root\" where \"root\".tradeDate in (${renderCollection(dates \",\" \"convert(DATE, \'\" \"\', 101)\" \"null\")})\n'+
      '      connection = DatabaseConnection(type = \"Sybase\")\n'+
      '    )\n'+
      '  )\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::relationalTDSTypeForColumnsAndQuoting():Boolean[1]
{
   let queryWithoutQuotes   = {|tableToTDS(meta::relational::functions::database::tableReference(meta::relational::tests::db,'default','tableWithQuotedColumns'))
                  ->project([
                               col({r:TDSRow[1]|$r.getString('FIRST NAME')}, 'FIRST NAME'),
                               col({r:TDSRow[1]|$r.getString('LAST NAME')}, 'LAST NAME'),
                               col({r:TDSRow[1]|$r.getString('1columnStartsWithNumber')}, '1columnStartsWithNumber')
                              ])
                 ->restrict(['FIRST NAME', 'LAST NAME', '1columnStartsWithNumber'])
                 ->filter({r | $r.getString('FIRST NAME') == 'Peter'})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(FIRST NAME, String, VARCHAR(200), ""), (LAST NAME, String, VARCHAR(200), ""), (1columnStartsWithNumber, String, VARCHAR(200), "")]\n'+
      '  resultColumns = [("FIRST NAME", VARCHAR(200)), ("LAST NAME", VARCHAR(200)), ("1columnStartsWithNumber", VARCHAR(200))]\n'+
      '  sql = select "root"."FIRST NAME" as "FIRST NAME", "root"."LAST NAME" as "LAST NAME", "root"."1columnStartsWithNumber" as "1columnStartsWithNumber" from tableWithQuotedColumns as "root" where "root"."FIRST NAME" = \'Peter\'\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';

   let planWithoutQuotes = executionPlan($queryWithoutQuotes, $mapping, $runtime, meta::relational::extension::relationalExtensions());

   assertEquals($expected, $planWithoutQuotes->planToString(meta::relational::extension::relationalExtensions()));

    let queryWithQuotes   = {|tableToTDS(meta::relational::functions::database::tableReference(meta::relational::tests::db,'default','tableWithQuotedColumns'))
                            ->project([
                               col({r:TDSRow[1]|$r.getString('FIRST NAME')}, 'FIRST NAME'),
                               col({r:TDSRow[1]|$r.getString('LAST NAME')}, 'LAST NAME'),
                               col({r:TDSRow[1]|$r.getString('1columnStartsWithNumber')}, '1columnStartsWithNumber')
                              ])
                 ->restrict(['"FIRST NAME"', '"LAST NAME"', '"1columnStartsWithNumber"'])
                 ->filter({r | $r.getString('"FIRST NAME"') == 'Peter'})};

   let planWithQuotes = executionPlan($queryWithoutQuotes, $mapping, $runtime, meta::relational::extension::relationalExtensions());

   assertEquals($expected, $planWithQuotes->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testViewToTDS():Boolean[1]
{
  let query = {|viewToTDS(meta::relational::functions::database::viewReference(meta::relational::tests::db,'default','FirstNameAddress'))};

  let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
  let runtime = meta::relational::tests::testRuntime();

  let expected =
      'Relational\n' +
      '(\n' +
      '  type = TDS[(firstName, String, VARCHAR(200), ""), (address, String, VARCHAR(200), "")]\n' +
      '  resultColumns = [("firstName", VARCHAR(200)), ("address", VARCHAR(200))]\n' +
      '  sql = select "root".firstName as "firstName", "root".address as "address" from (select distinct "root".FIRSTNAME as firstName, "addresstable_0".NAME as address from personTable as "root" left outer join addressTable as "addresstable_0" on ("addresstable_0".ID = "root".ADDRESSID)) as "root"\n' +
      '  connection = TestDatabaseConnection(type = "H2")\n' +
      ')\n';

  let plan = executionPlan($query, $mapping, $runtime, meta::relational::extension::relationalExtensions());
  assertEquals($expected, $plan->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagSimple():Boolean[1]
{
   let plan = executionPlan({id:Integer[1], name:String[*]|Person.all()->filter(p|$p.name->in($name) || $p.age == $id)->project(col(p|$p.firstName, 'firstName'))}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(relationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'id').supportsStream, false);
   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagWithSupportedAndUnSupportedUsages():Boolean[1]
{
   let plan = executionPlan({name:String[*]|Person.all()->filter(p|$p.name->in($name) || $name->isEmpty())->project(col(p|$p.firstName, 'firstName'))}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(relationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, false);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagWithTdsJoinForOneDB():Boolean[1]
{
   let plan =executionPlan({name:String[*]|
                testJoinTDS_Person.all()->filter(p|$p.firstName->in($name))->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])
                ->join(testJoinTDS_Firm.all()->filter(p|$p.legalName->in($name))->project([col(p|$p.firmID, 'fID'), col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');});},testJoinTDSMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(relationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagithTdsJoinForTwoDB():Boolean[1]
{
   let plan = executionPlan({name:String[*]|
                                 meta::relational::tests::tds::tdsJoin::testJoinTDS_Person.all()->filter(p|$p.firstName->in($name))->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])
                          ->join(meta::relational::tests::tds::tdsJoin::testJoinTDS_Firm.all()->filter(p|$p.legalName->in($name))->project([col(p|$p.firmID, 'fID'),col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');});}
                            , meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::relational::extension::relationalExtensions());

   let functionParameters = $plan.rootExecutionNode->allNodes(relationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, false);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagFromSimple():Boolean[1]
{
   let plan = executionPlan({id:Integer[1], name:String[*]|Person.all()->filter(p|$p.name->in($name) || $p.age == $id)->project(col(p|$p.firstName, 'firstName'))->from(simpleRelationalMapping, meta::relational::tests::testRuntime())}, meta::relational::extension::relationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(relationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'id').supportsStream, false);
   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagGraphFetchSimple():Boolean[1]
{
   let tree = #{
      Person {
         firstName,
         firm {
            legalName
         }
      }
   }#;

   let query = {name:String[*]|Person.all()->filter(p|$p.name->in($name))->graphFetch($tree)->serialize($tree)};
   let mapping = meta::relational::tests::mapping::embedded::model::mapping::testMappingEmbedded;
   let runtime = meta::relational::tests::testRuntime();

   let plan = executionPlan($query, $mapping, $runtime, meta::relational::extension::relationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(relationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagWithGraphFetchAndFrom():Boolean[1]
{
   let runtime = ^Runtime(connections = getConnection());
   let query = {firmName:String[*]|
                 let targetGraph = #{meta::pure::mapping::modelToModel::test::shared::dest::Firm{legalName,
                                          employees{
                                             firstName,
                                             lastName,
                                             addresses { street }
                                          }
                                       }}#;
                 let sourceGraph = meta::pure::graphFetch::calculateSourceTree($targetGraph, meta::relational::tests::functions::objectReferenceIn::simpleModelMapping, relationalExtensions());
                 let sourceFirms = _Firm.all()->filter(f | $f.name->in($firmName))
                                               ->graphFetch($sourceGraph)->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, $runtime);
                 Firm.all()->graphFetch($targetGraph)->serialize($targetGraph)->from(meta::relational::tests::functions::objectReferenceIn::simpleModelMapping, getRuntimeWithModelConnection(_Firm, $sourceFirms));
               };

   let plan = executionPlan($query, meta::relational::extension::relationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(meta::relational::extension::relationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'firmName').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::classPathsInfluencedByPlanId() : Boolean[1]
{
   let lambda = {| let x = adjust(%2005-10-10,1,DurationUnit.DAYS);
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>%2005-10-10->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};

   let unbound = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::relational::extension::relationalExtensions());

   let withoutPlanId        = $unbound->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), relationalExtensions());
   let withoutPlanIdPackage = $withoutPlanId.globalImplementationSupport->cast(@JavaPlatformImplementation).classes.package->removeDuplicates();

   let withPlanId           = $unbound->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA, planId='abc'), relationalExtensions());
   let withPlanIdPackage    = $withPlanId.globalImplementationSupport->cast(@JavaPlatformImplementation).classes.package->removeDuplicates();

   assertEquals('_pure.plan.root.n1.n1', $withoutPlanIdPackage);
   assertEquals('_pure.plan_abc.plan.root.n1.n1', $withPlanIdPackage);
}

function <<test.Test>> meta::pure::executionPlan::tests::testQuoteIdentifiersFlag():Boolean[1]
{
   let runtime = ^Runtime(connections = ^TestDatabaseConnection(element = meta::relational::tests::db,
                                                                type = DatabaseType.H2,
                                                                quoteIdentifiers = true
                                                             ));
   let result = executionPlan({|Product.all()->filter(p|$p.name == 'bla')}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::simple::Product | simpleRelationalMapping.meta_relational_tests_model_simple_Product)]\n'+
                '  resultSizeRange = *\n'+
                '  resultColumns = [("pk_0", INT), ("name", VARCHAR(200))]\n'+
                '  sql = select "root"."ID" as "pk_0", "root"."NAME" as "name" from "productSchema"."productTable" as "root" where "root"."NAME" = \'bla\'\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testQuoteIdentifiersFlagInOrderByClause():Boolean[1]
{
   let runtime = ^Runtime(connections = ^TestDatabaseConnection(element = meta::relational::tests::db,
                                                                type = DatabaseType.H2,
                                                                quoteIdentifiers = true
                                                             ));
   let result = executionPlan({|Product.all()->project(p|$p.name, 'name')->sort('name')}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = TDS[(name, String, VARCHAR(200), "")]\n'+
                '  resultColumns = [("name", VARCHAR(200))]\n'+
                '  sql = select "root"."NAME" as "name" from "productSchema"."productTable" as "root" order by "name"\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testQuoteIdentifiersFlagInGroupBy():Boolean[1]
{
   let runtime = ^Runtime(connections = ^TestDatabaseConnection(element = meta::relational::tests::db,
                                                                type = DatabaseType.H2,
                                                                quoteIdentifiers = true
                                                             ));
   let result = executionPlan({|Product.all()->project([#/Product/name!prodName#])->groupBy('prodName', agg('cnt', x|$x, y| $y->count()))}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = TDS[(prodName, String, VARCHAR(200), ""), (cnt, Integer, INT, "")]\n'+
                '  resultColumns = [("prodName", VARCHAR(200)), ("cnt", "")]\n'+
                '  sql = select "root"."NAME" as "prodName", count(*) as "cnt" from "productSchema"."productTable" as "root" group by "prodName"\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testQuoteIdentifiersFlagWithGraphFetch():Boolean[1]
{
   let runtime = ^Runtime(connections = ^TestDatabaseConnection(element = meta::relational::tests::db,
                                                                type = DatabaseType.H2,
                                                                quoteIdentifiers = true
                                                             ));
   let graph = #{Product{name}}#;
   let result = executionPlan({|Product.all()->graphFetch($graph)->serialize($graph)}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
   assertEquals('PureExp(type=Stringexpression=[NodeIndex:0]->serialize(#{meta::relational::tests::model::simple::Product{name}}#)(GlobalGraphFetch(type=PartialClass[impls=[(meta::relational::tests::model::simple::Product|simpleRelationalMapping.meta_relational_tests_model_simple_Product)],propertiesWithParameters=[name]]resultSizeRange=*store=meta::relational::tests::dblocalGraphFetchExecutionNode=RelationalGraphFetch(type=PartialClass[impls=[(meta::relational::tests::model::simple::Product|simpleRelationalMapping.meta_relational_tests_model_simple_Product)],propertiesWithParameters=[name]]nodeIndex=0relationalNode=SQL(type=meta::pure::metamodel::type::AnyresultColumns=[("pk_0",INT),("name",VARCHAR(200))]sql=select"root"."ID"as"pk_0","root"."NAME"as"name"from"productSchema"."productTable"as"root"connection=TestDatabaseConnection(type="H2"))children=[])children=[])))', $result->planToStringWithoutFormatting(meta::relational::extension::relationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanWithLocalH2ConnectionWithSQL():Boolean[1]
{
  let conn = ^meta::pure::alloy::connections::RelationalDatabaseConnection
                    (
                       element = db,
                       type = meta::relational::runtime::DatabaseType.H2,
                       datasourceSpecification = ^meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification(testDataSetupSqls=['a','b']),
                       authenticationStrategy = ^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy()
                    );

  let runtime = ^Runtime(connections = $conn);
  let plan = executionPlan({|Product.all()->filter(p|$p.name == 'ok')}, simpleRelationalMapping, $runtime, meta::relational::extension::relationalExtensions());
  assertEquals(['a','b'], $plan.rootExecutionNode.executionNodes->cast(@meta::relational::mapping::SQLExecutionNode).connection->cast(@meta::pure::alloy::connections::RelationalDatabaseConnection).datasourceSpecification->cast(@meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification).testDataSetupSqls);
  let transformedPlan = meta::protocols::pure::vX_X_X::transformation::fromPureGraph::executionPlan::transformPlan($plan, meta::relational::extension::relationalExtensions());
  assertEquals(['a','b'], $transformedPlan.rootExecutionNode.executionNodes->cast(@meta::protocols::pure::vX_X_X::metamodel::executionPlan::SQLExecutionNode).connection->cast(@meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::RelationalDatabaseConnection).datasourceSpecification->cast(@meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::specification::LocalH2DatasourceSpecification).testDataSetupSqls);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportGraphFetchWithCircularConstraint():Boolean[1]
{
  let tree = #{
    meta::pure::executionPlan::constraints::tests::Person {
        firstName,
        firm {
          legalName
        }
    }
  }#;

  let query = {|meta::pure::executionPlan::constraints::tests::Person.all()->graphFetchChecked($tree)->serialize($tree)};
  let mapping = meta::pure::executionPlan::constraints::tests::simpleRel;
  let runtime = meta::relational::tests::testRuntime();

  let plan = executionPlan($query, $mapping, $runtime, meta::relational::extension::relationalExtensions());
  let withJava = $plan->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), relationalExtensions());
   
 
  let generatedTree = $withJava.rootExecutionNode->cast(@PureExpressionPlatformExecutionNode).executionNodes->at(0)->cast(@GlobalGraphFetchExecutionNode).graphFetchTree.tree;
  let firmTree = $generatedTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('firm'))->toOne();
  let employeesTree = $firmTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('employees'))->toOne()->cast(@RoutedPropertyGraphFetchTree);

  // toFix: after fixing isDistinct related bug this test should expect ['titleNotEmpty'] result
  assertSameElements(['0', '1', 'titleNotEmpty'], $employeesTree.constraintsExclusions);

}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportGraphFetchWithCircularConstraint2():Boolean[1]
{
  let tree = #{
    meta::pure::executionPlan::constraints::tests::Person {
        firstName,
        firm {
          legalName,
          employees {
            lastName
          }
        }
    }
  }#;

  let query = {|meta::pure::executionPlan::constraints::tests::Person.all()->graphFetchChecked($tree)->serialize($tree)};
  let mapping = meta::pure::executionPlan::constraints::tests::simpleRel;
  let runtime = meta::relational::tests::testRuntime();

  let plan = executionPlan($query, $mapping, $runtime, meta::relational::extension::relationalExtensions());
  let withJava = $plan->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), relationalExtensions());
   
 
  let generatedTree = $withJava.rootExecutionNode->cast(@PureExpressionPlatformExecutionNode).executionNodes->at(0)->cast(@GlobalGraphFetchExecutionNode).graphFetchTree.tree;
  let firmTree = $generatedTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('firm'))->toOne();
  let employeesTree = $firmTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('employees'))->toOne()->cast(@RoutedPropertyGraphFetchTree);
  let innerFirmTree = $employeesTree.subTrees->filter(g | $g->cast(@RoutedPropertyGraphFetchTree).property.name->toOne()->equal('firm'))->toOne()->cast(@RoutedPropertyGraphFetchTree);


  assertSameElements([], $employeesTree.constraintsExclusions);
  assertSameElements(['duplicateEmployee'], $innerFirmTree.constraintsExclusions);

}
