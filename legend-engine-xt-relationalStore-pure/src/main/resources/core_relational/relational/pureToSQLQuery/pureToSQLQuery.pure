// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::executionPlan::*;
import meta::pure::extension::*;
import meta::relational::extension::*;
import meta::alloy::objectReference::*;
import meta::relational::runtime::*;
import meta::relational::functions::pureToSqlQuery::union::*;
import meta::relational::functions::pureToSqlQuery::metamodel::*;
import meta::relational::functions::pureToSqlQuery::*;
import meta::pure::metamodel::valuespecification::*;
import meta::relational::mapping::*;
import meta::relational::metamodel::*;
import meta::relational::metamodel::operation::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::join::*;
import meta::relational::functions::pureToSqlQuery::*;
import meta::relational::functions::pureToSqlQuery::relationalmappingspecification::*;
import meta::pure::mapping::*;
import meta::pure::metamodel::path::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::milestoning::*;
import meta::pure::tds::*;
import meta::relational::functions::*;
import meta::relational::milestoning::*;
import meta::pure::router::clustering::*;
import meta::pure::router::printer::*;
import meta::pure::router::routing::*;
import meta::pure::router::store::embedded::*;
import meta::pure::router::store::metamodel::*;
import meta::pure::router::store::metamodel::clustering::*;
import meta::pure::router::utils::*;
import meta::relational::extension::*;


Class meta::relational::functions::RelationalDebugContext extends DebugContext
{
   forcedIsolation: IsolationStrategy[0..1];
   logOnlyLastSQL : Boolean[0..1];
}

Class meta::relational::functions::pureToSqlQuery::OldAliasToNewAlias extends Pair<String, TableAlias>{}

Class meta::relational::functions::pureToSqlQuery::SelectWithCursor extends RelationalOperationElement
{
   parent : SelectWithCursor[0..1];
   select : SelectSQLQuery[1];
   currentTreeNode : RelationalTreeNode[0..1];
   positionBeforeLastApplyJoinTreeNode : RelationalTreeNode[0..1];
   savedRoot : Pair<RootJoinTreeNode,RelationalTreeNode>[0..1];
   milestoningContext: meta::relational::milestoning::TemporalMilestoningContext[0..1];
   alias(){if($this.currentTreeNode->isEmpty(),|[],|$this.currentTreeNode.alias)}:TableAlias[0..1];
}

Class meta::relational::functions::pureToSqlQuery::PureFunctionToRelationalFunctionPair extends Pair<meta::pure::metamodel::function::Function<Any>, meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>
{
}



Class meta::relational::functions::pureToSqlQuery::State
{
   inScopeVars:Map<String, List<Any>>[1];
   supportedFunctions:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>[1];
   contextBasedSupportedFunctions:Map<meta::pure::metamodel::function::Function<Any>, Pair<meta::pure::metamodel::function::Function<{FunctionExpression[1]->Boolean[1]}>, meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>>[1];
   mapping:Mapping[1];
   inProject:Boolean[1]; // should we fetch all properties in getAll ('NOT'ed)
   inProjectFunctions:Boolean[1];
   filterChainDepth:Integer[1];
   inFilter:Boolean[1];
   shouldIsolateNestedFilter:Boolean[0..1];
   inIsolatedIsEmpty:Boolean[0..1];
   shouldIsolate:Boolean[1];
   propertyMappingFromRouter : PropertyMapping[*];
   qualifierBase:OperationWithParentPropertyMapping[0..1];
   processingProjectionThread : Boolean[1];
   functionReferenceScope : FunctionParamScope[0..1];
   importDataFlow : Boolean[0..1];
   importDataFlowAddFks:Boolean[0..1];
   importDataFlowFksByTable : Map<Relation, List<Column>>[0..1];
   importDataFlowCurrentSetOffsetInUnion : Integer[0..1];
   importDataFlowImplementationCount : Integer[0..1];
   inGetterFlow:Boolean[0..1];
   inIf:Boolean[0..1];
   inIfTrueFalseStmt:Boolean[0..1];
   addDriverTablePkForProject:Boolean[0..1];
   insertDriverTablePkInTempTable:String[0..1];
   useTempTableAsDriver : String[0..1];
   milestoningUseOtherwise : Boolean[0..1];
   leftSideOfQualifier : ValueSpecification[0..1];
   leftSideOfQualifierMilestoningContext : meta::relational::milestoning::TemporalMilestoningContext[0..1];
   functionExpressionStack : FunctionExpression[*];
   inUnionChainedJoin : Boolean[0..1];
   preserveJoinOrder : Boolean[0..1];
   graphFetchFlow : Boolean[0..1];
   graphFetchProperties : Property<Nil,Any|*>[*];
}

Class meta::relational::functions::pureToSqlQuery::FunctionParamScope
{
   parent : FunctionParamScope[0..1];
   varToSelect : Map<String,SelectWithCursor>[0..1];
   varExpressionToSelect :  Pair<VariableExpression,FunctionParamScope>[*];

   resolveFunctionReferenceByName(s : String[1]){
      let resolved = if(!$this.varToSelect->isEmpty(),|$this.varToSelect->toOne()->get($s),|[]);
      if ($resolved->isEmpty(),| if(!$this.parent->isEmpty(),|$this.parent->toOne().resolveFunctionReferenceByName($s),|[]),|$resolved->toOne());
   }:SelectWithCursor[0..1];

   resolveFunctionReferenceByVar(v : VariableExpression[1]){
      let resolved = $this.varExpressionToSelect->filter(p|$p.first.name == $v.name)->first();
      if($resolved->isEmpty(),| if(!$this.parent->isEmpty(),|$this.parent->toOne().resolveFunctionReferenceByVar($v),|[]),|$resolved.second->toOne());
   }:FunctionParamScope[0..1];
}

function meta::relational::functions::pureToSqlQuery::updateFunctionParamScope(state:State[1], functionType:FunctionType[1], selectWithCursor: SelectWithCursor[1]):State[1]
{
   let paramNames = $functionType.parameters->evaluateAndDeactivate().name;
   let values=$paramNames->map(p|pair($p,$selectWithCursor));
   let varToSelect=newMap($values);
   let newScope = ^FunctionParamScope(parent=$state.functionReferenceScope, varToSelect=$varToSelect);
   ^$state(functionReferenceScope=$newScope);
}

function meta::relational::functions::pureToSqlQuery::updateFunctionParamScope(state:State[1], variableExpressions:VariableExpression[*], selectWithCursor: SelectWithCursor[1]):State[1]
{
   if(!$state.functionReferenceScope->isEmpty(),| let varExpressionToSelect=$variableExpressions->map(v|pair($v,$state.functionReferenceScope->toOne()));
                                                  let newScope = ^FunctionParamScope(parent=$state.functionReferenceScope, varExpressionToSelect=$varExpressionToSelect);
                                                  ^$state(functionReferenceScope=$newScope);,
                                                | $state);
}

function meta::relational::functions::pureToSqlQuery::shift(d:DebugContext[1]):DebugContext[1]
{
   ^$d(space = $d.space+'   ');
}

Class meta::relational::functions::pureToSqlQuery::ColumnGroup
{
    columns : RelationalOperationElement[*];
}

function meta::relational::functions::pureToSqlQuery::toSQLQuery(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], execCtx: RelationalExecutionContext[0..1], debug:DebugContext[1], extensions:Extension[*]):SQLQuery[1]
{
   toSQLQuery($functionExpression, $mapping, $inScopeVars, $debug, $execCtx->relationalExecutionContextToState(defaultState($mapping, $inScopeVars)), $extensions);
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::processQuery(functionExpression:FunctionExpression[1], state:State[1], debug:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   processValueSpecification( $functionExpression,
                              [],
                              ^SelectWithCursor(select=^SelectSQLQuery()),
                              newMap([]->cast(@Pair<VariableExpression, ValueSpecification>), VariableExpression->classPropertyByName('name')->cast(@Property<VariableExpression,String|1>)),
                              $state,
                              JoinType.LEFT_OUTER,
                              '',
                              ^List<ColumnGroup>(),
                              $debug,
                              $extensions
                            )->cast(@SelectWithCursor)->toOne();
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::applyPostProcessingForTempTableAsDriver(processedQuery:SelectWithCursor[1], state:State[1], debug:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   $state.useTempTableAsDriver->match([
      t:String[1] | $processedQuery->useTempAsDriver($t, $debug, $extensions),
      _:String[0] | $processedQuery
   ]);
}

function meta::relational::functions::pureToSqlQuery::toSQLQuery(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1], state:State[1], extensions:Extension[*]):SQLQuery[1]
{
   $functionExpression
      ->processQuery($state, $debug, $extensions)
      ->applyPostProcessingForTempTableAsDriver($state, $debug, $extensions)
      ->manageDeepMapClassColumns($functionExpression, $debug, $state, $extensions)
      .select
      ->pushSavedFilteringOperation($extensions)
      ->pushExtraFilteringOperation($extensions)
      ->orderImmediateChildNodeByJoinAliasDependencies();
}

function meta::relational::functions::pureToSqlQuery::toSelectWithCursor(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], execCtx: RelationalExecutionContext[0..1], debug:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   toSelectWithCursor($functionExpression, $mapping, $inScopeVars, $debug, $execCtx->relationalExecutionContextToState(defaultState($mapping, $inScopeVars)), $extensions);
}

function meta::relational::functions::pureToSqlQuery::toSelectWithCursor(functionExpression:FunctionExpression[1], mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1], debug:DebugContext[1], state:State[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let swc = $functionExpression
      ->processQuery($state, $debug, $extensions)
      ->applyPostProcessingForTempTableAsDriver($state, $debug, $extensions)
      ->manageDeepMapClassColumns($functionExpression, $debug, $state, $extensions);

   ^$swc(
      select = $swc.select
         ->pushSavedFilteringOperation($extensions)
         ->pushExtraFilteringOperation($extensions)
         ->orderImmediateChildNodeByJoinAliasDependencies()
   );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::manageDeepMapClassColumns(sql:SelectWithCursor[1], functionExpression:FunctionExpression[1], context:DebugContext[1], state:State[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let isMap = $functionExpression.func == map_T_MANY__Function_1__V_MANY_;
   let isFilter = $functionExpression.func == filter_T_MANY__Function_1__T_MANY_;
   if ($sql.select.columns->isEmpty() && ($isMap || $isFilter),
       |

        let setImplementation = $functionExpression.parametersValues->at(if($isMap,|1,|0))->cast(@StoreMappingRoutedValueSpecification).sets->toOne()->match([r:RootRelationalInstanceSetImplementation[1]|$r, c:CrossSetImplementation[1]|$c->convertCrossSetImplToRelationalSetImpl()]);
        let getAllSelectWithCursor = processGetAll($setImplementation, $setImplementation.class, '', true, -1, true, [], $state, $context, $extensions)->toOne();
        let columns = $getAllSelectWithCursor.select.columns->cast(@Alias);
        assertEquals(1, $columns.relationalElement->cast(@TableAliasColumn).alias->removeDuplicates()->size(), 'Types mapped with joins are not supported yet!');
        let topNode =$ sql.currentTreeNode->toOne();
        let newColumns = $columns->map(c|let t = $c.relationalElement->cast(@TableAliasColumn);
                                         ^$c(relationalElement=^$t(alias=$topNode.alias));
                                   );
        let realSql = $sql.select;
        ^$sql(select = ^$realSql(columns=$newColumns));,
       |$sql
   );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::printDebugQuery(select:SelectSQLQuery[1], space:String[1], extensions:Extension[*]):String[1]
{
   $select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'+
              $space+'             >>>>> '+$select.savedFilteringOperation.second->map(z|$z->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions))->makeString(',')+'\n'+
              $space+'             }}}}} '+$select.extraFilteringOperation->map(z|$z->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions))->makeString(',')+'\n'+
              $space+'             $$$$$ '+$select.leftSideOfFilter->size()->toString()+'\n';
}

function meta::relational::functions::pureToSqlQuery::printRelationalTreeNode(s:RelationalTreeNode[1], extensions:Extension[*]):String[1]
{
   $s->match([root:RootJoinTreeNode[1]|'root',j:JoinTreeNode[1]|$j.joinName+'('+$j.join.operation->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+')']) + '['+ $s->children()->map(c|$c->printRelationalTreeNode($extensions))->makeString(',') +']';
}

function meta::relational::functions::pureToSqlQuery::printNode(t:RelationalTreeNode[0..1]):String[1]
{
   if($t->isEmpty(),|'',|$t->match([a:RootJoinTreeNode[1]|'root',j:JoinTreeNode[1]| $j.join.name+'('+$j.alias.name+')']));
}

function meta::relational::functions::pureToSqlQuery::printNodeWithChildren(t:RelationalTreeNode[0..1]):String[1]
{
   $t->printNode()+'['+if($t->isEmpty(),|'',|$t->map(x|$x->children())->map(c|$c->printNodeWithChildren())->makeString(','))+']';
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::relationalExecutionContextToState(execCtx:RelationalExecutionContext[0..1], s:State[1]):State[1]
{
   if ($execCtx->isEmpty(),
       |$s,
       |^$s
        (
           preserveJoinOrder = $execCtx.preserveJoinOrder,
           addDriverTablePkForProject = $execCtx.addDriverTablePkForProject,
           insertDriverTablePkInTempTable = $execCtx.insertDriverTablePkInTempTable,
           useTempTableAsDriver = $execCtx.useTempTableAsDriver,
           importDataFlow = $execCtx.importDataFlow,
           importDataFlowAddFks = $execCtx.importDataFlowAddFks,
           importDataFlowFksByTable = $execCtx.importDataFlowFksByTable,
           importDataFlowImplementationCount = $execCtx.importDataFlowImplementationCount
        )
   )
}

function meta::relational::functions::pureToSqlQuery::defaultState(mapping:Mapping[1], inScopeVars:Map<String, List<Any>>[1]):State[1]
{
   ^State(inScopeVars=$inScopeVars, supportedFunctions=getSupportedFunctions(), mapping=$mapping, inProject=false, inProjectFunctions=false, inFilter=false, filterChainDepth=0, processingProjectionThread=false, shouldIsolate=true, contextBasedSupportedFunctions=getContextBasedSupportedFunctions());
}


function meta::relational::functions::pureToSqlQuery::pushSavedFilteringOperation(s:SelectSQLQuery[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   if ($s.savedFilteringOperation->isEmpty(),
         |$s,
         |^$s(
               savedFilteringOperation = [],
               filteringOperation = $s.filteringOperation->concatenate($s.savedFilteringOperation.second)->andFilters($extensions)
          )
   );
}

function meta::relational::functions::pureToSqlQuery::pushExtraFilteringOperation(s:SelectSQLQuery[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   if ($s.extraFilteringOperation->isEmpty(),
         |$s,
         |^$s(
               extraFilteringOperation = [],
               filteringOperation=$s.filteringOperation->concatenate($s.extraFilteringOperation->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second)->andFilters($extensions)
          )
   );
}

function meta::relational::functions::pureToSqlQuery::orderImmediateChildNodeByJoinAliasDependencies(s:SelectSQLQuery[1]): SelectSQLQuery[1]
{

   let data = $s.data;
   if(!$data->isEmpty(),| let toOneData = $data->toOne();
                          let childrenMetaData = $data->map(x|$x->children())->map(c|pair($c, buildAndTransformJoinMetaData($c, [], {j:Join[1], jtn:JoinTreeNode[*]|$j})));
                          let sortFunc = {x:Pair<JoinTreeNode,JoinTreeMetaData>[1],y:Pair<JoinTreeNode,JoinTreeMetaData>[1]| if($x.second.jtnAliases->containsAny($y.second.missingJoinAliases),|-1,| if($y.second.jtnAliases->containsAny($x.second.missingJoinAliases),|1,|0) )};
                          let orderedChildren = $childrenMetaData->sort($sortFunc).first;
                          let newData = ^$toOneData(childrenData=$orderedChildren);
                          let leftSideOfFilter = if($s.leftSideOfFilter == $toOneData, |$newData, |$s.leftSideOfFilter);
                          let preIsolationCurrentTreeNode = if($s.preIsolationCurrentTreeNode == $toOneData, |$newData, |$s.preIsolationCurrentTreeNode);
                          let savedFilteringOperation = $s.savedFilteringOperation->map(p|pair(if($p.first == $toOneData,|$newData,|$p.first), $p.second));
                          ^$s(data=$newData, leftSideOfFilter=$leftSideOfFilter, savedFilteringOperation=$savedFilteringOperation, preIsolationCurrentTreeNode=$preIsolationCurrentTreeNode);
                       ,| $s);
}

function meta::relational::functions::pureToSqlQuery::combineFilters(s:RelationalOperationElement[*], and:Boolean[1], extensions:Extension[*]):RelationalOperationElement[0..1]
{
   let ns = $s->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second;
   if ($ns->isEmpty(),
         |[],
         |if ($ns->size() == 1,
            | $ns->toOne(),
            | let dynaName = if($and,| 'and',| 'or');
              newAndOrDynaFunctionRelaxedBrackets($dynaName, $ns->reverse());
         )
   );
}

function meta::relational::functions::pureToSqlQuery::andFilters(s:RelationalOperationElement[*], extensions:Extension[*]):RelationalOperationElement[0..1]
{
   $s->combineFilters(true, $extensions);
}

function meta::relational::functions::pureToSqlQuery::orFilters(s:RelationalOperationElement[*], extensions:Extension[*]):RelationalOperationElement[0..1]
{
   $s->combineFilters(false, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processValueSpecification(vs:ValueSpecification[1], currentPropertyMapping:PropertyMapping[*],  operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[*]
{
   processValueSpecificationReturnPropertyMapping($vs, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->map(r | $r.element);
}

function meta::relational::functions::pureToSqlQuery::processValueSpecificationReturnPropertyMapping(vs:ValueSpecification[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
   let res = $vs->evaluateAndDeactivate()->match(
             [
                 r:StoreMappingRoutedValueSpecification[1] | $r.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, ^$state(propertyMappingFromRouter = $r.propertyMapping), $joinType, $nodeId, $aggFromMap, $context, $extensions),
                 r:FunctionRoutedValueSpecification[1] | $r.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions),
                 f:FunctionExpression[1] | processFunctionExpression($f, $currentPropertyMapping, $operation, $vars, ^$state(functionExpressionStack+=$f), $joinType, buildNodeId($nodeId,'_d'), $aggFromMap, $context, $extensions),
                 i:InstanceValue[1] | let elements = processInstanceValue($i, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);
                                      $elements->map(e | ^OperationWithParentPropertyMapping(element=$e));,
                 v:VariableExpression[1] | processVariableExpression($v,$currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions),
                 c:StoreMappingClusteredValueSpecification[1]|fail('This query is attempting to join across stores which is not currently supported. If you are reusing other mapping definitions this may indicate that you have not re-aliased the store names when defining includes. \n'+
                                                       'For example, the mapping may have\n include mapping::example::ExampleMapping\ninstead of\n include mapping::example::ExampleMapping[OtherStore->MyStore]\n' +
                                                       'Cluster details:\n' + $c->asString());
                                                  ^OperationWithParentPropertyMapping(element=$operation);,
                 n:NoSetRoutedValueSpecification[1]|$n.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions),
                 t:TDSRoutedValueSpecification[1] |  $t.value->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)
             ]);
    $res.element->map(e|$e->match([c:ClassInstanceHolder[1]|true, s:SelectWithCursor[1]|$s->validate($vs, $extensions)]));
    $res;
}

function meta::relational::functions::pureToSqlQuery::processVariableExpression(v:VariableExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
   print(if(!$context.debug, |'', | $context.space+'>Process Variable Expression, name:' + $v.name + '\n'));
   if ($v.name == 'this' && $state.qualifierBase->isNotEmpty(), | let op = $state.qualifierBase->toOne();
                            let elem = $op.element->cast(@SelectWithCursor);
                            let sel = $elem.select;
                            ^$op(element = ^$elem(select = ^$sel(filteringOperation = [])));,
                          | let res = $v->resolve($vars, $state.inScopeVars)->evaluateAndDeactivate();

                            let resolvedOperation = if(!$state.functionReferenceScope->isEmpty(), //attempt to resolve the variable name to a SelectWithCursor recorded in either this or a parent scope
                                                            | let resolvedOperation = $state.functionReferenceScope->toOne().resolveFunctionReferenceByName($v.name);
                                                              if(!$resolvedOperation->isEmpty(),| $resolvedOperation,|$operation)->toOne();,
                                                            | $operation);

                            let nres = if($res->isNotEmpty() && $res->toOne()->instanceOf(InstanceValue) && $res->cast(@InstanceValue).values->size() == 1 && $res->cast(@InstanceValue).values->at(0)->instanceOf(VarPlaceHolder) &&
                                          !$state.functionReferenceScope->isEmpty() && $state.functionReferenceScope->toOne().resolveFunctionReferenceByName($v.name)->isNotEmpty(),
                                          |//The open variable is managed in the scope of the expression, so we should not stub it
                                           [],
                                          |$res
                                        );

                            if($nres->isEmpty(),                                                   //true for function params e.g. $e in '[]->filter(e|$e...)'
                                       |$operation->match([ o:OperationWithParentPropertyMapping[1] | $o,
                                                             a:RelationalOperationElement[1] | ^OperationWithParentPropertyMapping(
                                                                                                    element=$resolvedOperation,
                                                                                                    currentPropertyMapping=$currentPropertyMapping
                                                                                               )
                                                          ]),
                                       |$nres->toOne()->match(
                                                                [
                                                                   e:VariableExpression[1]| ^OperationWithParentPropertyMapping(element=$operation);,
                                                                   a:Any[1]|                     //the resolved VariableExpression (ValueSpecification) is processed with respect to the $state recorded at the time the owning QualifiedProperty is processed e.g. address in 'Firm.all->filter(f|$f.employeesByAddress($f.address));' employeesByAddress(address: Address[1]){..}'
                                                                            let possiblyNewState = if(!$state.functionReferenceScope ->isEmpty(),
                                                                                                                    | let resolvedVariableExpression=$state.functionReferenceScope->toOne().resolveFunctionReferenceByVar($v);
                                                                                                                      if(!$resolvedVariableExpression->isEmpty(),|^$state(functionReferenceScope=$resolvedVariableExpression->toOne()),|$state);,
                                                                                                                    | $state
                                                                                                     )->toOne();
                                                                            processValueSpecificationReturnPropertyMapping($nres->toOne(), $currentPropertyMapping, $resolvedOperation, $vars, $possiblyNewState, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions);
                                                                ]);
                             );
                          )->cast(@OperationWithParentPropertyMapping);
}

function meta::relational::functions::pureToSqlQuery::validate(s:SelectWithCursor[1], v:ValueSpecification[0..1], extensions:Extension[*]):Boolean[1]
{
   let allNodes = if($s.select.data->isEmpty(),|[],|$s.select.data->toOne()->getAllNodes())->cast(@RelationalTreeNode);
   validateNode('currentTreeNode', $s.select, $s.currentTreeNode, $v, $allNodes, $extensions);
   validateNode('positionBeforeLastApplyJoinTreeNode', $s.select, $s.positionBeforeLastApplyJoinTreeNode, $v, $allNodes, $extensions);
   validate($s.select, $allNodes, $v, $extensions);
}

function meta::relational::functions::pureToSqlQuery::validate(s:SelectSQLQuery[1], extensions:Extension[*]):Boolean[1]
{
   if ($s.savedFilteringOperation->isEmpty() && $s.leftSideOfFilter->isEmpty(),
      |true,
      |validate($s, $s.data->toOne()->getAllNodes()->cast(@RelationalTreeNode), [], $extensions);
   );
}

function meta::relational::functions::pureToSqlQuery::validate(s:SelectSQLQuery[1], allNodes:RelationalTreeNode[*], v:ValueSpecification[0..1], extensions:Extension[*]):Boolean[1]
{
   $s.savedFilteringOperation.first->map(n|validateNode('savedFilteringOperation(Left Side)', $s, $n, $v, $allNodes, $extensions))->fold({a,b|$a->and($b)},true);
   validateNode('leftSideOfFilter', $s, $s.leftSideOfFilter, $v, $allNodes, $extensions);
}

function meta::relational::functions::pureToSqlQuery::validateNode(nodeName:String[1], s:SelectSQLQuery[1], node:RelationalTreeNode[0..1], v:ValueSpecification[0..1], allNodes:RelationalTreeNode[*], extensions:Extension[*]):Boolean[1]
{
   if ($node->isEmpty(),
      |true,
      |

         assert(
              $allNodes->contains($node->toOne()),
              |'\nfail:\n\nNODE VALIDATION ERROR: '+$nodeName+'\n\n'+$allNodes->map(n|$n->printNode())->makeString(', ')+'\n\nDOESN\'T CONTAIN:\n\n'+$node->printNode()+
               '\n\nIN:\n\n\''+$s->printDebugQuery('', $extensions)+
               'VS: \''+if($v->isEmpty(),|'',|$v->toOne()->meta::pure::router::printer::asString()+'\'');
             );
   );
}

function meta::relational::functions::pureToSqlQuery::getLeafNodes(nodes:TreeNode[*]):TreeNode[*]
{
   $nodes->map(x | if ($x.childrenData->isEmpty(),| $x,| $x.childrenData->getLeafNodes()));
}

function meta::relational::functions::pureToSqlQuery::removeLeafNodes(nodes:TreeNode[*]):TreeNode[*]
{
   $nodes->map(x | if ($x.childrenData->isEmpty(),| [],| ^$x(childrenData = $x.childrenData->removeLeafNodes())));
}

function meta::relational::functions::pureToSqlQuery::getParentNode(child:RelationalTreeNode[1], s:RelationalTreeNode[1]):RelationalTreeNode[0..1]
{
   let parentNode =  $s->getAllNodes()->cast(@RelationalTreeNode)->filter(n|$n->children()->contains($child));
   assert($parentNode->size()<2, | 'Multiple parent nodes found for child node: '+$child->printNode());
   $parentNode->first();
}

function meta::relational::functions::pureToSqlQuery::getAllNodes(s:TreeNode[1]):TreeNode[*]
{
   $s->concatenate($s.childrenData->map(k|$k->getAllNodes()));
}

function meta::relational::functions::pureToSqlQuery::wrapIfNecessary(operation:RelationalOperationElement[1]):OperationWithParentPropertyMapping[1]
{
   $operation->match([ o:OperationWithParentPropertyMapping[1] | $o,
                       a:RelationalOperationElement[1] | ^OperationWithParentPropertyMapping(element=$operation)
                     ])
}

Class meta::relational::functions::pureToSqlQuery::ClassInstanceHolder extends RelationalOperationElement
{
   value : Any[1];
}

function meta::relational::functions::pureToSqlQuery::processInstanceValue(i:InstanceValue[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[*]
{
   processValue($i.values, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processValue(vals:Any[*], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[*]
{
    let select = $operation.select;

    if ($vals->isEmpty(), | ^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=^SQLNull())),|^$select(columns = ^Literal(value=^SQLNull()))))
                        , | $vals->map(v | $v->match([
                                  s:String[1] | ^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$s)),|^$select(columns = ^Literal(value=$s)))),
                                  n:Number[1] | ^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$n)),|^$select(columns = ^Literal(value=$n)))),
                                  d:Date[1] | ^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$d)),|^$select(columns = ^Literal(value=$d)))),
                                  b:Boolean[1] | ^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$b)),|^$select(columns = ^Literal(value=$b)))),
                                  e:Enum[1] | let ev = mapEnumValue($e, $currentPropertyMapping, $context); ^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=$ev)),|^$select(columns = ^Literal(value=$ev))));,
                                  v:PlanSetPlaceHolder[1] | let newTable = ^VarSetPlaceHolder(varName=$v.name,
                                                                                              columns=$v.tdsColumns->map(c|^Column(owner =^VarSetPlaceHolder(varName=$v.name),
                                                                                                                                   name= $c.name,
                                                                                                                                   type = ^meta::relational::metamodel::datatype::Integer())),
                                                                                              paths =  $v.tdsColumns->map(c| pair($c.name,^PathInformation(type = $c.type ->toOne(), relationalType = $c.sourceDataType->cast(@meta::relational::metamodel::datatype::DataType)->toOne()))));
                                                                                          ^$operation(select = ^$select(data=^RootJoinTreeNode(alias = ^TableAlias(name = 'root', relationalElement = $newTable))));,
                                  v:PlanVarPlaceHolder[1] |^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value=^VarPlaceHolder(name=$v.name,type = $v.type, multiplicity = $v.multiplicity))),|^$select(columns = ^Literal(value=^VarPlaceHolder(name=$v.name,type = $v.type,  multiplicity = $v.multiplicity)))));,
                                  v:ValueSpecification[1] | processValueSpecification($v, $currentPropertyMapping, $operation, $vars, $state, $joinType, buildNodeId($nodeId,'_i'+$vals->indexOf($v)->toString()), $aggFromMap, $context, $extensions),
                                  l:LambdaFunction<Any>[1] | $l.expressionSequence->at(0)->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, $joinType, buildNodeId($nodeId,'_i'+$vals->indexOf($v)->toString()), $aggFromMap, $context, $extensions),
                                  a:Any[1] | ^ClassInstanceHolder(value=$a);
                             ])) );
}

function meta::relational::functions::pureToSqlQuery::processFunctionExpression(functionExpression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
  print(if(!$context.debug, |'', | $context.space+'>Process Function Expression: '+ $functionExpression.func.name->toOne() + '\n'));
  let res  = $functionExpression.func->match ([
                                    p:Property<Nil,Any|*>[1] | processPropertyFunctionExpression($functionExpression, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions);,
                                    q:QualifiedProperty<Any>[1] | processQualifiedPropertyFunctionExpression($functionExpression, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions);,
                                    a:Any[1]| processFunctionExpressionForNonPropertyFunction($functionExpression, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions);
                                   ]);

 print(if(!$context.debug, |'', | $context.space+'>End Process Function Expression: '+ $functionExpression.func.name->toOne() + '\n'+$res.element->cast(@SelectWithCursor).select->map(s | $s->printDebugQuery($context.space, $extensions))->joinStrings(', ')));

  $res;
}

function meta::relational::functions::pureToSqlQuery::processPropertyFunctionExpression(fe:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   let propertyOwner = $fe.parametersValues->at(0)->map(p|$p->byPassRouterInfo());

   print(if(!$context.debug, |'', | $context.space+'>Process Property Function Expression: ' + $fe.func.name->toOne() + ', property owner:' + $propertyOwner.genericType->genericTypeClass().name->toOne() + ', inFilter:' + $state.inFilter->toString() + '\n'));

   let leftSide = processValueSpecificationReturnPropertyMapping($fe.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions)->toOne();
   $leftSide.element->match(
                     [
                        c : ClassInstanceHolder[1] |
                              let val = $fe.func->cast(@Property<Nil,Any|*>)->eval($c.value);
                              let element = processValue($val, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions)->toOne();
                              ^OperationWithParentPropertyMapping(element=$element);,
                        sel : SelectWithCursor[1] |
                              let toCheckVals = if ($state.inFilter, |$sel.select.filteringOperation, |$sel.select.columns);
                              if ($toCheckVals->size() == 1 && $toCheckVals->toOne()->instanceOf(Literal) && $toCheckVals->toOne()->cast(@Literal).value->instanceOf(VarPlaceHolder),
                               |let select = $sel.select;
                                let vph = $toCheckVals->toOne()->cast(@Literal).value->cast(@VarPlaceHolder);
                                let newLiteral = ^Literal(value=^$vph(propertyPath+=$fe.func->cast(@Property<Nil,Any|*>)));
                                let newSelect = $state.inFilter->if(|^$select(filteringOperation=$newLiteral), |^$select(columns=$newLiteral));
                                ^$leftSide(element = ^$sel(select=$newSelect));,
                               |let property = $fe.func->cast(@AbstractProperty<Any>);
                                let propertyOwnerClass = $propertyOwner.genericType->genericTypeClass();
                                let baseOperation = if($currentPropertyMapping->isEmpty()
                                                                ,| $leftSide.currentPropertyMapping
                                                                ,| $currentPropertyMapping
                                                   )->match([
                                                         o:OtherwiseEmbeddedRelationalInstanceSetImplementation[1] | let navigateToOtherwiseMapping = $o->propertyMappingsByPropertyName($property.name->toOne())->isEmpty();
                                                                                                                     if($navigateToOtherwiseMapping
                                                                                                                           ,|let leftVS = if($state.leftSideOfQualifier->isEmpty(),
                                                                                                                                             |$fe.parametersValues->at(0),
                                                                                                                                             |$state.leftSideOfQualifier
                                                                                                                                          )->toOne()->evaluateAndDeactivate()->byPassRouterInfo();
                                                                                                                             let r = if($leftVS.genericType.rawType->toOne()->isTemporal(),
                                                                                                                                        |let leftMilestoningContext = if($state.leftSideOfQualifier->isEmpty(),
                                                                                                                                                                          |$operation.milestoningContext,
                                                                                                                                                                          |$state.leftSideOfQualifierMilestoningContext
                                                                                                                                                                      );
                                                                                                                                         processValueSpecificationReturnPropertyMapping($leftVS, $currentPropertyMapping, ^$operation(milestoningContext=$leftMilestoningContext), $vars, ^$state(milestoningUseOtherwise=true), $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions)->toOne().element->cast(@SelectWithCursor);,
                                                                                                                                        |processRelationalPropertyMapping($o.otherwisePropertyMapping->cast(@RelationalPropertyMapping), $o.property, $propertyOwnerClass, $sel, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions)->cast(@SelectWithCursor)
                                                                                                                                     );
                                                                                                                             ^OperationWithParentPropertyMapping
                                                                                                                             (
                                                                                                                                element = ^$r(milestoningContext=$operation.milestoningContext),
                                                                                                                                currentPropertyMapping = $o.otherwisePropertyMapping
                                                                                                                             );
                                                                                                                        ,|^OperationWithParentPropertyMapping
                                                                                                                          (
                                                                                                                             element = $sel,
                                                                                                                             currentPropertyMapping = if($leftSide.currentPropertyMapping->isEmpty(), | $currentPropertyMapping, | $leftSide.currentPropertyMapping)
                                                                                                                          )
                                                                                                                     );,

                                                         a:Any[*]|^OperationWithParentPropertyMapping
                                                                  (
                                                                     element = $sel,
                                                                     currentPropertyMapping = if($leftSide.currentPropertyMapping->isEmpty(), | $currentPropertyMapping, | $leftSide.currentPropertyMapping)
                                                                  );
                                                      ]);
                              processProperty(
                                           $property,
                                           $propertyOwnerClass,
                                           $baseOperation.currentPropertyMapping,
                                           $state.propertyMappingFromRouter,
                                           $baseOperation.element->cast(@SelectWithCursor),
                                           $state,
                                           $joinType,
                                           $nodeId,
                                           $aggFromMap,
                                           $context->shift(),
                                           $extensions
                                      );
                           );

                     ]
                   );
}

function  meta::relational::functions::pureToSqlQuery::processObjectGroupBy(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let sourceMainQuery = processValueSpecification($f.parametersValues->at(0), [], $operation, $vars, ^$state(inProject=true), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let sourceMainSelect = $sourceMainQuery.select->pushSavedFilteringOperation($extensions);
   let mainQuery = ^$sourceMainQuery(select=$sourceMainSelect);

   let functions = $f.parametersValues->at(1)->byPassRouterInfo()->cast(@InstanceValue).values->map(v|$v->match([f:FunctionRoutedValueSpecification[1]|$f.value->cast(@InstanceValue).values, a:Any[1]|$a]))->cast(@meta::pure::metamodel::function::Function<Any>);

   let aggsParams = $f.parametersValues->at(2);
   let aggs = if($aggsParams->instanceOf(meta::pure::functions::collection::AggregateValue),
      |$aggsParams,
      |let vs = $f.parametersValues->at(2)->reprocessVS();
       $vs->reactivate($state.inScopeVars)->evaluateAndDeactivate();
   )->cast(@meta::pure::functions::collection::AggregateValue<Any,Any,Any>);
   let ids = $f.parametersValues->at(3)->cast(@InstanceValue).values->cast(@String);

   assert($ids->size() == $functions->size()+$aggs->size(), | 'Incorrect number of column names for groupBy, got ' + $ids->size()->makeString() + ' but expected ' + makeString($functions->size()+$aggs->size()) + ' ' + $ids->joinStrings('[', ',', ']'));

   let noJoinMainQuery = $mainQuery->removeColumnsAndJoins($nodeId, $context, $extensions);

   let newQuery = addPkForAggregation($f, [], $noJoinMainQuery, $state, $nodeId, $context, $extensions);
   let newAgg = ^$aggFromMap(values+=^ColumnGroup(columns=$newQuery.select.columns));

   let newSelect = $newQuery.select;
   let newQueryNoColumns = ^$newQuery(select=^$newSelect(columns=[]));

   let processedGroupByCols = $functions->map(
                                 f| let elem = $f->processProjectFunction($functions->indexOf($f), $ids, $newQueryNoColumns, $vars, ^$state(shouldIsolate=false), $nodeId, $newAgg, $context->shift(), $extensions);
                                    let selectWithCursor = $elem.element->cast(@SelectWithCursor);
                                    let select = $selectWithCursor.select;
                                    ^$elem(element=^$selectWithCursor(select=^$select(groupBy=$select.columns)));
                              );

   let processedAggs = $aggs->map(
                           a|let offset = $aggs->indexOf($a)+$functions->size();
                             let elem = $a.mapFn->processProjectFunction($offset, $ids, $newQueryNoColumns, $vars, $a.mapFn->addPlaceHoldersForLambdaOpenVariables($vars, $state), $nodeId, $newAgg, $context->shift(), $extensions);
                             let selectWithCursor = $elem.element->cast(@SelectWithCursor);

                             print(if(!$context.debug, |'',
                                      | $context.space+'>Build Isolated Query For Agg: \n'+
                                        $context.space+'   (Q)Base Query>  '+$selectWithCursor.select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

                             let sqlQuery = $selectWithCursor.select;

                             let existingCol = $sqlQuery.columns->at(0)->cast(@Alias);
                             let aggregOp = $a.aggregateFn.expressionSequence->at(0)
                                            ->match([e:StoreMappingRoutedValueSpecification[1]|$e.value->cast(@FunctionExpression), f:FunctionExpression[1]|$f])
                                            ->evaluateAndDeactivate()->processAggFn($existingCol.relationalElement)->at(0);
                             let newSelect = ^$sqlQuery(columns=^Alias(name=$existingCol.name, relationalElement=$aggregOp)
                                                        );

                             print(if(!$context.debug, |'',
                                          | $context.space+'   (A)Result With Agg>  '+$newSelect->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

                             ^$elem(element=^$selectWithCursor(select=$newSelect));
                       );

   let preProcessedFuncs = $processedGroupByCols->concatenate($processedAggs);
   let processedFuncs = $preProcessedFuncs.element->cast(@SelectWithCursor).select->map(p|$p->manageIsolation([], [], $nodeId, false, ^$state(processingProjectionThread=true), $context, $extensions));

   let mainSelect = $mainQuery.select;
   let toMerge = if($state.preserveJoinOrder->isNotEmpty() && $state.preserveJoinOrder->toOne() ,|^$mainSelect(columns=[])->concatenate($processedFuncs),| $processedFuncs->concatenate(^$mainSelect(columns=[])));
   let merge = $toMerge->mergeSQLQueryData($nodeId, $state, $context, $extensions);

   // Nest potential filter --------

   //Functions
   let funcPathInformation = $functions->map(f|let index = $functions->indexOf($f);
                                               let p = $preProcessedFuncs->at($index);
                                               ^PathInformation(propertyMapping = if($p.currentPropertyMapping->isEmpty(),|[],|$p.currentPropertyMapping->at(0)),
                                                                type = $f->functionReturnType().rawType->toOne());
                                                       );

   //Add types for Aggregations
   let aggPathInformation = $aggs.aggregateFn->map(a | let pureType = $a->functionReturnType().rawType->toOne();
                                                       ^PathInformation(type=$pureType, relationalType = meta::relational::transform::fromPure::pureTypeToDataTypeMap()->get($pureType)););
   let paths = $funcPathInformation->concatenate($aggPathInformation)->cast(@PathInformation);

   ^$operation(
      select = ^TdsSelectSqlQuery(
                  distinct = $merge.distinct,
                  columns = $merge.columns,
                  data = $merge.data,
                  filteringOperation = $merge.filteringOperation,
                  extraFilteringOperation = $merge.extraFilteringOperation,
                  groupBy = $merge.groupBy,
                  paths = $ids->zip($paths)
               )
               ->isolateNonTerminalGroupByQueryWithEmptyGroupingColumns($state, $extensions) 
   );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::isolateNonTerminalGroupByQueryWithEmptyGroupingColumns(select: TdsSelectSqlQuery[1], state: State[1], extensions: Extension[*]): TdsSelectSqlQuery[1]
{
   // Non terminal group by operation with empty group by cols needs to be wrapped in a subselect
   // Else, it can cause problems like 'where' clause getting generated for aggregated columns (which is invalid)
   if ($select.groupBy->isEmpty() && ($state.functionExpressionStack->size() > 1),
       | $select->isolateTdsSelect($extensions),
       | $select
   )
}

function  meta::relational::functions::pureToSqlQuery::processObjectGroupByWithWindowSubSet(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let sourceMainQuery = processValueSpecification($f.parametersValues->at(0), [], $operation, $vars, ^$state(inProject=true), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let sourceMainSelect = $sourceMainQuery.select->pushSavedFilteringOperation($extensions);
   let mainQuery = ^$sourceMainQuery(select=$sourceMainSelect);

   let functions = $f.parametersValues->at(1)->byPassRouterInfo()->cast(@InstanceValue).values->map(v|$v->match([f:FunctionRoutedValueSpecification[1]|$f.value->cast(@InstanceValue).values, a:Any[1]|$a]))->cast(@meta::pure::metamodel::function::Function<Any>);

   let allIds = $f.parametersValues->at(3)->cast(@InstanceValue).values->cast(@String);

   let ids = $f.parametersValues->at(4)->cast(@InstanceValue).values->cast(@String);
   let subAggIds = $f.parametersValues->at(5)->cast(@InstanceValue).values->cast(@String);

   $subAggIds->map(i | assert(!$ids->contains($i), 'SubAggIds and Ids should not have an intersection'));
   $subAggIds->map(i | assert($allIds->slice($functions->size(), $allIds->size())->contains($i), 'SubAggIds must be a subset of ids'));
   $ids->map(i | assert($allIds->contains($i), 'Ids and Ids should not have an intersection'));

   let aggs = $f.parametersValues->at(2)->reprocessVS()->reactivate($state.inScopeVars)->evaluateAndDeactivate()->cast(@meta::pure::functions::collection::AggregateValue<Any,Any,Any>);
   let indexOfSubAggs = $subAggIds->map( i | $allIds->indexOf($i)) ;                // get index of the passed in aggregate param
   let newAggs = $indexOfSubAggs->map (i| $aggs->at( $i   - $functions->size() )) ; // Of that index get the value

   let indexOfFunctions = $ids->map( i | $allIds->indexOf($i)) ;// get index of the passed in aggregate param
   let newFunctions = $indexOfFunctions->map (i| $functions->at( $i )) ; //Of that index get the value

   let noJoinMainQuery = $mainQuery->removeColumnsAndJoins($nodeId, $context, $extensions);

   let newQuery = addPkForAggregation($f, [], $noJoinMainQuery, $state, $nodeId, $context, $extensions);
   let newAgg = ^$aggFromMap(values+=^ColumnGroup(columns=$newQuery.select.columns));

   let idParameter1 = $f.parametersValues->at(1)->cast(@InstanceValue);// ID Function
   let aggParameter2 = $f.parametersValues->at(2)->cast(@InstanceValue);// aggregate
   let allidParameter3 = $f.parametersValues->at(3)->cast(@InstanceValue);//All Ids

   let newF =  ^$f( parametersValues=[$f.parametersValues->at(0), ^$idParameter1( values=$newFunctions ), ^$aggParameter2( values=$newAggs ) , ^$allidParameter3( values=concatenate($ids,$subAggIds )  )   ] );

   processObjectGroupBy($newF, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);

}

function meta::relational::functions::pureToSqlQuery::gatherAllOperations(op : RelationalOperationElement[1], processDynaFunctions:Boolean[1]):RelationalOperationElement[*]{
   $op->match([
                  b:BinaryOperation[1]| gatherAllOperations($b.left, $processDynaFunctions)->concatenate(gatherAllOperations($b.right, $processDynaFunctions)),
                  u:UnaryOperation[1] | gatherAllOperations($u.nested, $processDynaFunctions),
                  d:DynaFunction[1]   | if($processDynaFunctions,|$d.parameters->map(p|$p->gatherAllOperations($processDynaFunctions)),|$d),
                  j:RelationalOperationElement[1]   | $j,
                  a:Any[1]            | []
              ])
}

function meta::relational::functions::pureToSqlQuery::isolateOrderBy(t:TableAlias[1]):TableAlias[1]
{
   //-here-

   let query = $t.relationalElement->cast(@SelectSQLQuery);
   if ($query.orderBy->isEmpty(),
       |$t,
       |let cols = $query.columns->map(c|$c->extractTableAliasColumns());
        let data = $query.data->toOne();
        let newTableAlias = ^TableAlias
                            (
                               name = 'orderBy',
                               relationalElement = ^$query
                                                   (
                                                        columns = $cols,
                                                        groupBy = []
                                                   )
                            );
        let oldToNew = $cols.alias.name->removeDuplicates()->map(c|^OldAliasToNewAlias(first=$c, second=$newTableAlias));
        ^$t
        (
           relationalElement = ^$query
                               (
                                  columns = $query.columns->map(v|$v->reprocessAliases($oldToNew)),
                                  data = ^$data
                                         (
                                            alias = $newTableAlias,
                                            childrenData=[]
                                         ),
                                  filteringOperation = [],
                                  orderBy = [],
                                  groupBy = $query.groupBy->map(v|$v->reprocessAliases($oldToNew))
                               )
        );
   );
}

function meta::relational::functions::pureToSqlQuery::processQualifiedPropertyFunctionExpression(fe:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   if ($fe.parametersValues->at(0)->byPassRouterInfo().genericType.rawType->toOne() == TDSRow
            ,| tdsQualifier($fe, $operation, $vars, $state, $extensions);

            ,| let leftSide = processValueSpecificationReturnPropertyMapping($fe.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, buildNodeId($nodeId,'_q'), $aggFromMap, $context, $extensions)->toOne();
               let leftSideSelectWithCursor = $leftSide.element->cast(@SelectWithCursor);
               let newMilestoningContext = getMilestoningContextForQualifiedProperty($fe, $operation.milestoningContext, $leftSide.element->cast(@SelectWithCursor).milestoningContext, $state, $vars, $context, $extensions);
               let milestoningContextArgs = if($operation.milestoningContext->isNotEmpty() && $operation.milestoningContext->toOne().isAllForEachDate(),
                                               | let context = $newMilestoningContext->toOne();
                                                 let strategy = $context.currentMilestoningStrategy->toOne();
                                                 $strategy->match([ b:BusinessTemporal[1] | ^$context(businessDate = $operation.milestoningContext.businessDate),
                                                                    p:ProcessingTemporal[1] | ^$context(processingDate = $operation.milestoningContext.processingDate)]);,
                                               | $newMilestoningContext);
               let leftSideWithMilestoningDates = ^$leftSideSelectWithCursor(milestoningContext=$milestoningContextArgs);

               let manageAgg = $fe.func->cast(@meta::pure::metamodel::function::Function<Any>)->toOne()->containsAggregationFunctionInFunction($state.supportedFunctions);
               let queryForGroupBy = if($manageAgg,
                     |addPkForAggregation($fe, $currentPropertyMapping, $leftSideWithMilestoningDates, $state, $nodeId, $context, $extensions),
                     |$leftSideWithMilestoningDates
               );
               let res = processQualifiedProperty(
                              $fe.func->cast(@QualifiedProperty<Any>),
                              if( $leftSide.currentPropertyMapping->isEmpty(), | $currentPropertyMapping, | $leftSide.currentPropertyMapping),
                              $leftSideWithMilestoningDates,
                              $fe->mapVariables($vars, $state.inScopeVars),
                              ^$state
                              (
                                 leftSideOfQualifier=$fe.parametersValues->at(0),
                                 leftSideOfQualifierMilestoningContext = $operation.milestoningContext,
                                 qualifierBase=^$leftSide(element=$leftSideWithMilestoningDates)
                              ),
                              $joinType,
                              $nodeId,
                              if($manageAgg,|^$aggFromMap(values+=^ColumnGroup(columns=$queryForGroupBy.select.columns)),|$aggFromMap),
                              $context,
                              $extensions);

               let milestoningContext = if($fe.func->hasGeneratedMilestoningPropertyStereotype(),| updateMilestoningContextWithPropagatedColumns($res.element->cast(@SelectWithCursor).select, $leftSideWithMilestoningDates.milestoningContext)
                                                                                                ,| if($fe.genericType.rawType->toOne()->isTemporal(),| $res.element->cast(@SelectWithCursor).milestoningContext
                                                                                                                                                    ,| []););
               manageMilestoningContextPropogationForQualifiedProperties($res, $milestoningContext);
           );

}

function meta::relational::functions::pureToSqlQuery::tdsQualifier(fe:FunctionExpression[1], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   let tdsProperties = ['getNumber', 'getInteger', 'getString', 'getFloat', 'getDate', 'getBoolean', 'getEnum', 'getDateTime', 'getStrictDate', 'isNull', 'isNotNull'];

   let funcName = $fe.func.functionName->toOne();
   let valid = $tdsProperties->contains($funcName);
   assert($valid, | 'Unsupported TDSRow function:' + $fe.func.functionName->toOne());
   let res1 = findColumnInTdsFromGetter($fe, $operation.select.columns->cast(@Alias),false, $vars, $state)->toOne();
   let newQuery = if($res1 ->instanceOf(WindowColumn),| $operation.select->moveSelectQueryToSubSelect($operation.currentTreeNode,[],'root', noDebug(), $extensions),|$operation.select);
   let newfilterCol = if($res1->instanceOf(WindowColumn),| ^TableAliasColumn(alias = $newQuery.data->toOne().alias, column = ^Column(name ='"'+$res1->cast(@WindowColumn).columnName+'"', type =^meta::relational::metamodel::datatype::Integer())),|$res1);

   assert(!(($funcName=='isNull' || $funcName=='isNotNull' ) && $res1->instanceOf(WindowColumn)), | 'Window Column cannot be used in '+$funcName+' function');
//    let res = if($funcName =='isNull',
//                    | ^DynaFunction(name = 'isNull', parameters=$newfilterCol),
//                    | if ($funcName =='isNotNull',
//                          | ^DynaFunction(name ='isNotNull', parameters=$newfilterCol),
//                          | $newfilterCol
//                          )
//                    );
   let res = $newfilterCol;
   let select = $newQuery;
   let newSelect = $state.inFilter->if(| ^$select(filteringOperation=$res)  ,| ^$select(columns=$res));

   let currentPropMapping = if ($fe.func.functionName->toOne() == 'getEnum',
                                    | let paths = $operation.select->cast(@TdsSelectSqlQuery).paths;
                                      let name = $fe.parametersValues->at(1)->cast(@InstanceValue).values->toOne()->cast(@String);
                                      let matchedPath = $paths->filter(p|$p.first->toLower() == $name->toLower());
                                      let pm = $matchedPath->toOne().second;
                                      assert(!$pm->isEmpty(), 'Could not find property mapping for enum');
                                      $pm.propertyMapping;,
                                    | [];
                                    );

   let currentTreeNode = if($operation.currentTreeNode->isNotEmpty(),| $operation.currentTreeNode->toOne()->findOneNode($operation.select.data->toOne(), $newSelect.data->toOne()),|[]);
   ^OperationWithParentPropertyMapping(element=^$operation(select=$newSelect, currentTreeNode=$currentTreeNode), currentPropertyMapping=$currentPropMapping);

}

function meta::relational::functions::pureToSqlQuery::removeFilteringOperation(operation:SelectWithCursor[1]):SelectWithCursor[1]
{
   let operationSelect = $operation.select;
   ^$operation(select = ^$operationSelect(filteringOperation=[]));
}

function meta::relational::functions::pureToSqlQuery::processQualifiedProperty(fe:QualifiedProperty<Any>[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   let operationWithoutFilter = $operation->removeFilteringOperation();

   print(if(!$context.debug, |'',
            | $context.space+'*>Process Qualified Property: \''+$fe.name->toOne()+'\''+$nodeId+'\n'+
              $context.space+'   (Q) Qualifier Source Operation>  '+$operationWithoutFilter->cast(@SelectWithCursor).select->printDebugQuery($context.space, $extensions)));

   let funcParams = $fe->genericType().typeArguments.rawType->cast(@FunctionType).parameters->tail();
   let updatedState = if(!$vars->keys()->isEmpty(),|updateFunctionParamScope($state, $funcParams->evaluateAndDeactivate(),$operation),|$state);

   let expression = $fe.expressionSequence;
   assertEquals(1, $expression->size(), 'Qualifiers with more than one functionExpression are not supported yet!');
   let result = processValueSpecificationReturnPropertyMapping($expression->toOne(), $currentPropertyMapping, $operationWithoutFilter, $vars, ^$updatedState(shouldIsolate=false), $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions)->at(0);

   print(if(!$context.debug, |'',
            | $context.space+'   (Q) Qualifier Processed Expression>  '+$result.element->cast(@SelectWithCursor).select->printDebugQuery($context.space, $extensions)));

   let selWithCursor = $result.element->cast(@SelectWithCursor);

   // Add the right pointers so that 'exists' or 'in' can be managed properly?
   let elementUpdated=^$selWithCursor( parent = $operation,
                                 positionBeforeLastApplyJoinTreeNode = $operation.currentTreeNode->toOne()->findNode($operation.select.data->toOne(), $selWithCursor.select.data->toOne())->first()
                               );

   let inForcedIsolationDebugMode=  {|$context->instanceOf(RelationalDebugContext) && !$context->cast(@RelationalDebugContext).forcedIsolation->isEmpty()};//when isolation is forced AND isolation is run below then the JoinTreeNode is processed multiple times, resulting in an incorrect joinName which subsequently may not merge with other branches
   let possiblyIsolatedElement = if($fe->hasGeneratedMilestoningPropertyStereotype() && $state.processingProjectionThread && !$inForcedIsolationDebugMode->eval(),
                                    | $elementUpdated->cast(@SelectWithCursor)->manageIsolation([],  $nodeId, false, ^$state(shouldIsolate=true), $context, $extensions),|$elementUpdated);

   let final = ^$result(
                  element = $possiblyIsolatedElement
               );

   print(if(!$context.debug, |'',
            | $context.space+'   (Q) Process Qualified Property>'+$fe.name->toOne()+'\''+$nodeId+' Result>  '+$final.element->cast(@SelectWithCursor).select->printDebugQuery($context.space, $extensions)));

   $final;
}

function meta::relational::functions::pureToSqlQuery::findNodeWithAliasBreakOnFork(join:RelationalTreeNode[1], alias:Alias[1]):RelationalTreeNode[*]
{


   if ($alias == $join.alias,
         |$join,
         |$join->children()->map(c|$c->findNodeWithAliasBreakOnFork($alias))
   )
}


function meta::relational::functions::pureToSqlQuery::moveFiltersInOnClause(select:SelectSQLQuery[1], filters:Pair<RelationalTreeNode, RelationalOperationElement>[*],  currentTreeNode:RelationalTreeNode[1], joinType:JoinType[1], state:State[1], extensions:Extension[*]):Pair<RelationalTreeNode, SelectSQLQuery>[1]
{

     $filters->reverse()
                    ->fold({
                     sf,pair |let f = $sf.second;
                              let base = $pair.second;

                              let savedFilterAlias = $sf.first.alias;
                              let nodeToApplyConstraintOn = $base.data->toOne()->findNodeWithAliasBreakOnFork($savedFilterAlias)->toOne()->cast(@JoinTreeNode);

                              let newJoinName = joinName($nodeToApplyConstraintOn, $f, $state, false, $extensions);

                              let join = $nodeToApplyConstraintOn.join;
                              let newJoinTree = ^$nodeToApplyConstraintOn
                                                (
                                                   joinName = $newJoinName,
                                                   join = ^$join(
                                                               name = $newJoinName,
                                                               operation = $f->concatenate($join.operation)->andFilters($extensions)->cast(@Operation)->toOne()
                                                           )
                                                );

                              let modifiedCurrentTreeNode = $base.data->toOne()->replaceTreeNode($nodeToApplyConstraintOn, $newJoinTree)->cast(@RootJoinTreeNode);
                              let newSelect = ^$base(
                                 data = $modifiedCurrentTreeNode,
                                 leftSideOfFilter = if(!$base.leftSideOfFilter->isEmpty() && $base.leftSideOfFilter->toOne()->instanceOf(JoinTreeNode) && !$nodeToApplyConstraintOn->getAllNodes()->cast(@JoinTreeNode)->filter(n|$n.joinName == $base.leftSideOfFilter->cast(@JoinTreeNode)->toOne().joinName)->isEmpty(),
                                                            |$modifiedCurrentTreeNode,
                                                            |if($base.leftSideOfFilter->isEmpty(),|[],|$base.leftSideOfFilter->toOne()->findOneNode($base.data->toOne(), $modifiedCurrentTreeNode))
                                                    ),
                                 savedFilteringOperation = []
                              );
                              $newSelect->validate($extensions);
                              pair(if($currentTreeNode==$nodeToApplyConstraintOn,|$newJoinTree,|$currentTreeNode->findOneNode($select.data->toOne(), $modifiedCurrentTreeNode))->cast(@RelationalTreeNode), $newSelect);
                  },
                  pair($currentTreeNode, $select)
         );
}


function meta::relational::functions::pureToSqlQuery::moveFiltersOnTop(select:SelectSQLQuery[1], filters:Pair<RelationalTreeNode, RelationalOperationElement>[*],commonNode:JoinTreeNode[0..1], updatedCurrentTreeNode:RelationalTreeNode[1], state:State[1], extensions:Extension[*]):Pair<RelationalTreeNode, SelectSQLQuery>[1]
{
   let root =  $select.data->toOne();
               let newSelect = ^$select(
                                 savedFilteringOperation = [],
                                 extraFilteringOperation = $select.extraFilteringOperation->concatenate($filters.second)
                               );
               if ($commonNode->isEmpty(),
                  |pair($updatedCurrentTreeNode, $newSelect),
                  |let child = $commonNode->toOne();
                   let joinName = joinName($child, if($select.savedFilteringOperation->isEmpty(),|[],|$select.savedFilteringOperation.second), $state, false, $extensions);
                   let j = $child.join;

                   // Rename the join so that it's not shared
                   let newJoin = ^$child(
                                    joinName = $joinName,
                                    join=^$j
                                         (
                                            name = $joinName
                                          )
                                 );

                   let newRoot = $root->replaceJoin($child, $newJoin)->cast(@RootJoinTreeNode);
                   let finalSelect = ^$newSelect(
                                          leftSideOfFilter = if(!$newSelect.leftSideOfFilter->isEmpty() && !$child->getAllNodes()->cast(@JoinTreeNode)->filter(n|$newSelect.leftSideOfFilter->toOne()->instanceOf(JoinTreeNode) && $n.joinName == $newSelect.leftSideOfFilter->cast(@JoinTreeNode)->toOne().joinName)->isEmpty(), |$newJoin ,|if (!$newSelect.leftSideOfFilter->isEmpty(),|$newSelect.leftSideOfFilter->toOne()->findOneNode($root, $newRoot),|[])),
                                          data = $newRoot
                   );
                   pair(if($updatedCurrentTreeNode==$child,|$newJoin,|$updatedCurrentTreeNode->findOneNode($root, $finalSelect.data->toOne()))->cast(@RelationalTreeNode), $finalSelect);
               );

}

function meta::relational::functions::pureToSqlQuery::buildCorrelatedSubQuery(selectSql:SelectSQLQuery[1], commonNode:JoinTreeNode[0..1], extraColumns:TableAliasColumn[*], aliasForExtractedColumns:TableAlias[0..1], shouldIsolateGroupBy:Boolean[1], nodeId:String[1], inner:Boolean[1], updatedCurrentTreeNodePre:RelationalTreeNode[1], state:State[1], extensions:Extension[*]):Pair<RelationalTreeNode, SelectSQLQuery>[1]
{
   let isolateGroupBy = $shouldIsolateGroupBy && !$selectSql.groupBy->isEmpty();
   let possibleState = if($commonNode->isEmpty(),|addSelfJoinOnNode($selectSql, $updatedCurrentTreeNodePre, $selectSql.data->toOne(), noDebug(), $extensions);,|^IsolationSelectState(foundNode=$commonNode, select=$selectSql, currentTreeNode=$updatedCurrentTreeNodePre););
   let child = $possibleState.foundNode->toOne();
   let select = $possibleState.select;
   let root =  $select.data->toOne();
   let updatedCurrentTreeNode = $possibleState.currentTreeNode->toOne();

   // Build a nested select
   let nestedSelect = if (!$child.alias.relationalElement->instanceOf(SelectSQLQuery),
                          |^SelectSQLQuery(
                             data= ^RootJoinTreeNode(alias = $child.alias, childrenData=$child.childrenData)
                           ),
                          |let q = $child.alias.relationalElement->cast(@SelectSQLQuery);
                           ^$q(columns=$q.columns->map(c|$c->match([a:Alias[1]|$a, t:TableAliasColumn[1]|^Alias(name=$t.column.name, relationalElement=$t)])));
                      );

   let targetAlias = if($child.alias.relationalElement->instanceOf(SelectSQLQuery),|$child.alias, |^TableAlias(name=$child.alias.name, relationalElement=$nestedSelect));

   // Find the columns that are in the filter but refer to nodes outside of the correlated subQuery
   let foundNodeSubNodes = $child->getAllNodes()->cast(@JoinTreeNode).alias;
   let filters = if($select.savedFilteringOperation->isEmpty(),|[],|$select.savedFilteringOperation.second->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second);
   let filtersPartition = $filters->map(f|let condition = $f->extractTableAliasColumns()->filter(t|!$foundNodeSubNodes.name->contains($t.alias.name))->isEmpty();
                                          if($condition,|^BiContainer<RelationalOperationElement>(first=$f),|^BiContainer<RelationalOperationElement>(second=$f));
                                    );

   let parentNestedPartitionedOrderBys = $select.orderBy->partition(o|let tableAliasNames = $o.column->extractTableAliasColumns().alias.name;
                                                                      assert($tableAliasNames->size() == 1, | 'unable to calculate order by columns for subselect, expected 1 matching TableAlias found: '+$tableAliasNames->makeString());
                                                                      !$foundNodeSubNodes.name->contains($tableAliasNames->at(0)););

   // The extra columns need to point to the last node...
   // Select only the important columns
   let allColumnsInScope = $child.join.operation
                           ->concatenate($filtersPartition.second)
                           ->concatenate(if($isolateGroupBy,|[],|$select.filteringOperation->concatenate($select.columns)))
                           ->concatenate($select.extraFilteringOperation)
                           ->extractTableAliasColumns()
                           ->filter(t|$t.alias->in($foundNodeSubNodes))->filter(c|!($c.alias == $child.alias && $nestedSelect.columns->cast(@Alias).name->contains($c.column.name)));


   let nestedColumns = $extraColumns->map(a|^$a(alias = $aliasForExtractedColumns->toOne()))
                                    ->concatenate($allColumnsInScope)
                                    ->removeDuplicates({u,v|$u.alias.name == $v.alias.name && $u.column.name == $v.column.name})
                                    ->map(c|^Alias(name = $c.column.name, relationalElement = $c));

   let allNestedColumns = $nestedColumns->concatenate($nestedSelect.columns->cast(@Alias));

   //Give unique names to any columns with the same name
   let aliasNames = $allNestedColumns->map(a | $a.name->toLower())->removeDuplicates();
   let nestedColumnsReprocessed = $aliasNames->map(n | let matches = $allNestedColumns->filter(d | $d.name->toLower() == $n);
                                                       if ($matches->size() == 1,
                                                           | pair($matches->toOne(), $matches->toOne()),
                                                           | incrementAliasRecursively($matches->head()->toOne(), $matches->tail())
                                                       );
                                               )->filter(p|$nestedColumns->contains($p.first));

   let colForGroupBy = if($isolateGroupBy,
                          |let aggFunc = $select.filteringOperation->concatenate($select.columns)->toOne();
                           let aggFuncModified = $aggFunc->match([a:Alias[1]|$a,
                                            a:Any[1]|^Alias(name = 'aggCol', relationalElement = $aggFunc)]
                                          );
                          pair($aggFunc,$aggFuncModified);,
                          |[]
                       );

   //calculate new target alias
   let pre_newTargetAlias = ^$targetAlias
                        (
                           relationalElement = if ($child.alias.relationalElement->instanceOf(SelectSQLQuery),
                                                   | // The element is already a SQL query
                                                     // We need to rewrite the filter so that it can be applied within the SQL Query
                                                     // In order to do so we find the internal TableAliasColumn by using the SQL Query columns
                                                     let remap = $filtersPartition.first->extractTableAliasColumns()->concatenate($child->children()->extractTableAliasColumns())
                                                                                        ->filter(e|$e.alias.name == $targetAlias.name)//extra cols are added to SelectSqlQuery, relationalElements are not reprocessed
                                                                                        ->distinct()
                                                                                        ->map(c|pair($c, $nestedSelect.columns->cast(@Alias)->filter(a|$a.name == $c.column.name)->toOne().relationalElement->cast(@TableAliasColumn)));

                                                     let data = $nestedSelect.data->toOne();
                                                     let newData=$child->children()->fold({c,root|let join = $c.join;
                                                                                               let reprocessOp = $join.operation->reprocessTableAliasColumns($remap)->cast(@Operation);
                                                                                               let reprocessOpAliases = $reprocessOp->extractTableAliasColumns().alias->distinct();
                                                                                               let reprocessOpAliasesPairs = $reprocessOpAliases->zip($reprocessOpAliases->reverse());
                                                                                               let reprocessJoin=^$join(operation=$reprocessOp, aliases=$reprocessOpAliasesPairs);
                                                                                               let reprocessC = ^$c(join=$reprocessJoin);
                                                                                               let newSourceAlias = $reprocessOpAliases->filter(a|$a!=$c.alias);
                                                                                               let newParent = $root->getAllNodes()->cast(@RelationalTreeNode)->filter(n|$n.alias==$newSourceAlias)->toOne();
                                                                                               let newParentWithIsolatedChild = ^$newParent(childrenData+=$reprocessC);
                                                                                               $root->replaceTreeNode($newParent, $newParentWithIsolatedChild)->cast(@RootJoinTreeNode);},$data);

                                                      //columns in select might come from children of this node so we need to add to subselect columns
                                                      let nestedColumnsName = $nestedSelect.columns->cast(@Alias).name;
                                                      let invisibleColumns = $nestedColumnsReprocessed.second->cast(@Alias)->filter(a | !$a.name->in($nestedColumnsName));
                                                      let preIsolationCurrentTreeNode = $updatedCurrentTreeNode->filter(n|$n.alias.relation()->instanceOf(Table))->concatenate($newData)->first();

                                                      ^$nestedSelect(
                                                        columns= if($isolateGroupBy,| $select.groupBy->concatenate($colForGroupBy.second)->reprocessAliases(^OldAliasToNewAlias(first = $child.alias.name, second = $newData.alias)), |$nestedSelect.columns->concatenate($invisibleColumns))->removeDuplicates(),
                                                        data=$newData,
                                                        filteringOperation=$nestedSelect.filteringOperation
                                                                              ->concatenate(
                                                                                 $filtersPartition.first->map(f|$f->reprocessTableAliasColumns($remap))->cast(@Operation)
                                                                              )->andFilters($extensions),
                                                        preIsolationCurrentTreeNode = $preIsolationCurrentTreeNode,
                                                        groupBy = if($isolateGroupBy, |$select.groupBy->reprocessAliases(^OldAliasToNewAlias(first = $child.alias.name, second = $newData.alias)), |[]),
                                                        orderBy = if($isolateGroupBy, |$select.orderBy, |$parentNestedPartitionedOrderBys.second.values)->map(ob | ^$ob(column = $ob.column->reprocessAliases(^OldAliasToNewAlias(first = $child.alias.name, second = $newData.alias))))
                                                     );,
                                                   | ^$nestedSelect(
                                                        columns=$nestedColumnsReprocessed.second->concatenate(if($isolateGroupBy, |$colForGroupBy.second, |[])),
                                                        preIsolationCurrentTreeNode = $updatedCurrentTreeNode,
                                                        filteringOperation= $filtersPartition.first->andFilters($extensions),
                                                        groupBy = if($isolateGroupBy, |$select.groupBy, |[]),
                                                        orderBy = if($isolateGroupBy, |$select.orderBy, |$parentNestedPartitionedOrderBys.second.values)
                                                     )

                                                )
                        );


   let newTargetAlias = if($isolateGroupBy, |$pre_newTargetAlias->isolateOrderBy(), |$pre_newTargetAlias);

   let tableAliasColumnRemap = $nestedColumnsReprocessed->map(p|let source = $p.first.relationalElement->cast(@TableAliasColumn);
                                                                let sourceCol = $source.column;
                                                                pair($source, ^$source(alias=$newTargetAlias, column=^$sourceCol(name=$p.second.name)));
                                                          );

   // Make sure that wrapped table aliases are now pointing to the top alias (referring to the nested select)
   let nestedJoinAliases = $child->collectTableNames()->map(t|^OldAliasToNewAlias(first=$t, second=$newTargetAlias));
   let join = $child.join;
   let j = ^$join(operation=$join.operation->concatenate($filtersPartition.second)->andFilters($extensions)->toOne()->reprocessTableAliasColumns($tableAliasColumnRemap)->cast(@Operation))->reprocessJoin($nestedJoinAliases, []);

   let joinName = joinName($child, if($select.savedFilteringOperation->isEmpty(),|[],|$select.savedFilteringOperation.second), $state, true, $extensions);
   let newJoin = ^$child(
                     alias = $newTargetAlias,
                     joinName = $joinName + 'csq',
                     join=^$j
                          (
                             name = $joinName  + 'csq'
                          ),
                     joinType = $inner->if(|JoinType.INNER, |JoinType.LEFT_OUTER),
                     childrenData=[]
                 );

   let newFilters = $colForGroupBy->filter(f|$f.first==$select.filteringOperation).second->map(a|^TableAliasColumn(alias=$newTargetAlias, column=^Column(name=$a.name, type=^meta::relational::metamodel::datatype::Integer())))->concatenate($select.filteringOperation->filter(f|!$f->in($colForGroupBy.first)));
   let newRoot = $root->replaceJoin($child, $newJoin)->cast(@RootJoinTreeNode);
   let newSelect = ^$select(
                     data = $newRoot,
                     columns = if ($isolateGroupBy,
                                    |^TableAliasColumn(alias=$newTargetAlias, column=^Column(name=$colForGroupBy.second->toOne().name, type=^meta::relational::metamodel::datatype::Integer())),
                                    |$select.columns->reprocessTableAliasColumns($tableAliasColumnRemap)
                               ),
                     leftSideOfFilter = if(!$select.leftSideOfFilter->isEmpty() && $select.leftSideOfFilter->toOne()->instanceOf(JoinTreeNode) && !$child->getAllNodes()->cast(@JoinTreeNode)->filter(n|$n.joinName == $select.leftSideOfFilter->cast(@JoinTreeNode)->toOne().joinName)->isEmpty(),
                                          |$newJoin,
                                          |if($select.leftSideOfFilter->isEmpty() || $shouldIsolateGroupBy  ,|[],|$select.leftSideOfFilter->toOne()->findOneNode($root, $newRoot))
                                        ),
                     savedFilteringOperation = [],
                     extraFilteringOperation = $select.extraFilteringOperation->reprocessTableAliasColumns($tableAliasColumnRemap),
                     filteringOperation = if($isolateGroupBy,|$newFilters,|$select.filteringOperation->reprocessTableAliasColumns($tableAliasColumnRemap)),
                     groupBy = if ($isolateGroupBy,|[],|$select.groupBy->reprocessTableAliasColumns($tableAliasColumnRemap)),
                     orderBy = if ($isolateGroupBy,|$parentNestedPartitionedOrderBys.first.values,|$select.orderBy)
                  );

   pair(if($child->getAllNodes()->contains($updatedCurrentTreeNode),|$newJoin,|$updatedCurrentTreeNode->findOneNode($select.data->toOne(), $newSelect.data->toOne()))->cast(@RelationalTreeNode), $newSelect);

}

function meta::relational::functions::pureToSqlQuery::buildNameFromDeactivatedQualifierParameter(v:ValueSpecification[1]):String[1]
{
   $v->match([
               i:InstanceValue[1] | $i.values->at(0)->toString(),
               v:VariableExpression[1] | $v.name,
               fe:FunctionExpression[1] | let funcName = $fe.func.functionName;
                                          let prefix = if($funcName->isEmpty(), |'LAMBDA', |$funcName->toOne());
                                          $fe.parametersValues->map(pv | $pv->buildNameFromDeactivatedQualifierParameter())
                                                              ->joinStrings($prefix, '', '');
             ]);
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::extractColumnName(col:RelationalOperationElement[1]):String[0..1]
{
   $col->match([a:Alias[1]|$a.name,
                w:WindowColumn[1]| $w.columnName,
                tac:TableAliasColumn[1] | $tac.column.name,
                r: RelationalOperationElement[1]|[]]);
}

function meta::relational::functions::pureToSqlQuery::processColumnsInRelationalOperationElements(z:RelationalOperationElement[1], state:State[1], srcOperation:SelectWithCursor[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], cancelJoinOnUnion:Boolean[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   $srcOperation->validate([], $extensions);
   let result = $z->match(
               [
                  t:TableAliasColumn[1] |
                              let currentTreeNode = $srcOperation.currentTreeNode->toOne();

                              let alias = $currentTreeNode.alias;
                              let relationalElement = $alias.relationalElement;

                              // Make sure the column is available a potentially SQL
                              let newSrcOperation = $relationalElement->match([
                                 s:SelectSQLQuery[1] | if ($s.columns->map(c|$c->match([t:TableAliasColumn[1]|$t.column.name,
                                                                                       a:Alias[1]|$a.relationalElement->match([t:TableAliasColumn[1]|$t.column.name, d:DynaFunction[1]|$d.name, l:Literal[1]|$a.name])
                                                                                      ])
                                                                      )->contains($t.column.name),
                                                         | $srcOperation;,
                                                         |// Add the missing columns in the nested select (coming most likely from isolation)
                                                          // 1. find the right alias within the nested SQL ...
                                                          // the alias we are trying to find might be from a view
                                                          let allNodes = $s.data->toOne()->getAllNodes()->cast(@RelationalTreeNode);
                                                          let aliasesToUse = $t.column->extractColumnAliasesInRelationalTreeNodes($t.alias.relationalElement, $allNodes, $context, $extensions);  
                                                          assert($aliasesToUse->size() == 1, | 'Found too many (or not enough) tables that could support the column '+$t.column.name+' in the nested SQL '+$s->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions));
                                                          let newSQL = ^$s(columns+=^Alias(name=$t.column.name, relationalElement=$aliasesToUse->toOne()));
                                                          let newTreeNode = ^$currentTreeNode(alias = ^$alias(relationalElement = $newSQL));
                                                          let newData = if ($currentTreeNode->instanceOf(RootJoinTreeNode),
                                                                               |$newTreeNode,
                                                                               |$srcOperation.select.data->toOne()->replaceJoin($currentTreeNode->toOne()->cast(@JoinTreeNode), $newTreeNode->cast(@JoinTreeNode))
                                                                        );
                                                          let oldToNew = $srcOperation.select.data->toOne()->getAllNodes()->cast(@RelationalTreeNode).alias->zip($newData->getAllNodes()->cast(@RelationalTreeNode).alias)->map(o|^OldAliasToNewAlias(first=$o.first.name, second=$o.second));
                                                          let opSelect = $srcOperation.select;

                                                          ^$srcOperation(
                                                                select = ^$opSelect(
                                                                               data = $newData->cast(@RootJoinTreeNode),
                                                                               leftSideOfFilter = if($opSelect.leftSideOfFilter->isEmpty(),|[],|$opSelect.leftSideOfFilter->toOne()->findOneNode($opSelect.data->toOne(), $newData)),
                                                                               savedFilteringOperation = $opSelect.savedFilteringOperation->map(p|pair($p.first->findOneNode($srcOperation.select.data->toOne(), $newData), $p.second->reprocessAliases($oldToNew)))
                                                                         ),
                                                                positionBeforeLastApplyJoinTreeNode = if($srcOperation.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$srcOperation.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($opSelect.data->toOne(), $newData)),
                                                                currentTreeNode = $newTreeNode
                                                          );
                                                      );
                                                      ,
                                 a:Any[1]|$srcOperation
                              ]);

                              let newOpSelect = $newSrcOperation.select;
                              let column = ^TableAliasColumn(alias=$newSrcOperation.alias->toOne(), column=$t.column);
                              ^$newSrcOperation(
                                    select = $state.inFilter->if(|^$newOpSelect(filteringOperation = $column),|^$newOpSelect(columns = $column))
                              );,
                  d:DynaFunction[1]| let newSelect = if ($d.parameters->isEmpty(),
                                                      | let select = $srcOperation.select;
                                                         $state.inFilter->if(|^$select(filteringOperation = $d),|^$select(columns = $d));
                                                         ,
                                                      |  let sqlThreads = $d.parameters->map(p|$p->processColumnsInRelationalOperationElements($state, $srcOperation, buildNodeId($nodeId,'_dy'+$d.parameters->indexOf($p)->toString()), $aggFromMap, $cancelJoinOnUnion, $context, $extensions));
                                                         let merged = $sqlThreads.select->mergeSQLQueryData($nodeId, $state, $context, $extensions);
                                                         let pFunc = ^$d(parameters = $state.inFilter->if(|$merged.filteringOperation,|$merged.columns));
                                                         $state.inFilter->if(|^$merged(filteringOperation=$pFunc),|^$merged(columns=$pFunc));
                                                    );
                                     ^$srcOperation(select = $newSelect,
                                                    currentTreeNode = $srcOperation.currentTreeNode->toOne()->findOneNode($srcOperation.select.data->toOne(), $newSelect.data->toOne()),
                                                    positionBeforeLastApplyJoinTreeNode = if ($srcOperation.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$srcOperation.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($srcOperation.select.data->toOne(), $newSelect.data->toOne()))
                                             );
                                     ,
                  l:Literal[1]| let select = $srcOperation.select;
                                ^$srcOperation(select = $state.inFilter->if(|^$select(filteringOperation = $l),|^$select(columns = $l)));,
                  r:RelationalOperationElementWithJoin[1]|
                              let col = $r->extractElement();
                              let currentData = $srcOperation.select.data->toOne();
                              let isDynaFunction = $col->instanceOf(DynaFunction);
                              let joinTreeNode = $r.joinTreeNode->toOne();
                              let opWithCol = if ($isDynaFunction,
                                 |
                                    let dynaFunction = $col->cast(@DynaFunction);
                                    let extraColumns=$col->extractTableAliasColumns();
                                    let op = applyJoinInTree($currentData, $srcOperation.currentTreeNode->toOne(), $joinTreeNode, $srcOperation, $nodeId, JoinType.LEFT_OUTER, true, true, $extraColumns, $state, $context, $extensions);
                                    let opWithCol = $dynaFunction->processColumnsInRelationalOperationElements($state, $op, $nodeId, $aggFromMap, $cancelJoinOnUnion, $context, $extensions);
                                    let pCol = $state.inFilter->if(|$opWithCol.select.filteringOperation,|$opWithCol.select.columns)->toOne();
                                    pair($opWithCol,$pCol->cast(@RelationalOperationElement));
                                 ,|
                                    let op = if($joinTreeNode == [] || ($cancelJoinOnUnion && $srcOperation.currentTreeNode.alias.relationalElement->toOne()->instanceOf(Union)),
                                                | $srcOperation,
                                                | let extraColumns=$col->filter(p|$p->instanceOf(TableAliasColumn))->cast(@TableAliasColumn);
                                                  let newOp = applyJoinInTree($currentData, $srcOperation.currentTreeNode->toOne(), $joinTreeNode, $srcOperation, $nodeId, JoinType.LEFT_OUTER, true, true, $extraColumns, $state, $context, $extensions);
                                                  let savedFilteringOperation = $srcOperation.select.savedFilteringOperation->map(p|pair($p.first->findOneNode($srcOperation.select.data->toOne(), $newOp.select.data->toOne()), $p.second));
                                                  let newOpSelect = $newOp.select;
                                                  let newOpSelectUpdated = ^$newOpSelect(savedFilteringOperation+=$savedFilteringOperation);
                                                  ^$newOp(select=$newOpSelectUpdated);
                                                );
                                    let pCol = $col->reprocessAliases(^OldAliasToNewAlias(first=$col->cast(@TableAliasColumn).alias.relationalElement->cast(@NamedRelation).name, second=$op.alias->toOne()));
                                    pair($op,$pCol->cast(@RelationalOperationElement));
                                  );

                             let op = $opWithCol.first;
                             let opSelect = $op.select;
                             let pCol = $opWithCol.second;

                             ^$op(
                                 select = $state.inFilter->if(|^$opSelect(filteringOperation = $pCol),|^$opSelect(columns = $pCol))
                             );,
                  s:SemiStructuredPropertyAccess[1] | let select = $srcOperation.select;
                                                      let processedOperand = $state.inFilter->if(|$select.filteringOperation,|$select.columns)->toOne();
                                                      let updatedPropertyAccess = ^$s(operand = $processedOperand);
                                                      ^$srcOperation(select = $state.inFilter->if(|^$select(filteringOperation = $updatedPropertyAccess),|^$select(columns = $updatedPropertyAccess)));
               ]
            );
   $result->validate([], $extensions);
   $result;
}

function meta::relational::functions::pureToSqlQuery::extractColumnAliasesInRelationalTreeNodes(column:Column[1], relationalElement:RelationalOperationElement[1], nodes:RelationalTreeNode[*], context:DebugContext[1], extensions:Extension[*]): TableAliasColumn[*]
{
   let aliasesToUse = $nodes->filter(n| let relElements = $n.alias.relationalElement->match([
         v:ViewSelectSQLQuery[1]| $v.view,
         s:SelectSQLQuery[1]|
            let relationsSupportingProjectedColumn = $s.columns->filter(c|$c->extractColumnName() == $column.name)->extractTableAliasColumns().alias.relation;
            print(if(!$context.debug, |'', | $context.space+'Found depth-2 nested select while processing column - ' +  $column.name + '. Adding inner relations from depth-2 subselect for handling class mapping filter with inner join : ' + $relationsSupportingProjectedColumn->map(rel | $rel->buildUniqueName(false, $extensions))->joinStrings('[', ' , ', ']')));
            $relationsSupportingProjectedColumn->concatenate($s);,
         a:Any[1]| $a]);
      $relElements->contains($relationalElement);).alias;
   $aliasesToUse->map(a| ^TableAliasColumn(alias=$a, columnName=$column.name, column=$column));
}

function meta::relational::functions::pureToSqlQuery::processProperty(property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], currentPropertyMapping:PropertyMapping[*], propertyMappingFromRouter:PropertyMapping[*], srcOperation:SelectWithCursor[1], state:State[1], joinType:JoinType[1], nodeId:String[1],
                                                                       aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   if( !$srcOperation.milestoningContext->isEmpty() && $srcOperation.milestoningContext->toOne().isAllForEachDate() && $property->hasGeneratedMilestoningDatePropertyStereotype()
      ,| let query = $srcOperation.select;
         let strategy = $srcOperation.milestoningContext.currentMilestoningStrategy->toOne();
         let col = $strategy->match([ b:BusinessTemporal[1] | $srcOperation.milestoningContext.businessDate,
                                      p:ProcessingTemporal[1] | $srcOperation.milestoningContext.processingDate]);
         let res = if ($state.inFilter, 
                       |^$srcOperation(select = ^$query(filteringOperation+=$col)),
                       |^$srcOperation(select = ^$query(columns+=$col)));
         ^OperationWithParentPropertyMapping(element = $res, currentPropertyMapping = []);
      ,| let propertyMappings = findPropertyMapping($property, $propertyOwnerClass, $currentPropertyMapping, $propertyMappingFromRouter, $state.mapping->toOne(),$context);
         let res = processPropertyMapping($propertyMappings, $propertyOwnerClass, $srcOperation, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);
         ^OperationWithParentPropertyMapping(element=$res, currentPropertyMapping=$propertyMappings););
}

function meta::relational::functions::pureToSqlQuery::processPropertyMapping(propertyMapping:PropertyMapping[*], propertyOwnerClass:Class<Any>[1], srcOperation:SelectWithCursor[1], state:State[1], joinType:JoinType[1], nodeId:String[1],
                                                                       aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'*>Process Property: \''+$propertyMapping.property->at(0).name->toOne()+'\' ('+$propertyMapping->map(p|$p.owner->toOne().id+'->'+$p.targetSetImplementationId)->joinStrings(',')+') '+$nodeId+ ',inFilter:' + $state.inFilter->toString() + '\n'+
              $context.space+'   (Q)Source Operation>  '+$srcOperation->cast(@SelectWithCursor).select->printDebugQuery($context.space, $extensions)));
   let res = $propertyMapping->match([
               s:SemiStructuredRelationalPropertyMapping[*] | processSemiStructuredRelationalPropertyMapping($s, $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions),
               r:RelationalPropertyMapping[*] | processRelationalPropertyMapping($r, $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions),
               r:CrossSetImplementationPropertyMapping[*] | processCrossPropertyMapping($r, $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions),
               e:EmbeddedRelationalInstanceSetImplementation[*] | if(($state.inGetterFlow == true || $state.milestoningUseOtherwise == true) && $e->size() == 1 && $e->toOne()->instanceOf(OtherwiseEmbeddedRelationalInstanceSetImplementation),
                                                                     | processRelationalPropertyMapping($e->toOne()->cast(@OtherwiseEmbeddedRelationalInstanceSetImplementation).otherwisePropertyMapping->cast(@RelationalPropertyMapping), $propertyMapping.property->at(0), $propertyOwnerClass, $srcOperation, $state, $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions);,
                                                                     | $srcOperation;
                                                                  )
             ]);

   print(if(!$context.debug, |'',
            | $context.space+'<*Process Property Result: \''+$propertyMapping.property->at(0).name->toOne()+'\' ('+$propertyMapping->map(p|$p.owner->toOne().id+'->'+$p.targetSetImplementationId)->joinStrings(',')+') '+$nodeId+ ',inFilter:' + $state.inFilter->toString() + '\n'+
              $context.space+'            '+$res->cast(@SelectWithCursor).select->printDebugQuery($context.space, $extensions)));

   $res;
}

function meta::relational::functions::pureToSqlQuery::doJoinToClass(relationalPropertyMapping:RelationalPropertyMapping[1], c:Class<Any>[1], base:SelectWithCursor[1], joinType:JoinType[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
       let joinTree = $relationalPropertyMapping.relationalOperationElement->cast(@RelationalOperationElementWithJoin).joinTreeNode->toOne();

       let className = $c.name->toOne();
       let classMappings = $state.mapping->classMappingById($relationalPropertyMapping.targetSetImplementationId);
       assertSize($classMappings, 1, 'Expected 1 class mapping for \'%s\' in \'%s\', found %d', [$className, $state.mapping.name->toOne(), $classMappings->size()]);
       let setImplementation = $classMappings->toOne()->match([a : meta::pure::mapping::aggregationAware::AggregationAwareSetImplementation[1] | $a.mainSetImplementation, s: SetImplementation[1] | $s])->cast(@RootRelationalInstanceSetImplementation);

       doJoinToClass($joinTree, $c, $setImplementation, $base, $joinType, $nodeId, $state, $context, $extensions);
}

function meta::relational::functions::pureToSqlQuery::replaceTreeNodeAndUpdatePointersInSwc(swc:SelectWithCursor[1], oldNode:TreeNode[1], newNode:TreeNode[1]):SelectWithCursor[1]
{
   let oldSelect = $swc.select;
   let oldData   = $oldSelect.data->toOne();
   let oldCtn    = $swc.currentTreeNode;
   let oldPb     = $swc.positionBeforeLastApplyJoinTreeNode;
   let oldSfOp   = $oldSelect.savedFilteringOperation;
   let oldLsf    = $oldSelect.leftSideOfFilter;

   let newData   = $oldData->replaceTreeNode($oldNode, $newNode)->cast(@RootJoinTreeNode);
   let newCtn    = if($oldCtn->isEmpty(),| [], | $oldCtn->toOne()->findOneNode($oldData, $newData));
   let newPb     = if($oldPb->isEmpty(),| [], | $oldPb->toOne()->findOneNode($oldData, $newData));
   let newSfOp   = $oldSfOp->map(s|let newNode = $s.first->findOneNode($oldData, $newData);
                                   pair($newNode, $s.second););
   let newLsf    = if($oldLsf->isEmpty(),| [],| $oldLsf->toOne()->findOneNode($oldData, $newData));

   ^$swc(select = ^$oldSelect(data = $newData,
                              leftSideOfFilter = $newLsf,
                              savedFilteringOperation=$newSfOp),
         currentTreeNode = $newCtn,
         positionBeforeLastApplyJoinTreeNode = $newPb);
}

function meta::relational::functions::pureToSqlQuery::replaceTreeNodeRelationalElement(treeNode:RelationalTreeNode[1], newRelation:RelationalOperationElement[1], updateJoinName:Boolean[1], extensions:Extension[*]):RelationalTreeNode[1]
{
   let oldAlias = $treeNode.alias;
   let newAlias = ^$oldAlias(relationalElement = $newRelation);

   if($treeNode->instanceOf(JoinTreeNode),
      |let joinTreeNode = $treeNode->cast(@JoinTreeNode);
       let oldJoin      = $joinTreeNode.join;

       let newJoinName     = if($updateJoinName, | $oldJoin.name + $newRelation->buildUniqueName(false, $extensions), | $oldJoin.name);
       let reprocessedJoin = reprocessJoin($oldJoin, [^OldAliasToNewAlias(first = $oldAlias.name, second = $newAlias)], []);
       let newJoin         = ^$reprocessedJoin(name = $newJoinName);
       ^$joinTreeNode(alias = $newAlias, join = $newJoin, joinName = $newJoinName);,
      |^$treeNode(alias = $newAlias));
}

function meta::relational::functions::pureToSqlQuery::processClassMappingInnerJoinFilter(queryWithJoin:SelectWithCursor[1], setImplementation:RootRelationalInstanceSetImplementation[1], c:Class<Any>[1], base:SelectWithCursor[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let ctn                = $queryWithJoin.currentTreeNode->toOne()->cast(@JoinTreeNode);
   let filteredClassQuery = getRelationalElementWithInnerJoin($setImplementation, $ctn.alias.relationalElement, $c, $nodeId, $state, $context, $extensions);
   let newCtn             = $ctn->replaceTreeNodeRelationalElement($filteredClassQuery, true, $extensions);
   let updatedQuery       = $queryWithJoin->replaceTreeNodeAndUpdatePointersInSwc($ctn, $newCtn);

   if($base.milestoningContext->isNotEmpty(),
      |
         let swcWithMilestoningFilters    = $updatedQuery->applyMilestoningTypeFilters($base.milestoningContext->toOne(), $state, true, $extensions);
         let selectWithMilestoneFilters   = $swcWithMilestoningFilters.select;
         let ctnWithMilestoneFilters      = $updatedQuery.currentTreeNode->toOne()->findOneNode($updatedQuery.select.data->toOne(), $selectWithMilestoneFilters.data->toOne())->cast(@JoinTreeNode);
         let ctnWithJoinReprocessed       = $ctnWithMilestoneFilters->replaceTreeNodeRelationalElement($ctnWithMilestoneFilters.alias.relationalElement, false, $extensions);

         let selectWithJoinReprocessed    = ^$selectWithMilestoneFilters(data = $selectWithMilestoneFilters.data->toOne()->replaceTreeNode($ctnWithMilestoneFilters, $ctnWithJoinReprocessed)->cast(@RootJoinTreeNode));
         let pbWithJoinReprocessed        = if($updatedQuery.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$updatedQuery.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($updatedQuery.select.data->toOne(), $selectWithJoinReprocessed.data->toOne()));
         ^$swcWithMilestoningFilters(select = $selectWithJoinReprocessed, currentTreeNode = $ctnWithJoinReprocessed, positionBeforeLastApplyJoinTreeNode = $pbWithJoinReprocessed);,
      |  $updatedQuery);
}

function meta::relational::functions::pureToSqlQuery::doJoinToClass(joinTree: JoinTreeNode[1], c:Class<Any>[1], setImplementation: RootRelationalInstanceSetImplementation[1], base:SelectWithCursor[1], joinType:JoinType[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{

       let queryWithJoin = applyJoinInTree($base.select.data->toOne(), $base.currentTreeNode->toOne(), $joinTree, $base, $nodeId, $joinType, true, true, [], $state, $context, $extensions);

       // Potentially add filter
       let queryWithFilterNoSaved = if ($setImplementation->resolveFilter()->isEmpty() || ($setImplementation->resolveDistinct() == true) || !$setImplementation->resolveGroupBy()->isEmpty(),
          | $queryWithJoin,
          | if ($setImplementation->resolveFilter()->isEmpty(),
                | $queryWithJoin,
                |  //Do not apply the filter if this is a multigrain table and we are joining on the primary key
                   if ($setImplementation->resolveFilter()->toOne().filter->instanceOf(MultiGrainFilter)
                      && isSimpleJoinToPk($joinTree.join, $base.currentTreeNode->toOne(), $extensions), | $queryWithJoin,
                      | if ($setImplementation->resolveFilter().joinTreeNode.joinType == JoinType.INNER,
                            | $queryWithJoin->processClassMappingInnerJoinFilter($setImplementation, $c, $base, $nodeId, $state, $context, $extensions),
                            | $queryWithJoin->applyTypeFilter($setImplementation, $nodeId, $state, $context, $extensions)
                        ));
            );
       );

       let queryWithFilter = ^$queryWithFilterNoSaved(savedRoot=if(!$queryWithFilterNoSaved.select.data->isEmpty() && !$queryWithFilterNoSaved.currentTreeNode->isEmpty(),|pair($queryWithFilterNoSaved.select.data->toOne(),$queryWithFilterNoSaved.currentTreeNode->toOne()),|[]));

       // Add existing filter
       let select = $queryWithFilter.select;
       let queryAllFilters = ^$queryWithFilter(
                                     select=^$select(
                                              filteringOperation= $select.filteringOperation
                                                                  ->concatenate($base.select.filteringOperation)->andFilters($extensions)
                                            )
                             );

       if (!$setImplementation->resolveDistinct() == true && $setImplementation->resolveGroupBy()->isEmpty(),
          | $queryAllFilters,
          | let getAllSelectWithCursor = processGetAll($setImplementation, $setImplementation.class, $nodeId, false, -1, true, [], $state, $context, $extensions);
            $queryAllFilters->replaceJoinTableWithSelectQuery($getAllSelectWithCursor.select, $queryAllFilters.currentTreeNode->toOne(), '', $nodeId, $context, $extensions);
       );
}

function meta::relational::functions::pureToSqlQuery::isSimpleJoinToPk(join:Join[1], currentTreeNode:RelationalTreeNode[1], extensions:Extension[*]):Boolean[1]
{
   if ($join.target->isEmpty() && ($join.operation->size() == 1) && ($join.operation->instanceOf(DynaFunction) && $join.operation->cast(@DynaFunction).name == 'equal'),
             | let left =  $join.operation->cast(@DynaFunction).parameters->at(0);
               let right =  $join.operation->cast(@DynaFunction).parameters->at(1);
               let targetAliasInJoin = findTarget($join, $currentTreeNode, $extensions);
               let joinNode = if($left->cast(@TableAliasColumn).alias == $targetAliasInJoin, | $left->cast(@TableAliasColumn).column,
                                    | if ($right->cast(@TableAliasColumn).alias == $targetAliasInJoin, | $right->cast(@TableAliasColumn).column , | fail('Should never happen, no matching join target'); $right->cast(@TableAliasColumn).column;) );

               (($joinNode.owner->cast(@Table).primaryKey->size() == 1) && ($joinNode.owner->cast(@Table).primaryKey == $joinNode));,
             | false
    )
}


function meta::relational::functions::pureToSqlQuery::getUnionPropertyName(union: Union[1], property: AbstractProperty<Any>[1], relationalPropertyMappings: RelationalPropertyMapping[*], state: State[1], extensions: Extension[*]): String[1]
{
   if ($union.setImplementations->removeDuplicates()->size() == 1,
       | $union->getPropertyName($property, $relationalPropertyMappings, $extensions),
       | let relOps = $union.setImplementations->size()->range()->map(i |
            let propMapping = findUnionPropertyMapping($union, $i, $property, $relationalPropertyMappings, $state, $extensions)->first();
            $propMapping.relationalOperationElement->defaultIfEmpty(^Literal(value = '__SQLNULL__'));
         );
         '"' + $relOps->buildUniqueName(false, $extensions) + '"';
   )
}

function meta::relational::functions::pureToSqlQuery::getPropertyName(relationalElement:RelationalOperationElement[1],property:AbstractProperty<Any>[1], relationalPropertyMappings:RelationalPropertyMapping[*], extensions:Extension[*]):String[1]
{
   $relationalElement->match(
            [u:Union[1]| '"'+ $relationalPropertyMappings.relationalOperationElement->buildUniqueName(false, $extensions)+'"',
             a:Any[1]|'"'+$property.name->toOne()+'"'] );
}

function meta::relational::functions::pureToSqlQuery::findUnionPropertyMapping(union: Union[1], index: Integer[1], property: AbstractProperty<Any>[1], relationalPropertyMappings: RelationalPropertyMapping[*], state: State[1], extensions: Extension[*]): RelationalPropertyMapping[*]
{
   let setImpl = $union.setImplementations->at($index);
   let allSourceSetImplementationIds = $setImpl->cast(@PropertyMappingsImplementation)->allPropertyMappings().sourceSetImplementationId->distinct();
   if ($setImpl->instanceOf(EmbeddedRelationalInstanceSetImplementation),
       | $setImpl->cast(@EmbeddedRelationalInstanceSetImplementation)->_propertyMappingsByPropertyName($property.name->toOne())->filter(r|$r->instanceOf(RelationalPropertyMapping))->cast(@RelationalPropertyMapping),
       | let propMappings = $relationalPropertyMappings->filter(r|$state.mapping->classMappingById($r.sourceSetImplementationId)->match([r:RootRelationalInstanceSetImplementation[1]|$r,e:EmbeddedRelationalInstanceSetImplementation[1]|$e.setMappingOwner])->cast(@InstanceSetImplementation).id->in($allSourceSetImplementationIds));
         // Filtering overriden property mappings
         let propertyMappingToSuperSetIdsMap = $propMappings->map({pm |
            let pmSourceSetId = $pm.sourceSetImplementationId;
            pair($pm, list($state.mapping->allSuperSetImplementationIds($pmSourceSetId)->remove($pmSourceSetId)));
         })->newMap();
         $propMappings->filter({pm |
            let pmSourceSetId = $pm.sourceSetImplementationId;
            // Check that there doesn't exist another property mapping with source set extending current property mapping source set (implying a property mapping override)
            !$propMappings->exists(other | $propertyMappingToSuperSetIdsMap->get($other).values->contains($pmSourceSetId));
         });
   );
}

function meta::relational::functions::pureToSqlQuery::addMissingColumn(nested:Boolean[1], union:Union[1], propName:String[1], relationalPropertyMappings:RelationalPropertyMapping[*], property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], oldSrcOperation:SelectWithCursor[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   $oldSrcOperation->addMissingColumnToUnion({q,i|if( $q.columns->filter(c|$c->cast(@Alias).name == $propName)->isEmpty(),
                                                     |
                                                     let filteredRelationalPropertyMappings =  findUnionPropertyMapping($union, $i, $property, $relationalPropertyMappings, $state, $extensions);
                                                     if ($filteredRelationalPropertyMappings->isEmpty(),
                                                         | ^$q(columns=$q.columns->concatenate(^Alias(name=$propName, relationalElement=^Literal(value=^SQLNull())))),
                                                         | let y = $union.currentTreeNodes->at($i);
                                                           let s = ^SelectWithCursor(select=$q, currentTreeNode=$y, milestoningContext=$oldSrcOperation.milestoningContext);
                                                           let sel = processRelationalPropertyMapping($filteredRelationalPropertyMappings, $property, $propertyOwnerClass, $s, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->cast(@SelectWithCursor).select;
                                                           let newAlias = ^Alias(
                                                                               name=$propName,
                                                                               relationalElement=if($state.inFilter,|$sel.filteringOperation->toOne(),|$sel.columns->toOne())
                                                                          );
                                                           ^$sel(
                                                              columns=$q.columns->concatenate($newAlias),
                                                              filteringOperation=$q.filteringOperation
                                                           );
                                                      );
                                                     ,
                                                     |$q
                                                  );
                                             },
                                             $nested,
                                             $propName,
                                             $extensions
                                          );
}

Class meta::relational::functions::pureToSqlQuery::MissingColProcessigRes
{
   propName:String[1];
   selectWC:SelectWithCursor[1];
}

function meta::relational::functions::pureToSqlQuery::processRelationalPropertyMapping(relationalPropertyMappings:RelationalPropertyMapping[*], property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], oldSrcOperation:SelectWithCursor[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let propertyReturnType = $property->cast(@Property<Nil,Any|*>).genericType.rawType->toOne();
   let firstStep = $propertyReturnType->match(
                                 [
                                    p:DataType[1] | let currentTreeNode = $oldSrcOperation.currentTreeNode->toOne();
                                                    // ---------------------------------------------------
                                                    // Potentially add missing columns in the union!
                                                    let relationalElement = $oldSrcOperation.currentTreeNode.alias.relationalElement->toOne();
                                                    let result  = if ($relationalElement->instanceOf(Union) && !$relationalElement->cast(@Union).currentTreeNodes->isEmpty(),
                                                                               |let propName = $relationalElement->cast(@Union)->getUnionPropertyName($property, $relationalPropertyMappings, $state, $extensions);
                                                                                pair($propName, addMissingColumn(false, $relationalElement->cast(@Union), $propName,  $relationalPropertyMappings, $property, $propertyOwnerClass, $oldSrcOperation, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions));,
                                                                               |if($relationalElement->instanceOf(SelectSQLQuery),
                                                                                   |let element = $relationalElement->cast(@SelectSQLQuery).data.alias.relationalElement->toOne();
                                                                                    if ($element->instanceOf(Union) && !$element->cast(@Union).currentTreeNodes->isEmpty(),
                                                                                        |let propName = $element->cast(@Union)->getUnionPropertyName($property, $relationalPropertyMappings, $state, $extensions);
                                                                                         pair($propName, addMissingColumn(true, $element->cast(@Union), $propName,  $relationalPropertyMappings, $property, $propertyOwnerClass, $oldSrcOperation, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions));,
                                                                                        |let propName = $relationalElement->getPropertyName($property, $relationalPropertyMappings, $extensions);
                                                                                         pair($propName, $oldSrcOperation);
                                                                                    );,
                                                                                   |let propName = $relationalElement->getPropertyName($property, $relationalPropertyMappings, $extensions);
                                                                                    pair($propName, $oldSrcOperation);
                                                                                )
                                                                       );
                                                    let srcOperation = $result.second;
                                                    let propName = $result.first;
                                                    // ---------------------------------------------------

                                                    let mappingImpl = $relationalPropertyMappings->at(0).relationalOperationElement;

                                                    let newCurrentTreeNode = $srcOperation.currentTreeNode->toOne();
                                                    let relElement = $newCurrentTreeNode.alias.relationalElement;
                                                    let res = if (
                                                                  ($relElement->instanceOf(SelectSQLQuery) &&
                                                                  ($mappingImpl->instanceOf(meta::relational::metamodel::operation::Function) || $mappingImpl->instanceOf(Literal)) &&
                                                                   $relElement->cast(@SelectSQLQuery).columns->filter(c|$c->instanceOf(Alias))->cast(@Alias).name->contains($propName))
                                                                  ||
                                                                  ($relElement->instanceOf(Union) &&
                                                                  ($mappingImpl->instanceOf(meta::relational::metamodel::operation::Function) || $mappingImpl->instanceOf(Literal) || $mappingImpl->instanceOf(RelationalOperationElementWithJoin)) &&
                                                                   $relElement->cast(@Union).queries->at(0).columns->filter(c|$c->instanceOf(Alias))->cast(@Alias).name->contains($propName))
                                                                  ||
                                                                  ($relElement->instanceOf(SelectSQLQuery) &&
                                                                   $relElement->cast(@SelectSQLQuery).data.alias.relationalElement->toOne()->instanceOf(Union) &&
                                                                   $relElement->cast(@SelectSQLQuery).data.alias.relationalElement->toOne()->cast(@Union).queries->at(0).columns->filter(c|$c->instanceOf(Alias))->cast(@Alias).name->contains($propName))
                                                                   ,
                                                                  | // We should not process the property mapping as it should have been done in the embedded selectSQLQuery....
                                                                    let sel = $srcOperation.select;
                                                                    //let embeddedSelect = $currentTreeNode.alias.relationalElement->cast(@SelectSQLQuery);
                                                                    // Warning the type of the column is bogus here....
                                                                    let newColumn = ^TableAliasColumn(alias=$newCurrentTreeNode.alias, column=^Column(name=$propName, type=^meta::relational::metamodel::datatype::Integer()));
                                                                    if ($state.inFilter,
                                                                       |^$srcOperation(select = ^$sel(filteringOperation+=$newColumn)),
                                                                       |^$srcOperation(select = ^$sel(columns+=$newColumn))
                                                                    );,
                                                                  | // Process the property mapping...
                                                                    let srcOperationWithMilestoneProcessingState=$srcOperation->updateMilestoningContextProcessingStateForProperties(MilestoningProcessingState.DATATYPE_PROPERTY);
                                                                    $mappingImpl->processColumnsInRelationalOperationElements($state, $srcOperationWithMilestoneProcessingState, $nodeId, $aggFromMap, true, $context, $extensions);
                                                               );
                                                    let sel = $res.select;
                                                    let firstStep = if ($state.inFilter,
                                                                        |^$res(select = ^$sel(filteringOperation = $sel.filteringOperation->at(0)->usePropertyName($property, $relationalPropertyMappings, $state, $extensions)));,
                                                                        |^$res(select = ^$sel(filteringOperation = [], columns = $sel.columns->at(0)->usePropertyName($property, $relationalPropertyMappings, $state, $extensions)));
                                                                       );
                                                    let secondStep = $mappingImpl->match([
                                                                                         r : RelationalOperationElementWithJoin[1] | $firstStep;,
                                                                                         a : Any[*]                                | ^$firstStep(positionBeforeLastApplyJoinTreeNode = if($srcOperation.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$srcOperation.positionBeforeLastApplyJoinTreeNode->toOne()->findNode($srcOperation.select.data->toOne(), $sel.data->toOne())->first()),
                                                                                                                                                 currentTreeNode = $newCurrentTreeNode->findNode($srcOperation.select.data->toOne(), $sel.data->toOne())->first());
                                                                                        ]);
                                                    let newSel = $secondStep.select;
                                                    if ($srcOperation.select.filteringOperation->isEmpty() || $srcOperation.select.leftSideOfFilter->isEmpty(),
                                                       |if (!$srcOperation.select.leftSideOfFilter->isEmpty(),
                                                          |^$secondStep(select = ^$newSel(leftSideOfFilter=[])),
                                                          |$secondStep
                                                        ),
                                                       |^$secondStep(select = ^$newSel(savedFilteringOperation = $newSel.savedFilteringOperation
                                                                                                                ->concatenate(pair($sel.leftSideOfFilter->toOne(), $srcOperation.select.filteringOperation->toOne()))
                                                                                                                ->map(f|pair($f.second->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second
                                                                             )
                                                        )
                                                    );
                                                    ,
                                    c:Class<Any>[1] |let srcOperation = $oldSrcOperation;

                                                      let currentTreeNodeElement = $srcOperation.currentTreeNode.alias.relationalElement->toOne();
                                                      let extractParentMappingId = {rpm: RelationalPropertyMapping[1] |
                                                         $state.mapping->classMappingById($rpm.sourceSetImplementationId)->match([
                                                            r:RootRelationalInstanceSetImplementation[1]     | $r.id,
                                                            e:EmbeddedRelationalInstanceSetImplementation[1] | $e.setMappingOwner.id
                                                         ])
                                                      };

                                                      let shouldUpdatePropertyMappings = if ($currentTreeNodeElement->isUnionOrNestedUnion(),
                                                                                             | let allSourceSetIdsForUnionSets = $currentTreeNodeElement->resolveUnion().setImplementations->map(s | $state.mapping->allSuperSetImplementationIds($s.id));
                                                                                               !$relationalPropertyMappings->exists({rpm |
                                                                                                  !$extractParentMappingId->eval($rpm)->in($allSourceSetIdsForUnionSets)
                                                                                               });,
                                                                                             | false
                                                                                         );
                                                      let updatedRelationalPropertyMappings = if ($shouldUpdatePropertyMappings,
                                                         {|
                                                            let union = $currentTreeNodeElement->resolveUnion();
                                                            let nullAlias = ^Alias(name = $property.name->toOne(), relationalElement = ^Literal(value = ^SQLNull()));
                                                            $union.setImplementations->map({currentSet |
                                                               let superSetIds = $state.mapping->allSuperSetImplementationIds($currentSet.id);
                                                               let filteredRpms = $relationalPropertyMappings->filter(rpm | $extractParentMappingId->eval($rpm)->in($superSetIds));
                                                               let newRpms = if ($filteredRpms->isNotEmpty(),
                                                                   | $filteredRpms,
                                                                   | $relationalPropertyMappings->map({rpm |
                                                                        print(if($context.debug,|$context.space+'- Creating null join from "' + $currentSet.id + '" -> "' + $rpm.targetSetImplementationId + '"\n',|''));
                                                                        let join = $rpm.relationalOperationElement->cast(@RelationalOperationElementWithJoin);
                                                                        let nullJoin = ^$join(relationalOperationElement = $nullAlias, joinTreeNode = []);
                                                                        ^RelationalPropertyMapping
                                                                        (
                                                                           owner                      = $currentSet->cast(@PropertyMappingsImplementation),
                                                                           property                   = $property->cast(@Property<Nil,Any|*>),
                                                                           relationalOperationElement = $nullJoin,
                                                                           sourceSetImplementationId  = $currentSet.id,
                                                                           targetSetImplementationId  = $rpm.targetSetImplementationId
                                                                        );                                          
                                                                     })
                                                               );
                                                               $newRpms
                                                                  ->removeDuplicates({a,b | ($a.sourceSetImplementationId == $b.sourceSetImplementationId) && ($a.targetSetImplementationId == $b.targetSetImplementationId)})
                                                                  ->map(rpm | ^$rpm(sourceSetImplementationId = $currentSet.id));
                                                            });
                                                         },
                                                         {|
                                                            $relationalPropertyMappings
                                                         }
                                                      );

                                                      let res = if ($updatedRelationalPropertyMappings->size() > 1,
                                                         |
                                                            let targets = $updatedRelationalPropertyMappings.targetSetImplementationId->removeDuplicates();
                                                            let srcOperationWithMilestoneProcessingState = if(!$property->hasGeneratedMilestoningPropertyStereotype(),
                                                                                                              | ^$srcOperation(milestoningContext = []),
                                                                                                              |
                                                                                                            if($property->isEdgePointProperty() || $srcOperation.milestoningContext.isAllVersions->orElse(false),
                                                                                                              | $srcOperation->updateMilestoningContextProcessingStateForProperties(MilestoningProcessingState.ALL_VERSIONS), 
                                                                                                              | $srcOperation->updateMilestoningContextProcessingStateForProperties(MilestoningProcessingState.NON_MILESTONED_CLASS_PROPERTY)));
                                                            let union = buildSQLQueryOutManySetImplementations($srcOperationWithMilestoneProcessingState,
                                                                                                               $updatedRelationalPropertyMappings,
                                                                                                               $propertyOwnerClass,
                                                                                                               $c,
                                                                                                               $nodeId,
                                                                                                               $state,
                                                                                                               $context,
                                                                                                               $extensions);
                                                            let nSrcOperation = $union.second.first;
                                                            let currentData = $nSrcOperation.select.data->toOne();
                                                            let queryWithJoin = applyJoinInTree($currentData, $nSrcOperation.currentTreeNode->toOne(), $union.first, ^$nSrcOperation(milestoningContext = $srcOperation.milestoningContext)->updateMilestoningContextProcessingStateForProperties(MilestoningProcessingState.NON_MILESTONED_CLASS_PROPERTY), $nodeId, $joinType, true, true, [], $state, $context, $extensions);
                                                            // Merge would most likely be more appropriate!
                                                            let select = $queryWithJoin.select;
                                                            let withFilter = ^$queryWithJoin(select = ^$select(filteringOperation = $nSrcOperation.select.filteringOperation));
                                                            let res = if ($targets->size() == 1, |$withFilter, |$withFilter->replaceJoinTableWithSelectQuery($union.second.second, $queryWithJoin.currentTreeNode->toOne(), '', $nodeId, $context, $extensions));
                                                            manageSavedFilteringOperation(^$res(savedRoot=if(!$res.select.data->isEmpty() && !$res.currentTreeNode->isEmpty(),|pair($res.select.data->toOne(),$res.currentTreeNode->toOne()),|[])), $nSrcOperation);,
                                                         |
                                                            let joinTree = $relationalPropertyMappings->at(0).relationalOperationElement->cast(@RelationalOperationElementWithJoin).joinTreeNode->toOne();
                                                            let targetAlias = $joinTree.join->findTarget($srcOperation.currentTreeNode->toOne(), $extensions);
                                                            let extraColumns = $joinTree.join.operation->extractTableAliasColumns()->filter(t|$t.alias != $targetAlias);
                                                            let yy = manageIsolation($srcOperation, $extraColumns, $nodeId, false, ^$state(shouldIsolate=true), $context, $extensions);
                                                            let srcOperationWithMilestoneProcessingState=$yy->updateMilestoningContextProcessingStateForProperties(MilestoningProcessingState.NON_MILESTONED_CLASS_PROPERTY);
                                                            doJoinToClass($relationalPropertyMappings->at(0), $c, $srcOperationWithMilestoneProcessingState, $joinType, $nodeId, $state, $context, $extensions);
                                                      );
                                  ]
                             )->manageMilestoningContextPropogationForProperties();

     let newSel = $firstStep.select;

     let finalResult = if ($oldSrcOperation.select.filteringOperation->isEmpty() || $newSel.leftSideOfFilter->isEmpty(),
        |if (!$oldSrcOperation.select.leftSideOfFilter->isEmpty(),
                |^$firstStep(select = ^$newSel(leftSideOfFilter=[])),
                |$firstStep
         ),
        |  //firstStep can result in (saved) milestoning filtering operations which need to be processed along with the existing src saved filtering operations
            let savedFilteringOpWithOldAndNewOps=$newSel.savedFilteringOperation->map(p| let existingOrNewNode=if($oldSrcOperation.select.savedFilteringOperation->contains($p),|$p.first->findOneNode($oldSrcOperation.select.data->toOne(), $newSel.data->toOne()),|$p.first);pair($existingOrNewNode, $p.second);)
                                                                               ->concatenate(pair($newSel.leftSideOfFilter->toOne(), $oldSrcOperation.select.filteringOperation->toOne()))
                                                                               ->map(f|pair($f.second->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second;

           ^$firstStep(select = ^$newSel(savedFilteringOperation = $savedFilteringOpWithOldAndNewOps));
     );
     $finalResult->validate([], $extensions);
     $finalResult;

}

function <<access.private>> meta::relational::functions::pureToSqlQuery::convertCrossSetImplToRelationalSetImpl(crossSet: CrossSetImplementation[1]):RootRelationalInstanceSetImplementation[1]
{
   let table = createCrossSetImplementationPlaceholder($crossSet);
   let mainTableAlias = ^TableAlias(name = 'root', relationalElement = $table);
   ^RootRelationalInstanceSetImplementation
   (
      class = $crossSet.class,
      id = $crossSet.id,
      parent = $crossSet.parent,
      root = $crossSet.root,
      userDefinedPrimaryKey = false,
      mainTableAlias = $mainTableAlias,
      propertyMappings = $crossSet.propertyMappings->filter(pm | $pm->instanceOf(CrossSetImplementationPrimtivePropertyMapping))->cast(@CrossSetImplementationPrimtivePropertyMapping)->map(pm |
                            ^RelationalPropertyMapping
                            (
                               property = $pm.property,
                               relationalOperationElement = ^TableAliasColumn
                                                             (
                                                                alias = $mainTableAlias,
                                                                columnName = $pm.property.name->toOne(),
                                                                column = $table.columns->filter(s|$s->cast(@Column).name == $pm.propertyPlaceHolder)->toOne()->cast(@Column)
                                                             ),
                               sourceSetImplementationId = $crossSet.id,
                               targetSetImplementationId = ''
                            )
                         )
   );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::createCrossSetImplementationPlaceholder(crossSet: CrossSetImplementation[1]):VarCrossSetPlaceHolder[1]
{
   ^VarCrossSetPlaceHolder
   (
      name = $crossSet.varName,
      schema = ^Schema(name='default', database = ^Database(name='Gen_Cross_DB')),
      columns = $crossSet.propertyMappings->filter(pm | $pm->instanceOf(CrossSetImplementationPrimtivePropertyMapping))->cast(@CrossSetImplementationPrimtivePropertyMapping)->map(pm |
                   ^Column
                   (
                      name = $pm.propertyPlaceHolder,
                      type = meta::relational::transform::fromPure::pureTypeToDataTypeMap()->get($pm.property->cast(@Property<Nil,Any|*>).genericType.rawType->toOne())->toOne()
                   )
                ),
      varName = $crossSet.varName,
      crossSetImplementation = $crossSet
   )
}

function meta::relational::functions::pureToSqlQuery::processCrossPropertyMapping(crossPropertyMappings:CrossSetImplementationPropertyMapping[*], property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], oldSrcOperation:SelectWithCursor[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let propertyReturnType = $property->cast(@Property<Nil,Any|*>).genericType.rawType->toOne();

   let firstStep = $propertyReturnType->match([
      p: DataType[1]   | // Assumption: The src op will always be a select * from {$(gen_var_x)}
                         let mappingImpl = $crossPropertyMappings->cast(@CrossSetImplementationPrimtivePropertyMapping)->at(0).propertyPlaceHolder;
                         let currentTreeNode = $oldSrcOperation.currentTreeNode->toOne();
                         let relElement = $currentTreeNode.alias.relationalElement;
                         let sel = $oldSrcOperation.select;
                         let newColumn = ^TableAliasColumn(alias=$currentTreeNode.alias, column=^Column(name=$mappingImpl, type=meta::relational::transform::fromPure::pureTypeToDataTypeMap()->get($p)->toOne()));
                         if($state.inFilter,
                            | ^$oldSrcOperation(select = ^$sel(filteringOperation+=$newColumn)),
                            | ^$oldSrcOperation(select = ^$sel(columns+=$newColumn))
                         );,

      c: Class<Any>[1] | let sourceSet = $crossPropertyMappings->at(0).owner->toOne()->instanceOf(CrossSetImplementation)->if(
                            | $crossPropertyMappings->at(0).owner->toOne()->cast(@CrossSetImplementation)->convertCrossSetImplToRelationalSetImpl(),
                            | $crossPropertyMappings->at(0).owner->toOne());
                         let targetSet = $crossPropertyMappings->at(0)->instanceOf(CrossSetImplementationReverseComplexPropertyMapping)->if(
                            | $crossPropertyMappings->at(0)->cast(@CrossSetImplementationReverseComplexPropertyMapping).targetSet->cast(@CrossSetImplementation)->convertCrossSetImplToRelationalSetImpl(),
                            | $state.mapping->classMappingById($crossPropertyMappings->at(0).targetSetImplementationId)->cast(@RootRelationalInstanceSetImplementation)->toOne());
                         let propertypairs = $crossPropertyMappings->at(0)->cast(@CrossSetImplementationComplexPropertyMapping).crossExperssionPropertyPairs;
                         let currentAlias = $oldSrcOperation.currentTreeNode.alias;
                         let targetAlias = $targetSet.mainTableAlias->createJoinTableAlias($nodeId, $state, [], $context, $extensions);
                         let joinTree = ^JoinTreeNode
                                         (
                                            alias = $targetAlias->toOne(),
                                            database=^Database(name='Gen_Cross_DB'),
                                            joinName = $sourceSet.id + '_gen_join_' + $targetSet.id,
                                            join  = ^Join
                                                     (
                                                        name=$sourceSet.id + '_gen_join_' + $targetSet.id,
                                                        operation = $propertypairs->map(pp |
                                                                       ^DynaFunction(name = 'equal', parameters=
                                                                        [
                                                                           $sourceSet->propertyMappingByPropertyNameAndTargetId($pp.first.name->toOne(), '' )->toOne()->cast(@RelationalPropertyMapping).relationalOperationElement->cast(@TableAliasColumn)->map(c|^$c(alias=$currentAlias->toOne())),
                                                                           $targetSet->propertyMappingByPropertyNameAndTargetId($pp.second.name->toOne(), '')->toOne()->cast(@RelationalPropertyMapping).relationalOperationElement->cast(@TableAliasColumn)->map(c|^$c(alias=$targetAlias))
                                                                        ]);
                                                                    )->andFilters($extensions)->cast(@Operation)->toOne(),
                                                        target = $targetAlias,
                                                        aliases = [pair($currentAlias->toOne(), $targetAlias->toOne()), pair($targetAlias->toOne(), $currentAlias->toOne())]
                                                     )
                                         );
                         doJoinToClass($joinTree, $c, $targetSet, $oldSrcOperation, $joinType, $nodeId, $state, $context, $extensions);

   ]);

   let newSel = $firstStep.select;

   let finalResult = if ($oldSrcOperation.select.filteringOperation->isEmpty() || $newSel.leftSideOfFilter->isEmpty(),
      |if (!$oldSrcOperation.select.leftSideOfFilter->isEmpty(),
              |^$firstStep(select = ^$newSel(leftSideOfFilter=[])),
              |$firstStep
       ),
      |  //firstStep can result in (saved) milestoning filtering operations which need to be processed along with the existing src saved filtering operations
          let savedFilteringOpWithOldAndNewOps=$newSel.savedFilteringOperation->map(p| let existingOrNewNode=if($oldSrcOperation.select.savedFilteringOperation->contains($p),|$p.first->findOneNode($oldSrcOperation.select.data->toOne(), $newSel.data->toOne()),|$p.first);pair($existingOrNewNode, $p.second);)
                                                                             ->concatenate(pair($newSel.leftSideOfFilter->toOne(), $oldSrcOperation.select.filteringOperation->toOne()))
                                                                             ->map(f|pair($f.second->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second;

         ^$firstStep(select = ^$newSel(savedFilteringOperation = $savedFilteringOpWithOldAndNewOps));
   );
   $finalResult->validate([], $extensions);
   $finalResult;

}

function <<access.private>> meta::relational::functions::pureToSqlQuery::processSemiStructuredRelationalPropertyMapping(propertyMappings:SemiStructuredRelationalPropertyMapping[*], property:AbstractProperty<Any>[1], propertyOwnerClass:Class<Any>[1], srcOperation:SelectWithCursor[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]): RelationalOperationElement[1]
{
   assert($propertyMappings->size() >= 1, | 'Expected non-empty semi structured property mappings');
   let result = $propertyMappings->at(0).relationalOperationElement->processColumnsInRelationalOperationElements($state, $srcOperation, $nodeId, $aggFromMap, true, $context, $extensions);
   $result->validate([], $extensions);

   if ($property.multiplicity->hasToOneUpperBound(),
       | $result,
       |
         // Property is 1->MANY. Need to flatten
         let arrayFlattening = ^SemiStructuredArrayFlatten(navigation = if($state.inFilter, | $result->cast(@SelectWithCursor).select.filteringOperation, | $result->cast(@SelectWithCursor).select.columns)->toOne());
         let leftAlias = $result.currentTreeNode->toOne().alias;
         let rightAlias = ^TableAlias(relationalElement = $arrayFlattening, name = 'arrayFlatten_' + $nodeId);
         let joinName = 'join_arrayFlatten_' + $arrayFlattening->buildUniqueName(true, true, $extensions);
         let join = ^Join(
            name = $joinName,
            target = $rightAlias,
            aliases = [pair($leftAlias, $rightAlias), pair($rightAlias, $leftAlias)],
            operation = ^DynaFunction(name = 'equal', parameters = [^Literal(value = 1), ^Literal(value = 1)]) // True operation
         );

         let lateralJoinNode = ^JoinTreeNode(
            database = ^Database(),
            joinName = $joinName,
            alias = $rightAlias,
            join = $join,
            joinType = $joinType,
            lateral = true
         );

         let joinAppliedNode = applyJoinInTree($result.select.data->toOne(), $result.currentTreeNode->toOne(), $lateralJoinNode, $srcOperation, $nodeId, $joinType, true, true, [], $state, $context, $extensions);
         let joinAppliedNodeSelect = $joinAppliedNode.select;
         let flattenOutput = ^SemiStructuredArrayFlattenOutput(tableAliasColumn = ^TableAliasColumn(alias = $joinAppliedNode.currentTreeNode.alias->toOne(), column = ^Column(name = 'result', type = ^meta::relational::metamodel::datatype::SemiStructured())), returnType  = $property.genericType.rawType);
         let res = ^$joinAppliedNode(
            select = ^$joinAppliedNodeSelect(
               columns = if($state.inFilter,|[],|$flattenOutput),
               filteringOperation = if($state.inFilter,|$flattenOutput,|[])
            )
         );

         $res->validate([], $extensions);
         $res;
   );
}

function meta::relational::functions::pureToSqlQuery::manageSavedFilteringOperation(res:SelectWithCursor[1], srcOperation:SelectWithCursor[1]):SelectWithCursor[1]
{
   let sel = $res.select;

   if ($sel.filteringOperation->isEmpty() || $sel.leftSideOfFilter->isEmpty(),
         |^$res(select = ^$sel(

                              savedFilteringOperation += $srcOperation.select.savedFilteringOperation->map(p|pair($p.first->findNode($srcOperation.select.data->toOne(), $sel.data->toOne())->toOne(),$p.second))
                         )
           ),
         |^$res(select = ^$sel(
                              filteringOperation=[],
                              savedFilteringOperation += $srcOperation.select.savedFilteringOperation->map(p|pair($p.first->findNode($srcOperation.select.data->toOne(), $sel.data->toOne())->toOne(),$p.second))
                                                                                                     ->concatenate(pair($sel.leftSideOfFilter->toOne(), $sel.filteringOperation->toOne()))
                         )
          )
   );
}

function meta::relational::functions::pureToSqlQuery::replaceJoinTableWithSelectQuery(s:SelectWithCursor[1], baseSelect:Relation[1], currentTreeNode:RelationalTreeNode[1], newJoinName:String[1], nodeId:String[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'*>Replace Join Table With Select: \n'+
              $context.space+'   (Q)Base Select Operation>  '+$s.select->printDebugQuery($context.space, $extensions)));

   let select = $s.select;

   let finalNode = $currentTreeNode->findLastJoinTreeNode()->cast(@JoinTreeNode);

   //Remove column aliases
   let reprocessedColumns = $baseSelect.columns->cast(@Alias)->map(c | $c.relationalElement->match([t:TableAliasColumn[1] | $t;,
                                                                                                    a:Any[1] | $c;
                                                                                                    ]););

   let columnsWithGroupBy = if ($baseSelect->instanceOf(SelectSQLQuery) && !$baseSelect->cast(@SelectSQLQuery).groupBy->isEmpty(),
                                                                | let columnsToAdd = $baseSelect->cast(@SelectSQLQuery).groupBy->filter(c | let foundInExisting = $reprocessedColumns->filter(e | if ($e->instanceOf(TableAliasColumn), | $e->cast(@TableAliasColumn).column.name == $c->cast(@TableAliasColumn).column.name, | false ););
                                                                                                                     $foundInExisting->isEmpty(););
                                                                  $reprocessedColumns->concatenate($columnsToAdd);,
                                                                | $reprocessedColumns);
   let withFilter = if ($baseSelect->instanceOf(SelectSQLQuery),|let k = $baseSelect->cast(@SelectSQLQuery); ^$k(filteringOperation=$k.filteringOperation->concatenate($k.savedFilteringOperation.second)->andFilters($extensions));,|$baseSelect);
   let newBaseSelect = ^$withFilter(columns=$columnsWithGroupBy);

   //TODO - should we use actual aliases ?
   let newAlias = ^TableAlias(name=$finalNode.alias->cast(@TableAlias).name, relationalElement=$newBaseSelect);
   let newJoinTree = ^$finalNode(alias=$newAlias);

   let modifiedCurrentTreeNode = $currentTreeNode->replaceTreeNode($finalNode, $newJoinTree);

   let root = $select.data->toOne()->replaceTreeNode($currentTreeNode, $modifiedCurrentTreeNode)->cast(@RootJoinTreeNode);
   let result = ^SelectWithCursor(
      select = ^$select(
                  data = $root,
                  savedFilteringOperation=$select.savedFilteringOperation->map(p|pair($p.first->findOneNode($select.data->toOne(), $root), $p.second)),
                  leftSideOfFilter=if($select.leftSideOfFilter->isEmpty(),|[],|$select.leftSideOfFilter->toOne()->findOneNode($select.data->toOne(), $root))
               ),
      currentTreeNode = $modifiedCurrentTreeNode->cast(@RelationalTreeNode),
      positionBeforeLastApplyJoinTreeNode = $root,
      milestoningContext = $s.milestoningContext
   );

   print(if(!$context.debug, |'',
            | $context.space+'   (R)New Select Operation>  '+$result->cast(@SelectWithCursor).select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

   $result;
}

function meta::relational::functions::pureToSqlQuery::processFunctionExpressionForNonPropertyFunction(functionExpression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[*]
{
   let func = findSupportedFunction($functionExpression, $state.supportedFunctions, $state.contextBasedSupportedFunctions);
   if ( (!$func->isEmpty()), | let params1 = [^List<Any>(values=$functionExpression), ^List<Any>(values=$currentPropertyMapping)];
                                   let params = $params1->concatenate([$operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context]->map(v | ^List<Any>(values=$v)))->concatenate(^List<Any>(values = $extensions));
                                   $func->toOne()->evaluate($params)->cast(@RelationalOperationElement)->toOne()->wrapIfNecessary();
       , |


      if($functionExpression.func->instanceOf(FunctionDefinition),
         |let expression = $functionExpression.func->cast(@FunctionDefinition<Any>).expressionSequence;
              assertEquals(1, $expression->size(), | 'Functions with more than one functionExpression are not supported yet! The function \'' + $functionExpression.func->toString() + '\' has ' + $expression->size()->toString() + ' expressions.');
              processValueSpecificationReturnPropertyMapping($expression->toOne(), $currentPropertyMapping, $operation, $functionExpression->mapVariables($vars, $state.inScopeVars), ^$state(inScopeVars=^Map<String, List<Any>>()), $joinType, $nodeId, $aggFromMap, $context->shift(), $extensions);
         ,
         |fail('No SQL translation exists for the PURE function \''+$functionExpression.func.name->toOne()+'\'. \nIf you would like to add a SQL translation for the function then follow the step-by-step guide on the PURE wiki.'); $operation->wrapIfNecessary();
          );
   );
}

function meta::relational::functions::pureToSqlQuery::flattenConcatenate(f:ValueSpecification[1]):ValueSpecification[*]
{
   $f->match([
      fe:FunctionExpression[1] | if ($fe.func->in([
                                            concatenate_T_MANY__T_MANY__T_MANY_, union_T_MANY__T_MANY__T_MANY_, 
                                            concatenate_TabularDataSet_1__TabularDataSet_1__TabularDataSet_1_,
                                            concatenate_TabularDataSet_1__TabularDataSet_MANY__TabularDataSet_1_
                                            ]),
                                       | $fe.parametersValues->at(0)->flattenConcatenate()->concatenate($fe.parametersValues->at(1)->flattenConcatenate()),
                                       | $fe
                                 );,
      iv:InstanceValue[1]| $iv.values->match([
                              v:ValueSpecification[*]|$v, 
                              a:Any[*]| $iv
                                ]),
      v:ValueSpecification[1] | $v
   ])
}


function meta::relational::functions::pureToSqlQuery::processConcatenate(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let targetType =  $f.genericType.rawType->toOne();
   let isDataType = $targetType->instanceOf(DataType);
   assert(!$f.genericType.rawType->toOne()->instanceOf(Enum), 'Enumerations are not yet supported in this context');

   let elements = $f->flattenConcatenate();

   let processed_pre = $elements->map(e|$e->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, ^$state(shouldIsolateNestedFilter=false, importDataFlowCurrentSetOffsetInUnion=$elements->indexOf($e)), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne(););

   let processed = $processed_pre->map(p|let selectWithCursor = $p.element->cast(@SelectWithCursor);
                                         let select = $selectWithCursor.select;

                                         let newSelect = if ($select.extraFilteringOperation->isEmpty(),
                                                                |$select,
                                                                |^$select(extraFilteringOperation=[],
                                                                          filteringOperation=$select.filteringOperation->concatenate($select.extraFilteringOperation->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second)->andFilters($extensions)
                                                                 )
                                                         );
                                         let newSelectWithCursor = ^$selectWithCursor(select = $newSelect);
                                         ^$p(element = $newSelectWithCursor);
                                   );

   let setImpl = if($isDataType || $targetType ->_subTypeOf(TabularDataSet),|[],|$elements->map(e|$e->cast(@StoreMappingRoutedValueSpecification).sets->toOne())->removeDuplicates());

   // Fix columns ----------------
   let columns = $processed.element->cast(@SelectWithCursor).select.columns;
   let transformed = if (!$columns->isEmpty() && $columns->at(0)->instanceOf(Alias),
                           | $processed->map(p|let selectWithCursor = $p.element->cast(@SelectWithCursor);
                                               let select = $selectWithCursor.select->alignJoinAndPkColumnsForUnion($columns);
                                               let element = $elements->at($processed->indexOf($p));
                                               let type = if($isDataType || $targetType ->_subTypeOf(TabularDataSet),
                                                             |[],
                                                             |^Alias
                                                              (
                                                                 name='u_type',
                                                                 relationalElement=^Literal(value=$setImpl->indexOf($element->cast(@StoreMappingRoutedValueSpecification).sets->toOne())->toString())
                                                              )
                                                          );
                                               let newSelect = ^$select(columns = $type->concatenate($select.columns));
                                               let newSelectWithCursor = ^$selectWithCursor(select = $newSelect);
                                               ^$p(element = $newSelectWithCursor);
                                          );,
                           | $processed
                     );
   // -----------------------------

   let res = if ($operation.select.data->isEmpty(),
      |print(if(!$context.debug, |'', | $transformed->map(t|$context.space+' >Result: '+$t.element->cast(@SelectWithCursor).select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n')->makeString('')));
       let firstSel = $transformed->at(0).element->cast(@SelectWithCursor).select;

       let selects = $transformed.element->cast(@SelectWithCursor).select->map(s | $s->pushSavedFilteringOperation($extensions));

       let rootTable = ^TableAlias(
                                     name = 'union',
                                     relationalElement = if($f.functionName == 'union',
                                                             |^Union(
                                                                   queries = $selects
                                                               ),
                                                             |^UnionAll(
                                                                   queries = $selects
                                                              )
                                                          )
                       );

       let newRoot = ^RootJoinTreeNode(alias = $rootTable);
       ^SelectWithCursor(
          select = ^$firstSel(
                         columns = $transformed.element->cast(@SelectWithCursor).select->at(0).columns
                                      ->map(c|$c->match([a:Alias[1]|^$a(relationalElement=^TableAliasColumn(column=^Column(name=$a.name, type=^meta::relational::metamodel::datatype::Integer()), alias=$rootTable)),
                                                         t:TableAliasColumn[1]|^$t(alias=$rootTable)
                                                        ])),
                         data = $newRoot,
                         savedFilteringOperation = [],
                         leftSideOfFilter = if($firstSel.leftSideOfFilter->isEmpty(),|[],|$newRoot),
                         filteringOperation = [],
                         groupBy = []
                   ),
         currentTreeNode = $newRoot
       );,
      |let propertyName = '"'+$transformed->map(t|if ($t.currentPropertyMapping->isEmpty(), |$t.element->cast(@SelectWithCursor).select.columns->map(c|$c->buildUniqueName(false, $extensions))->makeString('_'), |$t.currentPropertyMapping.property.name->toOne());)->removeDuplicates()->makeString('_')+'"';

       // Build new Select
       let newSelectsWithCutNode = $transformed->map(t| let nodeToCut = $operation.select.data->toOne()->findOneNode($operation.currentTreeNode->toOne(), $t.element->cast(@SelectWithCursor).select.data->toOne());
                                                        let newSelect = if ($nodeToCut->children()->isEmpty(),
                                                                        |let select = $t.element->cast(@SelectWithCursor).select;
                                                                         let withSelf = $select->addSelfJoin($nodeToCut->toOne(), $select.columns->map(q|$q->buildUniqueName(false, $extensions))->makeString('_'), $extensions).first;
                                                                         let oldToNew = ^OldAliasToNewAlias(first=$withSelf.data.alias.name->toOne(), second=$withSelf.data->map(x|$x->children()).alias->toOne());
                                                                         let withSelfReprocessed = ^$withSelf
                                                                                                   (
                                                                                                      columns = $withSelf.columns->map(c|$c->reprocessAliases($oldToNew)),
                                                                                                      savedFilteringOperation = $withSelf.savedFilteringOperation->map(p|pair($withSelf.data->map(x|$x->children())->toOne(), $p.second->reprocessAliases($oldToNew)))
                                                                                                   );
                                                                         let child = $withSelfReprocessed.data->toOne()->children()->toOne();
                                                                         pair($child, buildConcatenateSubSelect($child, $withSelfReprocessed, $isDataType, $propertyName, $state.inFilter, $extensions));,
                                                                        |let child = $nodeToCut->children()->toOne();
                                                                         pair($child, buildConcatenateSubSelect($child, $t.element->cast(@SelectWithCursor).select, $isDataType, $propertyName, $state.inFilter, $extensions));
                                                                    );
                                                 );
       print(if(!$context.debug, |'', | $transformed->zip($newSelectsWithCutNode.second)->map(t|$context.space+' >Result: '+$t.first.element->cast(@SelectWithCursor).select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'+
                                                                                                $context.space+' >Result reprocessed: '+$t.second->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'
                                                                                             )->makeString('')
             )
       );


       let currentTreeNodes = $newSelectsWithCutNode.second->map(t|$t.data->toOne()->findLastJoinTreeNode());

       let setImplementationIds = if($transformed->at(0).currentPropertyMapping.targetSetImplementationId == '',|[],
                                                                                                                |$transformed->map(t| if ($t.currentPropertyMapping->isEmpty(),
                                                                                                                                             |[],
                                                                                                                                             |$t.currentPropertyMapping->match([
                                                                                                                                                 e:EmbeddedRelationalInstanceSetImplementation[1]| $e,
                                                                                                                                                 p:PropertyMapping[1]| $state.mapping->classMappingById($t.currentPropertyMapping.targetSetImplementationId->toOne())->toOne()
                                                                                                                                                 ])
                                                                                                                                         )
                                                                                                                                   ));

       let newQueries = $newSelectsWithCutNode.second->map(s | $s->alignJoinAndPkColumnsForUnion($newSelectsWithCutNode.second.columns));

       let optimized = $newQueries->map(q|if($q.data.alias.relationalElement->toOne()->instanceOf(UnionAll),|$q.data.alias.relationalElement->cast(@UnionAll).queries,|$q));

       let union = if($f.functionName == 'union',
                      |^Union(queries = $optimized,
                              currentTreeNodes = $currentTreeNodes,
                              setImplementations = $setImplementationIds
                       ),
                      |^UnionAll(queries = $optimized,
                                 currentTreeNodes = $currentTreeNodes,
                                 setImplementations = $setImplementationIds
                       )
                   );

       print(if(!$context.debug, |'', | $context.space+' >Union: '+$union->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

       let unionNode = ^TableAlias(name = 'union'+$nodeId, relationalElement = $union);


       let newJoins = $newSelectsWithCutNode.first->map(c|let oldToNew = ^OldAliasToNewAlias(first=$c.alias.name, second=$unionNode);
                                                          let newJoin = $c.join->reprocessJoin($oldToNew, []);
                                                    );

       let firstJoin = $newJoins->at(0);
       let firstChild = $newSelectsWithCutNode->at(0).first;
       let joinY = ^$firstJoin(operation = $newJoins->removeDuplicates({a,b|$a.name == $b.name}).operation->orFilters($extensions)->cast(@Operation)->toOne());
       let newChild = ^$firstChild(alias=$unionNode, join=$joinY, childrenData=[]);

       let sel = $operation.select;
       let data = $sel.data->toOne();
       let newRoot = if ($data->children()->isEmpty(),
                          | ^$data(childrenData=$newChild),
                          | fail('use replaceTreeNode');$data->replaceTreeNode($operation.currentTreeNode->toOne(), $newChild)->cast(@RootJoinTreeNode);
                     );


       // No need to take both (they should be merged already)
       ^SelectWithCursor(
          select = ^$sel
                   (
                      columns = if($isDataType && !$state.inFilter,
                                      |let oldToNew = ^OldAliasToNewAlias(first=$firstChild.alias.name, second=$unionNode);
                                       let alias = $optimized->at(0).columns->at(0)->reprocessAliases($oldToNew)->cast(@Alias);
                                       ^TableAliasColumn(alias=$unionNode, column=^Column(name=$alias.name, type=^meta::relational::metamodel::datatype::Integer()));,
                                      |[]
                                ),
                      savedFilteringOperation = [],
                      data = $newRoot,
                      leftSideOfFilter = if($sel.leftSideOfFilter->isEmpty(),|[],|$sel.leftSideOfFilter->toOne()->findOneNode($data, $newRoot)),
                      filteringOperation = if($isDataType && $state.inFilter, |^TableAliasColumn(alias = $unionNode, column = ^Column(name=$propertyName, type=^meta::relational::metamodel::datatype::Integer())), |[])
                   ),
          currentTreeNode = $newChild
       );
   );

   print(if(!$context.debug, |'', | $context.space+' >Union Result: '+$res.select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

   $res;
}

function meta::relational::functions::pureToSqlQuery::buildConcatenateSubSelect(child:RelationalTreeNode[1], leftSelect:SelectSQLQuery[1], isDataType:Boolean[1], propertyName:String[1], inFilter:Boolean[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   let extraCol = if($isDataType,
                     |let c = if($inFilter,|$leftSelect.filteringOperation->toOne(),
                                           |$leftSelect.columns->toOne()
                      );
                     ^Alias(name=$propertyName, relationalElement=$c);,
                     |[]
                  );
   let newNode = ^RootJoinTreeNode(alias = $child.alias, childrenData = $child.childrenData);
   let newSelect = ^SelectSQLQuery(
                                     data = $newNode,
                                     columns = $extraCol->concatenate($child->cast(@JoinTreeNode)
                                                     ->extractTableAliasColumns()
                                                     ->filter(n|$n.alias == $child.alias)
                                                     ->map(t:TableAliasColumn[1]|^Alias(name=$t.column.name, relationalElement=$t)))
                                                     ->removeDuplicates(),
                                     filteringOperation = if($isDataType,|[],|$leftSelect.filteringOperation)->concatenate($leftSelect.savedFilteringOperation.second)
                                                          ->map(f|pair($f->buildUniqueName(false, $extensions), $f))
                                                          ->removeDuplicates({a,b|$a.first == $b.first})
                                                          .second->andFilters($extensions)
                                  );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::alignJoinAndPkColumnsForUnion(select: SelectSQLQuery[1], allColumns:RelationalOperationElement[*]):SelectSQLQuery[1]
{
   let allCols = $allColumns->removeDuplicates({a,b|$a->cast(@Alias).name == $b->cast(@Alias).name})->cast(@Alias).name;

   let sqlNull = ^Literal(value=^SQLNull());
   let newCols = $allCols->map(a| let col = $select.columns->filter(c|$c->cast(@Alias).name == $a);
                                  if ($col->isEmpty(),
                                      |^Alias(name=$a, relationalElement=$sqlNull),
                                      |$col->at(0)
                                  );
                           );
   ^$select(columns = $newCols);
}


function meta::relational::functions::pureToSqlQuery::processNoOp(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   //Ignores the function and only processes the first parameter
   processValueSpecificationReturnPropertyMapping($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::canProcessAt(f:FunctionExpression[1]):Boolean[1]
{
   // Can process 'at' in the context of semi structured set implementations
   let params = $f.parametersValues->evaluateAndDeactivate();
   if(($params->size() == 2) && ($params->at(0)->instanceOf(StoreMappingRoutedValueSpecification)),
      | let firstParam = $params->at(0)->cast(@StoreMappingRoutedValueSpecification);
        ($firstParam.sets->size() == 1) && ($firstParam.sets->at(0)->instanceOf(SemiStructuredRelationalInstanceSetImplementation));,
      | false
   );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::processAt(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let leftSide = $f.parametersValues->at(0);
   let byPassedLeftSide = $leftSide->deepByPassRouterInfo();

   let toManyPropertyCallCheck = {vs:ValueSpecification[1] |
      $vs->instanceOf(SimpleFunctionExpression) &&
      $vs->cast(@SimpleFunctionExpression).func->instanceOf(Property) &&
      (!$vs->cast(@SimpleFunctionExpression).func->cast(@Property<Nil,Any|*>).multiplicity->hasToOneUpperBound())
   };

   let isToManyPropertyCall    = $toManyPropertyCallCheck->eval($byPassedLeftSide);
   let isToManyPropertyAutomap = $byPassedLeftSide->instanceOf(SimpleFunctionExpression) &&
                                 ($byPassedLeftSide->cast(@SimpleFunctionExpression).functionName == 'map') &&
                                 ($byPassedLeftSide->cast(@SimpleFunctionExpression)->map({fe |
                                    let mapFn = $fe.parametersValues->evaluateAndDeactivate()->at(1)->cast(@InstanceValue).values->cast(@meta::pure::metamodel::function::FunctionDefinition<Any>);
                                    let mapExpr = $mapFn.expressionSequence->evaluateAndDeactivate();
                                    ($mapExpr->size() == 1) && $toManyPropertyCallCheck->eval($mapExpr->toOne()->deepByPassRouterInfo());
                                 }));

   assert($isToManyPropertyCall || $isToManyPropertyAutomap,
          | '->at(...) function is supported only after direct access of 1->MANY properties. Current expression: ' + $f->deepByPassRouterInfo()->cast(@FunctionExpression)->meta::pure::router::printer::asString());

   let processedLeftSide = processValueSpecificationReturnPropertyMapping($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne();
   let propertyMappings = $processedLeftSide.currentPropertyMapping;

   assert(($propertyMappings->size() >= 1) && $propertyMappings->forAll(pm | $pm->instanceOf(SemiStructuredRelationalPropertyMapping)),
          | 'Expected semi structured property mappings. Got: ' + $propertyMappings->map(x | $x->genericType().rawType->toOne()->elementToPath())->joinStrings('[', ', ', ']'));

   let preCollectionOp = processValueSpecification($f.parametersValues->at(0)->byPassRouterInfo()->cast(@SimpleFunctionExpression).parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let collectionSWC = $propertyMappings->at(0)->cast(@SemiStructuredRelationalPropertyMapping).relationalOperationElement->processColumnsInRelationalOperationElements($state, $preCollectionOp, $nodeId, $aggFromMap, true, $context, $extensions)->cast(@SelectWithCursor);
   let collectionSelect = $collectionSWC.select;

   let arrayAccessBuilder = {r:RelationalOperationElement[*] |
      assert($r->size() == 1, | 'Expected one relational operation element when processing \'at\'. Found: ' + $r->size()->toString());
      assert($r->toOne()->instanceOf(SemiStructuredPropertyAccess), | '\'at\' function is supported only when accessing properties mapped to semi structured data');
      let ssp = $r->toOne()->cast(@SemiStructuredPropertyAccess);
      assert($ssp.index->isEmpty(), | 'Detected unexpected multiple \'at\' function application ->at(...)->at(...)');
      let indexSelect = processValueSpecification($f.parametersValues->at(1), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor).select;
      ^$ssp(index = $state.inFilter->if(|$indexSelect.filteringOperation,|$indexSelect.columns)->toOne()->cast(@Literal));
   };

   let newSelect = $state.inFilter->if(|^$collectionSelect(filteringOperation = $arrayAccessBuilder->eval($collectionSelect.filteringOperation)),|^$collectionSelect(columns = $arrayAccessBuilder->eval($collectionSelect.columns)));
   ^$processedLeftSide(element = ^$collectionSWC(select = $newSelect));
}

function meta::relational::functions::pureToSqlQuery::processNot(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processUnary($f, $currentPropertyMapping, $operation, {a|^DynaFunction(name = 'not', parameters = $a)}, $vars, $state, $nodeId, $aggFromMap, $context, $extensions)->cast(@SelectWithCursor)->moveExtraFilterToFilter($extensions)
}

function meta::relational::functions::pureToSqlQuery::processPlus(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   if ($f.parametersValues->size() == 1 && !$f.parametersValues->at(0)->instanceOf(InstanceValue),
      |processAggregation($f, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions),
      |processVariableArity($f, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);
   );

}

function meta::relational::functions::pureToSqlQuery::processParseDate(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
    let formatInstance = ^InstanceValue(multiplicity = PureOne, genericType = ^GenericType(rawType=String), values = 'YYYY-MM-DD HH24:MI:SS'); 
    let dynaFuncName = 'toTimestamp';
    let oldFunc = $f.func;
    let newFunc = ^$oldFunc(functionName=$dynaFuncName);
    let functionExpression = ^$f(func = $newFunc, parametersValues=$f.parametersValues->concatenate($formatInstance));    
    $functionExpression->processDynaFunction($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);
}

function meta::relational::functions::pureToSqlQuery::findAliasOrFail(columnName:String[1], select:SelectSQLQuery[1]):Alias[1]
{
   findAliasOrFail($columnName, $select.columns->filter(c|$c->instanceOf(Alias))->cast(@Alias));
}

function meta::relational::functions::pureToSqlQuery::findAliasOrFail(columnName:String[1], aliases:Alias[*]):Alias[1]
{
   let ps = $columnName-> meta::relational::functions::pureToSqlQuery::addQuotesIfNecessary();
   let alias = $aliases->filter(a|$a.name->addQuotesIfNoQuotes() == $ps);
   assertNotEmpty($alias,{|'The column \''+$columnName+'\' can\'t be found ('+$aliases.name->joinStrings(',')+')'});
   $alias->toOne();
}

function meta::relational::functions::pureToSqlQuery::findAliasOrFail(f:FunctionExpression[1], select:SelectSQLQuery[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1]):Alias[*]
{
   $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@String)->map(s| $s->findAliasOrFail($select));
}

function meta::relational::functions::pureToSqlQuery::processTDSSortSingular(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let sortInfo = ^SortInformation(
      column = $f->instanceValueAtParameter(1)->cast(@String),
      direction = $f.parametersValues->at(2)->reactivate()->toOne()->cast(@meta::pure::tds::SortDirection));
   $f->processTDSSort($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $sortInfo, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processTDSSortColumns(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let sortInfo = $f->instanceValuesAtParameter(1,$vars, $state.inScopeVars)->cast(@String)->map(s | ^SortInformation(column = $s, direction = meta::pure::tds::SortDirection.ASC));
   $f->processTDSSort($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $sortInfo, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processTDSSortInformation(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let sortInfo = $f.parametersValues->at(1)->reactivate($state.inScopeVars)->cast(@SortInformation);
   $f->processTDSSort($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $sortInfo, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processTDSSort(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], sortInfo:SortInformation[*], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mainQuery = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let mainSelect = $mainQuery.select;
   ^$mainQuery(
      select = ^$mainSelect(
                  orderBy = $sortInfo->map(info |
                     let direction = if ($info.direction == meta::pure::tds::SortDirection.DESC,
                        | meta::relational::metamodel::SortDirection.DESC,
                        | meta::relational::metamodel::SortDirection.ASC);
                     ^OrderBy(column = $info.column->findAliasOrFail($mainSelect), direction = $direction);
                     )->concatenate($mainSelect.orderBy)
                  )
      );
}

function meta::relational::functions::pureToSqlQuery::processSortBy(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mainQuery = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let mainSelect = $mainQuery.select->pushSavedFilteringOperation($extensions);

   let sortByFunc = $f.parametersValues->evaluateAndDeactivate()->at(1)->byPassRouterInfo()->cast(@InstanceValue).values->at(0);
   assert($sortByFunc->instanceOf(Path), 'sortBy can currently be converted to SQL only if the parameter is a Path.');
   let path = $sortByFunc->cast(@Path<Nil,Any|*>);
   let pathName = 'o_'+$path->buildColumnNameOutOfPath();
   let joinResult = processPath($path, $pathName, '1', $mainQuery, $vars, ^$state(inFilter=false), $nodeId, $aggFromMap, $context->shift(), $extensions).element->cast(@SelectWithCursor).select;

   let merge = $mainSelect->concatenate($joinResult)->mergeSQLQueryData($nodeId, $state, $context, $extensions);

   ^$operation(
      currentTreeNode = $mainQuery.currentTreeNode->toOne()->findOneNode($mainQuery.select.data->toOne(), $merge.data->toOne()),
      positionBeforeLastApplyJoinTreeNode = if ($mainQuery.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$mainQuery.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($mainQuery.select.data->toOne(), $merge.data->toOne())),
      select = ^SelectSQLQuery(
                  columns = $merge.columns,
                  data = $merge.data,
                  leftSideOfFilter = $merge.leftSideOfFilter,
                  filteringOperation = $merge.filteringOperation,
                  extraFilteringOperation = $merge.extraFilteringOperation,
                  orderBy = ^OrderBy(column=$joinResult.columns->at(0)->cast(@Alias).relationalElement, direction=meta::relational::metamodel::SortDirection.ASC)
               )
   );
}

function meta::relational::functions::pureToSqlQuery::processSlice(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mainQuery = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let mainSelect = $mainQuery.select;

   let param1 = processValueSpecification($f.parametersValues->at(1), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor).select.columns->at(0);
   assert($param1->instanceOf(Literal),'Invalid type for first parameter inside the slice function. Expected a value, found operation/function');
   let fromRow = $param1->cast(@Literal);
   let param2 = processValueSpecification($f.parametersValues->at(2), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor).select.columns->at(0);
   assert($param2->instanceOf(Literal),'Invalid type for second parameter inside the slice function. Expected a value, found operation/function');
   let toRow = $param2->cast(@Literal); 
   let processedSelect = ^$mainSelect (
                  fromRow = if ($fromRow.value->instanceOf(Integer) && $fromRow.value->cast(@Integer) == 0, |[], |$fromRow),
                  toRow = $toRow
            )->isolateSubSelectIfNotLastOperation($f, $state.functionExpressionStack, $extensions);

   ^$mainQuery(
      select = $processedSelect,
      currentTreeNode = if($mainQuery.currentTreeNode->isEmpty(),  | $mainQuery.currentTreeNode, | $mainQuery.currentTreeNode->toOne()->findOneNode($mainQuery.select.data->toOne(), $processedSelect.data->toOne()))
      );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::isolateTdsSelect(select:TdsSelectSqlQuery[1], extensions:Extension[*]):TdsSelectSqlQuery[1]
{
   ^TdsSelectSqlQuery( data =^RootJoinTreeNode(alias = ^TableAlias(name = 'subselect', relationalElement=$select->pushExtraFilteringOperation($extensions))),
                       columns = $select.columns->map(c|^Alias(name = $c->cast(@Alias).name, relationalElement = ^ColumnName(name=$c->cast(@Alias).name))),
                       paths = $select.paths)
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::isolateSubSelectIfNotLastOperation(select:SelectSQLQuery[1], f:FunctionExpression[1], parents:FunctionExpression[*], extensions:Extension[*]):SelectSQLQuery[1]
{
   let p = $parents->evaluateAndDeactivate();
   if ($p->size() > 1,
    | let fe = $p->at($p->size()-2);
      let ft = $fe.func->functionType();
      if([$ft.parameters->at(0).genericType->toOne(), $ft.returnType]->forAll(x|$x.rawType->toOne()->_subTypeOf(TabularDataSet)),
                  | isolateTdsSelect($select->cast(@TdsSelectSqlQuery), $extensions);,
                  | $select
      );,
    | $select
   );
}

function meta::relational::functions::pureToSqlQuery::processTake(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mainQuery = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let param1 = processValueSpecification($f.parametersValues->at(1), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor).select.columns->toOne();
   assert($param1->instanceOf(Literal),'Invalid type for parameter inside the take/limit function. Expected a value, found operation/function');
   let limitValue = $param1->cast(@Literal);
   let mainSelect = $mainQuery.select;

   let limitSize = if($limitValue->instanceOf(SQLNull),
                      | [],
                      | $limitValue//->cast(@Integer)
                      );

   let processedSelect = ^$mainSelect(toRow = $limitSize)->isolateSubSelectIfNotLastOperation($f, $state.functionExpressionStack, $extensions);

   ^$mainQuery(
      select = $processedSelect,
      currentTreeNode = if($mainQuery.currentTreeNode->isEmpty(),  | $mainQuery.currentTreeNode, | $mainQuery.currentTreeNode->toOne()->findOneNode($mainQuery.select.data->toOne(), $processedSelect.data->toOne()))
      );
}


function meta::relational::functions::pureToSqlQuery::processIf(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{

  let returnType = $f.genericType.rawType->toOne();
  assert($returnType->instanceOf(DataType) || $returnType->instanceOf(Enumeration), | 'If only supported with a return type that is a DataType or Enumeration, return type:' + $returnType->toString());
  processDynaFunction($f, $currentPropertyMapping, $operation, $vars, ^$state(inIf=true), $joinType, $nodeId, $aggFromMap, $context, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processTdsWindowColWithoutWindow(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processTdsWindowColumn($f,[],$f.parametersValues->at(1)->cast(@ValueSpecification),$f.parametersValues->at(2)->cast(@ValueSpecification),$currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processTdsWindowColWithoutSort(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processTdsWindowColumn($f,$f.parametersValues->at(1)->cast(@InstanceValue),[],$f.parametersValues->at(2)->cast(@ValueSpecification),$currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)
}

function meta::relational::functions::pureToSqlQuery::processTdsWindowColWithoutWindowAndSort(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processTdsWindowColumn($f,[],[],$f.parametersValues->at(1)->cast(@ValueSpecification),$currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)
}

function meta::relational::functions::pureToSqlQuery::processTdsWindowColumn(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processTdsWindowColumn($f,$f.parametersValues->at(1)->cast(@InstanceValue),$f.parametersValues->at(2)->cast(@ValueSpecification),$f.parametersValues->at(3)->cast(@ValueSpecification),$currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)
}

function meta::relational::functions::pureToSqlQuery::processTdsWindowColumn(f:FunctionExpression[1], i:InstanceValue[0..1], sortFe:ValueSpecification[0..1], operationFe: ValueSpecification[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mainQuery = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let mainSelect = $mainQuery.select->cast(@TdsSelectSqlQuery);
   let columnName = $f.parametersValues->last()->toOne()->cast(@InstanceValue).values->at(0)->cast(@String);
   assert(!$mainSelect.columns->map(col | $col->extractColumnName())->contains($columnName), | 'Attempting to reuse the same column name: '+ $columnName);
   let windowElement = if($i->isNotEmpty(),|$i.values->map(v|let col = findAliasOrFail($v->toString(), $mainSelect);
                                                       $col.relationalElement;
                                                    );
                      ,|[]);
   let sortInfo =if($sortFe->isNotEmpty(),| $sortFe->toOne()->reprocessVS()->reactivate($state.inScopeVars)->cast(@SortInformation),|[]);
   let sortElement = if($sortInfo->isNotEmpty(),|findAliasOrFail($sortInfo.column->toOne(), $mainSelect).relationalElement,|[]);
   let sortDirection=if($sortInfo->isNotEmpty(),|if ($sortInfo.direction.name == meta::pure::tds::SortDirection.DESC.name,| meta::relational::metamodel::SortDirection.DESC,| meta::relational::metamodel::SortDirection.ASC),|[]);
   let olapOperation = $operationFe->reprocessVS()->reactivate($state.inScopeVars)->evaluateAndDeactivate()->cast(@OlapOperation<Any>)->toOne();
   let func = processTdsOlapOperation($olapOperation,^$operation(select=$mainSelect),$vars,$currentPropertyMapping,$state,$context)->cast(@DynaFunction);
   let windowColumn = ^Alias(name='"'+$columnName+'"' , relationalElement = ^meta::relational::metamodel::WindowColumn(columnName = $columnName,func=$func, window = ^meta::relational::metamodel::Window(partition=$windowElement,sortBy=$sortElement, sortDirection=$sortDirection)));
   let pureType = $olapOperation->match([t:TdsOlapAggregation<Any>[1]|$t.func->functionReturnType().rawType->toOne(), r:TdsOlapRank<Any>[1]|Integer]);
   let newPath = pair($columnName, ^PathInformation(type=$pureType, relationalType= meta::relational::transform::fromPure::pureTypeToDataType($pureType)));
   ^$operation(select=^$mainSelect(columns = $mainSelect.columns->concatenate($windowColumn),paths +=$newPath)->isolateSubSelectIfNotLastOperation($f, $state.functionExpressionStack, $extensions));
}

function meta::relational::functions::pureToSqlQuery::processTdsOlapOperation(o:OlapOperation<Any>[1], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1],currentPropertyMapping: PropertyMapping[*],state:State[1],context: DebugContext[1]):RelationalOperationElement[1]
{
   $o->extractOperation().expressionSequence->at(0)->processAggFn(
      $o->match([
      t: TdsOlapAggregation<Any>[1]| let col = findAliasOrFail($t.colName->toString(), $operation.select).relationalElement;
                                     assert($col->instanceOf(ColumnName) || $col->instanceOf(TableAliasColumn) || $col->instanceOf(DynaFunction),'Window Function does not refer to a column or an aggregate function');
                                     $col;,
      r:TdsOlapRank<Any>[1]|[]
      ] )
   )->toOne();
}

function meta::relational::functions::pureToSqlQuery::processTdsFilter(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mainQuery = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let mainSelect = $mainQuery.select;

   if($state.insertDriverTablePkInTempTable->isNotEmpty(),
      | $mainQuery->cast(@SelectWithCursor),
      | let res = processValueSpecification($f.parametersValues->at(1), [], ^$mainQuery(select=^$mainSelect(filteringOperation=[], extraFilteringOperation=[])), $vars, ^$state(inFilter=true), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
        let select = $res.select;
        let mainQueryFilter=$mainQuery.select.filteringOperation->concatenate($mainQuery.select.extraFilteringOperation)->andFilters($extensions);
        let mainQueryColumns = $mainQuery.select.columns;
        let finalColumns = $mainQueryColumns->map(c|
                                                  $c->match(
                                                     [
                                                        w:WindowColumn[1]|if(!$select.columns->extractTableAliasColumns().column.name->contains($w.columnName) ,|$w,|$select.columns->filter(c|$c->extractTableAliasColumns().column.name==$w.columnName)->toOne()),
                                                        a:Alias[1]| let col = $select.columns->filter(c|$c->instanceOf(Alias) && $c->cast(@Alias).name==$a.name);
                                                                    $col->isEmpty()->if(|$a,|$col);,
                                                        r:RelationalOperationElement[1]| $r
                                                     ]
                                                  ));
        let queryRootMutated = !$mainSelect->rootIsSubQuery() && $select->rootIsSubQuery();
        let placeNestedFilters = {select:SelectSQLQuery[1]|let havingFilter=$select.data->toOne().alias.relationalElement->cast(@SelectSQLQuery).filteringOperation;
                                                           let filter = $havingFilter->concatenate($mainQuery.select.havingOperation)->andFilters($extensions);
                                                           let newSelect = nestFilters($select,$mainQueryFilter,$filter);
                                                           ^$newSelect(columns=$finalColumns, filteringOperation=$select.filteringOperation);
                                 };
        let placeRootFilters = {select: SelectSQLQuery[1]|let havingFilter=$select.filteringOperation;
                                                          let filter = $havingFilter->concatenate($mainQuery.select.havingOperation)->andFilters($extensions);
                                                           ^$select(columns=$finalColumns, filteringOperation=$mainQueryFilter, havingOperation=$filter);
                                };
        let nestMainFilter = {select: SelectSQLQuery[1]|let newSelect = nestFilters($select,$mainQueryFilter,[]);
                                                        ^$newSelect(columns=$finalColumns, filteringOperation=$select.filteringOperation->concatenate($newSelect.filteringOperation)->andFilters($extensions));
                              };
        let placeMainFilterAtRoot ={select: SelectSQLQuery[1] | let filter = $select.filteringOperation->concatenate($mainQueryFilter)->andFilters($extensions);
                                                                ^$select(columns=$finalColumns, filteringOperation=$filter);
                                   };


        if($queryRootMutated,| let updatedSelect = if(!$mainQuery.select.groupBy->isEmpty(),| $placeNestedFilters->eval($select)
                                                                                           ,| $nestMainFilter->eval($select));
                               ^$res(select = $updatedSelect);

                            ,| let updatedSelect = if(!$mainQuery.select.groupBy->isEmpty(),|$placeRootFilters->eval($select)
                                                                                           ,|$placeMainFilterAtRoot->eval($select));

                               ^$res(select = $updatedSelect,
                                     currentTreeNode = if($mainQuery.currentTreeNode->isNotEmpty(),| $mainQuery.currentTreeNode->toOne()->findOneNode($mainQuery.select.data->toOne(), $res.select.data->toOne()), |[]),
                                     positionBeforeLastApplyJoinTreeNode = if($mainQuery.positionBeforeLastApplyJoinTreeNode->isNotEmpty(),| $mainQuery.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($mainQuery.select.data->toOne(), $res.select.data->toOne()), |[]));

           );
   );
}

function meta::relational::functions::pureToSqlQuery::rootIsSubQuery(query: SelectSQLQuery[1]): Boolean[1]
{
   $query.data->toOne().alias.relationalElement->instanceOf(SelectSQLQuery)
}

function meta::relational::functions::pureToSqlQuery::nestFilters(newQuery:SelectSQLQuery[1], filters:RelationalOperationElement[0..1],having:RelationalOperationElement[0..1]):SelectSQLQuery[1]
{
   let data = $newQuery.data->toOne()->cast(@RootJoinTreeNode);
   let alias = $data.alias;
   let nestedSelect = $alias.relationalElement->cast(if($alias.relationalElement->instanceOf(TdsSelectSqlQuery),|@TdsSelectSqlQuery,|@SelectSQLQuery));
   let oldToNew = ^OldAliasToNewAlias(first = 'root',second = $nestedSelect.data->cast(@RootJoinTreeNode)->toOne().alias);
   let newFilters = $filters->reprocessAliases($oldToNew);
   let newHaving = $having->reprocessAliases($oldToNew);
   ^$newQuery(data = ^$data(alias = ^$alias(relationalElement =^$nestedSelect(filteringOperation = $newFilters, havingOperation = $newHaving))));
}

function meta::relational::functions::pureToSqlQuery::addPkForAggregation(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], existingQuery:SelectWithCursor[1], state:State[1], nodeId:String[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   // Add PK
   if (!$f.parametersValues->at(0)->instanceOf(StoreMappingRoutedValueSpecification) || !$f.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->size() == 1,
         |$existingQuery,
         |if($f.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne()->instanceOf(RootRelationalInstanceSetImplementation),
             |let rs = $f.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne()->cast(@RootRelationalInstanceSetImplementation);
              let pk = $rs->resolvePrimaryKey();
              let valid = if ($pk->isEmpty(), |  fail('There is no primary key defined on the table ' + $rs->mainTable()->toOne().name + '. A primary key must be defined in the table definition in PURE to use this feature'); false; ,| true);
              let existingSelect = $existingQuery.select;
              let all = $pk->filter(p|$p->instanceOf(TableAliasColumn))->map(p|$p->processColumnsInRelationalOperationElements(^$state(inFilter=false), ^$existingQuery(select=^$existingSelect(leftSideOfFilter=[]), positionBeforeLastApplyJoinTreeNode=[]), $nodeId, ^List<ColumnGroup>(), false, $context, $extensions));
              let sel = $all->map(c|$c.select)->cast(@SelectSQLQuery)->mergeSQLQueryData($nodeId, $state, $context, $extensions);
              let mergedWithCollapsedFilteringOperation = ^$sel(filteringOperation = $sel.filteringOperation->tail()->fold({f,a|[$a->toOne(),$f]->andFilters($extensions)}, $sel.filteringOperation->head()));
              let res = $all->first()->toOne();
              let result = ^$res
                           (
                              select = ^$mergedWithCollapsedFilteringOperation
                                       (
                                          leftSideOfFilter = if($existingQuery.select.leftSideOfFilter->isEmpty(),|[],|$existingQuery.select.leftSideOfFilter->toOne()->findNode($existingQuery.select.data->toOne(), $mergedWithCollapsedFilteringOperation.data->toOne())->toOne())
                                       ),
                              currentTreeNode = $res.currentTreeNode->toOne()->findOneNode($res.select.data->toOne(), $mergedWithCollapsedFilteringOperation.data->toOne()),
                              positionBeforeLastApplyJoinTreeNode = if($existingQuery.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$existingQuery.positionBeforeLastApplyJoinTreeNode->toOne()->findNode($existingQuery.select.data->toOne(), $mergedWithCollapsedFilteringOperation.data->toOne())->toOne())
                           );
              $result->validate([], $extensions);
              $result;,
             |if($f.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne()->instanceOf(OperationSetImplementation) && ($f.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne()->cast(@OperationSetImplementation)->resolveOperation($state.mapping)->size() > 1) && $f.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne()->cast(@OperationSetImplementation)->resolveOperation($state.mapping)->forAll(set | $set->instanceOf(RootRelationalInstanceSetImplementation)) && $existingQuery.currentTreeNode->isNotEmpty() && $existingQuery.currentTreeNode->toOne().alias.relationalElement->instanceOf(Union),
                 |addPkForAggregationInUnion($existingQuery, $f.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne()->cast(@OperationSetImplementation)->resolveOperation($state.mapping)->cast(@RootRelationalInstanceSetImplementation), $state, $extensions),
                 |$existingQuery
              );
          );

   );

}

function meta::relational::functions::pureToSqlQuery::buildNodeId(startNode:String[1], preToAdd:String[1]):String[1]
{
   let toAdd = if($preToAdd == '_i0',|'_d',|$preToAdd);
   let res = if ($startNode == '',
      |$toAdd,
      |let lastIndexParsed = $startNode->lastIndexOf('#');
       let existingNumber = if($lastIndexParsed == -1,
                                 | // No #
                                   pair(1, $startNode->length());,
                                 | let number = $startNode->substring($lastIndexParsed+1,$startNode->length());
                                   if ($number->indexOf('_') == -1,
                                      |// Extract the value from the #
                                       pair($number->parseInteger(), $lastIndexParsed),
                                      |// We have a # but it's not terminal
                                       pair(1, $startNode->length())
                                   );
                            );
       let lastIndex = $existingNumber.second;
       let lastUnder = $startNode->lastIndexOf('_');
       let lastPattern = $startNode->substring($lastUnder, $lastIndex);
       if ($toAdd == $lastPattern,
          |let number = $existingNumber.first+1;
           $startNode->substring(0, $lastIndex)+'#'+$number->toString();,
          |$startNode+$toAdd;
       );
   );
   $res;
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::isAggregationFunction(f:meta::pure::metamodel::function::Function<Any>[1], supported:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>[1]):Boolean[1]
{
   let mFunc = $supported->get($f);
   $mFunc->in([meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_,
               meta::relational::functions::pureToSqlQuery::processStringPlus_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_,
               meta::relational::functions::pureToSqlQuery::processPlus_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_,
               meta::relational::functions::pureToSqlQuery::processJoinStrings_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_
   ]);
}


function <<access.private>> meta::relational::functions::pureToSqlQuery::containsAggregationFunctionInValueSpecification(f:ValueSpecification[1], supported:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>[1]):Boolean[1]
{
   $f->match([
                  e:StoreMappingRoutedValueSpecification[1]|$e.value,
                  a:Any[*]|$a
                ])
     ->match([
               f:FunctionExpression[1]| if ($f.func->isAggregationFunction($supported),
                                            |true,
                                            |$f.func->match([
                                                  f:FunctionDefinition<Any>[1]|$f->containsAggregationFunctionInFunction($supported),
                                                  a:Any[*]|false
                                                 ]) ||
                                             $f.parametersValues->evaluateAndDeactivate()->fold({a,b|$b || $a->containsAggregationFunctionInValueSpecification($supported)},false);
                                        );,
               i:InstanceValue[1]|$i.values->fold({a,b|$b || $a->match([f:FunctionDefinition<Any>[1]|$f->containsAggregationFunctionInFunction($supported),
                                                                        vs:ValueSpecification[1]|$vs->containsAggregationFunctionInValueSpecification($supported),
                                                                        a:Any[1]|false])},false),
               a:Any[1]|false
             ]
          );
}

function meta::relational::functions::pureToSqlQuery::containsAggregationFunctionInFunction(f:meta::pure::metamodel::function::Function<Any>[1], supported:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>[1]):Boolean[1]
{
   $f->match([f:FunctionDefinition<Any>[1]|$f.expressionSequence->at(0)->evaluateAndDeactivate()->containsAggregationFunctionInValueSpecification($supported),a:Any[1]|false]);
}

function meta::relational::functions::pureToSqlQuery::processMap(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   let res = processValueSpecificationReturnPropertyMapping($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, buildNodeId($nodeId,'_d'), $aggFromMap, $context, $extensions);
   let mainQuery = $res.element->toOne()->cast(@SelectWithCursor)->manageIsolation([], $nodeId, false, $state, $context, $extensions);//$res.element->toOne()->cast(@SelectWithCursor);
   let select = $mainQuery.select;
   let mainQueryWithColumns = ^$mainQuery(select = ^$select(columns=[]));

   let newCurrentPropertyMapping = if ($res.currentPropertyMapping->isEmpty(), | [], | $res.currentPropertyMapping);

   let func = $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->match([
                  e:StoreMappingRoutedValueSpecification[1]|$e.value->reactivate();,
                  a:Any[*]|$a
                ]);

   let newQuery = if($func->cast(@meta::pure::metamodel::function::Function<Any>)->toOne()->containsAggregationFunctionInFunction($state.supportedFunctions),
                     |addPkForAggregation($f, $newCurrentPropertyMapping, $mainQueryWithColumns, $state, $nodeId, $context, $extensions),
                     |$mainQueryWithColumns
                  );
   let newSelect = $newQuery.select;

   let milestoningContext=$newQuery.milestoningContext->concatenate($operation.milestoningContext)->first();

   let isSemiStructuredPropertyMapping = ($newCurrentPropertyMapping->size() >= 1) && $newCurrentPropertyMapping->forAll(pm | $pm->instanceOf(SemiStructuredRelationalPropertyMapping));
   let extraColumn = if($isSemiStructuredPropertyMapping && ($select.columns->size() == 1),
                        | $select.columns->toOne()->reprocessAliases(^OldAliasToNewAlias(first = $mainQuery.currentTreeNode.alias.name->toOne(), second = $newQuery.currentTreeNode.alias->toOne())),
                        | []);

   $func->match(
                [
                  p:Property<Nil,Any|*>[1]|processProperty($p, $f.parametersValues->at(0)->byPassRouterInfo()->cast(@ValueSpecification).genericType.rawType->toOne()->cast(@Class<Any>), $newCurrentPropertyMapping, $state.propertyMappingFromRouter, ^$newQuery(select=^$newSelect(columns=[])), $state, $joinType, buildNodeId($nodeId,'_d'), ^$aggFromMap(values+=^ColumnGroup(columns=$newSelect.columns)), $context->shift(), $extensions),
                  q:QualifiedProperty<Any>[1]|processQualifiedProperty($q, $newCurrentPropertyMapping, ^$newQuery(select=^$newSelect(columns=[])), $vars, ^$state(qualifierBase=$res->toOne()), $joinType, buildNodeId($nodeId,'_q'), ^$aggFromMap(values+=^ColumnGroup(columns=$newSelect.columns)), $context->shift(), $extensions)->toOne(),
                  f:FunctionDefinition<Any>[1]| let sourceOp = ^$newQuery(select=^$newSelect(columns=[]->concatenate($extraColumn)), milestoningContext=$milestoningContext);
                                                let stateUpdatedWithInputQuery = $state->updateFunctionParamScope($f.classifierGenericType.typeArguments.rawType->toOne()->cast(@FunctionType),$sourceOp);
                                                let inScopeVarsWithPlaceholdersState = $f->addPlaceHoldersForLambdaOpenVariables($vars, $stateUpdatedWithInputQuery);
                                                processValueSpecificationReturnPropertyMapping($f.expressionSequence->at(0), $newCurrentPropertyMapping, $sourceOp, $vars, $inScopeVarsWithPlaceholdersState, $joinType, buildNodeId($nodeId,'_f'), ^$aggFromMap(values+=^ColumnGroup(columns=$newSelect.columns)), $context->shift(), $extensions)->toOne();,
                  pa:Path<Nil,Any|*>[1] | let res = processPath($pa, 'map', '_map', $newQuery, $vars, $state, $nodeId, $aggFromMap, $context->shift(), $extensions);
                                          if($state.inFilter || $res.element->cast(@SelectWithCursor).select.columns->isEmpty(), | $res, | let selectWithCursor = $res.element->cast(@SelectWithCursor);
                                                                   let select = $selectWithCursor.select;
                                                                   let newColumn = $select.columns->toOne()->cast(@Alias).relationalElement;
                                                                   ^$res(element=^$selectWithCursor(select=^$select(columns=$newColumn)));
                                                                   );
                ]);
}

function meta::relational::functions::pureToSqlQuery::processDrop(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mainQuery = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let mainSelect = $mainQuery.select;

   let param1 = processValueSpecification($f.parametersValues->at(1), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor).select.columns->at(0);//.value->cast(@Integer);
   assert($param1->instanceOf(Literal),'Invalid type for parameter inside the drop function. Expected a value, found operation/function');
   let fromValue = $param1->cast(@Literal);
   let processedSelect = ^$mainSelect(fromRow = $fromValue)->isolateSubSelectIfNotLastOperation($f, $state.functionExpressionStack, $extensions);

   ^$mainQuery(
      select = $processedSelect,
      currentTreeNode = if($mainQuery.currentTreeNode->isEmpty(),  | $mainQuery.currentTreeNode, | $mainQuery.currentTreeNode->toOne()->findOneNode($mainQuery.select.data->toOne(), $processedSelect.data->toOne()))
      );
}

function meta::relational::functions::pureToSqlQuery::processAggregation(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mergedSQL = $f.parametersValues->map(pv|$pv->processValueSpecification($currentPropertyMapping, $operation, $vars, ^$state(shouldIsolateNestedFilter=true), $joinType, $nodeId, $aggFromMap, $context, $extensions))->map(x | extractSelectSQLQuery($x))->mergeSQLQueryData($nodeId, $state, $context, $extensions);
   let mergedResult = if($state.inFilter,|$mergedSQL.filteringOperation,|$mergedSQL.columns);

   //add the primary key for the last variable if we dont have a groupBy in the query
   let aggregationColumnsReferToCurrentNode = $mergedResult->extractTableAliasColumns().alias->removeDuplicates() == $operation.currentTreeNode.alias;
   let processingAggregationWithoutMapWithinQualifier = $operation.select.groupBy->isEmpty() && $aggFromMap.values->isEmpty() && $state.inProject && $state.functionReferenceScope->isNotEmpty();
   let moreAggregationKeys = if( $processingAggregationWithoutMapWithinQualifier && !$aggregationColumnsReferToCurrentNode,
                        | $state.functionReferenceScope.varToSelect->toOne()->keyValues().second
                           ->map(swc|
                                 let keys = $swc.currentTreeNode.alias.relationalElement
                                    ->match([
                                             t:Table[1]| $t.primaryKey,
                                             s:SelectSQLQuery[1]| $s.data.alias.relation->cast(@Table).primaryKey,
                                             u:Union[1]| assert(false,'Union query not supported'); $u.queries->first()->cast(@SelectSQLQuery).data.alias.relation->cast(@Table).primaryKey;
                                          ]);
                                 ^ColumnGroup(columns = $keys->map(k|^TableAliasColumn(column  =$k ,alias = findOneNode($swc.select.data->toOne(), $swc.currentTreeNode->toOne(), $mergedSQL.data->toOne()).alias)));
                                 )

                        ,|[]);
   //decide if we want to flatten out nested dynafunctions e.g we need to flatten out when a property is mapped to a plus operation and then is used in another plus operation.
   let dynaFunction = if(($mergedResult->size() == 1 && $mergedResult->toOne()->instanceOf(DynaFunction) && $mergedResult->toOne()->cast(@DynaFunction).name == $f.func.functionName) && $moreAggregationKeys->isEmpty(),
                          | $mergedResult->toOne() ,
                          | newDynaFunction($f.func.functionName->toOne(), if($state.inFilter,|$mergedSQL.filteringOperation,|$mergedSQL.columns)));

   manageAggregation($mergedSQL, $dynaFunction, $operation, $state, $nodeId, list($moreAggregationKeys->concatenate($aggFromMap.values)), $context, $extensions);
}

function meta::relational::functions::pureToSqlQuery::manageAggregation(leftSql:SelectSQLQuery[1], relationalOperation:RelationalOperationElement[1], operation:SelectWithCursor[1], state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let mergedSQL = $leftSql;
   // Add aggregation function + groupBy
   let select = if($state.inFilter,
                   | let new = ^$mergedSQL(filteringOperation = $relationalOperation);
                     if ($aggFromMap.values->isEmpty(),|$new,|^$new(filteringOperation=$new.filteringOperation, groupBy=$aggFromMap.values->last().columns->concatenate($leftSql.extraFilteringOperation->extractTableAliasColumns()->removeDuplicates())));,
                   | let new = ^$mergedSQL(columns = $relationalOperation);
                     if ($aggFromMap.values->isEmpty(),|$new,|^$new(columns=$new.columns, groupBy=$aggFromMap.values->last().columns));
                );

   let newSelect2 = if ($operation.currentTreeNode->isEmpty(),
                      |$select,
                      |let nodeToCut = $operation.currentTreeNode->toOne()->findNode($operation.select.data->toOne(), $select.data->toOne())->toOne();
                       if ($nodeToCut->children()->isEmpty(),
                           |$select,
                           |let withSelfJoinResult = $select->addSelfJoin($nodeToCut, $select.columns->map(q|$q->buildUniqueName(false, $extensions))->makeString('_'), $extensions);
                            let withSelfJoin = $withSelfJoinResult.first;
                            let newNodeCut = $nodeToCut->findNode($select.data->toOne(), $withSelfJoin.data->toOne())->toOne();
                            let newNodeCutChild = $newNodeCut->children()->at(0);
                            let res = ^$withSelfJoin(groupBy=$withSelfJoin.groupBy->map(g|$g->reprocessAliases(^OldAliasToNewAlias(first=$newNodeCut.alias.name, second=$newNodeCutChild.alias->toOne()))));
                            let newNode = $nodeToCut->findNode($select.data->toOne(), $res.data->toOne())->map(x|$x->children())->at(0);
                            $res->buildCorrelatedSubQuery($newNode->cast(@JoinTreeNode)->toOne(), []->cast(@TableAliasColumn), []->cast(@TableAlias), true, $nodeId, false, $newNode->cast(@JoinTreeNode)->toOne(), $state, $extensions).second;
                       );
                    );

   ^$operation(select = $newSelect2,
               currentTreeNode = [],
               positionBeforeLastApplyJoinTreeNode = []
   );
}


function meta::relational::functions::pureToSqlQuery::addSelfJoin(s:SelectSQLQuery[1], j:RelationalTreeNode[1], newJoinName:String[1], extensions:Extension[*]):Pair<SelectSQLQuery, List<Pair<JoinTreeNode, JoinTreeNode>>>[1]
{
   let rootJtn = $j;
   let rootJtnAlias = $rootJtn.alias;

   let rootJtnAliasTable = $rootJtnAlias.relationalElement->match([t:Table[1]| pair($t.schema.database, ^List<Column>(values=$t.primaryKey)),
                                                                   u:Union[1]| let mt = $u.queries.data.alias.relationalElement->cast(@Table);
                                                                               pair($mt.schema.database->at(0), ^List<Column>(values=$u.queries.columns->cast(@Alias)->filter(a|$a.relationalElement->instanceOf(TableAliasColumn) && $mt.primaryKey->contains($a.relationalElement->cast(@TableAliasColumn).column))->map(a|let col = $a.relationalElement->cast(@TableAliasColumn).column; ^$col(name=$a.name);)));,
                                                                   select:SelectSQLQuery[1]| assert($select.data.alias.relationalElement->toOne()->instanceOf(Table), 'Add self Join is supported with SelectSQLQuery only when main relationalElement is Table');
                                                                                             let mt = $select.data.alias.relationalElement->cast(@Table);
                                                                                             pair($mt.schema.database->at(0), ^List<Column>(values=$select.columns->cast(@Alias)->filter(a|$a.relationalElement->instanceOf(TableAliasColumn) && $mt.primaryKey->contains($a.relationalElement->cast(@TableAliasColumn).column))->map(a|let col = $a.relationalElement->cast(@TableAliasColumn).column; ^$col(name=$a.name);)));
                                                               ]);

   let rootJtnAliasTablePks = $rootJtnAliasTable.second.values;
   let database = $rootJtnAliasTable.first;

   let genAliasSuffix = $rootJtn->match([
      root: RootJoinTreeNode[1] | $root,
      join: JoinTreeNode[1]     | ^RootJoinTreeNode(alias = ^TableAlias(name = 'fakeRoot', relationalElement = ^NamedRelation(name = 'fakeRoot')), childrenData = $join)
   ])->buildUniqueName(false, $extensions);

   let genJtnAliasName='gen_'+$genAliasSuffix;
   let genJtnAlias=^$rootJtnAlias(name=$genJtnAliasName);

   let oldAndNewReprocessedJoinJtns = $j->children()->cast(@JoinTreeNode)->map(c|
      let join = $c.join;
      let oldToNewAlias = ^OldAliasToNewAlias(first=$rootJtnAlias.name, second=$genJtnAlias);
      let reprocessedJoinOp = $join.operation->map(o|$o->reprocessAliases($oldToNewAlias))->cast(@Operation);
      let reprocessedJoin = ^$join(operation=$reprocessedJoinOp, aliases=$join.aliases->map(a|pair($a.first->reprocessAliases($oldToNewAlias)->cast(@TableAlias)->toOne(),$a.second->reprocessAliases($oldToNewAlias)->cast(@TableAlias)->toOne())));
      let reprocessedAlias = if($c.alias.relationalElement->instanceOf(SemiStructuredArrayFlatten), | let alias = $c.alias; ^$alias(relationalElement = $alias.relationalElement->reprocessAliases($oldToNewAlias));, | $c.alias);
      pair($c,^$c(join=$reprocessedJoin, alias = $reprocessedAlias));
   );
   let reprocessedJoinJtns = $oldAndNewReprocessedJoinJtns.second;

   let joinTreeNodeName = 'gen_'+$genJtnAlias->buildUniqueName(false, $extensions);
   let nonIsoJoinName = $joinTreeNodeName + $newJoinName;

   let rootToGenJoinOperation = $rootJtnAlias.relationalElement->match([t:Table[1]| meta::relational::functions::pureToSqlQuery::andFilters_RelationalOperationElement_MANY__Extension_MANY__RelationalOperationElement_$0_1$_,
                                                                        u:Union[1]| meta::relational::functions::pureToSqlQuery::orFilters_RelationalOperationElement_MANY__Extension_MANY__RelationalOperationElement_$0_1$_,
                                                                        select:SelectSQLQuery[1]| meta::relational::functions::pureToSqlQuery::andFilters_RelationalOperationElement_MANY__Extension_MANY__RelationalOperationElement_$0_1$_]);


   let rootJtnToGenJtnSelfJoinOp = $rootToGenJoinOperation->eval($rootJtnAliasTablePks->map(c|^DynaFunction(name = 'equal', parameters=[^TableAliasColumn(alias=$rootJtnAlias, column=$c), ^TableAliasColumn(alias=$genJtnAlias, column=$c)])), $extensions);

   let rootJtnToGenJtnJoin = ^Join(name=$nonIsoJoinName, target=$genJtnAlias, aliases=[pair($rootJtnAlias,$genJtnAlias),pair($genJtnAlias,$rootJtnAlias)],operation=$rootJtnToGenJtnSelfJoinOp->cast(@Operation)->toOne());
   let rootJtnToGenJtnJoinTreeNode = ^JoinTreeNode(childrenData=$reprocessedJoinJtns, joinName=$joinTreeNodeName, database=$database, alias=$genJtnAlias, join=$rootJtnToGenJtnJoin, joinType=JoinType.LEFT_OUTER);
   let rootJtnWithGenChildJtn = ^$rootJtn(childrenData=$rootJtnToGenJtnJoinTreeNode);

   let newSelect = ^$s(data=$s.data->toOne()->replaceTreeNode($j, $rootJtnWithGenChildJtn)->cast(@RootJoinTreeNode));

   pair($newSelect, ^List<Pair<JoinTreeNode, JoinTreeNode>>(values = $oldAndNewReprocessedJoinJtns));
}


function meta::relational::functions::pureToSqlQuery::processIsEmpty(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processEmpty($f, true, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)
}

function meta::relational::functions::pureToSqlQuery::processIsNotEmpty(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processEmpty($f, false, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)
}

function meta::relational::functions::pureToSqlQuery::processEmpty(f:FunctionExpression[1],not:Boolean[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let param = $f.parametersValues->at(0);
   $param->byPassRouterInfo()->match(
      [
         fe:FunctionExpression[1] |
            $fe.genericType.rawType->match(
                  [
                     d:DataType[1]| $f->processSubEmpty($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);
                     ,c:Class<Any>[1] | processExists($f, $not, $currentPropertyMapping, $operation, $vars, $state, $nodeId, $aggFromMap, $context, $extensions)
                  ]
            )
        ,a:Any[1] | $f->processSubEmpty($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);
      ]
   );
}

function meta::relational::functions::pureToSqlQuery::findFunctionSequenceMultiplicity(v:ValueSpecification[1]):Pair<FunctionExpression,Multiplicity>[*]
{
   let toMultiplicity = {fe: FunctionExpression[*] | let v = $fe->evaluateAndDeactivate()->last()->cast(@FunctionExpression); if(!$v.resolvedMultiplicityParameters->isEmpty(),|$v.resolvedMultiplicityParameters,| $v.multiplicity)->toOne();};

   $v->match([ fe:FunctionExpression[1]| $fe.func->match([qp:QualifiedProperty<Any>[1]| $qp.expressionSequence->at(0)->findFunctionSequenceMultiplicity()
                                                         ,a:Any[1]|pair($fe, $toMultiplicity->eval($fe))])
                                                  ->concatenate(if($fe.parametersValues->size() > 0,| $fe.parametersValues->at(0)->findFunctionSequenceMultiplicity(),|[]));,
               e:StoreMappingRoutedValueSpecification[1]|$e->byPassRouterInfo()->findFunctionSequenceMultiplicity(),
               a:Any[1]|[]
             ]);
}


function meta::relational::functions::pureToSqlQuery::expressionSequenceReturnsAtLeastToOneDataType(v:ValueSpecification[1]):Boolean[1]
{
  let isToOne = {fs:Pair<FunctionExpression,Multiplicity>[*]|let funs = if($fs->head().first.func == map_T_m__Function_1__V_m_  || $fs->head().first.func == map_T_MANY__Function_1__V_MANY_
                                                                          ,|$fs ,|$fs->tail());
                                                             $funs->map(p|pair(if($p.first.func->instanceOf(NativeFunction),|$p.first.func.functionName,|'')->toOne(), $p.second))->fold({fm, a| pair($fm.first, ($a.first->in(['toOne','toOneMany']) || (getLowerBound($fm.second) >= 1)) && $a.second)}, pair('',true));
                 };

  $v->match([i :InstanceValue[1] | $i.multiplicity->getLowerBound() >= 1; ,
             ve:VariableExpression[1] | $ve.multiplicity->getLowerBound() >= 1;,
             v: ValueSpecification[1] | $isToOne->eval(findFunctionSequenceMultiplicity($v)->evaluateAndDeactivate()).second;
           ]);
}

function meta::relational::functions::pureToSqlQuery::processIsEmptyOnPlanVar(v:VariableExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   assert(!$v.genericType.rawType->toOne()->instanceOf(Class), | 'IsEmpty null checks should only occur on DataTypes, Variable Expression: ' + $v.name + ' does not contain a datatype value');
   let sqlQuery = $v->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->extractSelectSQLQuery()->mergeSQLQueryData($nodeId, $state, $context, $extensions);
   let columns = $state.inFilter->if(|$sqlQuery.filteringOperation, |$sqlQuery.columns);
   assertNotEmpty($columns, 'Error, no columns found when processing IsEmpty or IsNotEmpty');

   let res = ^DynaFunction(name = 'equal',
                           parameters = [^FreeMarkerOperationHolder(name = 'variableCollectionSize',
                                                                    parameters = [$columns]),
                                         ^Literal(value = 0)]);
   ^$operation(
      select = $state.inFilter->if(
         | ^$sqlQuery(filteringOperation = $res);,
         | ^$sqlQuery(columns = $res);
      ),
      currentTreeNode = [],
      positionBeforeLastApplyJoinTreeNode = []
   );
}

function meta::relational::functions::pureToSqlQuery::isParamPlanVar(param:ValueSpecification[1], vars:Map<VariableExpression, ValueSpecification>[1], openVars:Map<String, List<Any>>[1]):Boolean[1]
{
   if($param->instanceOf(VariableExpression),
      |let resolvedVar = $param->cast(@VariableExpression)->resolve($vars, $openVars)->evaluateAndDeactivate();
      if(!$resolvedVar->isEmpty() && $resolvedVar->toOne()->instanceOf(InstanceValue) && $resolvedVar->cast(@InstanceValue).values->size() == 1
         && $resolvedVar->cast(@InstanceValue).values->toOne()->instanceOf(PlanVarPlaceHolder),
         |true,
         |false);,
      |false)
}

function meta::relational::functions::pureToSqlQuery::processSubEmpty(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let parameters = $f.parametersValues->at(0);
   let isParameterPlanVarOfTypeList = isParamPlanVar($parameters, $vars, $state.inScopeVars) && $parameters.multiplicity == ZeroMany;

   let isEmptyExpressionValid = $parameters->match([v:FunctionExpression[1]| $v.func == map_T_m__Function_1__V_m_  || $v.func == map_T_MANY__Function_1__V_MANY_ || !$v.genericType.rawType->toOne()->instanceOf(Class);,
                                                    a:Any[1]| true;]);


   assert($isEmptyExpressionValid, | 'IsEmpty null checks should only occur on DataTypes, function: '+$parameters->asString()+' does not return a DataType');

   if($isParameterPlanVarOfTypeList,
      |processIsEmptyOnPlanVar($parameters->cast(@VariableExpression), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions),
      |
      let mergedSQL = if($state.inFilter
                         && !expressionSequenceReturnsAtLeastToOneDataType($parameters)
                         ,| let forcedIsolationContext = ^RelationalDebugContext(forcedIsolation=IsolationStrategy.MoveFilterInOnClause, space=$context.space, debug=$context.debug);
                         let isolatedIsEmptyState = ^$state(inIsolatedIsEmpty=true);
                         let processedParams = $f.parametersValues->map(pv|$pv->processValueSpecification($currentPropertyMapping, $operation, $vars, $isolatedIsEmptyState, $joinType, $nodeId, $aggFromMap, $forcedIsolationContext, $extensions))->map(x | extractSelectSQLQuery($x));
                         $processedParams->mergeSQLQueryData($nodeId, $isolatedIsEmptyState, $forcedIsolationContext, $extensions);
                         ,| let processedParams = $f.parametersValues->map(pv|$pv->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions))->map(x | extractSelectSQLQuery($x));
                         let mergedSql = $processedParams->mergeSQLQueryData($nodeId, $state, $context, $extensions);
                      );

      let columns = $state.inFilter->if(|$mergedSQL.filteringOperation, |$mergedSQL.columns);
      assertNotEmpty($columns, 'Error, no columns found when processing IsEmpty or IsNotEmpty');
      ^$operation(
            select = $state.inFilter->if(
                                    | ^$mergedSQL(filteringOperation = newDynaFunction($f.func.functionName->toOne(), $columns));,
                                    | ^$mergedSQL(columns = newDynaFunction($f.func.functionName->toOne(), $columns));
                                  ),
            currentTreeNode = [],
            positionBeforeLastApplyJoinTreeNode = []
      );
   );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::isIfForEnum(f:FunctionExpression[1], inFilter:Boolean[1]):Boolean[1]
{
   $f.func.functionName->toOne()=='if' && !$inFilter && $f.genericType.rawType->toOne()->instanceOf(Enumeration)
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::processIfForEnum(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):Pair<List<RelationalOperationElement>,meta::pure::metamodel::function::Function<{RelationalOperationElement[1]->RelationalOperationElement[1]}>>[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'Processing "if for enum"\n'));

   let execSides = $f.parametersValues->tail()->map(p|pair($p,$p->byPassRouterInfo()->cast(@InstanceValue).values->cast(@LambdaFunction<Any>)->toOne()));
   let propertyMappings = $execSides.second.expressionSequence->map(e|
                                                               let classPropertyPair = $e->findPropertySequence()->first();
                                                               if(!$classPropertyPair->isEmpty(),| let class = $classPropertyPair.first;
                                                                                                   let propertyName = $classPropertyPair.second.name->toOne();
                                                                                                   let classMapping = $state.mapping->_classMappingByClass($class->toOne());
                                                                                                   $classMapping->cast(@PropertyMappingsImplementation)->map(x|$x->_propertyMappingsByPropertyName($propertyName));
                                                                                                ,|[]);
                                                             );

   let distinctTransformers = $propertyMappings->filter(m|$m->instanceOf(RelationalPropertyMapping))->cast(@RelationalPropertyMapping).transformer->distinct();
   let semiStructuredMappings = $propertyMappings->filter(m|$m->instanceOf(RelationalPropertyMapping))->forAll(x|$x->instanceOf(SemiStructuredRelationalPropertyMapping));

   assertFalse($distinctTransformers->size() > 1, 'Unable to determine a unique Enum property mapping for an if stmt (returning an Enum)');
   if ($semiStructuredMappings,
       | print(if(!$context.debug, |'', |$context.space+'  Ignoring distinct transformer check as all property mappings are semi structured property mappings\n'));,
       | assertFalse($distinctTransformers->isEmpty(), 'Unable to determine the Enum property mapping for an if stmt (returning an Enum)');
   );

   print(if(!$context.debug, |'',
            | $context.space+'  Found '+$distinctTransformers->size()->toString()+' distinct transformers\n'));

   let foundEnumPropertyMapping = $propertyMappings->at(0);
   let isEnumConstantSide = {l:LambdaFunction<Any>[1] |
         $l.expressionSequence->match([
            sfe : SimpleFunctionExpression[1]| $sfe.func == extractEnumValue_Enumeration_1__String_1__T_1_,
            iv : InstanceValue[1]|$iv.values->size() == 1 && $iv.values->toOne()->instanceOf(Enum),
            vs:ValueSpecification[*]|false
            ]);
         };

   let pred = $f.parametersValues->at(0)->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions);
   let sides = $execSides->map(s|$s.first->processValueSpecification(if($isEnumConstantSide->eval($s.second),
                                                                        |print(if(!$context.debug, |'', | $context.space+'  Enum in if is a constant\n'));
                                                                         $foundEnumPropertyMapping;,
                                                                        |print(if(!$context.debug, |'', | $context.space+'  Enum in if is NOT a constant\n'));
                                                                         $currentPropertyMapping;
                                                                     ), $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions));
   pair(^List<RelationalOperationElement>(values=$pred->concatenate($sides)),{r:RelationalOperationElement[1]|^OperationWithParentPropertyMapping(element=$r, currentPropertyMapping=$foundEnumPropertyMapping)});
}

function meta::relational::functions::pureToSqlQuery::moveExtraFilterToFilter(s:SelectWithCursor[1], extensions:Extension[*]):SelectWithCursor[1]
{
   ^$s(select=$s.select->moveExtraFilterToFilter($extensions));
}

function meta::relational::functions::pureToSqlQuery::moveExtraFilterToFilter(s:SelectSQLQuery[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   let filters = $s.filteringOperation->concatenate($s.extraFilteringOperation);
   ^$s(
         extraFilteringOperation=[],
         filteringOperation = if ($filters->size() > 1,|^DynaFunction(name = 'group', parameters = $filters->andFilters($extensions)->toOne()),|$filters)
   );
}

function meta::relational::functions::pureToSqlQuery::processDynaFunction(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let isIfTrueFalseStmt = $f.func == if_Boolean_1__Function_1__Function_1__T_m_ || $state.inIf == true;
   let paramIsIfTrueFalseStmt = {paramIndex:Integer[1]|$state.inIf == true && $paramIndex->in([1,2])};

   let processedParams = if($f->isIfForEnum($state.inFilter),| processIfForEnum($f, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)
                                                            ,| let zippedParameters = $f.parametersValues->size()->range()->zip($f.parametersValues);
                                                               pair(^List<RelationalOperationElement>(values=$zippedParameters->map(pv| let updatedState = if($paramIsIfTrueFalseStmt->eval($pv.first),|^$state(inIfTrueFalseStmt=true),|$state);
                                                                                                                                        $pv.second->processValueSpecification($currentPropertyMapping, $operation, $vars, $updatedState, $joinType, buildNodeId($nodeId,'_dy'+$pv.first->toString()), $aggFromMap, $context, $extensions);)),{res:RelationalOperationElement[1]|$res}););

   let parameterSQL = $processedParams.first.values->map(x | extractSelectSQLQuery($x));//$f.parametersValues->map(pv|$pv->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context))->map(x | extractSelectSQLQuery($x));

   let mergedSQL = if ($parameterSQL->isEmpty(),
                     | $operation.select,
                     | let sqls = if ($parameterSQL->size() > 1,
                           | let zippedParameterSQLs = $parameterSQL->size()->range()->zip($parameterSQL);
                             $zippedParameterSQLs->map(s| let updatedState = if($isIfTrueFalseStmt,|^$state(inIfTrueFalseStmt=true, shouldIsolate=true),|^$state(shouldIsolate=true));
                                                          $s.second->manageIsolation([], [],  $nodeId, false, $updatedState, $context, $extensions););,
                           | $parameterSQL
                       );
                       let nsqls =
                                     if($f.func.functionName->toOne() != 'or',
                                       |$sqls,
                                       |$sqls->map(s|$s->moveExtraFilterToFilter($extensions))
                                     );
                       $nsqls->mergeSQLQueryData($nodeId, $state, $context, $extensions);
               );

   let res = ^$operation(select = $state.inFilter->if(
                           | let unSupportedBiTemporalProcessing = $mergedSQL.filteringOperation->isEmpty() && $operation.milestoningContext->isNotEmpty() && $operation.milestoningContext->toOne()->isBiTemporalMilestoningTopLevelAnd($f.func);
                             if($unSupportedBiTemporalProcessing ,| $mergedSQL
                                                                 ,| ^$mergedSQL(filteringOperation = newDynaFunction($f.func.functionName->toOne(), if($parameterSQL->isEmpty(), | [], |$mergedSQL.filteringOperation))));,
                           | ^$mergedSQL
                             (
                                columns = newDynaFunction($f.func.functionName->toOne(), $mergedSQL.columns)
                             )
                        ),
                        currentTreeNode = [],
                        positionBeforeLastApplyJoinTreeNode = []
                     );

   $processedParams.second->eval($res);
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::newDynaFunction(name: String[1], params: RelationalOperationElement[*]): DynaFunction[1]
{
   if($name->in(['and','or']),
               | newAndOrDynaFunctionWrappedInGroup($name, $params),
               | ^DynaFunction(name = $name, parameters = $params)
     );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::newAndOrDynaFunctionWrappedInGroup(name: String[1], params: RelationalOperationElement[*]): DynaFunction[1]
{
   ^DynaFunction(name = 'group', parameters = ^DynaFunction(name = $name, parameters = $params));
}

function meta::relational::functions::pureToSqlQuery::newAndOrDynaFunctionRelaxedBrackets(funcName: String[1], params: RelationalOperationElement[*]): DynaFunction[1]
{
   let potentiallyWrapedParams = $params->map(p | $p->match([ d: DynaFunction[1] | if($d.name->in(['and','or']) && $d.name != $funcName, | ^DynaFunction(name='group', parameters=$d), | $d),
                                                              r: RelationalOperationElement[1] | $r
                                                            ])
                                              );
   ^DynaFunction(name = $funcName, parameters = $potentiallyWrapedParams);
}

function meta::relational::functions::pureToSqlQuery::extractElement(z:RelationalOperationElement[1]):RelationalOperationElement[1]
{
   $z->match([ j:RelationalOperationElementWithJoin[1] | $j.relationalOperationElement,
               r:RelationalOperationElement[1] | $r
            ])->toOne()
}

function meta::relational::functions::pureToSqlQuery::processGetAllForEachDate(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let setImplementation = $expression.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne();
   let mappingOwner = $expression.parametersValues->at(1)->cast(@StoreMappingRoutedValueSpecification).sets->toOne();
   let swc1 = processGetAll($expression, $setImplementation, [], $nodeId, $state, $vars, $context, $extensions)->cast(@SelectWithCursor);
   let swc2 = processValueSpecification($expression.parametersValues->at(1), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let query1 = $swc1.select->pushExtraFilteringOperation($extensions)->pushSavedFilteringOperation($extensions);
   let query2 = $swc2.select->pushExtraFilteringOperation($extensions)->pushSavedFilteringOperation($extensions);
   let data = $query2.data->toOne();

   //alias for both the queries for join
   let alias = $data.alias;
   let rightAlias = $query1.data.alias;
   let leftAlias = ^TableAlias(name='"joinleft_"'+$nodeId, relationalElement=$query2);
   let dateRange = $query2.columns->reprocessAliases(^OldAliasToNewAlias(first = $alias.name, second = $leftAlias));
   
   // join operation condition
   let milestoningContext = getMilestoningContextForAll($expression,$setImplementation, $expression.parametersValues, $state, $vars, $context, $extensions);
   let strategy = $milestoningContext.currentMilestoningStrategy->at(0);
   let table = $rightAlias->toOne().relationalElement->cast(@Table);
   let milestoneColumns = getTemporalMilestoneColumns($rightAlias->toOne(), $strategy);
   let inclusive = $strategy->getInclusive($table);
   let temporalFrom = if($inclusive,|^DynaFunction(name = 'lessThan', parameters=[$milestoneColumns->at(0), $dateRange->toOne()]),|^DynaFunction(name = 'lessThanEqual', parameters=[$milestoneColumns->at(0), $dateRange->toOne()]));
   let temporalThru = if($inclusive,|^DynaFunction(name = 'greaterThanEqual', parameters=[$milestoneColumns->at(1), $dateRange->toOne()]),|^DynaFunction(name = 'greaterThan', parameters=[$milestoneColumns->at(1), $dateRange->toOne()]));
   let joinOp = newAndOrDynaFunctionRelaxedBrackets('and', [$temporalFrom,$temporalThru]);
   
   //propogating and mapping business date in milestoningContext
   let mapColumn = $dateRange->cast(@TableAliasColumn);
   let thisMilestoning = $milestoningContext->toOne();
   let newMappedColumn = ^TableAliasColumn(alias = $mapColumn.alias->toOne(),column = $mapColumn.column->toOne(), setMappingOwner = $mappingOwner->cast(@PropertyMappingsImplementation));
   let newMilestoningContext = $strategy->match([ b:BusinessTemporal[1] | ^$thisMilestoning(businessDate = $newMappedColumn),
                                                  p:ProcessingTemporal[1] | ^$thisMilestoning(processingDate = $newMappedColumn)]);

   //final join
   let join = ^Join(name='join', target= $leftAlias,aliases=[pair($leftAlias,$rightAlias->toOne()),pair($rightAlias->toOne(), $leftAlias)], operation=$joinOp->toOne());
   let child = ^JoinTreeNode(alias=$rightAlias->toOne(), join=$join, joinType=$joinType, database=^Database(), joinName='join');
   let root = ^RootJoinTreeNode(alias=$leftAlias, childrenData=$child);
   ^$swc2(
      select = ^SelectSQLQuery(
      data = $root,
      filteringOperation = $query1.filteringOperation
         ),
       currentTreeNode = $child,
       savedRoot = pair($root,$child),
       milestoningContext = $newMilestoningContext
       );
}

function meta::relational::functions::pureToSqlQuery::processGetAll(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let setImplementation = $expression.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne();
   processGetAll($expression, $setImplementation, $expression.parametersValues, $nodeId, $state, $vars, $context, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processGetAll(expression: FunctionExpression[1], setImplementation:SetImplementation[1], parameters:ValueSpecification[*], nodeId:String[1], state:State[1], vars:Map<VariableExpression, ValueSpecification>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let processRootSetImpl = {r:RootRelationalInstanceSetImplementation[1] |let milestoningContext = getMilestoningContextForAll($expression,$r, $parameters, $state, $vars, $context, $extensions);
                                                                           processGetAll($r, $r.class, $nodeId, true, -1, !$state.inProject, $milestoningContext, $state, $context, $extensions);};

   $setImplementation->match([r:RootRelationalInstanceSetImplementation[1]| $processRootSetImpl->eval($r),
                              r:meta::pure::router::clustering::CrossSetImplementation[1]| let newTable = ^VarCrossSetPlaceHolder(varName=$r.varName, name=$r.varName, schema=^Schema(name='default', database=^Database()), crossSetImplementation = $r);
                                                                                           let treeNode = ^RootJoinTreeNode(alias = ^TableAlias(name = 'root', relationalElement = $newTable));
                                                                                           ^SelectWithCursor(select = ^SelectSQLQuery(data = $treeNode), currentTreeNode = $treeNode);,
                              o:OperationSetImplementation[1]|let setImpls = $o->resolveOperation($state.mapping)->cast(@RootRelationalInstanceSetImplementation);
                                                              if($setImpls->size()==1,| $processRootSetImpl->eval($setImpls->at(0))
                                                                                     ,| let milestoningContext = getMilestoningContextForAll($expression,$o, $parameters, $state, $vars, $context, $extensions);
                                                                                        let union = buildUnion($setImpls, [], false, $state.inProject, $milestoningContext, $nodeId, $state, $context, $extensions);
                                                                                        let propMap = $setImpls->at(0)->cast(@RelationalInstanceSetImplementation)->dataTypePropertyMappings();
                                                                                        let newRoot = ^RootJoinTreeNode(alias = ^TableAlias(name='unionBase', relationalElement=$union));
                                                                                        let fullCols = $union.queries->at(0).columns->cast(@Alias).name->filter(n | $n != 'u_type');
                                                                                        ^SelectWithCursor( select = ^SelectSQLQuery( columns = ^Alias(name= 'u_type', relationalElement = ^TableAliasColumn(alias = $newRoot.alias, column = ^Column(name='u_type', type=^meta::relational::metamodel::datatype::Integer())))
                                                                                                                                               ->concatenate($fullCols->map(p|^Alias(name=$p, relationalElement =^TableAliasColumn(alias = $newRoot.alias, column = ^Column(name=$p, type=^meta::relational::metamodel::datatype::Integer()))))),
                                                                                                                                     data = $newRoot,
                                                                                                                                     filteringOperation = []
                                                                                                                                   ),
                                                                                                           currentTreeNode = $newRoot,
                                                                                                           milestoningContext=$milestoningContext);
                                                                                      );
                           ]);
}


function meta::relational::functions::pureToSqlQuery::getAllExpressionSetImplementations(expression:FunctionExpression[1]):RootRelationalInstanceSetImplementation[*]
{
   let setImplementation = $expression.parametersValues->at(0)->cast(@StoreMappingRoutedValueSpecification).sets->toOne();
   $setImplementation->match(
                           [
                              r:RootRelationalInstanceSetImplementation[1]|$r,
                              e:EmbeddedRelationalInstanceSetImplementation[1]|$e.setMappingOwner,
                              o:OperationSetImplementation[1]|$o->resolveOperation($setImplementation.parent)->cast(@RootRelationalInstanceSetImplementation);
                           ]
                       );
}

function meta::relational::functions::pureToSqlQuery::rebuildSelectWithCursor(name:String[0..1], suffix:String[0..1], newQuery: SelectWithCursor[1], quotes:Boolean[1]):SelectWithCursor[1]
{
   let newName = if($name->isEmpty(),
                    |$newQuery.select.columns->toOne()->cast(@TableAliasColumn).column.name,
                    |$name->toOne()
                 )+
                 if($suffix->isEmpty(),
                    |'',
                    |'_'+$suffix->toOne()
                 );
   ^SelectWithCursor(
      select = ^SelectSQLQuery(
                     columns = ^Alias(name = if($quotes,
                                                |'"'+$newName+'"',
                                                |$newName
                                             ),
                                      relationalElement = $newQuery.select.columns->toOne()
                               ),
                     data = $newQuery.select.data,
                     filteringOperation = [],
                     extraFilteringOperation=$newQuery.select.extraFilteringOperation
               ),
      currentTreeNode = $newQuery.select.data
   );
}

function meta::relational::functions::pureToSqlQuery::removeQuotes(s:String[1]):String[1]
{
   if ($s->startsWith('"'),|$s->substring(1,$s->length()-1),|$s);
}

function meta::relational::functions::pureToSqlQuery::getRelationalElementWithInnerJoin(viewSpecification:RelationalMappingSpecification[1], mainTable: RelationalOperationElement[1], c:Class<Any>[0..1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   let innerQueryRoot = ^RootJoinTreeNode(alias=^TableAlias(name = 'root', relationalElement = $mainTable));
   let innerQueryBase = ^SelectWithCursor(select = ^SelectSQLQuery(data = $innerQueryRoot), currentTreeNode = $innerQueryRoot);
   let filterApplied  = $innerQueryBase->applyTypeFilter($viewSpecification, $nodeId, $state, $context, $extensions).select->pushSavedFilteringOperation($extensions);
   let withFilterRoot = $filterApplied.data->toOne();
   ^$filterApplied
   (
      columns = $viewSpecification->mainRelation().columns->cast(@Column)->map({c |
         ^Alias(name = $c.name, relationalElement = ^TableAliasColumn(alias = $withFilterRoot.alias, column = $c))
      }),
      preIsolationCurrentTreeNode = $withFilterRoot
   );
}

function meta::relational::functions::pureToSqlQuery::processGetAll(viewSpecification:RelationalMappingSpecification[1], c:Class<Any>[0..1], nodeId:String[1], addPk:Boolean[1], pkOffset:Integer[1], addAllColumns:Boolean[1], milestoningContext: TemporalMilestoningContext[0..1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let newState = ^$state(inProject=false, inProjectFunctions=false, processingProjectionThread=false, shouldIsolate=false, inFilter=false);
   processRelationalMappingSpecification($viewSpecification, $c, $nodeId, $addPk, $pkOffset, $addAllColumns, $milestoningContext, $newState, $context, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processRelationalMappingSpecification(viewSpecification:RelationalMappingSpecification[1], c:Class<Any>[0..1], nodeId:String[1], addPk:Boolean[1], pkOffset:Integer[1], addAllColumns:Boolean[1], milestoningContext: TemporalMilestoningContext[0..1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let mainTable = $viewSpecification->mainRelation()->processRelation($c, $nodeId, $addPk, $pkOffset, $addAllColumns, $milestoningContext, $state, $context, $extensions);

   let innerJoinFilterExists = $viewSpecification->getFilter().joinTreeNode.joinType == JoinType.INNER;
   let currentRelationalElement = if ($innerJoinFilterExists,
                                      | getRelationalElementWithInnerJoin($viewSpecification, $mainTable, $c, $nodeId, $state, $context, $extensions),
                                      | $mainTable
                                  );

   let currentNode = ^RootJoinTreeNode(alias=^TableAlias(name = 'root', relationalElement = $currentRelationalElement));

   let base = ^SelectWithCursor(
      select = ^SelectSQLQuery(
                      data = $currentNode
                  ),
      currentTreeNode = $currentNode
   );

   let quoteColumnAliases = shouldQuoteColumnAliases($viewSpecification);
   let requiresAllProperties = ($addAllColumns || (!$viewSpecification->getGroupBy()->isEmpty()) || ($viewSpecification->getDistinct()->toOne()));

   let properties = if($requiresAllProperties, | columnNamesWithRelationalElement($viewSpecification, $c, $state)->map(c | let newQuery = $c.second->processColumnsInRelationalOperationElements($state, $base, $nodeId, ^List<ColumnGroup>(), false, $context, $extensions);
                                                                                                           rebuildSelectWithCursor($c.first, [], $newQuery, $quoteColumnAliases);)
                                             , | [] );

   let pks = if($addPk && $viewSpecification->getGroupBy()->isEmpty() && ($viewSpecification->getDistinct()->isEmpty() || $viewSpecification->getDistinct()->toOne() == false),
                  | let pks = viewSpecificationPrimaryKey($viewSpecification);
                    $pks->map(pm|let offset = $pks->indexOf($pm);
                                 let newQuery = $pm->processColumnsInRelationalOperationElements($state, $base, $nodeId, ^List<ColumnGroup>(), false, $context, $extensions);
                                 if($state.importDataFlow == true,
                                    |rebuildSelectWithCursor([], if($pkOffset == -1,
                                                                    |if($state.importDataFlowCurrentSetOffsetInUnion->isEmpty() || $state.importDataFlowImplementationCount == 1,
                                                                        |[],
                                                                        |$state.importDataFlowCurrentSetOffsetInUnion->toOne()->toString()
                                                                     ),
                                                                    |$pkOffset->toString()
                                                                 ), $newQuery, $quoteColumnAliases),
                                    |rebuildSelectWithCursor('pk_'+$offset->toString(), if($pkOffset == -1,|[],|$pkOffset->toString()), $newQuery, $quoteColumnAliases)
                                 );
                          );,
                  | $base
               );

   let groupByQuery = $base->applyGroupBy($viewSpecification, $nodeId);

   let filterQuery = if ($innerJoinFilterExists, | $groupByQuery, | $groupByQuery->applyTypeFilter($viewSpecification, $nodeId, $state, $context, $extensions));

   // TODO: Ideally, should try to isolate pk & property queries in all cases. Restrict to graphFetch flow for now
   let pksAndProperties = if ($state.graphFetchFlow == true,
                              | $pks->concatenate($properties).select->mergeSQLQueryData($nodeId, ^$state(shouldIsolate=true), $context, $extensions),
                              | $pks->concatenate($properties).select
                          );

   let merged = $pksAndProperties->concatenate($filterQuery.select)->mergeSQLQueryData($nodeId, $state, $context, $extensions);
   let fks = if ($viewSpecification->getDistinct() == true && !$viewSpecification->instanceOf(View),
                     | collectAdditionalJoinColumnsForSource($viewSpecification, $state.mapping,  $merged.data->toOne(), $merged.columns->cast(@Alias)),
                     | if ($state.importDataFlowAddFks == true,
                           |$state.importDataFlowFksByTable->toOne()->get($mainTable).values->map(c|^Alias(name=$c.name, relationalElement=^TableAliasColumn(alias=$merged.data.alias->toOne(), columnName=$c.name, column=$c))),
                           |[]
                       )
                 );

   let addedFks = if ($state.importDataFlowAddFks == true, |$fks->map(a|^$a(name='fk_'+$a.name)), |$fks);

   let s = ^SelectWithCursor(
      select = ^SelectSQLQuery(
                  distinct = $viewSpecification->getDistinct(),
                  columns = $merged.columns->concatenate($addedFks),
                  data = $merged.data,
                  filteringOperation = $merged.filteringOperation,
                  savedFilteringOperation = $merged.savedFilteringOperation,
                  extraFilteringOperation = $merged.extraFilteringOperation,
                  groupBy = $merged.groupBy
               ),
      currentTreeNode = $merged.data
   );

   if(!$milestoningContext->isEmpty() ,|applyMilestoningTypeFilters($s, $milestoningContext->toOne(), $state, $innerJoinFilterExists, $extensions),|$s);

}

function meta::relational::functions::pureToSqlQuery::processRelation(r: RelationalOperationElement[1], c:Class<Any>[0..1], nodeId:String[1], addPk:Boolean[1], pkOffset:Integer[1], addAllColumns:Boolean[1], milestoningContext: TemporalMilestoningContext[0..1], state:State[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   $r->match([
               s:SelectSQLQuery[1] | $s,
               t:Table[1] | $t,
               u:Union[1] | $u,
               v:View[1]  | let selectWithCursor = processRelationalMappingSpecification($v, $c, $nodeId, $addPk, $pkOffset, true, $milestoningContext, ^$state(inFilter=false), $context, $extensions);
                            let select = $selectWithCursor.select;
                            let selectWithFiltersProcessed = $select->pushExtraFilteringOperation($extensions)->pushSavedFilteringOperation($extensions);
                            ^ViewSelectSQLQuery(view=$v, name=$v.name, columns = $selectWithFiltersProcessed.columns, selectSQLQuery = $selectWithFiltersProcessed, schema=$v->mainTable().schema);,
               s:SemiStructuredArrayFlatten[1] | $s
             ]);
}

function meta::relational::functions::pureToSqlQuery::applyMilestoningTypeFilters(select: SelectWithCursor[1], milestoningContext: TemporalMilestoningContext[1], state:State[1], innerJoinFilterExists: Boolean[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let query = $select.select;
   let milestoningStrategy = $milestoningContext.currentMilestoningStrategy->toOne();
   let nestedRoot = $select.alias.relationalElement->toOne()->instanceOf(SelectSQLQuery);
   if(!$milestoningContext.isAllVersions() && !$milestoningContext.isAllForEachDate() && if($nestedRoot && $innerJoinFilterExists ,| $select.alias.relationalElement->toOne()->cast(@SelectSQLQuery).data.alias.relationalElement->toOne()->relationalElementIsMilestoned(),|$select.alias.relationalElement->toOne()->relationalElementIsMilestoned())
      ,|
         let tableFilter = $milestoningStrategy->getAllMilestonedTableFilter($query, $milestoningContext, $state.inScopeVars, $extensions);
         let queryWithMilestoningFilters = $query->applyMilestoningFilters($tableFilter, getTableToTableIdentifyFunction(), true, $extensions)->cast(@SelectSQLQuery);
         let newSavedFilteringOperation = $query.savedFilteringOperation->map(s|let newNode=$s.first->findNode($query.data->toOne(), $queryWithMilestoningFilters.data->toOne());pair($newNode->toOne(),$s.second););
         let queryWithMilestoningColumns = ^$queryWithMilestoningFilters(columns+=$milestoningContext.columns($query.data.alias.relationalElement->toOne()->findMainTable()), savedFilteringOperation=$newSavedFilteringOperation);
         ^$select(select=$queryWithMilestoningColumns, currentTreeNode=$queryWithMilestoningColumns.data, milestoningContext=^$milestoningContext(currentProcessingState=[]));
      ,| let selectWithTemporalColumns = ^$query(columns+=$milestoningContext.columns($query.data.alias.relationalElement->toOne()->findMainTable()));
         ^$select(select=$selectWithTemporalColumns, milestoningContext=$milestoningContext););
}

function meta::relational::functions::pureToSqlQuery::relationalmappingspecification::columnNamesWithRelationalElement(vs: RelationalMappingSpecification[1], c:Class<Any>[0..1], state: State[1]):Pair<String, RelationalOperationElement>[*]
{
   $vs->match([
               r:RootRelationalInstanceSetImplementation[1] | $r->dataTypePropertyMappings()
                                                              ->filter(x | if($state.graphFetchFlow == true, | $x.property->in($state.graphFetchProperties), | true))
                                                              ->map(pm|pair($pm.property.name->toOne(),$pm->cast(@RelationalPropertyMapping).relationalOperationElement)),
               v:View[1] | $v.columnMappings->map(cm|pair($cm.columnName, $cm.relationalOperationElement));
              ]);
}

function meta::relational::functions::pureToSqlQuery::relationalmappingspecification::viewSpecificationPrimaryKey(vs: RelationalMappingSpecification[1]):RelationalOperationElement[*]
{
   $vs->match([
                r:RootRelationalInstanceSetImplementation[1] | $r->resolvePrimaryKey(),
                v:View[1] | []
              ]);
}

function meta::relational::functions::pureToSqlQuery::relationalmappingspecification::shouldQuoteColumnAliases(vs: RelationalMappingSpecification[1]):Boolean[1]
{
   $vs->match([
                r:RootRelationalInstanceSetImplementation[1] | true,
                v:View[1] | false
              ]);
}

function meta::relational::functions::pureToSqlQuery::collectAdditionalJoinColumnsForSource(vs:RelationalMappingSpecification[1], mapping:Mapping[1], currentTreeNode:RootJoinTreeNode[1], existingColumns:Alias[*]):Alias[*]
{
   let pms = $vs->match([
               r:RootRelationalInstanceSetImplementation[1] |
                     let relationalPropertyMappings = $mapping->classMappings()->filter(c|$c->instanceOf(RootRelationalInstanceSetImplementation))->cast(@RootRelationalInstanceSetImplementation)->map(x|$x->allPropertyMappings())
                     ->filter(pm|$pm->instanceOf(RelationalPropertyMapping) && ($pm.sourceSetImplementationId == $r.id || $pm.targetSetImplementationId == $r.id));
                     let partition = $relationalPropertyMappings->partition(pm|$pm.sourceSetImplementationId == $r.id);
                     let srcOnes = $partition.first.values->cast(@RelationalPropertyMapping).relationalOperationElement->filter(r|$r->instanceOf(RelationalOperationElementWithJoin))->cast(@RelationalOperationElementWithJoin).joinTreeNode;
                     let trgtOnes = $partition.second.values->cast(@RelationalPropertyMapping).relationalOperationElement->filter(r|$r->instanceOf(RelationalOperationElementWithJoin))->cast(@RelationalOperationElementWithJoin).joinTreeNode->map(x|$x->findLastJoinTreeNode())->cast(@JoinTreeNode);
                     $srcOnes->concatenate($trgtOnes);,
               v:View[1] | $v.columnMappings->filter(cm|$cm.relationalOperationElement->instanceOf(RelationalOperationElementWithJoin))->map(cm|$cm.relationalOperationElement)->cast(@RelationalOperationElementWithJoin).joinTreeNode
              ]);


   //todo - this probably isn't good enough to identify the source table?
   let currentTable = $vs->mainTable();
   let currentTableAlias =  $currentTreeNode->getAllNodes()->cast(@RelationalTreeNode)->filter(n|$n.alias.relationalElement==$vs->mainTable())->last()->toOne().alias;

   $pms->map(r | let join = $r.join;
                   let targetAliasInJoin = if (!$join.target->isEmpty(), |$join.target->toOne(), |$join->otherTable($currentTable)->toOne());
                   let sourceAliasInJoin = $join->otherTableFromAlias($targetAliasInJoin)->toOne();

                   let newJoin = reprocessJoin($join->toOne(), [ ^OldAliasToNewAlias(first=$sourceAliasInJoin.name->toOne(), second=$currentTableAlias) ], []);

                   let aliases = $newJoin.operation->extractColumnAliases();
                   let columnAliasesForThisTarget = $aliases->filter(a | $a.relationalElement->cast(@TableAliasColumn).alias == $currentTableAlias);
                   $columnAliasesForThisTarget->filter(c | let existing = $existingColumns->filter(e | $e.relationalElement->instanceOf(TableAliasColumn) && $e.relationalElement->cast(@TableAliasColumn).column.name == $c.relationalElement->cast(@TableAliasColumn).column.name; );
                                                           $existing->isEmpty(););

              )->removeDuplicates();
}

function meta::relational::functions::pureToSqlQuery::applyTypeFilter(base:SelectWithCursor[1], viewSpecification:RelationalMappingSpecification[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
  let filterMapping = $viewSpecification->getFilter();
  if ($filterMapping->isEmpty(),
        | $base,
        | let baseFilterQuery =
              if ($filterMapping->toOne().joinTreeNode->isEmpty(),
                  | $base;
                 ,| applyJoinInTree($base.select.data->toOne(), $base.currentTreeNode->toOne(), $filterMapping->toOne().joinTreeNode->toOne(), $base, $nodeId, JoinType.LEFT_OUTER, true, false, [], $state, $context, $extensions);
               );
          let select = $baseFilterQuery.select;

          let lastNode = $baseFilterQuery.currentTreeNode->toOne()->findLastJoinTreeNode();
          ^$baseFilterQuery(
                   select = ^$select(
                                savedFilteringOperation += pair($lastNode, $filterMapping.filter.operation->toOne()->reprocessAliases(^OldAliasToNewAlias(first=$lastNode.alias.relation->cast(@Table).name, second=$lastNode.alias->toOne())))
                            )
                   );
     );
}

function meta::relational::functions::pureToSqlQuery::applyGroupBy(base:SelectWithCursor[1], viewSpecification:RelationalMappingSpecification[1], nodeId:String[1]):SelectWithCursor[1]
{
   let groupByMapping = $viewSpecification->getGroupBy();
   if ($groupByMapping->isEmpty(), | $base,
                                   | let baseSelect = $base.select;
                                     let lastNode = $base.currentTreeNode->toOne()->findLastJoinTreeNode();
                                     let columns = $groupByMapping.columns->map(c | $c->reprocessAliases(^OldAliasToNewAlias(first=$c->cast(@TableAliasColumn).alias.name, second=$lastNode.alias->toOne())));
                                     ^$base(select=^$baseSelect(groupBy=$columns)););
}

function meta::relational::functions::pureToSqlQuery::containsDynaFunction(filteringElements:RelationalOperationElement[*], columns:RelationalOperationElement[*]) : Boolean[1]
{
   let dynaFunctionGroupByColumns = $columns->filter(d | $d->cast(@Alias).relationalElement->instanceOf(DynaFunction))->cast(@Alias).relationalElement;
   $dynaFunctionGroupByColumns->fold({a, b| $b || containsElementRecursive($filteringElements, $a)},false);
}

function meta::relational::functions::pureToSqlQuery::containsElementRecursive(elements:RelationalOperationElement[*], elementToFind:RelationalOperationElement[1]): Boolean[1]
{
   $elements->fold({a, b| $b || $a->containsElementRecursive($elementToFind)},false);
}

function meta::relational::functions::pureToSqlQuery::containsElementRecursive(element:RelationalOperationElement[1], elementToFind:RelationalOperationElement[1]):Boolean[1]
{
   $element->equal($elementToFind) ||
   $element->match(
      [
         f:BinaryOperation[1] |  containsElementRecursive($f.left, $elementToFind) || containsElementRecursive($f.right, $elementToFind);,
         d:DynaFunction[1] | $d.parameters->containsElementRecursive($elementToFind),
         a:Any[1] | false;
      ]);
}

function meta::relational::functions::pureToSqlQuery::replaceDynaFunctionWithTableAliasColumn(relationalOperationElement:RelationalOperationElement[1], toRootColLookup: Pair<Alias,Alias>[*]) : RelationalOperationElement[1]
{
   $relationalOperationElement->match(
      [
         f:BinaryOperation[1] |  ^$f(left=replaceDynaFunctionWithTableAliasColumn($f.left,$toRootColLookup), right=replaceDynaFunctionWithTableAliasColumn($f.right,$toRootColLookup));,
         d:DynaFunction[1]    |  let match = $toRootColLookup->filter(p | $p.first.relationalElement == $d);
                                 if (!$match->isEmpty(),|$match->toOne().second.relationalElement,
                                                        |let newParams = $d.parameters->map(p | $p->replaceDynaFunctionWithTableAliasColumn($toRootColLookup));
                                                         ^$d(parameters=$newParams);
                                                         );,
         a:RelationalOperationElement[1] | $a;
      ]);
}

function meta::relational::functions::pureToSqlQuery::realiasAndReplaceDynaFunctionColumnsAndFilters(select: SelectSQLQuery[1], rsSelect: SelectSQLQuery[1], originalSelect: SelectSQLQuery[1], nodeId:String[1], context:DebugContext[1]) : Pair<SelectSQLQuery,SelectSQLQuery>[1]{
      let subselectCols = $select.columns;
      let reAliasedCols = reAliasAndRemoveTopLevelDynaFunctionColumns($select, $subselectCols);
      let oldToNewCols = $originalSelect.columns->zip($reAliasedCols)->filter(a|$a.first->instanceOf(Alias))->map(z|pair($z.first->cast(@Alias),$z.second->cast(@Alias)));
      let revisedLeftSideSelect = ^$select(columns=$reAliasedCols);
      let reprocessedFilterOps=$rsSelect.filteringOperation->map(r|$r->replaceDynaFunctionWithTableAliasColumn($oldToNewCols));
      let revisedRightSideSelect = ^$rsSelect(filteringOperation=$reprocessedFilterOps);
      pair($revisedLeftSideSelect, $revisedRightSideSelect);
}

function meta::relational::functions::pureToSqlQuery::processFilter(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType : JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'   (M)Processing filter(inFilterExpression='+$state.inFilter->toString()+',depth='+$state.filterChainDepth->toString()+')>  \n'));

   let leftSidePure = $expression.parametersValues->at(0);
   let newNested = $state.filterChainDepth+1;
   let leftSideOp = processValueSpecificationReturnPropertyMapping($leftSidePure, $currentPropertyMapping, $operation, $vars, ^$state(filterChainDepth=$newNested), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne();
   let leftSide = $leftSideOp.element->cast(@SelectWithCursor);

   let treeAndCurrentTreeNode = if (!$leftSide.savedRoot->isEmpty(),
                                   |let savedCurrentTreeNodeInLeftSide = $leftSide.savedRoot->toOne().second->findNodeByChild($leftSide.savedRoot->toOne().first,$leftSide.select.data->toOne())->cast(@RelationalTreeNode);
                                    if(!$savedCurrentTreeNodeInLeftSide->isEmpty(),
                                      |pair($leftSide.select.data->toOne(),$savedCurrentTreeNodeInLeftSide->toOne()),
                                      |pair($leftSide.select.data->toOne(),$leftSide.select.data->toOne()->findLastJoinTreeNode()));,
                                   | let rootData = $leftSide.select.data->toOne(); let rootDataWithNoChildren=^$rootData(childrenData = []); pair($rootDataWithNoChildren,$rootDataWithNoChildren->cast(@RelationalTreeNode)););

   let tree=$treeAndCurrentTreeNode.first;
   let currentTreeNode=$treeAndCurrentTreeNode.second;

   //Include the saved filters that are applicable to this root tree
   let savedFilteringOp =  $leftSide.select.savedFilteringOperation->map(p|let filtersToRoot = $p.first->findNodeByChild($leftSide.select.data->toOne(), $tree->cast(@RootJoinTreeNode));
                                                                           if ($filtersToRoot->isEmpty(),  | [], | pair($filtersToRoot->toOne(), $p.second));
                                                                         );

   let rootSelect = ^SelectWithCursor(
                       select = ^SelectSQLQuery(
                                  filteringOperation = if(isGetAll($leftSidePure),
                                                          |$leftSide.select.filteringOperation,
                                                          |$state.inFilter->if( | $leftSide.select.filteringOperation,
                                                                                | let byPassedLeft = $leftSidePure->byPassRouterInfo();
                                                                                  let isDataTypeInput = $byPassedLeft.genericType.rawType->isNotEmpty() && $byPassedLeft.genericType.rawType->toOne()->instanceOf(DataType);
                                                                                  let isSemiStructuredPropertyMapping = ($leftSideOp.currentPropertyMapping->size() >= 1) && $leftSideOp.currentPropertyMapping->forAll(pm | $pm->instanceOf(SemiStructuredRelationalPropertyMapping));
                                                                                  if ($isDataTypeInput || $isSemiStructuredPropertyMapping, | $leftSide.select.columns, | []);)),
                                  //extraFilteringOperation = $leftSide.select.extraFilteringOperation,
                                  savedFilteringOperation = $savedFilteringOp,
                                  data = $tree
                                ),
                       currentTreeNode = $currentTreeNode,
                       milestoningContext = $leftSide.milestoningContext
                     );

   let paramValue = $expression.parametersValues->at(1)->match([e:StoreMappingRoutedValueSpecification[1]|$e.value,v:ValueSpecification[1]|$v]);
   let updatedState = $state->updateFunctionParamScope($paramValue.genericType.typeArguments.rawType->toOne()->cast(@FunctionType),$rootSelect);

   let filterFunction = $expression->instanceValuesAtParameter(1, $vars, $updatedState.inScopeVars)->at(0)->cast(@FunctionDefinition<Any>);
   let filterFunctionExpression = $filterFunction.expressionSequence->at(0);

   let inScopeVarsWithPlaceholdersState = $filterFunction->addPlaceHoldersForLambdaOpenVariables($vars, $updatedState);

   let embeddedMapping = if($leftSideOp.currentPropertyMapping->isEmpty(), | $currentPropertyMapping, | $leftSideOp.currentPropertyMapping);
   let rightSide = processValueSpecification($filterFunctionExpression, $embeddedMapping, $rootSelect, $vars, ^$inScopeVarsWithPlaceholdersState(inFilter=true,filterChainDepth=$state.filterChainDepth+1), JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);

   let isGroupByWithAggFilter = !$leftSide.select.groupBy->isEmpty() && $rightSide.select.filteringOperation->containsDynaFunction($leftSide.select.columns);

   let revisedLeftRightSelects = if ($isGroupByWithAggFilter,
                                    |  let leftSideSelect = $leftSide.select;
                                       let subSelectWithGroupByCols = ^$leftSideSelect(columns+=$leftSideSelect.groupBy);
                                       let subselect = moveSelectQueryToSubSelect($subSelectWithGroupByCols, $leftSide.currentTreeNode, [], $nodeId, $context->shift(), $extensions);
                                       realiasAndReplaceDynaFunctionColumnsAndFilters($subselect, $rightSide.select, $subSelectWithGroupByCols, $nodeId, $context );,
                                    |  pair($leftSide.select,$rightSide.select);
                                    );

   let merged = [$revisedLeftRightSelects.first, $revisedLeftRightSelects.second]->cast(@SelectSQLQuery)->mergeSQLQueryData($nodeId, $updatedState, $context, $extensions);

   let mergedWithCollapsedFilteringOperation = ^$merged(filteringOperation = $merged.filteringOperation->tail()->fold({f,a|[$a->toOne(),$f]->andFilters($extensions)}, $merged.filteringOperation->head()));

   let newLastNode = if ($leftSide.currentTreeNode->isEmpty(),|[] ,|$leftSide.currentTreeNode->toOne()->findOneNode($leftSide.select.data->toOne(), $mergedWithCollapsedFilteringOperation.data->toOne()));

   let managedFilteredPosition = if ($state.inProjectFunctions && $state.qualifierBase->isEmpty() && !$mergedWithCollapsedFilteringOperation.filteringOperation->isEmpty(),
         |^$mergedWithCollapsedFilteringOperation
           (
              filteringOperation = [],
              savedFilteringOperation +=  pair($newLastNode->toOne(), $mergedWithCollapsedFilteringOperation.filteringOperation->toOne())
           ),
         | $mergedWithCollapsedFilteringOperation

   );

   let rawType = $leftSidePure.genericType.rawType->toOne();
   let isFilterOnDataType = $state.inFilter && $rawType->instanceOf(DataType);
   let savedFilterCurrentTreeNode = $newLastNode;

   let filteringOperation = if ($isFilterOnDataType || $savedFilterCurrentTreeNode->isEmpty(), | $managedFilteredPosition.filteringOperation,|[]);
   let savedFilteringOperation = if($isFilterOnDataType  || $savedFilterCurrentTreeNode->isEmpty() || $managedFilteredPosition.filteringOperation->isEmpty(),
                                    |$managedFilteredPosition.savedFilteringOperation,
                                    |$managedFilteredPosition.savedFilteringOperation->concatenate(pair($savedFilterCurrentTreeNode->toOne(), $managedFilteredPosition.filteringOperation->toOne())));

   let preIsolation = ^$leftSideOp
   (
      element = ^SelectWithCursor(
                    select = ^$managedFilteredPosition
                              (
                                 leftSideOfFilter = $newLastNode,
                                 filteringOperation = $filteringOperation,
                                 savedFilteringOperation = $savedFilteringOperation
                              ),
                    currentTreeNode = $newLastNode,
                    positionBeforeLastApplyJoinTreeNode = if($leftSide.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$leftSide.positionBeforeLastApplyJoinTreeNode->toOne()->findNode($leftSide.select.data->toOne(), $mergedWithCollapsedFilteringOperation.data->toOne())->toOne()),
                    milestoningContext = $leftSide.milestoningContext,
                    savedRoot=$leftSide.savedRoot
                )
   );


   print(if(!$context.debug, |'',
             | $context.space+ '   (M)Processing filter pre-isolation >  : \n' + $context.space+meta::relational::functions::pureToSqlQuery::printDebugQuery($preIsolation.element->cast(@SelectWithCursor).select, $context.space, $extensions)+'\n'));


   let inForcedIsolationDebugMode=  {|$context->instanceOf(RelationalDebugContext) && !$context->cast(@RelationalDebugContext).forcedIsolation->isEmpty()};//when isolation is forced AND isolation is run below then the JoinTreeNode is processed multiple times, resulting in an incorrect joinName which subsequently may not merge with other branches

   //dont force isolation if  we are processing an Exists as we will isolate as part of it.
   let shouldIsolateNestedFilter = $state.inFilter && ($state.filterChainDepth <= 1 ) && !$inForcedIsolationDebugMode->eval() && ($state.shouldIsolateNestedFilter->isEmpty() || $state.shouldIsolateNestedFilter->toOne() );
   print(if(!$context.debug, |'',| $context.space+'   (M)Should isolate nested filter State(nested='+ $state.inFilter->toString()+',shouldIsolate='+$state.shouldIsolate->toString()+',shouldIsolateNestedFilter='+if($state.shouldIsolateNestedFilter->isEmpty(),|'[]',|$state.shouldIsolateNestedFilter->toOne()->toString())+') ? '+ $shouldIsolateNestedFilter->toString()+' >  \n'));

   let res = if($shouldIsolateNestedFilter
                      ,|^$preIsolation(element = manageIsolation($preIsolation.element->cast(@SelectWithCursor),[],  $nodeId, $joinType==JoinType.INNER, ^$state(shouldIsolateNestedFilter=$shouldIsolateNestedFilter,shouldIsolate=$shouldIsolateNestedFilter ), $context, $extensions));
                      ,| $preIsolation;
                     );
   print(if(!$context.debug, |'',
            | $context.space+ '   (M)End processing filter >  : \n' + meta::relational::functions::pureToSqlQuery::printDebugQuery($res.element->cast(@SelectWithCursor).select, $context.space, $extensions)+'\n'));

   $res;
}

function meta::relational::functions::pureToSqlQuery::isGetAll(v:ValueSpecification[1]):Boolean[1]
{
   let extracted = $v->match([e:StoreMappingRoutedValueSpecification[1]|$e.value, v:ValueSpecification[1]|$v]);
   $extracted->instanceOf(FunctionExpression) && $extracted->cast(@FunctionExpression).functionName == 'getAll';
}

function meta::relational::functions::pureToSqlQuery::addPlaceHoldersForLambdaOpenVariables(fn:FunctionDefinition<Any>[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1]):State[1]
{
   let inScopeVars = $state.inScopeVars;
   $fn->match([
                  l:LambdaFunction<Any>[1] | let placeHolders = $l.openVariables->map(v |if($inScopeVars->get($v)->isEmpty(),
                                                                                             |pair($v, ^List<Any>(values=[^VarPlaceHolder(name=$v,type = $l->functionReturnType().rawType->toOne())]));,
                                                                                             | []
                                                                                         )
                                                                                     );
                                             ^$state(inScopeVars=$inScopeVars->putAll($placeHolders));,
                  o:FunctionDefinition<Any>[1] | $state;
   ]);
}

function meta::relational::functions::pureToSqlQuery::getAllNodeNames(t:RelationalTreeNode[0..1]):String[*]
{
   $t->printNode()->concatenate(if($t->isEmpty(),|[],|$t->map(x|$x->children())->map(c|$c->getAllNodeNames())));
}


function meta::relational::functions::pureToSqlQuery::findNode(oldTarget:RelationalTreeNode[1], oldNode:RelationalTreeNode[1], newNode:RelationalTreeNode[1]):RelationalTreeNode[*]
{
   if ($oldTarget == $oldNode,
         | $newNode,
         | findNodeByChild($oldTarget,$oldNode,$newNode));
}

function meta::relational::functions::pureToSqlQuery::findNodeByChild(oldTarget:RelationalTreeNode[1], oldNode:RelationalTreeNode[1], newNode:RelationalTreeNode[1]):JoinTreeNode[0..1]
{
   let indexOfOldTarget= $oldNode->children()->indexOf($oldTarget);
   let res = if($indexOfOldTarget != -1,
         |   let newNodeMatchByJoinName=$newNode->children()->filter(c|$c.join.name == $oldTarget->cast(@JoinTreeNode).join.name);
             if($newNodeMatchByJoinName->isNotEmpty(),
                   |$newNodeMatchByJoinName->toOne();,
                   |if($newNode->children()->size() > $indexOfOldTarget,| $newNode->children()->at($indexOfOldTarget),
                      |if ($newNode->instanceOf(JoinTreeNode) && $newNode->cast(@JoinTreeNode).joinName->startsWith('__iso'),
                         |$newNode,
                         |if($newNode->children()->size() == 1 && $newNode->children()->at(0)->instanceOf(JoinTreeNode) && $newNode->children()->at(0)->cast(@JoinTreeNode).joinName->startsWith('__iso'),
                             |$newNode->children()->at(0),
                             |[]
                          )
                       )
                    )
              )->cast(@JoinTreeNode);,
         |range(0, $oldNode->children()->size(), 1)->map(i|if ($newNode->children()->size() > $i, |$oldTarget->findNodeByChild($oldNode->children()->at($i), $newNode->children()->at($i)),|[]))->first()->cast(@JoinTreeNode);
    );
    assert($res->size() <= 1, | 'Found '+$res->size()->toString()+' nodes\n'+'to find:'+$oldTarget->printNodeWithChildren()+'\nold:'+$oldNode->printNodeWithChildren()+'\nnew:'+$newNode->printNodeWithChildren());
    $res->first();
}

function meta::relational::functions::pureToSqlQuery::findOneNode(oldTarget:RelationalTreeNode[1], oldNode:RelationalTreeNode[1], newNode:RelationalTreeNode[1]):RelationalTreeNode[1]
{
   let res = findNode($oldTarget, $oldNode, $newNode);
   assert($res->size() == 1, | 'Found '+$res->size()->toString()+' nodes\n'+'to find:'+$oldTarget->printNodeWithChildren()+'\nold:'+$oldNode->printNodeWithChildren()+'\nnew:'+$newNode->printNodeWithChildren());
   $res->toOne();
}

function meta::relational::functions::pureToSqlQuery::processExists(functionExpression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
    processExists($functionExpression,false, $currentPropertyMapping, $operation, $vars, $state, $nodeId, $aggFromMap, $context, $extensions)
}

function meta::relational::functions::pureToSqlQuery::processNotExists(functionExpression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   if ($functionExpression.parametersValues->at(0).multiplicity->hasUpperBound() && ($functionExpression.parametersValues->at(0).multiplicity->getUpperBound() <= 1),
      | processIsEmpty($functionExpression, $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions),
      | $functionExpression.parametersValues->at(0)->match([
                  //build a Noop - the literal list of values is not empty
                  i:InstanceValue[1]| processIsEmpty(^$functionExpression(parametersValues=^InstanceValue(values=$i.values->size(), genericType=$i.genericType, multiplicity=PureOne)), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions);,
                  v:VariableExpression[1]| processIsEmpty($functionExpression, $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions);,
                  a:Any[1] | processExists($functionExpression, true, $currentPropertyMapping, $operation, $vars, $state, $nodeId, $aggFromMap, $context, $extensions);
                  ])
                  );
}

function meta::relational::functions::pureToSqlQuery::processExists(expression:FunctionExpression[1],negate:Boolean[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
    let existsState=^$state(shouldIsolateNestedFilter=false);
    let leftSideOp = processValueSpecificationReturnPropertyMapping($expression.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $existsState, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions);
    let leftSide = $leftSideOp.element->toOne()->cast(@SelectWithCursor);

    let select = $leftSide.select;
    print(if(!$context.debug, |'',
            | $context.space+'   (S)Exists Left side Select>  '+$select->printDebugQuery($context.space, $extensions)));

    // Rebuild old query (it may have been mutated by adding keys in Union)
    let node = $operation.currentTreeNode->toOne()->findNode($operation.select.data->toOne(), $select.data->toOne())->toOne();
    let nNode = ^$node(childrenData=[]);
    let newData=  $select.data->toOne()->replaceTreeNode($node, $nNode)->cast(@RootJoinTreeNode);
    let nSelect = ^$select(
                      data=$newData,
                      savedFilteringOperation = $select.savedFilteringOperation->map(p| let foundNode = $p.first->findNode($operation.select.data->toOne(), $select.data->toOne());
                                                                                        if ($foundNode->isEmpty(), | [], | pair($foundNode->toOne(), $p.second));),
                      leftSideOfFilter =  if ($select.leftSideOfFilter->isEmpty(),
                                              |[],
                                              |let res = $select.leftSideOfFilter->toOne()->findNode($operation.select.data->toOne(), $select.data->toOne());
                                               if ($res->isEmpty(),|[],|$res->toOne());
                                          )
                  );
    let nOperation = ^$leftSide(select=$nSelect,
                                currentTreeNode=$nNode,
                                positionBeforeLastApplyJoinTreeNode = if($operation.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$operation.positionBeforeLastApplyJoinTreeNode->toOne()->findNode($operation.select.data->toOne(), $nSelect.data->toOne())->toOne())
                            );

    let opSel = $nOperation.select;
    print(if(!$context.debug, |'',
            | $context.space+'   (O)Exists Left side Operation>  '+$opSel->printDebugQuery($context.space, $extensions)));


    let opMapping = $leftSideOp.currentPropertyMapping;
    if (!$opMapping->isEmpty() && $opMapping->at(0)->instanceOf(EmbeddedRelationalInstanceSetImplementation)
                  ,{|                                                                   
                     let existsAsFilter = processFilter($expression, $currentPropertyMapping, $nOperation, $vars, $existsState, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions);
                     if($existsState.inFilter
                         ,|$existsAsFilter
                         ,{|
                            let selectWithCursor = $existsAsFilter.element->cast(@SelectWithCursor);
                            let select = $selectWithCursor.select;
                            ^$selectWithCursor(select=^$select(savedFilteringOperation=[], columns=$select.savedFilteringOperation.second));
                          }
                      );
                   }
                  ,| if($node.childrenData->size() == 1 && $leftSide->shouldBuildExistsPredicate()
                     ,| buildExistsPredicate($leftSide, $expression, $negate, $opMapping, $nOperation, $vars, $existsState, $nodeId, $aggFromMap, $context, $extensions);
                     ,| buildExistsAsJoinWithNullCheck($leftSide, $expression, $negate, $opMapping, $nOperation, $vars, $existsState, $nodeId, $aggFromMap, $context, $extensions);
                     );
                   );
}

function meta::relational::functions::pureToSqlQuery::findJoiningColumns(node:JoinTreeNode[1]):TableAliasColumn[*]
{
    let tableAliases = $node.join.operation->extractTableAliasColumns();
    $tableAliases->filter(a | $a.alias == $node.alias);
}

function meta::relational::functions::pureToSqlQuery::shouldBuildExistsPredicate(left:SelectWithCursor[1]):Boolean[1]
{
     let alias = $left.currentTreeNode->cast(@RelationalTreeNode)->toOne().alias;

     $alias.relationalElement->match([s:SelectSQLQuery[1] | true,
                                      u:UnionAll[1] | true,
                                      u:Union [1] | true,
                                      a:Any[1]|false]);

}

function meta::relational::functions::pureToSqlQuery::isTdsRowsRunction(v:ValueSpecification[1]):Boolean[1]
{
   $v->instanceOf(FunctionExpression) && $v->cast(@FunctionExpression).func == tdsRows_TabularDataSet_1__TDSRow_MANY_
}

function meta::relational::functions::pureToSqlQuery::buildExistsAsJoinWithNullCheck(left:SelectWithCursor[1], expression:FunctionExpression[1], negate:Boolean[1], currentPropertyMapping:PropertyMapping[*], preOperation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   print(if(!$context.debug, |'',| $context.space+'   (M)Processing Exists>  isolating Left side\n'));

   let leftSelect = $left.select;
   let ctx = if($context->instanceOf(RelationalDebugContext) && !$context->cast(@RelationalDebugContext).forcedIsolation->isEmpty(),
                |$context,
                |^RelationalDebugContext(debug=$context.debug, space=$context.space, forcedIsolation=IsolationStrategy.MoveFilterOnTop)
              );

   let preIsolationCutPointParent = if($left.positionBeforeLastApplyJoinTreeNode->isEmpty() && $expression.parametersValues->at(0)->isTdsRowsRunction(),| $leftSelect.data,| $left.positionBeforeLastApplyJoinTreeNode);
   let subSelectNodes = $preIsolationCutPointParent->map(x|$x->children())->at(0)->getAllNodes()->cast(@RelationalTreeNode);
   let rootAndNonRootExtraFilteringOperations = $leftSelect.extraFilteringOperation->partition(f| $f->extractTableAliasColumns()->fold({c, a | !$subSelectNodes.alias.name->contains($c.alias.name) && $a}, true));
   let rootExtraFilteringOperations = $rootAndNonRootExtraFilteringOperations.first.values;
   let childrenExtraFilteringOperations = $rootAndNonRootExtraFilteringOperations.second.values;

   let leftSide = ^$left(select=^$leftSelect(extraFilteringOperation=$childrenExtraFilteringOperations))->manageIsolation([],  $nodeId, false, ^$state(shouldIsolate=true), $ctx, $extensions);

    print(if(!$context.debug, |'',
            | $context.space+'   (S)Exists before condition>  '+$leftSide.select->printDebugQuery($context.space, $extensions)));

    //may be able to relax this so that in all cases if the positionBeforeLastApplyJoinTreeNode is empty we build the subselect from the root, is it reasonable to say that if it is not set then it must be root
    let cutPointParent = if($leftSide.positionBeforeLastApplyJoinTreeNode->isEmpty() && $expression.parametersValues->at(0)->isTdsRowsRunction(),| $leftSelect.data,| $leftSide.positionBeforeLastApplyJoinTreeNode);

    let childNode = $cutPointParent->map(c|$c->children())->at(0);

    let node = ^RootJoinTreeNode(alias = $childNode.alias, childrenData = $childNode.childrenData);

    let existsFilter = if ($expression.parametersValues->size() == 1,
                               | let s= $leftSide.select;
                                 ^$s(filteringOperation=$s.extraFilteringOperation->concatenate($s.filteringOperation)->andFilters($extensions));,
                               | let filterFunctionExpression = $expression.parametersValues->at(1)->byPassRouterInfo()->cast(@InstanceValue).values->at(0)->cast(@FunctionDefinition<Any>).expressionSequence->at(0);
                                 let subSelect = ^SelectWithCursor(
                                                     select = ^SelectSQLQuery(data = $node ,filteringOperation = $leftSide.select.extraFilteringOperation->concatenate($leftSide.select.filteringOperation)->andFilters($extensions)),
                                                     currentTreeNode = if($childNode.alias == $leftSide.alias, |$node, |$leftSide.currentTreeNode),
                                                     milestoningContext = $leftSide.milestoningContext
                                                  );

                                 let valueSpec = processValueSpecification($filterFunctionExpression, $currentPropertyMapping, $subSelect, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne();
                                 let nestedFilter = $valueSpec->cast(@SelectWithCursor).select;
                                 let filterOperation = if($nestedFilter.filteringOperation->isEmpty(),|[] ,|$nestedFilter.filteringOperation->toOne());
                                ^$nestedFilter(filteringOperation = if($state.inFilter,|$filterOperation,|$nestedFilter.columns->at(0))->concatenate($leftSide.select.extraFilteringOperation)->andFilters($extensions));
                        );

    let hasNoColumnsOutsideSubSelect = $existsFilter.filteringOperation->filter(fo| 'root'->in($fo->extractTableAliasColumns().alias.name))->isEmpty();

    if ($hasNoColumnsOutsideSubSelect
    ,|
         let joinAliases = $childNode->cast(@JoinTreeNode)->findJoiningColumns()->removeDuplicates();

         let joinAndNonJoinElements = $existsFilter.groupBy->partition(r| let tacs = $r->extractTableAliasColumns();
                                                                          $tacs->size() == 1 && $joinAliases->contains($tacs->at(0));
                                                                      );
         let allColumns = $joinAliases->concatenate($existsFilter.groupBy)->removeDuplicates({a,b| $a == $b });

         assertFalse($joinAliases->isEmpty(),'Cant find any aliases right side of exists ->');
         
         let existsSubSelectFilter = if ($expression.parametersValues->size() == 1, |$rootExtraFilteringOperations, |[]);
         let existsSubSelect = ^$existsFilter(distinct = true,
                                              columns = $allColumns, 
                                              extraFilteringOperation = [], 
                                              filteringOperation = $existsFilter.filteringOperation->concatenate($existsSubSelectFilter)->andFilters($extensions), 
                                              groupBy=if($existsFilter.groupBy->isNotEmpty(),|$allColumns,|[]));

         print(if(!$context.debug, |'',
                 | $context.space+'   (S)Exists condition result>  '+$existsSubSelect->printDebugQuery($context.space, $extensions)));

         let targetAlias =  ^TableAlias(name=$childNode.alias.name+'_ecq', relationalElement=$existsSubSelect);

         let columnNullCheck =  $joinAliases->map(c| let newCol =^$c(alias=$targetAlias) ;$negate->if(|^DynaFunction(name = 'isNull', parameters=$newCol),|^DynaFunction(name = 'isNotNull', parameters=$newCol));)->andFilters($extensions);

         let oldJoin = $childNode.join;

         let oldToNewAlias = $joinAliases->map(a|^OldAliasToNewAlias(first=$a.alias.name,second=$targetAlias ))->removeDuplicates();

         let newJoinOperation = $oldJoin.operation->andFilters($extensions)->reprocessAliases($oldToNewAlias);

         let newJoin = ^$oldJoin(name=$oldJoin.name + $existsSubSelect.data.alias.relation->buildUniqueName(false, $extensions) + '_ecq',operation=$newJoinOperation->toOne()->cast(@Operation))->reprocessJoin($oldToNewAlias, []);

         let newChildNode = ^$childNode(alias=$targetAlias,join=$newJoin,childrenData=[]);

         let newData=  $leftSide.select.data->toOne()->replaceTreeNode($childNode, $newChildNode)->cast(@RootJoinTreeNode);

         let sel = $leftSide.select;

         let newLefSideOfFilter = if($sel.leftSideOfFilter->isEmpty(),|[],|$newData);

         let result = if($state.inFilter,
                        |^$leftSide(select=^$sel(data=$newData,
                                    extraFilteringOperation=$rootExtraFilteringOperations,
                                    filteringOperation = $columnNullCheck,
                                    leftSideOfFilter=$newLefSideOfFilter,
                                    groupBy=[]),
                                    positionBeforeLastApplyJoinTreeNode = [],
                                    currentTreeNode=[]),
                        | ^$leftSide(select=^$sel(columns= $columnNullCheck,
                                     extraFilteringOperation=$rootExtraFilteringOperations,
                                     data=$newData,
                                     leftSideOfFilter=$newLefSideOfFilter,
                                     groupBy=[]),
                                     positionBeforeLastApplyJoinTreeNode = [],
                                     currentTreeNode=[])
                      );

         print(if(!$context.debug, |'',
                 | $context.space+'   (M)Exists Built>  '+$result.select->printDebugQuery($context.space, $extensions)));

         $result;

     ,| buildExistsPredicate($leftSide, $expression, $negate, $currentPropertyMapping, $preOperation, $vars, $state, $nodeId, $aggFromMap, $context, $extensions)
    );
}

function meta::relational::functions::pureToSqlQuery::buildExistsPredicate(left:SelectWithCursor[1], expression:FunctionExpression[1], negate:Boolean[1], currentPropertyMapping:PropertyMapping[*], preOperation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
//   print(if(!$context.debug, |'',
//            | $context.space+'   (M)PRE Exists1  '+$left.select->printDebugQuery($context.space)));
//   print(if(!$context.debug, |'',
//            | $context.space+'   (M)PRE Exists2  '+$preOperation.select->printDebugQuery($context.space)));
   let leftSide = $left->manageIsolation([], $nodeId, false, ^$state(shouldIsolate=true), $context, $extensions);

    let childNode = if($leftSide.positionBeforeLastApplyJoinTreeNode->isEmpty(),| $leftSide.select.data,| $leftSide.positionBeforeLastApplyJoinTreeNode)->map(x|$x->children())->at(0);
    let node = ^RootJoinTreeNode(alias = $childNode.alias, childrenData = $childNode.childrenData);

    let subSelect = ^SelectWithCursor(
                       select = ^SelectSQLQuery(
                                  data = $node,
                                  filteringOperation = $leftSide.select.extraFilteringOperation->andFilters($extensions)
                                ),
                       currentTreeNode = if($childNode.alias == $leftSide.alias, |$node, |$leftSide.currentTreeNode),
                       milestoningContext = $leftSide.milestoningContext
                     );

    let withFilter = if ($expression.parametersValues->size() == 1,
                               | let s = $subSelect.select;
                                 ^$s(filteringOperation = $childNode->cast(@JoinTreeNode).join.operation->concatenate($leftSide.select.extraFilteringOperation)->andFilters($extensions));,
                               | let filterFunctionExpression = $expression.parametersValues->at(1)->byPassRouterInfo()->cast(@InstanceValue).values->at(0)->cast(@FunctionDefinition<Any>).expressionSequence->at(0);
                                 let valueSpec = processValueSpecification($filterFunctionExpression, $currentPropertyMapping, $subSelect, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne();
                                 let nestedFilter = $valueSpec->cast(@SelectWithCursor).select;
                                 // Add the join (combing with the left property)
                                 let filterOperation = if($nestedFilter.filteringOperation->isEmpty(),|[] ,|$nestedFilter.filteringOperation->toOne());
                                 let nestedJoinAndFilter = ^$nestedFilter(filteringOperation = if($state.inFilter,|$filterOperation,|$nestedFilter.columns->at(0))->concatenate($childNode->cast(@JoinTreeNode).join.operation)->concatenate($leftSide.select.extraFilteringOperation)->andFilters($extensions));
                        );

    let operation = $preOperation->manageIsolation([],  $nodeId, false, ^$state(shouldIsolate=true), $context, $extensions);
    let existingSelect = $operation.select;
    let funcToRemoveColumnsNotValidForSelect = {col:RelationalOperationElement[1] | let tacs = $col->extractTableAliasColumns();
                                                                                    $tacs.alias->forAll(alias | $alias->in($existingSelect.data->toOne()->getAllNodes()->cast(@RelationalTreeNode).alias));};

    let shouldGroupByBeMovedToExistsClause = $existingSelect.groupBy->filter(rel | !$funcToRemoveColumnsNotValidForSelect->eval($rel))->isNotEmpty();

    let updatedSelect = ^$existingSelect(columns = $existingSelect.columns->filter($funcToRemoveColumnsNotValidForSelect),
                                         groupBy = if($shouldGroupByBeMovedToExistsClause, | [], |$existingSelect.groupBy),
                                         havingOperation  = if($shouldGroupByBeMovedToExistsClause, | [], |$existingSelect.havingOperation));

    let nestedJoinAndFilterWithColumn = ^$withFilter(columns = if($shouldGroupByBeMovedToExistsClause, |$existingSelect.groupBy, |[^Literal(value = 1)]),
                                                     groupBy = if($shouldGroupByBeMovedToExistsClause, |$existingSelect.groupBy, |[]),
                                                     havingOperation  = if($shouldGroupByBeMovedToExistsClause, |$existingSelect.havingOperation, |[]));

    let filteringOp = if ($negate, | ^DynaFunction(name = 'not', parameters=^DynaFunction(name = 'exists', parameters = $nestedJoinAndFilterWithColumn)), | ^DynaFunction(name = 'exists', parameters = $nestedJoinAndFilterWithColumn));

    let sel = if ($leftSide.parent == [],
       | $updatedSelect,
       | ^$updatedSelect(data = $leftSide->cast(@SelectWithCursor).parent.select.data->toOne())
       );

    let result = if ($state.inFilter,
                   |^$leftSide(select=^$sel(filteringOperation = $filteringOp, extraFilteringOperation=[]),
                               positionBeforeLastApplyJoinTreeNode = [],
                               currentTreeNode=[]),
                   | ^$leftSide(select=^$sel(columns= $filteringOp, extraFilteringOperation=[]),
                                positionBeforeLastApplyJoinTreeNode = [],
                                currentTreeNode=[])
                 );

    print(if(!$context.debug, |'',
            | $context.space+'   (M)Exists Built>  '+$result.select->printDebugQuery($context.space, $extensions)));

    $result;
}

function meta::relational::functions::pureToSqlQuery::processContains(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processIn($f.parametersValues->at(1), $f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $nodeId, $aggFromMap, $context, $extensions)
}

function meta::relational::functions::pureToSqlQuery::processIn(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processIn($f.parametersValues->at(0), $f.parametersValues->at(1), $currentPropertyMapping, $operation, $vars, $state, $nodeId, $aggFromMap, $context, $extensions)
}

function meta::relational::functions::pureToSqlQuery::processIn(valueArg:ValueSpecification[1], collectionArg:ValueSpecification[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let processedValueArg = $valueArg->processValueSpecificationReturnPropertyMapping($currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne();

   let processedCollectionArg = $collectionArg->processValueSpecification($currentPropertyMapping, $operation, $vars, ^$state(shouldIsolate=false), JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->cast(@SelectWithCursor);
   let singleProcessedCollectionArg = $processedCollectionArg->size() == 1;
   let reprocessedCollectionArg = if($singleProcessedCollectionArg,
                                     | $processedCollectionArg->toOne(),
                                     | let processedCollection = if($state.inFilter, |$processedCollectionArg->map(s | $s.select.filteringOperation), |$processedCollectionArg->map(s | $s.select.columns));
                                       assert($processedCollection->forAll(pc | $pc->instanceOf(Literal) || ($pc->instanceOf(DynaFunction) && $pc->cast(@DynaFunction).name == 'minus' && $pc->cast(@DynaFunction).parameters->size() == 1)), 'IN is supported only for literal values or negative numbers');
                                       let list = ^LiteralList(values=$processedCollection->map(m| $m->processLiteralOrMinusDynaFunction()));
                                       let first = $processedCollectionArg->at(0);
                                       let firstSelect = $first.select;
                                       ^$first(select=if($state.inFilter, |^$firstSelect(filteringOperation=$list), |^$firstSelect(columns=$list))););

   let mergedSQL = mergeSQLQueryData([$processedValueArg.element->cast(@SelectWithCursor), $reprocessedCollectionArg, $operation]->map(x|$x->extractSelectSQLQuery()), $nodeId, $state, $context, $extensions);

   let leftTable = if ($reprocessedCollectionArg.parent == [], |[],|$reprocessedCollectionArg.parent.alias.relationalElement);
   let filterTable = if($reprocessedCollectionArg.alias->isEmpty(),|[],|$reprocessedCollectionArg.alias.relationalElement);

   let isJoinToFilterTable = $state.inFilter && $leftTable != [] && $leftTable != $filterTable && $processedCollectionArg->at(0).select.filteringOperation->at(0)->instanceOf(TableAliasColumn);

   let valueFilter = if ($isJoinToFilterTable, | $reprocessedCollectionArg.select ,| $mergedSQL);
   let value = if($state.inFilter,|$valueFilter.filteringOperation->filter(p|$p->instanceOf(TableAliasColumn) || $p->instanceOf(DynaFunction) || $p->instanceOf(JoinStrings) || $p->instanceOf(SemiStructuredArrayFlattenOutput) || $p->instanceOf(SemiStructuredObjectNavigation))->at(0),|$mergedSQL.columns->at(0));
   let collection = if($state.inFilter, |$mergedSQL.filteringOperation->filter(p|$p->instanceOf(Literal) || $p->instanceOf(LiteralList) || $p->instanceOf(FreeMarkerOperationHolder))->at(0),|$mergedSQL.columns->at(1));

   let selectWithCursor = $value->extractSelectWithCursor($operation);

   let op = if($singleProcessedCollectionArg,
               | assert($collection->instanceOf(Literal), | 'Parameter to IN operation isn\'t a literal!');
                 if($collection->cast(@Literal).value->instanceOf(VarPlaceHolder) && $collection->cast(@Literal).value->cast(@VarPlaceHolder).type->instanceOf(Enumeration),
                    | let enumParamFreeMarker = generateFreeMarkerForEnumParam($processedValueArg, $collection);
                      let newCollection = generateFreeMarkerOpSelectorForEnumParam($enumParamFreeMarker, $value, $collection);,
                    | let literal = $collection->cast(@Literal);
                      let newLiteral = if($literal.value->instanceOf(Enum),
                                            |if($valueArg->instanceOf(VariableExpression),
                                                | ^DynaFunction(name = 'equal', parameters = [$value, $collection]),
                                                | let enumPropMapping = $processedValueArg.currentPropertyMapping->at(0)->cast(@RelationalPropertyMapping);
                                                  let vals = $enumPropMapping.transformer->toOne()->cast(@EnumerationMapping<Any>)->toSourceValues($literal.value);
                                                  if($vals->size() == 1,
                                                      | ^DynaFunction(name = 'equal', parameters=[$value, ^Literal(value=$vals->at(0))]),
                                                      | ^DynaFunction(name = 'in', parameters = [$value, ^LiteralList(values=$vals->map(v|^Literal(value=$v)))]);
                                                    );
                                                );,
                                            |let literalValue = $literal.value;
                                             if($literalValue->instanceOf(VarPlaceHolder),
                                                  | ^DynaFunction(name = 'in', parameters = [$value, ^LiteralList(values=$literal)]),
                                                  | ^DynaFunction(name = 'equal', parameters=[$value, $literal]));
                                          );
               );,
               | let literalList = $collection->cast(@LiteralList);
                 let newCollection =
                     if ($literalList.values->at(0).value->instanceOf(Enum) && !$valueArg->instanceOf(VariableExpression),
                     |let enum = $literalList.values->at(0).value;
                      let enumPropMapping = $processedValueArg.currentPropertyMapping->at(0)->cast(@RelationalPropertyMapping);
                      ^LiteralList(values=$literalList.values->map(v|$enumPropMapping.transformer->toOne()->cast(@EnumerationMapping<Any>)->toSourceValues($v.value))->map(v|^Literal(value=$v)));,
                     |$literalList
                  );
               ^DynaFunction(name = 'in', parameters=[$value,$newCollection]);
            );

   if ($isJoinToFilterTable,
                     |processInWithJoin($operation, $processedCollectionArg->at(0), $op->cast(@DynaFunction), $state.inFilter, $extensions);
                    ,|^$selectWithCursor(select = if($state.inFilter, |^$mergedSQL(filteringOperation=$op), |^$mergedSQL(columns=$op)), currentTreeNode=[], positionBeforeLastApplyJoinTreeNode=[]);
   );

}

function meta::relational::functions::pureToSqlQuery::extractPkValuesFromRelationalObjectReferences(objectRefs:String[*], pkOrder:String[*]):String[*]
{
   $objectRefs->map(o | let pkMap = if($o->startsWith('ASOR'),
                                             | $o->decodeAndParseAlloyObjectReference()->get('pkMap'),
                                             | $o->meta::json::parseJSON()->cast(@meta::json::JSONObject)->meta::json::getValue('pkMap')->toOne()->meta::json::fromJSON(Map))->cast(@Map<String, Any>)->toOne();
                        $pkOrder->map(pk | $pkMap->get($pk)->toOne()->toString())->joinStrings(','););
}

function meta::relational::functions::pureToSqlQuery::processObjectReferenceIn(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let leftSide               = $f.parametersValues->at(0);
   let mainClass              = $leftSide->byPassRouterInfo().genericType->genericTypeClass();
   let processedLeftSide      = $leftSide->processValueSpecification($currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context->shift(), $extensions)->toOne()->cast(@SelectWithCursor);

   let setImplementation      = $leftSide->match([
                                   e:StoreMappingRoutedValueSpecification[1] | $e.sets,
                                   v:ValueSpecification[1]               | $state.mapping->rootClassMappingByClass($mainClass);
                                ])->toOne();

   assert($setImplementation->instanceOf(RelationalInstanceSetImplementation), | 'OperationInstanceSetImplementation not supported yet!!');

   let primaryKeyColumns      = $setImplementation->toOne()->cast(@RelationalInstanceSetImplementation)->resolvePrimaryKey();
   let pkOrder                = ^LiteralList(values = range(0, $primaryKeyColumns->size())->map(i | ^Literal(value ='pk$_' + $i->toString())));

   let objectReferenceInImp   = if($primaryKeyColumns->size() > 1,
                                   |^DynaFunction(
                                        name = 'concat',
                                        parameters = $primaryKeyColumns->first()->concatenate($primaryKeyColumns->tail()->map(pk | [^Literal(value=','), $pk]))
                                    );,
                                   |if($primaryKeyColumns->toOne()->cast(@TableAliasColumn).column.type->instanceOf(meta::relational::metamodel::datatype::Varchar),
                                       |$primaryKeyColumns->toOne(),
                                       |^DynaFunction(
                                           name = 'toString',
                                           parameters = $primaryKeyColumns
                                        ))
                                   );
   let reProcessedleftSide    = $objectReferenceInImp->processColumnsInRelationalOperationElements($state, $processedLeftSide, $nodeId, $aggFromMap, true, $context->shift(), $extensions);

   let processedCollectionArg = $f.parametersValues->at(1)->processValueSpecification($currentPropertyMapping, $operation, $vars, ^$state(shouldIsolate=false), JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context->shift(), $extensions)->cast(@SelectWithCursor);
   let processedCollection    = if($state.inFilter, |$processedCollectionArg->map(s | $s.select.filteringOperation), |$processedCollectionArg->map(s | $s.select.columns));
   assert($processedCollection->forAll(pc | $pc->instanceOf(Literal)), 'ObjectReferenceIn is supported only for Literal');
   let isPostProcessingReq    = !$processedCollection->forAll(pc | $pc->cast(@Literal).value->instanceOf(String) || $pc->cast(@Literal).value->instanceOf(SQLNull));

   let list                   = ^LiteralList(values=$processedCollection->cast(@Literal));
   let first                  = $processedCollectionArg->at(0);
   let firstSelect            = $first.select;
   let reprocessedCollectionArg = ^$first(select=if($state.inFilter, |^$firstSelect(filteringOperation=$list), |^$firstSelect(columns=$list)));

   let mergedSQL              = mergeSQLQueryData([$reProcessedleftSide, $reprocessedCollectionArg, $operation]->map(x|$x->extractSelectSQLQuery()), $nodeId, $state, $context, $extensions);

   let value                  = if($state.inFilter, |$mergedSQL.filteringOperation->filter(p|$p->instanceOf(DynaFunction) || $p->instanceOf(TableAliasColumn))->at(0),|$mergedSQL.columns->at(1));
   let collection             = if($state.inFilter, |$mergedSQL.filteringOperation->filter(p|$p->instanceOf(LiteralList))->at(0),|$mergedSQL.columns->at(1));

   let op = if(!$isPostProcessingReq,
               |
                if($processedCollection->cast(@Literal).value->at(0)->instanceOf(SQLNull),
                  |^DynaFunction(name = 'equal', parameters=[$value, $processedCollection->toOne()]);,
                  |
                   let pkCollection = $processedCollection->cast(@Literal).value->cast(@String)->extractPkValuesFromRelationalObjectReferences($pkOrder.values.value->cast(@String));
                   let pkLiteralList = ^LiteralList(values = $pkCollection->map(pk | ^Literal(value=$pk)));
                   ^DynaFunction(name = 'in', parameters=[$value, $pkLiteralList]);
                  ),
               |^DynaFunction(name = 'objectReferenceIn', parameters=[$value, $collection->cast(@LiteralList), $pkOrder]));

   ^$operation(select = if($state.inFilter, |^$mergedSQL(filteringOperation=$op), |^$mergedSQL(columns=$op)), currentTreeNode=[], positionBeforeLastApplyJoinTreeNode=[]);
}

function meta::relational::functions::pureToSqlQuery::processLiteralOrMinusDynaFunction(input:Any[1]):Literal[1]
{
   $input->match([
      l:Literal[1] | $l,
      f:DynaFunction[1] | ^Literal(value = 0 - $f.parameters->toOne()->cast(@Literal).value->toString()->parseInteger())
   ]);
}

function meta::relational::functions::pureToSqlQuery::processInWithJoin(leftSide: SelectWithCursor[1], processedCollectionArg: SelectWithCursor[1], op: DynaFunction[1], inFilter:Boolean[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let leftToFilterTableJoinTreeNode = $processedCollectionArg.positionBeforeLastApplyJoinTreeNode->toOne()->match([
      j: JoinTreeNode[1] | $j,
      r: RelationalTreeNode[1] | $r->children()->at(0)
   ]);

   assert(if($inFilter, |$processedCollectionArg.select.filteringOperation->at(0)->instanceOf(TableAliasColumn), |$op.parameters->at(0)->instanceOf(TableAliasColumn)), 'Collection argument for \'in\' must be a simple property collection');
   let joinTableAlias = $inFilter->if( | $processedCollectionArg.select.filteringOperation->cast(@TableAliasColumn).alias->at(0),
                                       | $op.parameters->at(0)->cast(@TableAliasColumn).alias->at(0));

   let node = $inFilter->if(| if($processedCollectionArg.select.data->isNotEmpty() && $processedCollectionArg.select.data->map(x|$x->children())->isNotEmpty(),
                                  | ^RootJoinTreeNode(alias = $processedCollectionArg.select.data->map(x|$x->children())->at(0).alias, childrenData =  $processedCollectionArg.select.data->map(x|$x->children())->at(0)->children()),
                                  | ^RootJoinTreeNode(alias = $joinTableAlias)),
                            | ^RootJoinTreeNode(alias = $joinTableAlias));
   let existsSubSelect = ^SelectWithCursor(
                         select = ^SelectSQLQuery(columns = [^Literal(value = 1)],
                                    data = $node,
                                    filteringOperation = [$leftToFilterTableJoinTreeNode.join.operation, $op]->concatenate($processedCollectionArg.select.savedFilteringOperation.second)->andFilters($extensions)
                                  ),
                         currentTreeNode = $node
                       );
   let subSelectWithExists = ^DynaFunction(name = 'exists', parameters = $existsSubSelect.select);
   let leftSideSelect=$leftSide.select;
   $inFilter->if( | ^$leftSide(select=^$leftSideSelect(filteringOperation=$subSelectWithExists)),
                  | ^$leftSide(select=^$leftSideSelect(columns=$subSelectWithExists)));
}

function meta::relational::functions::pureToSqlQuery::processEvaluate(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   if($expression.parametersValues->size() == 1,
      |
         processValueSpecification($expression.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne();
      ,
      |
         let operationWithoutFilter = $operation->removeFilteringOperation();
         let filterFunctionExpression = $expression.parametersValues->at(0)->byPassRouterInfo()->cast(@InstanceValue).values->at(0)->cast(@FunctionDefinition<Any>).expressionSequence->at(0);
         let rightSide = processValueSpecification($expression.parametersValues->at(1), $currentPropertyMapping, $operationWithoutFilter, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne();
         processValueSpecification($filterFunctionExpression, $currentPropertyMapping, $rightSide->extractSelectWithCursor($operationWithoutFilter), $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne();
      );
}


Class meta::relational::functions::pureToSqlQuery::OperationWithParentPropertyMapping extends RelationalOperationElement
{
   element : RelationalOperationElement[1];
   currentPropertyMapping : PropertyMapping[*];
}

Class meta::relational::functions::pureToSqlQuery::ProjectionContainer extends OperationWithParentPropertyMapping
{
   returnType : Type[1];
   id : String[1];
}

function meta::relational::functions::pureToSqlQuery::collectTableNames(n:JoinTreeNode[1]):String[*]
{
   $n.alias.name->concatenate($n.childrenData->map(j|$j->cast(@JoinTreeNode)->collectTableNames()));
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::reprocessVS(v:ValueSpecification[1]):ValueSpecification[1]
{
   $v->match([
               f:FunctionExpression[1]|^$f(parametersValues=$f.parametersValues->map(v|$v->reprocessVS())),
               e:StoreMappingRoutedValueSpecification[1]|$e.value->reprocessVS(),
               e:FunctionRoutedValueSpecification[1]|$e.value->reprocessVS(),
               i:InstanceValue[1]|^$i(values = $i.values->map(v|$v->match([e:ValueSpecification[1]|$e->reprocessVS(),a:Any[1]|$a]))),
               v:ValueSpecification[1]|$v
            ])
}

function meta::relational::functions::pureToSqlQuery::processGroupBy(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let nestedQuery = processValueSpecification($expression.parametersValues->at(0), [], $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let select = $nestedQuery.select->cast(@TdsSelectSqlQuery);
   let groupByColumns = findAliasOrFail($expression, $select,  $vars, $state);
   let noSubSelect = $select.groupBy->isEmpty() && ($select.distinct->isEmpty() || !$select.distinct->toOne()) && $select.orderBy.column->removeAll($groupByColumns)->isEmpty();
   $groupByColumns->map(gc| assert(!$gc.relationalElement->instanceOf(WindowColumn),'Group by columns cannot include window columns'););
   let aggVS = $expression.parametersValues->at(2)->reprocessVS()->reactivate($state.inScopeVars)->evaluateAndDeactivate()->cast(@meta::pure::tds::AggregateValue<Any,Any>);
   let newColumns= $aggVS->map(a|let aggFn = $a.aggregateFn->cast(@FunctionDefinition<Any>).expressionSequence->at(0);
                                 let params = if($a.mapFn.expressionSequence->at(0)->instanceOf(FunctionExpression) || $a.mapFn.expressionSequence->at(0)->instanceOf(InstanceValue),
                                                 |let inScopeVarsWithPlaceholdersState = $a.mapFn->addPlaceHoldersForLambdaOpenVariables($vars, $state);
                                                  processTdsLambda($a.mapFn.expressionSequence->at(0)->evaluateAndDeactivate(), $select.columns->filter(c|!$c->instanceOf(WindowColumn))->cast(@Alias),!$noSubSelect, $vars, $inScopeVarsWithPlaceholdersState, $currentPropertyMapping, $context);,
                                                 |[]
                                              );
                                 ^Alias(name='"'+$a.name+'"', relationalElement=$aggFn->processAggFn($params)->at(0));
                           );
   let existingPaths = $select.paths;
   let pathInfos = $expression->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@String)->map(n|$existingPaths->filter(p|$p.first == $n))
                   ->concatenate($aggVS->map(a|  let pureType = $a.aggregateFn->functionReturnType().rawType->toOne();
                                                 pair($a.name, ^PathInformation(type=$pureType, relationalType= meta::relational::transform::fromPure::pureTypeToDataTypeMap()->get($pureType)));));

   if($noSubSelect
      ,|^$nestedQuery(
           select = ^$select(columns = $groupByColumns->concatenate($newColumns),
                             groupBy = $groupByColumns->cast(@Alias),
                             paths = $pathInfos
                    )->isolateNonTerminalGroupByQueryWithEmptyGroupingColumns($state, $extensions)
        )
      ,|
        let alias = ^TableAlias(name = 'aggreg', relationalElement=$select);
        let newData = ^RootJoinTreeNode(alias = $alias);
        let groupByAliases = $groupByColumns->map(c|let src = $c->cast(@Alias);
                                                                     ^Alias(name = $src.name,
                                                                            relationalElement = ^TableAliasColumn
                                                                                                (
                                                                                                   alias = $alias,
                                                                                                   column = ^Column
                                                                                                            (
                                                                                                               name = $src.name,
                                                                                                               type = ^meta::relational::metamodel::datatype::Integer()
                                                                                                            )
                                                                                                )
                                                                     );
                                                               );
        ^$nestedQuery(select = ^TdsSelectSqlQuery(
                                    data =$newData,
                                    columns = $groupByAliases->concatenate($newColumns),
                                    groupBy = $groupByAliases,
                                    paths = $pathInfos
                               )->isolateNonTerminalGroupByQueryWithEmptyGroupingColumns($state, $extensions),
                  currentTreeNode = if($nestedQuery.currentTreeNode->isEmpty(), | $nestedQuery.currentTreeNode, | $nestedQuery.currentTreeNode->toOne()->findOneNode($nestedQuery.select.data->toOne(), $newData))
        );
   );
}

function meta::relational::functions::pureToSqlQuery::processAggFn(v:ValueSpecification[1], params:RelationalOperationElement[*]):RelationalOperationElement[*]
{
   $v->match(
      [
         e:RoutedValueSpecification[1]|$e.value->processAggFn($params),
         f:FunctionExpression[1] |
               if($f.func == cast_Any_m__T_1__T_m_,
                  | $f.parametersValues->at(1)->cast(@ValueSpecification)->processAggFn($params),
                  |
                    newDynaFunction(
                          $f.func.functionName->toOne(),
                          $f.parametersValues->map(p|$p->processAggFn($params))
                    )
                  ),
         a:VariableExpression[1]|$params,
         i:InstanceValue[1]| if($i.values->isEmpty(),
                                | ^Literal(value=^SQLNull()),
                                |
                                   $i.values->map(v | $v->match([
                                                          s:String[1] | ^Literal(value=$s),
                                                          n:Number[1] | ^Literal(value=$n),
                                                          d:Date[1] | ^Literal(value=$d),
                                                          b:Boolean[1] | ^Literal(value=$b),
                                                          f:ValueSpecification[1]|$f->processAggFn($params),
                                                          f:LambdaFunction<Any>[1]|$f.expressionSequence->toOne()->cast(@ValueSpecification)->processAggFn($params),
                                                          a:Any[1] | fail('Unsupported aggregation operation'); [];
                                              ]));
                                );
      ]
   );
}

function meta::relational::functions::pureToSqlQuery::processTdsExtend(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processTdsProjectExtend($f, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, true, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processTdsProject(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   processTdsProjectExtend($f, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, false, $extensions);
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::processTdsProjectExtend(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], includeOriginalColumns : Boolean[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mainQuery = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let select = $mainQuery.select->cast(@TdsSelectSqlQuery);
   let funcParams = $f->genericType().typeArguments.rawType->cast(@FunctionType).parameters->tail();
   let updatedState = if(!$vars->keys()->isEmpty(),|updateFunctionParamScope($state, $funcParams->evaluateAndDeactivate(),$operation),|$state);
   let cols = $f->instanceValuesAtParameter(1, $vars, $updatedState.inScopeVars)->cast(@BasicColumnSpecification<Any>);
   let newCols = $cols->map(cs|
         let newElement = processTdsLambda($cs.func->cast(@FunctionDefinition<Any>).expressionSequence->at(0), $mainQuery.select.columns->cast(@Alias), false, $vars, $updatedState, $currentPropertyMapping, $context)->at(0);
         let alias = ^Alias(name='"'+$cs.name+'"', relationalElement=$newElement);
         let path = pair($cs.name, ^PathInformation(type=$cs.func->functionReturnType().rawType->toOne(),
                                                    relationalType = $newElement->getRelationalTypeFromRelationalPropertyMapping()));
         pair($alias,$path);
         );

   ^$mainQuery(
      select = ^$select(
         columns = if($includeOriginalColumns, | $mainQuery.select.columns, | [])->concatenate($newCols.first),
         paths= if($includeOriginalColumns, | $select.paths, | [])->concatenate($newCols.second)
         )
      );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::processTableToTDS(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{

     let mainTable = $f.parametersValues->at(0)->cast(@FunctionExpression)->getTableFromParameter();
     let mainTableAliasTDS = ^TableAlias(name = 'root', relationalElement = $mainTable->processRelation([], $nodeId, false, 0, false, [], $state, $context, $extensions));
     let joinTreeNode = ^RootJoinTreeNode(alias=$mainTableAliasTDS);
     ^SelectWithCursor(
      select = ^TdsSelectSqlQuery(
                      data =$joinTreeNode,
                      columns = $mainTable.columns->map(c |   let column = $c->cast(@Column);
                                                              let aliasName = $column.name->toOne()->addQuotesIfNoQuotes();
                                                              let tableAliasColumn = ^TableAliasColumn(alias=$mainTableAliasTDS, columnName=$column.name, column=$column);
                                                              ^Alias(name=$aliasName, relationalElement=$tableAliasColumn);),
                      paths = $mainTable.columns ->map(c |pair($c->cast(@Column).name, ^PathInformation(type=$c->cast(@Column).type->meta::relational::metamodel::datatype::dataTypeToCompatiblePureType(),
                                                                                                   relationalType = $c->cast(@Column).type)
                                                                                                  )
                                                      )
                     )
   );
 }

function <<access.private>> meta::relational::functions::pureToSqlQuery::getTableFromParameter(f:FunctionExpression[1]): NamedRelation[1]
{

   let database = $f.parametersValues->at(0)->cast(@InstanceValue).values->toOne()->cast(@Database);
   let schemaName = $f.parametersValues->at(1)->cast(@InstanceValue).values->toOne()->cast(@String);
   let relName = $f.parametersValues->at(2)->cast(@InstanceValue).values->toOne()->cast(@String);
   let schema = $database->schema($schemaName)->toOne();
   if($f.func == meta::relational::functions::database::viewReference_Database_1__String_1__String_1__View_1_, |$schema->view($relName), |$schema->table($relName))->toOne();

 }

function meta::relational::functions::pureToSqlQuery::processTdsRenameColumns(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let mainQuery = processValueSpecification($expression.parametersValues->at(0), [], $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let select = $mainQuery.select->cast(@TdsSelectSqlQuery);

   let projectColPairNames = $expression->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->match([
          p:Pair<String,String>[*] | $p,
          vss:ValueSpecification[*] | $vss->map(vs|$vs->reprocessVS()->reactivate($state.inScopeVars)->evaluateAndDeactivate()->cast(@Pair<String,String>));
         ]);
   let projectColNamesMap = $projectColPairNames->map(p|^$p(first = $p.first->addQuotesIfNecessary(), second = $p.second->addQuotesIfNecessary()))->newMap();
   let noWrappedProjectColNamesMap = $projectColPairNames->map(p|^$p(first = $p.first->stripMatchingQuotes(), second = $p.second))->newMap();

   let newAlias = ^TableAlias(name = 'rename_' + $nodeId, relationalElement=$select);
   let newData = ^RootJoinTreeNode(alias = $newAlias);

   ^$mainQuery(
      select = ^TdsSelectSqlQuery(
                  data = $newData,
                  columns =$select.columns->map(c|
                                 let newNamePair = $c->match([
                                    a:Alias[1]|
                                    let newNameStr = $projectColNamesMap->get($a.name);
                                    let newName = if($newNameStr->isEmpty(),
                                                     | $a.name,
                                                     | $newNameStr->toOne()
                                                     );
                                    pair($a.name, $newName);
                                 ]);

                                 ^Alias(
                                       name = $newNamePair.second,
                                       relationalElement = ^TableAliasColumn(
                                                                  alias=$newAlias,
                                                                  columnName = $newNamePair.second,
                                                                  column=^Column(name=$newNamePair.first, type=^meta::relational::metamodel::datatype::Integer())
                                                         )
                                       );
                                 ),
                  groupBy = []->cast(@Alias),
                  paths = $select.paths->map(p|let res = $noWrappedProjectColNamesMap->get($p.first);
                                         ^$p(first=if($res->isEmpty(),|$p.first,|$res->toOne()));)
               ),
         currentTreeNode = if($mainQuery.currentTreeNode->isEmpty(), | $mainQuery.currentTreeNode, | $mainQuery.currentTreeNode->toOne()->findOneNode($mainQuery.select.data->toOne(), $newData))
   );
}

function meta::relational::functions::pureToSqlQuery::stripMatchingQuotes(s:String[1]):String[1]
{
   if($s->startsWith('"') && $s->endsWith('"'), | $s->substring(1, $s->length()-1), | $s);
}

function meta::relational::functions::pureToSqlQuery::addQuotesIfNecessary(s:String[1]):String[1]
{
   if($s->startsWith('"') && $s->endsWith('"'), | $s, | '"' + $s + '"');
}


function meta::relational::functions::pureToSqlQuery::processTdsRestrict(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   if (shouldOptimizeRestrictDistinct($expression, $vars, $state, $context, $extensions),
       | processTdsRestrictOptimized($expression, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions),
       | processTdsRestrictNormal($expression, $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)
   )
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::shouldOptimizeRestrictDistinct(f:FunctionExpression[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):Boolean[1]
{
   let index = $state.functionExpressionStack->indexOf($f);
   let restrictFollowedByDistinct = ($index >= 1) && ($state.functionExpressionStack->at($index - 1)->evaluateAndDeactivate().func == distinct_TabularDataSet_1__TabularDataSet_1_);

   let nestedQuery = $f.parametersValues->at(0)->byPassRouterInfo()->evaluateAndDeactivate();
   let projectFollowedByRestrictBasicCols =
      $nestedQuery->instanceOf(FunctionExpression) &&
      (
         $nestedQuery->cast(@FunctionExpression).func->equal(project_K_MANY__Function_MANY__String_MANY__TabularDataSet_1_) || // Project with functions
         (
            $nestedQuery->cast(@FunctionExpression).func->equal(project_T_MANY__ColumnSpecification_MANY__TabularDataSet_1_) &&
            $nestedQuery->cast(@FunctionExpression)->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->forAll(c | $c->instanceOf(BasicColumnSpecification))
         )  // Project with column specifications and all basic cols (no window cols)
      );

   let optimizationDecision = $restrictFollowedByDistinct && $projectFollowedByRestrictBasicCols;
   print(if(!$context.debug, |'',|$context.space+'Restrict optimization decision:'+$optimizationDecision->toString()+' / Restrict followed by distinct:'+$restrictFollowedByDistinct->toString()+', Project followed by restrict (basic cols):'+$projectFollowedByRestrictBasicCols->toString()+'\n'));
   $optimizationDecision;
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::processTdsRestrictOptimized(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   // Called in the context : $collection->project(...)->restrict(...)->distinct(...)
   // Potentially cut down joins which can be generated for columns not in restrict set

   let nestedQuery = $expression.parametersValues->at(0)->byPassRouterInfo()->evaluateAndDeactivate()->cast(@FunctionExpression);
   let restrictSet = $expression->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@String);

   if ($nestedQuery.func == project_K_MANY__Function_MANY__String_MANY__TabularDataSet_1_,
       
       | // Project with functions 
         let functions = $nestedQuery->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@meta::pure::metamodel::function::Function<Any>);
         let columnNames = $nestedQuery->instanceValuesAtParameter(2, $vars, $state.inScopeVars)->cast(@String);
         $restrictSet->map(c | assert($columnNames->contains($c), | 'Project column list ' + $columnNames->map(x | '\'' + $x + '\'')->joinStrings('[', ', ', ']') + ' does not contain restrict column \'' + $c + '\''));
         
         let filteredFunctionAndNamePairs = $functions->zip($columnNames)->filter(p | $p.second->in($restrictSet));
         let columnNameToFunctionAndNamePairMap = $filteredFunctionAndNamePairs->map(p | pair($p.second, $p))->newMap();
         let orderedFunctionAndNamePairs = $restrictSet->map(c | $columnNameToFunctionAndNamePairMap->get($c));

         processProject($orderedFunctionAndNamePairs.second, $orderedFunctionAndNamePairs.first, [], $nestedQuery, $operation, $vars, $state, $nodeId, $aggFromMap, $context, [], $extensions);,

       | // Project with column specifications
         // All columns are basic columns (no window columns as per check in the shouldOptimize function)
         let columns = $nestedQuery->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@BasicColumnSpecification<Any>);
         $restrictSet->map(c | assert($columns.name->contains($c), | 'Project column list ' + $columns.name->map(x | '\'' + $x + '\'')->joinStrings('[', ', ', ']') + ' does not contain restrict column \'' + $c + '\''));

         let filteredColumns = $columns->filter(c | $c.name->in($restrictSet));
         let columnNameToColMap = $filteredColumns->map(c | pair($c.name, $c))->newMap();
         let orderedColumns = $restrictSet->map(c | $columnNameToColMap->get($c));
         
         processProject($orderedColumns.name, $orderedColumns.func, $orderedColumns->map(c|if($c.documentation->isEmpty(),|'', |$c.documentation)), $nestedQuery, $operation, $vars, $state, $nodeId, $aggFromMap, $context, [], $extensions);

   );
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::processTdsRestrictNormal(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let nestedQuery = processValueSpecification($expression.parametersValues->at(0), [], $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);

   let projectColNames = $expression->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@String);
   let projectAliasNames = $projectColNames->map(colName| $colName->addQuotesIfNecessary());

   let origSelect = $nestedQuery.select->cast(@TdsSelectSqlQuery);

   let origColumnsByName = $origSelect.columns->map(column|
         let name = $column->match([
               a:Alias[1]|$a.name,
               c:ColumnName[1]|$c.name
         ]);

         pair($name, $column);
      );
    let origColumnsByNameAsMap = $origColumnsByName->newMap();
    let origGroupByByName = $origSelect.groupBy->map(column|
         let name = $column->match([
               a:Alias[1]|$a.name,
               c:ColumnName[1]|$c.name
         ]);

         pair($name, $column);
      );

    let origSortByByName = $origSelect.orderBy.column->map(column|
         let name = $column->match([
               a:Alias[1]|$a.name,
               c:ColumnName[1]|$c.name
         ]);

         pair($name, $column);
      );

   let noSubSelectReqiured = (
                       ($origGroupByByName->isEmpty() || $projectAliasNames->containsAll($origGroupByByName.first))
                     &&
                       ($origSortByByName->isEmpty() || $projectAliasNames->containsAll($origSortByByName.first))
                     &&
                       (($origSelect.distinct->isEmpty() || !$origSelect.distinct->toOne()))
                     );

   let newCols = $projectAliasNames->map(aliasName|let origCol = $origColumnsByNameAsMap->get($aliasName); assertNotEmpty($origCol, | 'Failed to find column ' + $aliasName + ' in ' + $origColumnsByNameAsMap->keys()->joinStrings('[', ',', ']')); $origCol->toOne(););

   if($noSubSelectReqiured
      ,|
         //The query has no group bys, or they are all being projected with at least one agg remaining
         ^$nestedQuery(select = ^$origSelect(columns = $newCols, paths = $projectColNames->map(p|$origSelect.paths->filter(z|$z.first->stripMatchingQuotes() == $p->stripMatchingQuotes()))));
      ,|
         //Drop unnecessary aggregation columns from the sub query to be created
         let newSubCols = if ($origSelect.distinct == true && $origGroupByByName->isEmpty(),
               | $origSelect.columns,
               | $origColumnsByName->filter(p |
                     $projectAliasNames->contains($p.first)
                     || $origSortByByName.first->contains($p.first)
                     || $origGroupByByName.first->contains($p.first)
                     ).second;
               );

         let subSelect = ^$origSelect(columns = $newSubCols);
         let newAlias = ^TableAlias(name = 'restrict_' + $nodeId, relationalElement=$subSelect);
         let newData = ^RootJoinTreeNode(alias = $newAlias);
         ^$nestedQuery(
                  select = ^TdsSelectSqlQuery(
                                    data =$newData,
                                    columns = $newCols->map(c|
                                                let tac = ^TableAliasColumn(alias=$newAlias,
                                                                                column=^Column(name=$c->match([a:Alias[1]|$a.name, c:ColumnName[1]|$c.name]), type=^meta::relational::metamodel::datatype::Integer()));
                                                ^Alias(name=$tac.column.name, relationalElement=$tac);
                                             ),
                                    groupBy = []->cast(@Alias),
                                    paths = $projectColNames->map(p|$origSelect.paths->filter(z|$z.first->stripMatchingQuotes() == $p->stripMatchingQuotes()))
                               ),
                  currentTreeNode = if($nestedQuery.currentTreeNode->isEmpty(), | $nestedQuery.currentTreeNode, | $nestedQuery.currentTreeNode->toOne()->findOneNode($nestedQuery.select.data->toOne(), $newData))
            );
   );
}

function meta::relational::functions::pureToSqlQuery::processTdsJoin(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let swc1 = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let swc2 = processValueSpecification($f.parametersValues->at(1), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let query2 = $swc2.select->pushExtraFilteringOperation($extensions);

   let type = $f->instanceValuesAtParameter(2, $vars, $state.inScopeVars)
               ->match([ j: JoinType[1] | $j,
                         a: Any[1] | let jt = $a->cast(@FunctionExpression).parametersValues;
                                    extractEnumValue($jt->at(0)->cast(@InstanceValue).values->toOne()->cast(@Enumeration<Any>), $jt->at(1)->cast(@InstanceValue).values->cast(@String)->toOne())->cast(@JoinType);
                        ]);

    let joinCondition = $f->instanceValuesAtParameter(3, $vars, $state.inScopeVars);
    let joinOp = $joinCondition->cast(@FunctionDefinition<{TDSRow[1],TDSRow[1]->Boolean[1]}>);
    let newOpenVars = $state.inScopeVars->putAll($joinCondition->cast(@meta::pure::metamodel::function::Function<Any>)->at(0)->evaluateAndDeactivate()->openVariableValues());

    assert($joinOp->cast(@FunctionDefinition<Any>).expressionSequence->size() <= 1, 'Lambda with more than one expression are not supported yet');

    let query1WithFilter = $swc1.select->pushExtraFilteringOperation($extensions);
    let Q1isVarSetPlaceHolder = $query1WithFilter.data.alias.relationalElement->toOne()->instanceOf(VarSetPlaceHolder);
    let query1 =  if($Q1isVarSetPlaceHolder,| $query1WithFilter.data.alias.relationalElement->cast(@VarSetPlaceHolder)->toOne(),|   $query1WithFilter);
    let leftTableAlias =    ^TableAlias(name='"joinleft_"'+$nodeId, relationalElement=$query1);


    let leftAliasWithColumns = createAliasWithColumns($query1,'"joinleft_"'+$nodeId);
    let rightAlias = ^TableAlias(name='"joinright_"'+$nodeId, relationalElement=$query2);
    let aliases2 = $rightAlias->switchAliasForJoinInput($query2.columns);
    assertEmpty($leftAliasWithColumns->filter(n|$n.name->in($aliases2->map(a|$a.name))), 'Duplicate column names between input TDS are not supported');

   let element_old = processTdsLambda($joinOp.expressionSequence->at(0)->cast(@ValueSpecification), $leftAliasWithColumns->concatenate($aliases2), false, $vars, ^$state(inScopeVars=$newOpenVars), $currentPropertyMapping, $context);
   let element_new = $element_old->match([
      i: Literal[1] | let val = $i.value->cast(@Boolean);
                      if($val ,|^DynaFunction(name = 'equal', parameters = [^Literal(value=1), ^Literal(value=1)]), |^DynaFunction(name = 'equal', parameters=[^Literal(value=1), ^Literal(value=0)]));,
      a: Any[1] | $a;
   ])->cast(@Operation);

   let leftAliasForJoinNode =  if($Q1isVarSetPlaceHolder,
                                | ^TableAlias(name='"joinleft_"'+$nodeId, relationalElement=^$query1(columns=[]));
                              , |  $leftTableAlias);

   let join = ^Join(name='tdsJoin', target=$rightAlias, aliases=[pair($leftAliasForJoinNode,$rightAlias),pair($rightAlias,$leftAliasForJoinNode)],operation=$element_new->cast(@Operation)->toOne());
   let child = ^JoinTreeNode(alias=$rightAlias, join=$join, joinType=$type, database=^Database(), joinName='tdsJoin');
   let root = ^RootJoinTreeNode(alias=$leftAliasForJoinNode, childrenData=$child);
   let newAlias = ^TableAlias(name = 'tdsJoined_' + $nodeId, relationalElement=^TdsSelectSqlQuery(data=$root, columns=if($Q1isVarSetPlaceHolder,|[],|$leftAliasWithColumns->concatenate($aliases2))));
   let newData = ^RootJoinTreeNode(alias = $newAlias);

   ^$swc1(select = ^TdsSelectSqlQuery(
                                    data =$newData,
                                    columns =$leftAliasWithColumns->concatenate($aliases2)->map(cl| let als = $cl->cast(@Alias);
                                                                                                    let col = $als.relationalElement->cast(@TableAliasColumn).column;
                                                                                                    ^Alias(name=if($Q1isVarSetPlaceHolder,|$als.name->addQuotesIfNoQuotes(),|$als.name), relationalElement=^TableAliasColumn(alias=$newAlias, column=^$col(name=$als.name)));),
                                    paths = $query1->cast(@RelationalTds).paths->concatenate($query2->cast(@RelationalTds).paths)
                     ),
          currentTreeNode = $swc1->concatenate($swc2)->filter(q|$q.currentTreeNode->isNotEmpty())->map(q|$q.currentTreeNode->toOne()->findNode($q.select.data->toOne(), $newData))->first()

   );
}

function  meta::relational::functions::pureToSqlQuery::createAliasWithColumns(query:SelectSQLQuery[1],prefix:String[1]):Alias[*]
{
   let alias = ^TableAlias(name=$prefix, relationalElement=$query);
   if($query->instanceOf(VarSetPlaceHolder),
      |$query.columns->map(c|^Alias(name=$c->cast(@Column).name, relationalElement=^TableAliasColumn(alias=$alias, column=$c->cast(@Column))))
     ,|$alias->switchAliasForJoinInput($query.columns));

}

function meta::relational::functions::pureToSqlQuery::processTdsJoinOnColumns(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let query1 = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let query2 = processValueSpecification($f.parametersValues->at(1), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);

   let type = $f->instanceValuesAtParameter(2, $vars, $state.inScopeVars)->match([
      j: JoinType[1] | $j,
      a: Any[1] | let jt = $a->cast(@FunctionExpression).parametersValues;
                  extractEnumValue($jt->at(0)->cast(@InstanceValue).values->toOne()->cast(@Enumeration<Any>), $jt->at(1)->cast(@InstanceValue).values->cast(@String)->toOne())->cast(@JoinType);
   ]);

   let tds1Cols = $f->instanceValuesAtParameter(3, $vars, $state.inScopeVars)->cast(@String);
   let tds2Cols = $f->instanceValuesAtParameter(4, $vars, $state.inScopeVars)->cast(@String);

   assertNotEmpty($tds1Cols, 'No join columns specified for TDS input 1');
   assertNotEmpty($tds2Cols, 'No join columns specified for TDS input 2');
   assertEquals($tds1Cols->size(), $tds2Cols->size(), {|'Join columns from TDS input 1 and TDS input 2 must be of the same size (' + $tds1Cols->size()->makeString() + ',' + $tds2Cols->size()->makeString() + ')'});

   let Q1isVarSetPlaceHolder = $query1.select.data.alias.relationalElement->toOne()->instanceOf(VarSetPlaceHolder);
   let leftQueryWithFilter = $query1.select->pushExtraFilteringOperation($extensions);


   let rightAlias = ^TableAlias(name='"joinright_"'+$nodeId, relationalElement=$query2.select);
   let leftAlias = ^TableAlias(name='"joinleft_"'+$nodeId, relationalElement=$query1.select);

   let leftQueryProcessed =  if($Q1isVarSetPlaceHolder,| $leftQueryWithFilter.data.alias.relationalElement->cast(@VarSetPlaceHolder)->toOne(),|   $leftQueryWithFilter);


   let aliases1 = createAliasWithColumns($leftQueryProcessed,'"joinleft_"'+$nodeId);

   let aliases2 = $rightAlias->switchAliasForJoinInput($query2.select.columns);


   let joinColAliasPairs = $tds1Cols->map(c|$c->findAliasOrFail($aliases1))->zip($tds2Cols->map(c|$c->findAliasOrFail($aliases2)));

   let duplicateTds2ColNames = $aliases1.name->intersection($aliases2.name)->removeAll($joinColAliasPairs.second.name);

   assertEmpty($duplicateTds2ColNames, | 'Duplicate column names between input TDS are not supported if they are not part of the join columns' + $duplicateTds2ColNames->joinStrings(' (', ',', ')'));

   let joinOperation = $joinColAliasPairs->fold({p, r|
              let x = ^DynaFunction(name = 'equal', parameters=[$p.first.relationalElement, $p.second.relationalElement]);
              if ($r->isEmpty(),
                | $x,
                | newAndOrDynaFunctionRelaxedBrackets('and', [$r->toOne(), $x])
                );
         }, [])->toOne();


   let join = ^Join(name='tdsJoin', target=$rightAlias, aliases=[pair($leftAlias,$rightAlias),pair($rightAlias,$leftAlias)],operation=$joinOperation);
   let child = ^JoinTreeNode(alias=$rightAlias, join=$join, joinType=$type, database=^Database(), joinName='tdsJoin');
   let root = ^RootJoinTreeNode(alias=$leftAlias, childrenData=$child);

   let newColumns = if($type == JoinType.RIGHT_OUTER,
                       | $aliases1->filter(a|!if($Q1isVarSetPlaceHolder,|$a.name->addQuotesIfNoQuotes(),|$a.name)->in($aliases2.name))->concatenate($aliases2),
                       | $aliases1->concatenate($aliases2->filter(a|!if($Q1isVarSetPlaceHolder,|$a.name->addQuotesIfNoQuotes(),|$a.name)->in($aliases1.name)))
                       );


   let newAlias = ^TableAlias(name = 'tdsJoined_' + $nodeId, relationalElement=^TdsSelectSqlQuery(data=$root, columns=$newColumns));
   let newData = ^RootJoinTreeNode(alias = $newAlias);

   ^$query1(
            select = ^TdsSelectSqlQuery(
                                    data =$newData,
                                    columns =$newColumns->map(cl|if($Q1isVarSetPlaceHolder,
                                                                  |let als = $cl->cast(@Alias);
                                                                   let col = $als.relationalElement->cast(@TableAliasColumn).column;
                                                                   ^Alias(name=$als.name->addQuotesIfNoQuotes(), relationalElement=^TableAliasColumn(alias=$newAlias, column=^$col(name=$als.name)));
                                                                , |$newAlias->switchAliasForJoinInput($cl) )),
                                     paths = if($type == JoinType.RIGHT_OUTER,
                                               | $query2.select->cast(@RelationalTds).paths->concatenate($leftQueryProcessed->cast(@RelationalTds).paths->filter(p|!$p.first->in($query2.select->cast(@RelationalTds).paths.first))),
                                               | $leftQueryProcessed->cast(@RelationalTds).paths->concatenate($query2.select->cast(@RelationalTds).paths->filter(p|!$p.first->in($leftQueryProcessed->cast(@RelationalTds).paths.first)))
                                               )
                     ),
            currentTreeNode = $query1->concatenate($query2)->filter(q|$q.currentTreeNode->isNotEmpty())->map(q|$q.currentTreeNode->toOne()->findNode($q.select.data->toOne(), $newData))->first(),
            positionBeforeLastApplyJoinTreeNode = []
            );

}

function meta::relational::functions::pureToSqlQuery::processTdsContains(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let funcs = $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@meta::pure::metamodel::function::Function<Any>);

   let tdsSelect_PreFilter = processValueSpecification($f.parametersValues->at(2), [], ^SelectWithCursor(select=^SelectSQLQuery()), $vars, defaultState($state.mapping, $state.inScopeVars), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let tdsSelect = $tdsSelect_PreFilter.select->pushExtraFilteringOperation($extensions);
   let tdsColumns = $tdsSelect.data.alias.relationalElement->toOne()->match([
      v: VarSetPlaceHolder[1] | $v.columns,
      r: RelationalOperationElement[1] | $tdsSelect.columns;
   ]);
   let leftTableAlias = ^TableAlias(name='"tdsContains_TDS_"'+$nodeId, relationalElement=$tdsSelect);
   let leftSelect = ^SelectSQLQuery(data = ^RootJoinTreeNode(alias = $leftTableAlias));

   let leftAliasWithColumns  =  if($tdsSelect.data.alias.relationalElement->toOne()->instanceOf(VarSetPlaceHolder),
                                     |$tdsSelect.data.alias.relationalElement->toOne()->cast(@VarSetPlaceHolder).columns->map(c| ^TableAliasColumn(alias=$leftTableAlias, column=$c->cast(@Column)))
                                    ,|$leftTableAlias->switchAliasForJoinInput($tdsSelect.columns).relationalElement);

   assertEquals($funcs->size(), $tdsColumns->size(), | 'Number of functions doesn\'t match TDS columns, Functions number: ' + $funcs->size()->toString() + ', TDSColumns number: ' + $tdsColumns->size()->toString());

   let allFunctionsEndWithDataType = $funcs->fold({f,a| $a && $f->functionReturnType().rawType->toOne()->instanceOf(DataType) }, true)->toOne();
   if ($allFunctionsEndWithDataType == false, | fail('All the paths provided to tdsContains need to end with a DataType'),| []);

   let processedMaps = $funcs->map(fn | let builtMapExpr = ^SimpleFunctionExpression(func=map_T_MANY__Function_1__V_MANY_, functionName='map', importGroup=system::imports::coreImport, genericType=^GenericType(rawType=Any), multiplicity=ZeroMany, parametersValues=[$f.parametersValues->at(0), ^InstanceValue(genericType=^GenericType(rawType=meta::pure::metamodel::function::Function), multiplicity=PureOne, values=$fn)])->evaluateAndDeactivate();
                                        processMap($builtMapExpr, $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions).element->toOne()->cast(@SelectWithCursor);
                                  );
   let mergedSQL = $processedMaps->map(s|$s->extractSelectSQLQuery())->mergeSQLQueryData($nodeId, $state, $context, $extensions);
   let res = ^$operation(
      select = $state.inFilter->if(
         | ^$mergedSQL(filteringOperation = ^DynaFunction(name = 'exists', parameters = ^$leftSelect(columns = ^Literal(value=1), filteringOperation = $mergedSQL.filteringOperation->size()->range()->map(id | ^DynaFunction(name = 'equal', parameters=[$mergedSQL.filteringOperation->at($id), $leftAliasWithColumns->at($id)]))->andFilters($extensions) ))),
         | ^$mergedSQL(columns = ^DynaFunction(name = 'exists', parameters = ^$leftSelect(columns = ^Literal(value=1), filteringOperation = $mergedSQL.columns->size()->range()->map(id | ^DynaFunction(name = 'equal', parameters=[$mergedSQL.columns->at($id), $leftAliasWithColumns->at($id)]))->andFilters($extensions) )))
      ),
      currentTreeNode = [],
      positionBeforeLastApplyJoinTreeNode = []
   );
}

function meta::relational::functions::pureToSqlQuery::processTdsContainsWithLambda(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let funcs = $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@meta::pure::metamodel::function::Function<Any>);
   let ids = $f->instanceValuesAtParameter(2, $vars, $state.inScopeVars)->cast(@String);

   let tdsSelect_PreFilter = processValueSpecification($f.parametersValues->at(3), [], ^SelectWithCursor(select=^SelectSQLQuery()), $vars, defaultState($state.mapping, $state.inScopeVars), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let tdsSelect = $tdsSelect_PreFilter.select->pushExtraFilteringOperation($extensions);
   let rightTableAlias = ^TableAlias(name='"tdsContains_TDS_"'+$nodeId, relationalElement=$tdsSelect);
   let rightSelect = ^SelectSQLQuery(data = ^RootJoinTreeNode(alias = $rightTableAlias));

   let rightAliasWithColumns  =  if($tdsSelect.data.alias.relationalElement->toOne()->instanceOf(VarSetPlaceHolder),
                                     |$tdsSelect.data.alias.relationalElement->toOne()->cast(@VarSetPlaceHolder).columns->map(c| ^Alias(name=$c->cast(@Column).name, relationalElement=^TableAliasColumn(alias=$rightTableAlias, column=$c->cast(@Column))))
                                    ,|$rightTableAlias->switchAliasForJoinInput($tdsSelect.columns));

   assertEquals($funcs->size(), $ids->size(), | 'Number of functions doesn\'t match Ids, Functions number: ' + $funcs->size()->toString() + ', Ids number: ' + $ids->size()->toString());

   let allFunctionsEndWithDataType = $funcs->fold({f,a| $a && $f->functionReturnType().rawType->toOne()->instanceOf(DataType) }, true)->toOne();
   if ($allFunctionsEndWithDataType == false, | fail('All the paths provided to tdsContains need to end with a DataType'),| []);

   let processedMaps = $funcs->map(fn | let builtMapExpr = ^SimpleFunctionExpression(func=map_T_MANY__Function_1__V_MANY_, functionName='map', importGroup=system::imports::coreImport, genericType=^GenericType(rawType=Any), multiplicity=ZeroMany, parametersValues=[$f.parametersValues->at(0), ^InstanceValue(genericType=^GenericType(rawType=meta::pure::metamodel::function::Function), multiplicity=PureOne, values=$fn)])->evaluateAndDeactivate();
                                        processMap($builtMapExpr, $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions).element->toOne()->cast(@SelectWithCursor);
                                  );
   let mergedSQL = $processedMaps->map(s|$s->extractSelectSQLQuery())->mergeSQLQueryData($nodeId, $state, $context, $extensions);

   let leftAliasWithColumns = $state.inFilter->if(|$mergedSQL.filteringOperation->zip($ids)->map(p | ^Alias(name=$p.second, relationalElement=$p.first)), |$mergedSQL.columns->zip($ids)->map(p|^Alias(name=$p.second, relationalElement=$p.first)));

   assertEmpty($leftAliasWithColumns->filter(n|$n.name->in($rightAliasWithColumns->map(a|$a.name))), 'Duplicate names among Ids and right TDS are not supported');

   let crossOp = $f->instanceValuesAtParameter(4, $vars, $state.inScopeVars)->cast(@FunctionDefinition<Any>);
   let newOpenVars = $state.inScopeVars->putAll($crossOp->cast(@meta::pure::metamodel::function::Function<Any>)->at(0)->evaluateAndDeactivate()->openVariableValues());
   let filterOp = $crossOp.expressionSequence->evaluateAndDeactivate()->at(0)->processTdsLambda($leftAliasWithColumns->concatenate($rightAliasWithColumns), false, $vars, ^$state(inScopeVars=$newOpenVars), $currentPropertyMapping, $context);

   let res = ^$operation(
      select = $state.inFilter->if(
         | ^$mergedSQL(filteringOperation = ^DynaFunction(name = 'exists', parameters = ^$rightSelect(columns = ^Literal(value=1), filteringOperation = $filterOp ))),
         | ^$mergedSQL(columns = ^DynaFunction(name = 'exists', parameters = ^$rightSelect(columns = ^Literal(value=1), filteringOperation = $filterOp )))
      ),
      currentTreeNode = [],
      positionBeforeLastApplyJoinTreeNode = []
   );
}

function meta::relational::functions::pureToSqlQuery::processColumnProjectionsFromRoot(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let query1_preFilter = processValueSpecification($f.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor).select;
   let query1 = $query1_preFilter->pushExtraFilteringOperation($extensions);

   let relationParameter = $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@NamedRelation)->toOne();
   let columnNames = $f->instanceValuesAtParameter(2, $vars, $state.inScopeVars)->cast(@String);
   let distinct = $f->instanceValuesAtParameter(3, $vars, $state.inScopeVars)->cast(@Boolean);
   let limit = $f->instanceValuesAtParameter(4, $vars, $state.inScopeVars)->cast(@Integer)->map(i|^Literal(value=$i));

   assert($relationParameter.columns->cast(@Column).name->containsAll($columnNames), 'Column names should be from the relation');
   assert($columnNames->size() == $columnNames->distinct()->size(), 'Duplicate column names are not allowed');

   let relationColumns = $relationParameter.columns->cast(@Column);
   let toProjectColumns = $columnNames->map(x | $relationColumns->filter(y | $y.name == $x)->toOne());
   let colNameGenerationFunction = {c:Column[1] | 'gen_col_projection_' + $c.name->removeQuotes()->replace(' ', '_')};

   let queryWithAddedColumns = $query1->recursiveAddColumnsToRoot($toProjectColumns, $colNameGenerationFunction);

   let innerAlias = ^TableAlias(name = 'root', relationalElement = $queryWithAddedColumns);

   let select = ^RelationDataSelectSqlQuery
                 (
                    relation = $relationParameter,
                    distinct = $distinct->isEmpty()->if(|[],|$distinct->toOne()),
                    toRow = $limit->isEmpty()->if(|[],|$limit->toOne()),
                    columns = $toProjectColumns->map(x | ^Alias(name=$x.name->addQuotesIfNoQuotes(), relationalElement=^TableAliasColumn(alias=$innerAlias, column=^Column(name=$colNameGenerationFunction->eval($x), type=$x.type)))),
                    data = ^RootJoinTreeNode
                            (
                               alias = $innerAlias
                            ),
                    columnSubset = $toProjectColumns
                 );

   ^$operation(
      select = $select,
      currentTreeNode = [],
      positionBeforeLastApplyJoinTreeNode = []
   );
}

function <<access.protected>> meta::relational::functions::pureToSqlQuery::recursiveAddColumnsToRoot(query: SelectSQLQuery[1], columns: Column[*], columnNameGenerationFunction: meta::pure::metamodel::function::Function<{Column[1]->String[1]}>[1]):SelectSQLQuery[1]
{
   let queryData = $query.data->toOne();
   let queryAlias = $queryData.alias;
   let rootRelElement = $queryAlias.relationalElement;

   $rootRelElement->match([
      s: ViewSelectSQLQuery[1] | let columnAliases = $columns->map(x | ^Alias(name=$columnNameGenerationFunction->eval($x), relationalElement=^TableAliasColumn(alias = $queryAlias, column = ^$x(name = $columnNameGenerationFunction->eval($x)))));
                                 ^$query
                                  (
                                     columns = $query.columns->concatenate($columnAliases),
                                     groupBy = if($query.groupBy->isEmpty(), | [], | $query.groupBy->concatenate($columnAliases.relationalElement)),
                                     data    = ^$queryData(alias = ^$queryAlias(relationalElement = ^$s(selectSQLQuery = $s.selectSQLQuery->recursiveAddColumnsToRoot($columns, $columnNameGenerationFunction))))
                                  );,
      t: Table[1]              | let columnAliases = $columns->map(x | ^Alias(name=$columnNameGenerationFunction->eval($x), relationalElement=^TableAliasColumn(alias=$queryAlias, column=$x)));
                                 ^$query
                                  (
                                     columns = $query.columns->concatenate($columnAliases),
                                     groupBy = if($query.groupBy->isEmpty(), | [], | $query.groupBy->concatenate($columnAliases.relationalElement))
                                  );,
      s: SelectSQLQuery[1]     | let columnAliases = $columns->map(x | ^Alias(name=$columnNameGenerationFunction->eval($x), relationalElement=^TableAliasColumn(alias = $queryAlias, column = ^$x(name = $columnNameGenerationFunction->eval($x)))));
                                 ^$query
                                  (
                                     columns = $query.columns->concatenate($columnAliases),
                                     groupBy = if($query.groupBy->isEmpty(), | [], | $query.groupBy->concatenate($columnAliases.relationalElement)),
                                     data    = ^$queryData(alias = ^$queryAlias(relationalElement = $s->recursiveAddColumnsToRoot($columns, $columnNameGenerationFunction)))
                                  );
   ]);
}


function <<access.private>> meta::relational::functions::pureToSqlQuery::switchAliasForJoinInput(newAlias : TableAlias[1], columns : RelationalOperationElement[*]):Alias[*]
{
   $columns->map(cl|
      let als = $cl->cast(@Alias);
      $als.relationalElement->match([
            tac : TableAliasColumn[1] | let col = $tac.column; ^Alias(name=$als.name, relationalElement=^TableAliasColumn(alias=$newAlias , column=^$col(name=$als.name)));,
            cn : ColumnName[1] | ^Alias(name=$als.name, relationalElement=^TableAliasColumn( alias = $newAlias, column = ^Column(name = $cn.name, type = ^meta::relational::metamodel::datatype::Integer())));,
            l: Literal[1] | ^Alias(name=$als.name, relationalElement=^TableAliasColumn( alias = $newAlias, column = ^Column(name = $als.name, type = ^meta::relational::metamodel::datatype::Integer())));,
            o:Operation[1] |  ^Alias(name=$als.name, relationalElement=^TableAliasColumn(alias=$newAlias, column=^Column(name = $als.name, type = ^meta::relational::metamodel::datatype::Integer()))),
            o:WindowColumn[1] |  ^Alias(name=$als.name, relationalElement=^TableAliasColumn(alias=$newAlias, column=^Column(name = $als.name, type = ^meta::relational::metamodel::datatype::Integer()))),
            df: DynaFunction[1] |
               ^Alias(
                  name=$als.name,
                  relationalElement=^TableAliasColumn( alias = $newAlias, column = ^Column(name = $als.name, type = ^meta::relational::metamodel::datatype::Integer()))
               );
         ]);
   );
}

function meta::relational::functions::pureToSqlQuery::findColumnInTdsFromGetter(f:FunctionExpression[1], tdsAliases:Alias[*],returnColumnName:Boolean[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1]):RelationalOperationElement[*]
{
    let propertyName =  $f.parametersValues->at(1)->match([ iv:InstanceValue[1]|$iv.values,
                                                            ve:VariableExpression[1]|let res = $ve->resolve($vars, $state.inScopeVars);
                                                                                     $res->cast(@InstanceValue).values;
                                                          ])->toOne()->toString()->addQuotesIfNecessary();


    let foundColumn = $tdsAliases->filter(a|$a->match([a:Alias[1]|$a.name->addQuotesIfNecessary() == $propertyName,
                                                       t:TableAliasColumn[1]| $propertyName == $t.column.name->addQuotesIfNecessary(),
                                                       w:WindowColumn[1]| $w.columnName->addQuotesIfNecessary()==$propertyName])); //TODO: I think this case can be removed - WindowColumn isn't a subtype of Alias?

    assertNotEmpty($foundColumn, {|'The column \''+$propertyName+'\' can\'t be found in the TDS ('+$tdsAliases.name->makeString(',')+')'});

    let funcName = $f.func.functionName;

    if($returnColumnName,
       {|
          assert($funcName->isEmpty() || !['isNull', 'isNotNull']->contains($funcName->toOne()), | $funcName->makeString() + ' can not be used to return column name');

          $foundColumn->map(c|^ColumnName(name=$c->match([a:Alias[1]|$a.name ,w:WindowColumn[1]| $w.columnName,t:TableAliasColumn[1]| $t.column.name])));
       },
       {|
          let foundCol = $foundColumn->map(c|$c->match([ a:Alias[1]| $a.relationalElement,r:RelationalOperationElement[1]|$r]));

          if($funcName =='isNull',
                   | ^DynaFunction(name = 'isNull', parameters = $foundCol->toOne()),
                   | if ($funcName =='isNotNull',
                         | ^DynaFunction(name = 'isNotNull', parameters = $foundCol->toOne()),
                         | $foundCol
                         )
                   );
       });
}

function meta::relational::functions::pureToSqlQuery::addQuotesIfNoQuotes(aliasName:String[1]):String[1]
{
    if($aliasName->startsWith('"'),| $aliasName ,|'"'+$aliasName+'"');
}

function meta::relational::functions::pureToSqlQuery::processTdsLambda(mapFn:ValueSpecification[1], a:Alias[*],returnColumnName:Boolean[1],vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], currentPropertyMapping:PropertyMapping[*], context:DebugContext[1]):RelationalOperationElement[*]
{
   $mapFn->match(
                  [
                     r:FunctionRoutedValueSpecification[1]|$r.value->processTdsLambda($a,$returnColumnName, $vars, $state, $currentPropertyMapping, $context),
                     f:FunctionExpression[1]|
                        let dispatch = [
                           pair('getNumber', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('getInteger', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('getString', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('getFloat', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('getDate', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('getDateTime', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('getStrictDate', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('getBoolean', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('getEnum', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('isNull', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state)),
                           pair('isNotNull', | findColumnInTdsFromGetter($f, $a,$returnColumnName, $vars, $state))
                        ];

                        let func = $dispatch->filter(d|$d.first == $f.func.functionName);
                        
                        if($func->isNotEmpty(),
                                 |$func->toOne().second->cast(@meta::pure::metamodel::function::Function<{->RelationalOperationElement[*]}>)->eval(),
                                 |
                                    let supportedFunction = findSupportedFunction($f, $state.supportedFunctions, $state.contextBasedSupportedFunctions);
                                  
                                    if($supportedFunction->isNotEmpty(),
                                       | if($f.func == extractEnumValue_Enumeration_1__String_1__T_1_,
                                            | ^Literal(value=extractEnumValue($f, $currentPropertyMapping, $context)),
                                            | if($f.func == meta::pure::functions::string::plus_String_MANY__String_1_,
                                                 | ^JoinStrings(strings=$f.parametersValues->map(p|$p->processTdsLambda($a,$returnColumnName, $vars, $state, $currentPropertyMapping, $context))),
                                                 | if ($f.func == meta::pure::functions::collection::in_Any_1__Any_MANY__Boolean_1_,
                                                       | let arg1 = $f.parametersValues->at(0)->processTdsLambda($a, $returnColumnName, $vars, $state, $currentPropertyMapping, $context);
                                                         let arg2 = $f.parametersValues->at(1)->processTdsLambda($a, $returnColumnName, $vars, $state, $currentPropertyMapping, $context);
                                                         let dynaParams = $arg1->concatenate($arg2->match([ll:Literal[*] | ^LiteralList(values = $ll), r:RelationalOperationElement[*] | $r]));
                                                         newDynaFunction($f.func.functionName->toOne(), $dynaParams);,
                                                       | if ($supportedFunction == processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_,
                                                          | $f.parametersValues->at(0)->processTdsLambda($a,$returnColumnName, $vars, $state, $currentPropertyMapping, $context),
                                                          | newDynaFunction($f.func.functionName->toOne(), $f.parametersValues->map(p|$p->processTdsLambda($a,$returnColumnName, $vars, $state, $currentPropertyMapping, $context))))
                                                   )
                                              )
                                            ),
                                       | fail('function ' + $f.func.name->makeString() + ' is not yet supported'); ^DynaFunction(name='fail');
                                       );
                         );                        
                     ,i:InstanceValue[1]| let transformedValues = $i.values->map(v | $v->match([
                                                          s:String[1] | ^Literal(value=$s),
                                                          n:Number[1] | ^Literal(value=$n),
                                                          d:Date[1] | ^Literal(value=$d),
                                                          b:Boolean[1] | ^Literal(value=$b),
                                                          e:Enum[1] | ^Literal(value=$e),
                                                          e:Enumeration<Any>[1] | ^Literal(value=$e),
                                                          f:SimpleFunctionExpression[1]|$f->processTdsLambda($a, $returnColumnName, $vars, $state, $currentPropertyMapping, $context),
                                                          i:InstanceValue[1]|$i->processTdsLambda($a, $returnColumnName, $vars, $state, $currentPropertyMapping, $context),
                                                          f:FunctionDefinition<Any>[1]|$f.expressionSequence->at(0)->processTdsLambda($a, $returnColumnName,$vars, $state, $currentPropertyMapping, $context),
                                                          v:PlanVarPlaceHolder[1]| ^Literal(value=^VarPlaceHolder(name=$v.name,type = $v.type, multiplicity = $v.multiplicity))
                                              ]));
                                          if($transformedValues->isNotEmpty(),
                                             | $transformedValues,
                                             | ^Literal(value = ^SQLNull())
                                          );
                     ,v:VariableExpression[1] | let res = $v->resolve($vars, $state.inScopeVars);
                                                processTdsLambda($res->toOne(), $a, $returnColumnName, $vars, $state, $currentPropertyMapping, $context);

                  ]
                );
}

function meta::relational::functions::pureToSqlQuery::processPath(pa:Path<Nil,Any|*>[1], pathName:String[1], counter:String[1], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
     let projection = $pa.path->fold(
                         {p, container |  let property = $p->cast(@PropertyPathElement).property;
                                     let propertyReturnType = $property.genericType.rawType->toOne();
                                     $property->evaluateAndDeactivate()->match(
                                                             [
                                                                p:Property<Nil,Any|1>[1] | let res = processProperty($property, $container.returnType->cast(@Class<Any>), $container.currentPropertyMapping, $state.propertyMappingFromRouter, $container.element->cast(@SelectWithCursor), $state, JoinType.LEFT_OUTER, buildNodeId($nodeId,$container.id+$counter), $aggFromMap, $context->shift(), $extensions);
                                                                                           ^ProjectionContainer(returnType=$propertyReturnType, element=$res.element, id=$container.id+'1', currentPropertyMapping=$res.currentPropertyMapping);
                                                                                           ,
                                                                q:QualifiedProperty<Any>[1]|  let milestoningContext = getMilestoningContextForPropertyPathQualifiedProperty($q, $p->cast(@PropertyPathElement)->mapVariables(), ^$state(qualifierBase=^OperationWithParentPropertyMapping(currentPropertyMapping=$container.currentPropertyMapping, element=$container.element)));
                                                                                              let op = $container.element->cast(@SelectWithCursor);
                                                                                              let opWithMilestoningContext = if($milestoningContext->isNotEmpty(),|^$op(milestoningContext=$milestoningContext),|^$op(milestoningContext=[]));
                                                                                              let queryBranch = processQualifiedProperty($q, $container.currentPropertyMapping, $opWithMilestoningContext, $p->cast(@PropertyPathElement)->mapVariables(), ^$state(qualifierBase=^OperationWithParentPropertyMapping(currentPropertyMapping=$container.currentPropertyMapping, element=$opWithMilestoningContext)), JoinType.LEFT_OUTER, buildNodeId($nodeId,$container.id+$counter), $aggFromMap, $context->shift(), $extensions);
                                                                                              let currentPropertyMapping= if($q->hasGeneratedMilestoningPropertyStereotype(),|$queryBranch.currentPropertyMapping,|[]);
                                                                                              let queryBranchOp = $queryBranch.element->cast(@SelectWithCursor);
                                                                                              let operationWithPropagatedContext = ^$queryBranchOp(milestoningContext=$opWithMilestoningContext.milestoningContext);
                                                                                              ^ProjectionContainer(returnType=$propertyReturnType, element=$operationWithPropagatedContext, id=$container.id+'1', currentPropertyMapping=$currentPropertyMapping);
                                                             ]
                                                       );

                         }
                         ,
                         ^ProjectionContainer(returnType=$pa.start.rawType->toOne(), element=$operation, id='')
                      );

     let joinResult = $projection.element->cast(@SelectWithCursor);

     print(if(!$context.debug, |'',
              | $context.space+'   (P)'+$pa.path->last()->cast(@PropertyPathElement).property.name->toOne()+'>  '+$joinResult->cast(@SelectWithCursor).select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));


     let selectWithCursor = if ($state.inFilter,
                                   |$joinResult,
                                   |let select = $joinResult->cast(@SelectWithCursor).select;
                                    ^$joinResult
                                    (
                                       select=^$select(
                                          columns=if($select.columns->isEmpty(), | [], | ^Alias(name='"'+$pathName+'"',relationalElement = $select.columns->toOne()))
                                       )
                                    );
                             );
   ^OperationWithParentPropertyMapping(element=$selectWithCursor, currentPropertyMapping= $projection.currentPropertyMapping);
}

function meta::relational::functions::pureToSqlQuery::removeUnionColumnsAndJoins(u:Union[1]):Union[1]
{
   let newQueriesAndCurrentTreeNodes = $u.queries->zip($u.currentTreeNodes)->map(p| let newQuery=removeSelectColumnsAndJoins($p.first, $p.second).first; let newCurrentTreeNode = $p.second->findOneNode($p.first.data->toOne(), $newQuery.data->toOne()); pair($newQuery, $newCurrentTreeNode););
   ^$u(queries=$newQueriesAndCurrentTreeNodes.first, currentTreeNodes = $newQueriesAndCurrentTreeNodes.second);
}

function meta::relational::functions::pureToSqlQuery::removeSelectColumnsAndJoins(s:SelectSQLQuery[1], ctn:RelationalTreeNode[0..1]):Pair<SelectSQLQuery, RelationalTreeNode>[1]
{
  let oldNode = if($s.leftSideOfFilter->isEmpty(),| $ctn,| $s.leftSideOfFilter)->toOne();
  let newNode = $oldNode.alias.relationalElement->match([
                                                            u:Union[1] | let alias = $oldNode.alias;
                                                                        let newAlias = ^$alias(relationalElement=removeUnionColumnsAndJoins($u));
                                                                        ^$oldNode(childrenData = [], alias=$newAlias);,
                                                            a:Any[1] |   ^$oldNode(childrenData=[]);
                                                        ]);
  let newRoot = $s.data->toOne()->replaceTreeNode($oldNode, $newNode)->cast(@RootJoinTreeNode);
  let allNodes = $newRoot->getAllNodes()->cast(@RelationalTreeNode);
  let newSelect = ^$s(columns = [],
                      data = $newRoot,
                      filteringOperation = [],
                      savedFilteringOperation = $s.savedFilteringOperation->map(p|pair(if($p.first == $oldNode,|$newNode,|$p.first), $p.second))->filter(s|$allNodes->contains($s.first)),
                      leftSideOfFilter = [],
                      extraFilteringOperation = []);
  pair($newSelect, $newNode);
}

function meta::relational::functions::pureToSqlQuery::removeColumnsAndJoins(query:SelectWithCursor[1], nodeId:String[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let isDistinct = $query.select.distinct == true;
   let selectAndCurrentTreeNode = if($isDistinct,
                                          | let selectMoved = moveSelectQueryToSubSelect($query.select, $query.currentTreeNode, [], $nodeId, $context, $extensions);
                                            pair($selectMoved, $selectMoved.data->toOne());,
                                          | removeSelectColumnsAndJoins($query.select, $query.currentTreeNode));

   ^SelectWithCursor(
         select = $selectAndCurrentTreeNode.first,
         currentTreeNode = $selectAndCurrentTreeNode.second,
         positionBeforeLastApplyJoinTreeNode=[],
         milestoningContext = $query.milestoningContext
   );
}

function meta::relational::functions::pureToSqlQuery::processProjectFunction(f:meta::pure::metamodel::function::Function<Any>[1], index:Integer[1], ids:String[*], query:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):OperationWithParentPropertyMapping[1]
{
   let newState = ^$state(processingProjectionThread=true, inFilter=false);
   $f->match(
         [
            pa:Path<Nil,Any|1>[1] |
               let pathName = $ids->at($index);
               let counter = '_'+$index->toString();
               processPath($pa, $pathName, $counter, $query, $vars, $newState, $nodeId, $aggFromMap, $context->shift(), $extensions);
            ,
            f:FunctionDefinition<Any>[1] |
               let newStateUpdated = $newState->updateFunctionParamScope($f.classifierGenericType.typeArguments.rawType->toOne()->cast(@FunctionType),$query);
               let id = $ids->at($index);
               let expression = $f.expressionSequence;
               assertEquals(1, $expression->size(), 'Qualifiers with more than one functionExpression are not supported yet!');
               let result = processValueSpecificationReturnPropertyMapping($expression->toOne(), [], $query, $vars, $newStateUpdated, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context->shift(), $extensions)->toOne();
               let selectWithCursor = $result.element->cast(@SelectWithCursor);
               ^OperationWithParentPropertyMapping(element= ^$selectWithCursor(select = $selectWithCursor.select->buildSimpleSQL($id)), currentPropertyMapping = $result.currentPropertyMapping);
         ]
   );
}

function meta::relational::functions::pureToSqlQuery::processProjectPaths(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let paths=$f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@Path<Nil,Any|*>);
   $paths->validatePaths();
   processProject($paths->map(p|$p->buildColumnNameOutOfPath()), $paths, [], $f, $operation, $vars, $state, $nodeId, $aggFromMap, $context,[], $extensions);
}

function meta::relational::functions::pureToSqlQuery::processProjectFunctions(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let ids = $f->instanceValuesAtParameter(2, $vars, $state.inScopeVars)->cast(@String);
   let funcs = $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@meta::pure::metamodel::function::Function<Any>);
   processProject($ids, $funcs, [], $f, $operation, $vars, $state, $nodeId, $aggFromMap, $context,[], $extensions);
}

function meta::relational::functions::pureToSqlQuery::processProjectWithColumnSubset(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{

  let columnsDetails = $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->filter(c|$c->instanceOf(BasicColumnSpecification))->cast(@BasicColumnSpecification<Any>);
  let windowColumns =  $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->filter(c|$c->instanceOf(WindowColumnSpecification))->cast(@WindowColumnSpecification<Any>);
  let columnNames = $f->instanceValuesAtParameter(2, $vars, $state.inScopeVars)->cast(@String);
  let filteredColumns = $columnsDetails->filter( y | $columnNames->contains( $y.name ) );

  $columnNames->map(i | assert($filteredColumns.name->contains($i), 'subset / filteredColumns should exists in projected Column Names'));

  processProject($filteredColumns.name , $filteredColumns.func, $filteredColumns->map(c|if($c.documentation->isEmpty(),|'', |$c.documentation)), $f, $operation, $vars, $state, $nodeId, $aggFromMap, $context,$windowColumns, $extensions);
}


function meta::relational::functions::pureToSqlQuery::processProjectWithColumnSubsetFunctions(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
  let functions = $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->cast(@meta::pure::metamodel::function::Function<Any>);
  let columnIds = $f->instanceValuesAtParameter(2, $vars, $state.inScopeVars)->cast(@String);
  let filteredIds = $f->instanceValuesAtParameter(3, $vars, $state.inScopeVars)->cast(@String);
  $filteredIds->map(i | assert($columnIds->contains($i), 'subset / filteredColumns should exists in projected Column Names'));
  let filteredFunctionIDPairs = $functions->zip($columnIds)->filter(p|$p.second->in( $filteredIds  ));

  processProject($filteredFunctionIDPairs.second , $filteredFunctionIDPairs.first, [], $f, $operation, $vars, $state, $nodeId, $aggFromMap, $context,[], $extensions);
}

function meta::relational::functions::pureToSqlQuery::processProjectColumns(f:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let columns = $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->filter(c|$c->instanceOf(BasicColumnSpecification))->cast(@BasicColumnSpecification<Any>);
   let windowColumns =  $f->instanceValuesAtParameter(1, $vars, $state.inScopeVars)->filter(c|$c->instanceOf(WindowColumnSpecification))->cast(@WindowColumnSpecification<Any>);
   processProject($columns.name, $columns.func, $columns->map(c|if($c.documentation->isEmpty(),|'', |$c.documentation)), $f, $operation, $vars, $state, $nodeId, $aggFromMap, $context,$windowColumns, $extensions);
}

function meta::relational::functions::pureToSqlQuery::getRootPrimaryKeyCols(source: SelectSQLQuery[1], sourceColumns: RelationalOperationElement[*], state:State[1], expression:FunctionExpression[1]):Pair<List<RelationalOperationElement>, RootJoinTreeNode>[1]
{
   let setImpl               = getAllExpressionSetImplementations($expression);
   let setImplPrimaryKeys    = $setImpl->map(x|$x->resolvePrimaryKey());
   assert($setImplPrimaryKeys->isNotEmpty(),|'Root primary key addition is only valid for classes which have PKs available.  This is not the case for Class:'+$setImpl.id->toOne());
   let setImplPrimaryKeyCols = $setImplPrimaryKeys->cast(@TableAliasColumn).column;
   let sourceColumnsNames    = $sourceColumns->cast(@Alias)->map(r|$r.relationalElement->match([t:TableAliasColumn[1] | $t.column.name, a:Any[1] | []]));
   let keysToAdd             = $setImplPrimaryKeyCols->map(c|let columnName = $c.name; if(!$columnName->in($sourceColumnsNames), | ^Alias(name='"'+$columnName+'"', relationalElement=^TableAliasColumn(alias=$source.data.alias->toOne(), column=$c)), |[]););
   assertFalse($keysToAdd.name->fold({k,a| $a || $sourceColumns->cast(@Alias).name->contains($k)},false), {|'Unable to add PKs, Alias name conflict, attempting to add: '+$keysToAdd.name->makeString(',')+' to: '+$sourceColumns->cast(@Alias).name->makeString(',')});

   $source.data.alias->toOne().relation()->match([ t:Table[1] | pair(^List<RelationalOperationElement>(values = $keysToAdd), $source.data->toOne());,
                                          select:SelectSQLQuery[1] | let possiblePKsWithUpdatedData = $select->getRootPrimaryKeyCols($select.columns, $state, $expression);
                                                                     let newSelect = ^$select(columns = $select.columns->concatenate($possiblePKsWithUpdatedData.first.values), data = $possiblePKsWithUpdatedData.second);

                                                                     let oldData = $source.data->toOne();
                                                                     let oldAlias = $oldData.alias;
                                                                     let newData = ^$oldData(alias = ^$oldAlias(relationalElement = $newSelect));
                                                                     pair(^List<RelationalOperationElement>(values = $keysToAdd), $newData);,
                                          a:Any[1] | fail('Addition of root primary primary keys in project is only available for Tables and SelectSQLQuery: found: '+ $a->type()->toString()); pair(^List<RelationalOperationElement>(values = $sourceColumns), $source.data->toOne());]);
}

function meta::relational::functions::pureToSqlQuery::processWindowColumns(cols:WindowColumnSpecification<Any>[*],newQuery:SelectWithCursor[1],mainSelect:SelectSQLQuery[1],vars:Map<VariableExpression, ValueSpecification>[1],state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[*]
{
   let queries=  $cols->map(wc|
                           let newSelect = $newQuery.select;
                           let newAgg = ^$aggFromMap(values+=^ColumnGroup(columns=$newSelect.columns));
                           let partitionNames = range($wc.window.partition->size())->map(x|'PartitionFunc'+'_'+$x->toString());
                           let olapPartitionFuncs = if($wc.window->isNotEmpty(),| $wc.window.partition->map(f|$f->processProjectFunction($wc.window.partition->indexOf($f), $partitionNames, ^$newQuery(select=^$newSelect(columns=[])), $vars, ^$state(shouldIsolate=false, inProjectFunctions=true), $nodeId, $newAgg, $context->shift(), $extensions)),|[]);
                           let olapSortFunc = $wc.sortInfo.column->map(f|$f->processProjectFunction($wc.sortInfo.column->indexOf($f), 'sortBy'->repeat($wc.sortInfo.column->size()), ^$newQuery(select=^$newSelect(columns=[])), $vars, ^$state(shouldIsolate=false, inProjectFunctions=true), $nodeId, $newAgg, $context->shift(), $extensions));
                           let olapMapFunc = if($wc.func->instanceOf(OlapAggregation),|$wc.func->cast(@OlapAggregation<Any>).mapFn->processProjectFunction(0, 'mapFunc'->repeat($wc.func->cast(@OlapAggregation<Any>).mapFn->size()), ^$newQuery(select=^$newSelect(columns=[])), $vars, ^$state(shouldIsolate=false, inProjectFunctions=true), $nodeId, $newAgg, $context->shift(), $extensions),|[]);
                           let colsForAgg = if($olapMapFunc->isNotEmpty(),|$olapMapFunc.element->cast(@SelectWithCursor).select.columns,|[]);
                           let processedFunctions =  $olapPartitionFuncs->concatenate($olapSortFunc)->concatenate($olapMapFunc).element->cast(@SelectWithCursor).select->map(p|$p->manageIsolation([], [], $nodeId, false, ^$state(processingProjectionThread=true), $context, $extensions));
                           let newMerge = ^$mainSelect(columns=[])->concatenate($processedFunctions)->mergeSQLQueryData($nodeId, $state, $context, $extensions);
                           let partitionCol = $newMerge.columns->cast(@Alias)->filter(a|$a.name->startsWith('"PartitionFunc')).relationalElement;
                           let sortByCol = $newMerge.columns->cast(@Alias)->filter(a|$a.name->startsWith('"sortBy"')).relationalElement;
                           let mapCol = $newMerge.columns->cast(@Alias)->filter(a|$a.name->startsWith('"mapFunc"')).relationalElement;
                           assert($wc.func->extractOperation()->isSupported(), | 'The function you have specified ('+ $wc.func->extractOperation().expressionSequence->cast(@FunctionExpression).functionName->toOne()+') is not supported. The supported window functions are: '+ olapFuncs()->joinStrings(',')+' .');
                           let windowFunc = $wc.func->extractOperation().expressionSequence->toOne()->processAggFn(if($wc.func->instanceOf(OlapRank),|[],|$mapCol->toOne()));
                           let windowColumn = ^Alias(name ='"'+$wc.name+'"',relationalElement =  ^meta::relational::metamodel::WindowColumn(columnName = $wc.name,func=$windowFunc->cast(@DynaFunction)->toOne(),
                                                                                         window = ^meta::relational::metamodel::Window(partition=$partitionCol,sortBy=$sortByCol, sortDirection=if ($wc.sortInfo.direction.name == meta::pure::tds::SortDirection.DESC.name,| meta::relational::metamodel::SortDirection.DESC,| meta::relational::metamodel::SortDirection.ASC))));
                           let newMergeWithWindow = ^$newMerge(columns=[]->concatenate($windowColumn));
                           $newMergeWithWindow;
                           );

   let finalMerge=^$mainSelect(columns=[])->concatenate($queries)->mergeSQLQueryData($nodeId, $state, $context, $extensions);
   $finalMerge;


}

function meta::relational::functions::pureToSqlQuery::olapFuncs():String[*]
{
    ['average','sum','max','min','rank','averageRank','denseRank', 'rowNumber'];
}

function meta::relational::functions::pureToSqlQuery::isSupported(f:FunctionDefinition<Any>[1]):Boolean[1]
{
   olapFuncs()->contains($f.expressionSequence->cast(@FunctionExpression).functionName->toOne());
}


function meta::relational::functions::pureToSqlQuery::processProject(ids:String[*], functions:meta::pure::metamodel::function::Function<Any>[*], docs:String[*], expression:FunctionExpression[1], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1],wc:WindowColumnSpecification<Any>[*], extensions:Extension[*]):RelationalOperationElement[1]
{
   assertEquals($ids->size(), $functions->size(), | 'The number of column names must match the number of functions. Please provide a column name for each projection function ('+$ids->size()->toString()+' != '+$functions->size()->toString()+')');
   assertEquals($ids->size(), $ids->removeDuplicates()->size(), 'The list of Paths provided to project can\'t contain duplicate names. Please use ! to provide an alias. Example:#/Person/lastName!newAlias#');

   let allFunctionsEndWithDataType = $functions->fold({f,a|$a && $f->functionReturnType().rawType->toOne()->instanceOf(DataType)}, true)->toOne();

   if ($allFunctionsEndWithDataType == false, | let functionsAndIds = $functions->zip($ids);
                                                let functionsAndIdsNotEndingInDatatype = $functionsAndIds->filter( f| !$f.first->functionReturnType().rawType->toOne()->instanceOf(DataType));
                                                fail('All the paths provided to project need to end with a DataType, problems: '
                                                      + $functionsAndIdsNotEndingInDatatype->map( f| $f.second->toString() + ' (' + $f.first->functionReturnType().rawType->toOne()->toString()+')'  )->makeString( ', '));
                                              ,| []);

   print(if(!$context.debug, |'',
            | $context.space+'*>Process Project: '+$functions->map(f|$f->match([p:Path<Nil,Any|1>[1]|$p->printPath('/'), f:FunctionDefinition<Any>[1]|'\'Function\'']))->makeString(', ')+'\n'+
              $context.space+'   (P)Source Operation>  '+$operation->cast(@SelectWithCursor).select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

   let sourceQuery = processValueSpecification($expression.parametersValues->at(0), [], $operation, $vars, ^$state(inProject=true), JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context->shift(), $extensions)->toOne()->cast(@SelectWithCursor);

   let sourceSelect = $sourceQuery.select;
   let mainSelect = $sourceSelect->pushSavedFilteringOperation($extensions);
   let mainQuery = ^$sourceQuery(select=$mainSelect);

   print(if(!$context.debug, |'',
            | $context.space+'   (M)Main Select>  '+$mainSelect->printDebugQuery($context.space, $extensions)));

   let noJoinMainQuery = $mainQuery->removeColumnsAndJoins($nodeId, $context, $extensions);

   print(if(!$context.debug, |'',
            | $context.space+'   (M)Clean Up Query>  '+$noJoinMainQuery.select->printDebugQuery($context.space, $extensions)));

   let newQuery = addPkForAggregation($expression, [], $noJoinMainQuery, $state, $nodeId, $context, $extensions);
   let newSelect = $newQuery.select;

   let newAgg = ^$aggFromMap(values+=^ColumnGroup(columns=$newSelect.columns));
   let queryWithWindowCols = if($wc->isNotEmpty(),|$wc->processWindowColumns($newQuery,$mainSelect,$vars,$state,$nodeId,$aggFromMap,$context, $extensions);,|[]);
   let milestoningContext=$newQuery.milestoningContext->concatenate($operation.milestoningContext)->first();
   let processedFuncsAndProperties = $functions->map(f|$f->processProjectFunction($functions->indexOf($f), $ids, ^$newQuery(select=^$newSelect(columns=[]), milestoningContext=$milestoningContext), $vars, ^$state(shouldIsolate=false, inProjectFunctions=true), $nodeId, $newAgg, $context->shift(), $extensions));//, milestoningContext=$operation.milestoningContext
   let newMainSelect = if ($mainSelect.distinct == true,
                           | moveSelectQueryToSubSelect($mainSelect, $newQuery.currentTreeNode, [], $nodeId, $context, $extensions),
                           | $mainSelect
                       );
   let preProcessedFuncs = $processedFuncsAndProperties.element->cast(@SelectWithCursor).select;

   let processedFuncs = $preProcessedFuncs->map(p|$p->manageIsolation([], [], $nodeId, false, ^$state(processingProjectionThread=true), $context, $extensions));

   let merge = ^$newMainSelect(columns=[])->concatenate($processedFuncs)->concatenate($queryWithWindowCols->cast(@SelectSQLQuery))->mergeSQLQueryData($nodeId, $state, $context, $extensions);

   if ($state.insertDriverTablePkInTempTable->isEmpty(),
       | let newColumns = if ($mainSelect.distinct == false,
                        | $merge.columns,
                        | reAliasAndRemoveTopLevelDynaFunctionColumns($merge, $newMainSelect.columns)
                    );

         let possiblePKsWithUpdatedData = if($state.addDriverTablePkForProject == true,
                                             |getRootPrimaryKeyCols($merge, $newColumns, $state, $expression),
                                             |pair(^List<RelationalOperationElement>(values = []), $merge.data->toOne()));

         let newColumnsWithPossiblePKs = $newColumns->concatenate($possiblePKsWithUpdatedData.first.values);

         let pathInformation = $processedFuncsAndProperties->map(p|let index = $processedFuncsAndProperties->indexOf($p);
                                                             ^PathInformation(propertyMapping = if($p.currentPropertyMapping->isEmpty(),|[],|$p.currentPropertyMapping->at(0)),
                                                                              type = $functions->at($index)->functionReturnType().rawType->toOne(),
                                                                              documentation = if ($docs->isEmpty(),|[],|let val=$docs->at($index);if($val=='',|[],|$val);)
                                                                               );
                                                        );
         let windowColPaths = $wc->map(w| let pureType = $w.func->match([a:OlapAggregation<Any>[1]|$a.aggregateFn->functionReturnType().rawType->toOne(),r:OlapRank<Any>[1]|Integer ]);
                                          let path = ^PathInformation(type = $pureType,documentation = $w.documentation,relationalType = meta::relational::transform::fromPure::pureTypeToDataType($pureType));
                                          pair($w.name,$path);
                                       );
         let olapCols = $newColumnsWithPossiblePKs->filter(c|$c->instanceOf(WindowColumn));
         let nonOlap = $newColumnsWithPossiblePKs->filter(c|!$c->instanceOf(WindowColumn));

         let possiblePKs = $possiblePKsWithUpdatedData.first.values->cast(@Alias).relationalElement->cast(@TableAliasColumn).column->map(c| pair($c.name, ^PathInformation(type = $c.type->meta::relational::metamodel::datatype::dataTypeToCompatiblePureType(), relationalType = $c.type)));
         
         let importDataFlowCols = if($state.importDataFlow == true && $state.importDataFlowAddFks == true,
                                     |let rootTreeNode = $merge.data->toOne();
                                      let joinTreeNodes = $rootTreeNode->children()->map(c| $c->getAllNodes())->cast(@JoinTreeNode)->sortBy(j| $j.join.name);
                                      let allTreeNodes = $rootTreeNode->concatenate($joinTreeNodes);
                                      let candidateJoinedFkTables = if($state.importDataFlowFksByTable->isEmpty(), |[], |$state.importDataFlowFksByTable->toOne()->keys()->remove($rootTreeNode.alias.relation()));
                                      let joinedFkTables = $joinTreeNodes->map(j| $j.alias.relation())->distinct()->filter(r| $candidateJoinedFkTables->contains($r));
                                      let joinedFkCols = $joinedFkTables->toIndexed()->map(p|
                                         let prefix = 'fk_j' + $p.first->toString() + '_';
                                         $state.importDataFlowFksByTable->toOne()->get($p.second).values->map(c|
                                            let columnAliases = $c->extractColumnAliasesInRelationalTreeNodes($p.second, $allTreeNodes, $context, $extensions);
                                            $columnAliases->toIndexed()->map(cp| ^Alias(name=$prefix + if($columnAliases->size() == 1, |'', |$cp.first->toString() + '_') + $c.name, relationalElement=$cp.second));););
                                      $mainQuery.select.columns->concatenate($joinedFkCols);,
                                     |[]);

         ^$operation(
                     select = ^TdsSelectSqlQuery(
                        distinct = $merge.distinct,
                        columns = $nonOlap->concatenate($importDataFlowCols)->cast(@Alias)->removeDuplicates({a,b|$a.name == $b.name})->concatenate($olapCols),//->concatenate($olapCols),
                        data = $possiblePKsWithUpdatedData.second,
                        savedFilteringOperation = $merge.savedFilteringOperation,
                        filteringOperation = $merge.filteringOperation,
                        extraFilteringOperation = $merge.extraFilteringOperation,
                        groupBy = $merge.groupBy,
                        orderBy = $merge.orderBy,
                        paths = $ids->zip($pathInformation)->concatenate($windowColPaths)->concatenate($possiblePKs)
                     ),
                     currentTreeNode = if($operation.currentTreeNode->isEmpty(), | $operation.currentTreeNode, | $operation.currentTreeNode->toOne()->findOneNode($operation.select.data->toOne(), $possiblePKsWithUpdatedData.second->toOne())),
                     positionBeforeLastApplyJoinTreeNode = if($operation.positionBeforeLastApplyJoinTreeNode->isEmpty(), | $operation.positionBeforeLastApplyJoinTreeNode, | $operation.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($operation.select.data->toOne(), $possiblePKsWithUpdatedData.second->toOne()))
                 );,

        |let newMerge = $merge.data.alias->toOne().relation()->match(
                                         [
                                            t:Table[1] | ^$merge(columns = getRootPrimaryKeyCols($merge, [], $state, $expression).first.values),
                                            u:UnionAll[1]| ^$merge
                                                           (
                                                              columns = $u.queries->at(0).columns->cast(@Alias)
                                                                        ->filter(c|$c.name->startsWith('"pk_'))
                                                                        ->map(a|^$a(relationalElement=^TableAliasColumn(alias=$merge.data.alias->toOne(), column=^Column(name=$a.name, type=^meta::relational::metamodel::datatype::Integer()))))
                                                           );
                                         ]
                                        );

         ^$operation(
                     select = ^TdsSelectSqlQuery(
                        distinct = $newMerge.distinct,
                        columns = $newMerge.columns,
                        data = $newMerge.data,
                        savedFilteringOperation = $newMerge.savedFilteringOperation,
                        filteringOperation = $newMerge.filteringOperation,
                        extraFilteringOperation = $newMerge.extraFilteringOperation,
                        groupBy = $newMerge.groupBy,
                        orderBy = $newMerge.orderBy
                     )
                 );
   );
}

function meta::relational::functions::pureToSqlQuery::joinToTemp(select:SelectSQLQuery[1], table: Table[1], tempTableName:String[1], indexInUnion:Integer[0..1], context:DebugContext[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   let data = $select.data->toOne();
   let alias = $data.alias;

   let tempTable = ^Table(name=$tempTableName, temporaryTable=true, columns=$table.primaryKey, schema=^Schema(name='default', database=$table.schema.database), primaryKey=$table.primaryKey);
   let tempTableAlias = ^TableAlias(name='tempTableKeys', relationalElement=$tempTable);

   let newData = ^$data
                 (
                    alias=$tempTableAlias,
                    childrenData=^JoinTreeNode
                                 (
                                   joinName='from_'+$tempTableName,
                                   database=^Database(),
                                   alias=$data.alias,
                                   join=^Join(name='from_'+$tempTableName,
                                              aliases=[pair($alias,$tempTableAlias),pair($tempTableAlias, $alias)],
                                              operation=$table.primaryKey->map(c|^DynaFunction(name = 'equal',
                                                                                       parameters=[ ^TableAliasColumn(alias=$alias, column=$c),
                                                                                                    ^TableAliasColumn(alias=$tempTableAlias, column=if ($indexInUnion->isEmpty(),
                                                                                                                                                       |$c,
                                                                                                                                                       |^Column(name='"pk_'+$table.primaryKey->indexOf($c)->toString()+'_'+$indexInUnion->toOne()->toString()+'"', type=$c.type)
                                                                                                                                             )
                                                                                                                     )
                                                                                                  ]
                                                                                  )
                                                                           )->andFilters($extensions)->cast(@Operation)->toOne()
                                        ),
                                   joinType=JoinType.INNER,
                                   childrenData = $data.childrenData
                                 )
                 );

   ^$select
   (
      data=$newData,
      savedFilteringOperation=$select.savedFilteringOperation->map(p|pair($p.first->findOneNode($data, $newData), $p.second))
   );

}

function meta::relational::functions::pureToSqlQuery::useTempAsDriver(s:SelectWithCursor[1], tempTableName: String[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let select = $s.select;
   let data = $select.data->toOne();
   let alias = $data.alias;

   $data.alias.relationalElement->match(
      [
         t:Table[1] | let newSelect = joinToTemp($select, $t, $tempTableName, [], $context, $extensions);
                      ^$s
                      (
                        select= $newSelect,
                        currentTreeNode=if(!$s.currentTreeNode->isEmpty(),|$s.currentTreeNode->toOne()->findOneNode($data, $newSelect.data->toOne()),|[])
                      );,
         u:Union[1] | ^$s
                      (
                        select = ^$select
                                 (
                                    data = ^$data
                                          (
                                             alias = ^$alias
                                                     (
                                                        relationalElement = ^$u(queries = $u.queries->map(q|let re = $q->joinToTemp($q.data.alias.relationalElement->toOne()->cast(@Table), $tempTableName, $u.queries->indexOf($q), $context, $extensions)))
                                                     )
                                          )
                                 )
                      );
      ]
   );
}

function meta::relational::functions::pureToSqlQuery::manageIsolation(swc:SelectWithCursor[1], extraColumns:TableAliasColumn[*], nodeId:String[1], inner:Boolean[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
   let p = $swc.select;
   print(if(!$context.debug, |'',
            | $context.space+'*>Isolation: \n'+
              $context.space+'  '+$p->printDebugQuery($context.space, $extensions)));


   $swc->validate([], $extensions);

   let filterShouldIsolate = !$p.savedFilteringOperation->isEmpty();
   let innerShouldIsolate = !$p.data->toOne()->children()->isEmpty() && $p.data->toOne()->containsInnerJoin();
   let thisIsolationDecision = ($innerShouldIsolate || $filterShouldIsolate);
   let finalIsolationDecision = $state.shouldIsolate && $thisIsolationDecision;

   print(if(!$context.debug, |'',|$context.space+'  ? '+$finalIsolationDecision->toString()+' / State isolation:'+$state.shouldIsolate->toString()+', Isolation required (filter or inner joins):'+$thisIsolationDecision->toString()+'\n'));

   $swc->validate([], $extensions);


   let res2 = if($finalIsolationDecision,
                  |let res = $p->isolateSubJoins($swc.currentTreeNode->toOne(), $extraColumns, $swc.alias, $nodeId, $inner, $state, $context, $extensions);
                   ^$swc
                   (
                     select = $res.second,
                     currentTreeNode = $res.first,
                     positionBeforeLastApplyJoinTreeNode = if($swc.positionBeforeLastApplyJoinTreeNode->isEmpty(),|[],|$swc.positionBeforeLastApplyJoinTreeNode->toOne()->findOneNode($swc.select.data->toOne(), $res.second.data->toOne()))
                   );,
                  |$swc
              );

   $res2->validate([], $extensions);

   print(if(!$context.debug, |'',
            | $context.space+'*>Isolation Result: \n'+
              $context.space+'  '+$res2.select->printDebugQuery($context.space, $extensions))
        );



   $res2;
}

function meta::relational::functions::pureToSqlQuery::manageIsolation(p:SelectSQLQuery[1], extraColumns:TableAliasColumn[*], aliasForExtractedColumns:TableAlias[0..1], nodeId:String[1], inner:Boolean[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'*>Isolation: \n'+
              $context.space+'  '+$p->printDebugQuery($context.space, $extensions)));




   let filterShouldIsolate = !$p.savedFilteringOperation->isEmpty();
   let innerShouldIsolate = !$p.data->isEmpty() && !$p.data->toOne()->children()->isEmpty() && $p.data->toOne()->containsInnerJoin();
   let thisIsolationDecision = ($innerShouldIsolate || $filterShouldIsolate);
   let finalIsolationDecision = $state.shouldIsolate && $thisIsolationDecision;

   print(if(!$context.debug, |'',|$context.space+'  ? '+$finalIsolationDecision->toString()+' / State isolation:'+$state.shouldIsolate->toString()+', Isolation required (filter or inner joins):'+$thisIsolationDecision->toString()+'\n'));

   let res2 = if($finalIsolationDecision, |^$p(preIsolationCurrentTreeNode=[])->isolateSubJoins($p.data->toOne(), $extraColumns, $aliasForExtractedColumns, $nodeId, $inner, $state, $context, $extensions).second, |^$p(preIsolationCurrentTreeNode=[]));

   print(if(!$context.debug, |'',
            | $context.space+'*>Isolation Result: \n'+
              $context.space+'  '+$res2->printDebugQuery($context.space, $extensions))
      );


   $res2;
}

function meta::relational::functions::pureToSqlQuery::addedSelfJoin(r:RelationalTreeNode[1]):Boolean[1]
{
   $r.alias.name->startsWith('gen_');
}

function meta::relational::functions::pureToSqlQuery::containsInnerJoin(r:RelationalTreeNode[1]):Boolean[1]
{

   $r->instanceOf(JoinTreeNode) && $r->cast(@JoinTreeNode).joinType == JoinType.INNER || $r->children()->fold({i,a|$i->containsInnerJoin() || $a}, false);
}
function meta::relational::functions::pureToSqlQuery::reAliasAndRemoveTopLevelDynaFunctionColumns(select:SelectSQLQuery[1], columnsToReAlias:RelationalOperationElement[*]):RelationalOperationElement[*]
{
   $select.columns->map(c | $c->match([a:Alias[1]|
         let columnFound = $columnsToReAlias->filter(c|$c->instanceOf(Alias))->cast(@Alias)->filter(c | $c.name == $a.name);
         if ($columnFound->isEmpty(), | $a, |
         $a.relationalElement->match(
            [
               d:DynaFunction[1] |  ^Alias(name=$a.name, relationalElement=^TableAliasColumn(alias=$select.data->toOne().alias, column=^Column(name=$a.name, type=^meta::relational::metamodel::datatype::Integer()))),
               o:Operation[1] |  ^Alias(name=$a.name, relationalElement=^TableAliasColumn(alias=$select.data->toOne().alias, column=^Column(name=$a.name, type=^meta::relational::metamodel::datatype::Integer()))),
               t:TableAliasColumn[1] | $a
            ]););,
         a:RelationalOperationElement[1]|$a]));
}

function meta::relational::functions::pureToSqlQuery::buildSimpleSQL(result:SelectSQLQuery[1], id:String[1]):SelectSQLQuery[1]
{
   ^SelectSQLQuery(
      columns = ^Alias(name = '"'+$id+'"', relationalElement = $result.columns->toOne()),
      data = $result.data,
      filteringOperation = $result.filteringOperation,
      savedFilteringOperation = $result.savedFilteringOperation,
      extraFilteringOperation = $result.extraFilteringOperation,
      groupBy = $result.groupBy
   );
}



function meta::relational::functions::pureToSqlQuery::collectJoinNames(n:RelationalTreeNode[1], includeChildJoinNames:Boolean[1]):String[*]
{
   let base = $n->match([r:RootJoinTreeNode[1]|'root', j:JoinTreeNode[1]|$j.join.name]);
   if($includeChildJoinNames,|$base->concatenate($n->children()->map(j|$j->collectJoinNames($includeChildJoinNames))),|$base);
}

Enum meta::relational::functions::pureToSqlQuery::IsolationStrategy
{
   MoveFilterOnTop,
   MoveFilterInOnClause,
   BuildCorrelatedSubQuery
}

function meta::relational::functions::pureToSqlQuery::joinName(node:RelationalTreeNode[1], f:RelationalOperationElement[*], state:State[1], includeChildJoinNames:Boolean[1], extensions:Extension[*]):String[1]
{
   let isEmptyIsolationFlag = if(!$state.inIsolatedIsEmpty->isEmpty() && $state.inIsolatedIsEmpty->toOne(),|'_is_empty_lhs_',|'');
   '__iso_'+$isEmptyIsolationFlag+$node->collectJoinNames($includeChildJoinNames)->makeString('_')+$f->map(q|$q->buildUniqueName(false, false, $extensions))->makeString('_');
}

Class meta::relational::functions::pureToSqlQuery::BiContainer<T>
{
   first : T[0..1];
   second : T[0..1];
}

Class meta::relational::functions::pureToSqlQuery::IsolationSelectState
{
  foundNode : JoinTreeNode[0..1];
  select : SelectSQLQuery[1];
  currentTreeNode :RelationalTreeNode[0..1];
}

function meta::relational::functions::pureToSqlQuery::addSelfJoinOnNode(select:SelectSQLQuery[1], currentTreeNode:RelationalTreeNode[0..1], selfJoinNode:RelationalTreeNode[1], context:DebugContext[1], extensions:Extension[*]):IsolationSelectState[1]
{
   let res = addSelfJoin($select, $selfJoinNode, $select.savedFilteringOperation.second->map(q|$q->buildUniqueName(false, $extensions))->makeString('_'), $extensions);
   let newSelect = $res.first;
   print(if(!$context.debug, |'',| $context.space+'SelfJoin Added: '+$newSelect->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)));
   let revisedCurrentTreeNode = $res.second.values->filter(p|$p.first==$currentTreeNode)->first();
   let newCurrentTreeNode = if(!$revisedCurrentTreeNode->isEmpty(),|$revisedCurrentTreeNode.second,|if($currentTreeNode == $select.data,|$newSelect.data,|$currentTreeNode));
   ^IsolationSelectState(foundNode =if($selfJoinNode->instanceOf(RootJoinTreeNode),|$newSelect.data->map(x|$x->children())->toOne(),|$newSelect->findBestNodeToIsolate()), select=$newSelect, currentTreeNode=$newCurrentTreeNode);
}

function meta::relational::functions::pureToSqlQuery::nodeSupportsTriangularFilter(s:SelectSQLQuery[1], node:RelationalTreeNode[0..1], state: State[1]): Boolean[1]
{
   let nodesInOperation  =  $s.savedFilteringOperation.second->extractTableAliasColumns().alias.name->removeDuplicates();
   !$state.inProjectFunctions && $state.processingProjectionThread &&
   if($node->isNotEmpty() && ($node->toOne()->children()->size()>1),
      |let childrenReferencedInOperation = $node->map(x|$x->children())->map(c| $c->getAllNodes()->cast(@RelationalTreeNode).alias.name->fold({n,b| $nodesInOperation->contains($n) || $b },false));
       let allChildrenReferencedInOperation =!$childrenReferencedInOperation->contains(false);
       let leafNodes = $node->map(x|$x->children())->map(c| $c->getAllNodes()->filter(n|$n->cast(@RelationalTreeNode)->children()->isEmpty()));
       let leafNodesHaveSameElement = $leafNodes->cast(@RelationalTreeNode).alias.relation->removeDuplicates()->size() ==1;
       $allChildrenReferencedInOperation && $leafNodesHaveSameElement;,
      |false);
}

function meta::relational::functions::pureToSqlQuery::isolateSubJoins(s:SelectSQLQuery[1], currentTreeNode:RelationalTreeNode[1], extraColumns:TableAliasColumn[*], aliasForExtractedColumns:TableAlias[0..1], nodeId:String[1], inner:Boolean[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):Pair<RelationalTreeNode, SelectSQLQuery>[1]
{
   $s->validate($extensions);
   let root = $s.data->toOne();
   let possibleFoundNode = $s->findBestNodeToIsolate();

   let r = if ($possibleFoundNode->isEmpty() && $s.data->toOne()->children()->isEmpty()
          ,| // It means we don't need isolation (The constraint needs to be applied at root level)
             let newSelect = ^$s(
                           savedFilteringOperation = [],
                           extraFilteringOperation += if($s.savedFilteringOperation->isEmpty(),|[],|$s.savedFilteringOperation.second)
                         );
             pair($currentTreeNode, $newSelect);
         ,|
         let shouldAddSelfJoinOnRoot = $possibleFoundNode->isEmpty() && $state.processingProjectionThread;
         let isolationSelectState = if ($shouldAddSelfJoinOnRoot,
                                        |addSelfJoinOnNode($s, $currentTreeNode, $s.data->toOne(), $context, $extensions),
                                        |if(nodeSupportsTriangularFilter($s, $possibleFoundNode, $state) ,
                                           |//need to protect node for possible subsequent mergeOperation.
                                            addSelfJoinOnNode($s, $currentTreeNode, $possibleFoundNode->cast(@RelationalTreeNode)->toOne(), $context, $extensions),
                                           |^IsolationSelectState(foundNode=$possibleFoundNode, select=$s, currentTreeNode=$currentTreeNode)
                                           );
                                        );
         let foundNode = $isolationSelectState.foundNode;
         let select = $isolationSelectState.select;
         let updatedCurrentTreeNode = $isolationSelectState.currentTreeNode->toOne();
         let foundSuitableNode = $foundNode->isNotEmpty() && $foundNode->map(x|$x->children())->isEmpty();

         let root = $select.data->toOne();

         // Decide which strategy to use
         let possibleStrategy =  if ($context->instanceOf(RelationalDebugContext) && !$context->cast(@RelationalDebugContext).forcedIsolation->isEmpty()
                                    ,| $context->cast(@RelationalDebugContext).forcedIsolation->toOne();
                                    ,|

                                       if ($state.processingProjectionThread
                                         ,|if ($foundSuitableNode && $select.data->map(x|$x->children())->contains($foundNode->toOne())
                                              ,|IsolationStrategy.MoveFilterInOnClause
                                              ,|IsolationStrategy.BuildCorrelatedSubQuery)
                                         ,|if ((($foundSuitableNode && $select.data->toOne()->cast(@TreeNode)->getLeafNodes()->contains($foundNode->toOne()) &&
                                                                                            $state.shouldIsolateNestedFilter == true ) || ($foundNode->isNotEmpty() && ($state.inIfTrueFalseStmt == true))) &&
                                                                                          (!$foundNode.alias.relationalElement->toOne()->instanceOf(SelectSQLQuery) || $foundNode.alias.relationalElement->toOne()->cast(@SelectSQLQuery)->map(sel | $sel.data.alias.relation->toOne()->instanceOf(Table) && $sel.data->map(x|$x->children())->size() == 1 && $sel.data->map(x|$x->children())->toOne().joinType == JoinType.INNER)->toOne())
                                                                                         ,|IsolationStrategy.MoveFilterInOnClause
                                                                                         ,|IsolationStrategy.MoveFilterOnTop);
                                         );
                                  );

         let strategy = if($possibleStrategy == IsolationStrategy.MoveFilterOnTop && $root->containsInnerJoin(),| IsolationStrategy.BuildCorrelatedSubQuery, | $possibleStrategy);
         print(if(!$context.debug, |'',| $context.space+'\n  >Strategy: '+$strategy->id()+'\n'));
         // Execute the strategy
         if ($strategy == IsolationStrategy.MoveFilterOnTop
            ,|// MoveFilterOnTop
               // Pro: it doesn't use subQueries and it reduces the toMany explosion (where on clause doesn't)
               // Cons: When n threads are projected some rows may be canceled if a data point is missing
               $select->moveFiltersOnTop($select.savedFilteringOperation,$foundNode,$updatedCurrentTreeNode,  $state, $extensions);
            ,|
              if ($strategy == IsolationStrategy.BuildCorrelatedSubQuery
                  ,|  // BuildCorrelatedSubQuery
                      // Pro: Provides really good isolation
                      // Cons: Expensive during execution, reduces the scope of column that can be used (injection doesn't work)
                     let preRes = $select->buildCorrelatedSubQuery($foundNode, $extraColumns, $aliasForExtractedColumns, false, $nodeId, $inner, $updatedCurrentTreeNode, $state, $extensions);
                     let joinName = $preRes.first->match([j:JoinTreeNode[1]|$j.joinName,a:Any[*]|[]]);
                     if($foundSuitableNode
                        ,|let hasSiblingWithSameJoinName = $preRes.first->getParentNode($preRes.second.data->toOne())->map(x|$x->children()).joinName->filter(n|$n==$joinName)->size()>1;
                          if($hasSiblingWithSameJoinName && $state.processingProjectionThread ,|$select->moveFiltersInOnClause($select.savedFilteringOperation, $updatedCurrentTreeNode, JoinType.LEFT_OUTER, $state, $extensions),|$preRes);
                        ,|$preRes
                        );
                  ,| // MoveFilterInOnClause
                     // Pro: Provides good isolation, avoids the usage of correlated sub queries
                     // Cons: Doesn't prevent records explosion (maybe we should try to groupBy)
                     $select->moveFiltersInOnClause($select.savedFilteringOperation, $updatedCurrentTreeNode, JoinType.LEFT_OUTER, $state, $extensions);
                   );
            );
       );

    $r.second->validate($extensions);

    $r;
}

function meta::relational::functions::pureToSqlQuery::buildThreads(l:List<RelationalTreeNode>[1]):List<RelationalTreeNode>[*]
{
   let children = $l.values->last()->toOne()->children();
   if ($children->isEmpty(),|$l ,|$children->map(c|^$l(values+=$c)->buildThreads()));
}

function meta::relational::functions::pureToSqlQuery::checkCondition(n:RelationalTreeNode[1], aliases:Alias[*]):Boolean[1]
{
   $n->match([j:JoinTreeNode[1]|$j.joinType == JoinType.INNER, a:Any[1]|false]) || !$aliases->filter(a|$a.name == $n.alias.name)->isEmpty();
}


function meta::relational::functions::pureToSqlQuery::matchAnyAlias(thread:List<RelationalTreeNode>[1],aliases:Alias[*]):Boolean[1]
{
   $thread.values->exists(e|$e->checkCondition($aliases));
}

function meta::relational::functions::pureToSqlQuery::matchAllAliases(thread:List<RelationalTreeNode>[1],aliases:Alias[*]):Boolean[1]
{
   $aliases->fold({a,b| $b && $thread.values->exists(e|$e->checkCondition($a))},true);
}


function meta::relational::functions::pureToSqlQuery::findBestNodeToIsolate(select:SelectSQLQuery[1]):JoinTreeNode[0..1]
{
   let joinThreads = ^List<RelationalTreeNode>(values=$select.data)->buildThreads();

   let aliasesWithConstraints = $select.savedFilteringOperation.second->extractTableAliasColumns().alias->removeDuplicates();

   let filterThreadsWithAllConditions = $joinThreads->filter(thread| $thread->matchAllAliases($aliasesWithConstraints));

   let filteredThreads = if($filterThreadsWithAllConditions->isEmpty()
                             ,|$joinThreads->filter(thread| $thread->matchAnyAlias($aliasesWithConstraints));
                             ,|$filterThreadsWithAllConditions);

   let filteredCutThreads = $filteredThreads->map(t|let selectedList = $t.values->filter(n|$n->checkCondition($aliasesWithConstraints));
                                                    if($selectedList->isNotEmpty(),| let selected = if ($selectedList->size()>1, |$selectedList->filter(s|!$s->instanceOf(RootJoinTreeNode)), |$selectedList)->at(0);
                                                                                    ^$t(values=$t.values->slice(0,$t.values->indexOf($selected)+1));
                                                                                 ,| []);
                                                 );
   let min = min($filteredCutThreads->map(l|$l.values->size()))->toOne();
   let mostCommonNodes = range(0,$min,1)->fold({i,a|let dedup = $filteredCutThreads->map(f|$f.values->at($i))->removeDuplicates();
                                                   if ($dedup->size() == 1,|^$a(values+=$dedup),|$a);
                                              },
                                              ^List<RelationalTreeNode>()
                                         ).values;

   let lastCommonNode = $mostCommonNodes->at($mostCommonNodes->size()-1);

   let mostCommonNode = if($lastCommonNode->match([j:JoinTreeNode[1]|$j.joinType == JoinType.INNER, a:Any[1]|false]),|$mostCommonNodes->at($mostCommonNodes->size()-2),|$lastCommonNode);

   let firstNodeWithConstraint = $mostCommonNode->match([j:JoinTreeNode[1]|$j, a:Any[1]|[]]);

   let foundNode = if ($firstNodeWithConstraint->isEmpty() || $select.savedFilteringOperation->isEmpty(),
      |$firstNodeWithConstraint,
      |let leftOfFilter = $select.savedFilteringOperation->first()->toOne().first;
       if ($leftOfFilter->instanceOf(RootJoinTreeNode),
          |[],
          |if ($firstNodeWithConstraint->toOne()->getAllNodes()->contains($leftOfFilter->toOne()),
             |$firstNodeWithConstraint,
             |if($leftOfFilter->getAllNodes()->contains($firstNodeWithConstraint->toOne()),
                |$leftOfFilter->toOne()->cast(@JoinTreeNode);,
                |$firstNodeWithConstraint
              );
          );
      );
   );
  //select the leaf node when the filters refer to the found node and it's immediate child where the found node is a SelectSQLQuery and the filters are made up of binary operations referring to both nodes
  if($foundNode->isNotEmpty() && !$foundNode->toOne()->instanceOf(RootJoinTreeNode) && $foundNode.alias.relationalElement->toOne()->instanceOf(SelectSQLQuery)
     ,| let foundNodeAlias = $aliasesWithConstraints->filter(n|$n.name == $foundNode.alias.name);
        if ($aliasesWithConstraints->size()==2 && $foundNodeAlias->size()==1 ,| let otherAlias = $aliasesWithConstraints->filter(n|$n != $foundNodeAlias);
                                                                                let otherNode = $foundNode->toOne()->getAllNodes()->cast(@JoinTreeNode)->filter(n|$n.alias.name == $otherAlias.name);
                                                                                if($otherNode->isNotEmpty() && $otherNode->map(c|$c->children())->isEmpty()
                                                                                   ,| let aliasesReferencedOnBothSidesOfFilter = $select.savedFilteringOperation.second->forAll(f|$f->aliasesReferencedOnBothSidesOfSimpleBinaryOperation([$foundNodeAlias->toOne(), $otherAlias->toOne()]));
                                                                                      if ($aliasesReferencedOnBothSidesOfFilter,| $otherNode->toOne(),| $foundNode);
                                                                                   ,| $foundNode);
                                                                             ,| $foundNode);
     ,| $foundNode);
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::aliasesReferencedOnBothSidesOfSimpleBinaryOperation(b:RelationalOperationElement[1], ta: TableAlias[*]):Boolean[1]
{
   $b->match([b:BinaryOperation[1] | [$b.left, $b.right]->checkTableAliasesOnBothSidesBinaryOperation($ta),
              d:DynaFunction[1] | if($d.parameters->size() == 2, | $d.parameters->checkTableAliasesOnBothSidesBinaryOperation($ta), | false),
              o:RelationalOperationElement[1] | false])
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::checkTableAliasesOnBothSidesBinaryOperation(params:RelationalOperationElement[*], ta: TableAlias[*]):Boolean[1]
{
   let left = $params->at(0);
   let right = $params->at(1);
   if($params->forAll(s|$s->instanceOf(Operation)),| $left->aliasesReferencedOnBothSidesOfSimpleBinaryOperation($ta) && $right->aliasesReferencedOnBothSidesOfSimpleBinaryOperation($ta)
                                                  ,| if(!$params->exists(s|$s->instanceOf(Operation) && !$s->instanceOf(DynaFunction)),| let leftAlias = $left->extractTableAliasColumns().alias->distinct();
                                                                                                                                         let rightAlias = $right->extractTableAliasColumns().alias->distinct();
                                                                                                                                         $leftAlias->size()==1 && $rightAlias->size()==1 && $ta->containsAll([$leftAlias->toOne(), $rightAlias->toOne()]);
                                                                                                                                      ,| false));
}

function meta::relational::functions::pureToSqlQuery::buildUniqueName(elements:RelationalOperationElement[*], alias:Boolean[1], extensions:Extension[*]):String[1]
{
   $elements->buildUniqueName($alias, true, $extensions)
}

function meta::relational::functions::pureToSqlQuery::buildUniqueName(elements:RelationalOperationElement[*], alias:Boolean[1], selectColumns:Boolean[1], extensions:Extension[*]):String[1]
{
   let uniqueName = $elements->map(e | $e->match($extensions->map(e|$e.moduleExtension('relational')->cast(@RelationalExtension).pureToSQL_buildUniqueName)->map(f | $f->eval($alias, $selectColumns, $extensions))->concatenate(
      [
         n:RootJoinTreeNode[1]|$n->getAllNodes()->map(a|$a->match([j:RootJoinTreeNode[1]|if($alias,|$j.alias.name,|$j.alias.relationalElement->buildUniqueName($alias, $selectColumns, $extensions)),j:JoinTreeNode[1]|$j.joinName]))->makeString('_'),
         s:SelectSQLQuery[1]|'s('+if($selectColumns,|$s.columns->buildUniqueName($alias, $selectColumns, $extensions)+',',|'')+$s.data->buildUniqueName($alias, $selectColumns, $extensions)+','+$s.filteringOperation->buildUniqueName($alias, $selectColumns, $extensions)+')',
         u:UnaryOperation[1]| $u->type()->toOne().name->toOne() + $u.nested->buildUniqueName($alias, $selectColumns, $extensions),
         i:BinaryOperation[1]|$i->type()->toOne().name->toOne() + '_' + $i.left->buildUniqueName($alias, $selectColumns, $extensions) + '_' + $i.right->buildUniqueName($alias, $selectColumns, $extensions),
         a:Alias[1]|if($alias,|$a.name,|$a.relationalElement->buildUniqueName($alias, $selectColumns, $extensions)),
         c:ColumnName[1]|$c.name,
         n:NamedRelation[1]|$n.name,
         u:Union[1]|$u.queries->map(q|$q->buildUniqueName($alias, $selectColumns, $extensions))->joinStrings(),
         c:TableAliasColumn[1]|$c.alias->buildUniqueName($alias, $selectColumns, $extensions)+$c.column.name;,
         l:Literal[1]|if($l.value->instanceOf(VarPlaceHolder),|$l.value->cast(@VarPlaceHolder).name,|$l.value->toString()),
         l:LiteralList[1]|  $l.values->map(l|$l->buildUniqueName($alias, $selectColumns, $extensions))->joinStrings(),
         v:VariableArityOperation[1]|$v->type()->toOne().name->toOne() + '_' + $v.args->buildUniqueName($alias, $selectColumns, $extensions),
         d:DynaFunction[1]| $d.name +'_'+$d.parameters->buildUniqueName($alias, $selectColumns, $extensions),
         f:FreeMarkerOperationHolder[1]| $f.name +'_'+$f.parameters->buildUniqueName($alias, $selectColumns, $extensions),
         wc:WindowColumn[1]| $wc.columnName+'_'+ $wc.func->buildUniqueName($alias,$selectColumns, $extensions),
         j:JoinStrings[1]|'join_'+$j.strings->buildUniqueName($alias, $selectColumns, $extensions)+$j.prefix->buildUniqueName($alias, $selectColumns, $extensions)+$j.separator->buildUniqueName($alias, $selectColumns, $extensions)+$j.suffix->buildUniqueName($alias, $selectColumns, $extensions),
         rj:RelationalOperationElementWithJoin[1]| $rj.joinTreeNode->toOne().joinName+ $rj.relationalOperationElement->buildUniqueName($alias, $selectColumns, $extensions),
         ssp:SemiStructuredPropertyAccess[1]|'ssp('+$ssp.operand->buildUniqueName($alias, $selectColumns, $extensions)+'['+$ssp.property->buildUniqueName($alias, $selectColumns, $extensions)+']'+if($ssp.index->isEmpty(),|'',|'['+$ssp.index->toOne()->buildUniqueName($alias, $selectColumns, $extensions)+']')+')',
         ssa:SemiStructuredArrayElementAccess[1]|'ssa('+$ssa.operand->buildUniqueName($alias, $selectColumns, $extensions)+'['+$ssa.index->buildUniqueName($alias, $selectColumns, $extensions)+'])',
         ssf:SemiStructuredArrayFlatten[1]|'ss_flatten('+$ssf.navigation->buildUniqueName($alias, $selectColumns, $extensions)+')',
         ssf:SemiStructuredArrayFlattenOutput[1]|'ss_flatten_output('+$ssf.tableAliasColumn->buildUniqueName($alias, $selectColumns, $extensions)+')',
         v:VarPlaceHolder[1]| $v.name
      ])->toOneMany()
   ))->joinStrings('_');
   
   let maxSize = 256;  // TODO: make this configurable
   if($uniqueName->length() > $maxSize, |$uniqueName->substring(0, $maxSize - 35) + '___' + $uniqueName->substring($maxSize - 35)->meta::pure::functions::hash::hash(meta::pure::functions::hash::HashType.MD5), |$uniqueName);
}

function meta::relational::functions::pureToSqlQuery::incrementAliasRecursively(head:Alias[1], tail:Alias[*]):Pair<Alias,Alias>[*]
{
   if ($tail->isEmpty(), | pair($head, $head), | pair($head, ^$head(name= $head.name + '_' + $tail->size()->toString()))->concatenate(incrementAliasRecursively($tail->head()->toOne(), $tail->tail())))
}

function meta::relational::functions::pureToSqlQuery::replaceJoin(currentJoin:RelationalTreeNode[1], joinToReplace:JoinTreeNode[1], newJoin:JoinTreeNode[1]):RelationalTreeNode[1]
{
   if ($currentJoin == $joinToReplace,
      | $newJoin,
      | let newChildren = $currentJoin->children()->map(j | $j->replaceJoin($joinToReplace, $newJoin));
        ^$currentJoin(childrenData=$newChildren);
   );
}


function meta::relational::functions::pureToSqlQuery::moveSelectQueryToSubSelect(select:SelectSQLQuery[1], currentTreeNode:RelationalTreeNode[0..1], extraColumns : TableAliasColumn[*], nodeId:String[1], context:DebugContext[1], extensions:Extension[*]):SelectSQLQuery[1]
{
    print(if(!$context.debug, |'',
            | $context.space+ 'Query Before Move To Sub Select:' + $select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

    let currentAlias = $select.data.alias->toOne();
    let targetAlias = '_sub' + $nodeId;
    let val = ^OldAliasToNewAlias(first=$currentAlias.name, second=^TableAlias(name=$targetAlias, relationalElement=$currentAlias.relationalElement));
    let literals = $select.filteringOperation->filter(f|$f->instanceOf(Literal));
   //if size is one then we're moving to subquery while processing one side of a filter e.g col_a = 1
    let reprocessedFilteringOperation = if($select.filteringOperation->size()==1,|$select.filteringOperation->filter(f|!$f->instanceOf(Literal)),|$select.filteringOperation)->concatenate($select.extraFilteringOperation)->concatenate($select.savedFilteringOperation.second)->andFilters($extensions)->map(f|$f->reprocessAliases($val));
    let reprocessedGroupBys = $select.groupBy->map(t|$t->reprocessAliases($val));

    let child = if ($select.data->map(x|$x->children())->isEmpty(), | [], | $select.data->map(x|$x->children())->map(child | let reprocessedJoin = $child.join->reprocessJoin($val, []);
                                                                                                  ^$child(join=$reprocessedJoin);
                                                                                                  );
                                                           );

    let cols = $select.columns->concatenate($extraColumns)->reprocessAliases($val);
    let reprocessedColumns = $cols->map(e|let res = $e->match([
                                                       t:TableAliasColumn[1] | ^Alias(name=$t.column.name, relationalElement=$t),
                                                       a:Alias[1] | $a.relationalElement->match([t:TableAliasColumn[1] | ^$a(name=$t.column.name), o:Any[1]|$a]),
                                                       a:RelationalOperationElement[1] | ^Alias(name='col'+$cols->indexOf($e)->toString(), relationalElement=$a)
                                                    ]);
                                          pair($e, $res);
                                   );

    let newData = ^RootJoinTreeNode(alias=^$currentAlias(name=$targetAlias), childrenData=$child);

    let newLeftSideOfFilter = $select.leftSideOfFilter->isNotEmpty()->if(|$select.leftSideOfFilter->toOne()->findOneNode($select.data->toOne(), $newData),|[]);
    let newAlias = ^TableAlias(name=$currentAlias.name,
                                              relationalElement=^$select(
                                                 data = $newData,
                                                 filteringOperation = $reprocessedFilteringOperation,
                                                 columns = $reprocessedColumns.second->cast(@Alias)->removeDuplicates({a,b|$a.name == $b.name}),
                                                 preIsolationCurrentTreeNode = $currentTreeNode,
                                                 groupBy = $reprocessedGroupBys->filter(c|$c->instanceOf(TableAliasColumn)),
                                                 leftSideOfFilter = $newLeftSideOfFilter
                                              )
                   );
    let names = $reprocessedColumns.second->cast(@Alias).name;
    let newSelectClass = if($select->instanceOf(TdsSelectSqlQuery),| ^TdsSelectSqlQuery(paths = $select->cast(@TdsSelectSqlQuery).paths),| ^SelectSQLQuery());
    let newSelect = ^$newSelectClass(
                      data= ^RootJoinTreeNode(alias = $newAlias),
                      columns=$select.columns->map(c|let index = $select.columns->indexOf($c);
                                                     let newCol = ^TableAliasColumn(column=^Column(name=$names->at($index), type=^meta::relational::metamodel::datatype::Integer()), alias=$newAlias);
                                                     $c->match([
                                                                a:Alias[1]|^$a(relationalElement=$newCol),
                                                                t:RelationalOperationElement[1]|$newCol
                                                               ]);
                                                  ),
                      filteringOperation = if($select.filteringOperation->size()==1,|$literals,|[])
                   );

    print(if(!$context.debug, |'',
            | $context.space+ 'Query After Move To Sub Select:' + $newSelect->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

    $newSelect;
}

function meta::relational::functions::pureToSqlQuery::processEquals(
                 expression : FunctionExpression[1],
                 currentPropertyMapping:PropertyMapping[*],
                 operation : SelectWithCursor[1],
                 vars : Map<VariableExpression, ValueSpecification>[1],
                 state:State[1],
                 joinType : JoinType[1],
                 nodeId : String[1],
                 aggFromMap:List<ColumnGroup>[1],
                 context : DebugContext[1],
                 extensions:Extension[*]
         ) : RelationalOperationElement[1]
{
   let leftParam = $expression.parametersValues->at(0);
   let rightParam = $expression.parametersValues->at(1);

   assert($leftParam.multiplicity->hasUpperBound() && ($leftParam.multiplicity->getUpperBound() <= 1)
          ,|'Left multiplicity error. Please use \'exists\' instead of \'==\' in the expression: '+$leftParam->asString()+' == '+$rightParam->asString());

   assert($rightParam.multiplicity->hasUpperBound() && ($rightParam.multiplicity->getUpperBound() <= 1)
          ,|'Right multiplicity error. Please use \'exists\' instead of \'==\' in the expression: '+$leftParam->asString()+' == '+$rightParam->asString());

   validateParamHasDataTypeReturnType($leftParam);
   validateParamHasDataTypeReturnType($rightParam);

   let milestoningStrategy = getTemporalMilestoningStrategy($expression);

   if (!$milestoningStrategy->isEmpty()
     ,| if($operation.alias.relationalElement->toOne()->relationalElementIsMilestoned() && ($state.milestoningUseOtherwise == true || !(!$currentPropertyMapping->isEmpty() && $currentPropertyMapping->at(0)->instanceOf(EmbeddedRelationalInstanceSetImplementation)))
            ,| let opSelect = $operation.select;
               let newCurrentTreeNode = $operation.currentTreeNode->toOne()->findOneNode($operation.select.data->toOne(), $opSelect.data->toOne());
               let processMilestoningParams = {|processValueSpecificationReturnPropertyMapping($rightParam, $currentPropertyMapping, $operation, $vars, ^$state(shouldIsolate=false), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne().element->extractSelectSQLQuery()->toOne()};
               let milestonedFilteringSelect = $milestoningStrategy->toOne()->getEqualityMilestonedFiltering($opSelect, $leftParam, $newCurrentTreeNode.alias->toOne(), $operation.milestoningContext->toOne(), $processMilestoningParams, $state, $extensions);
               ^$operation
               (
                  select=$milestonedFilteringSelect,
                  currentTreeNode = [],
                  positionBeforeLastApplyJoinTreeNode = []
               );

           ,| $operation);
     ,|
         let left = processValueSpecificationReturnPropertyMapping($leftParam, $currentPropertyMapping, $operation, $vars, ^$state(shouldIsolate=false), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne();
         let right = processValueSpecificationReturnPropertyMapping($rightParam, $currentPropertyMapping, $operation, $vars, ^$state(shouldIsolate=false), $joinType, $nodeId, $aggFromMap, $context, $extensions)->toOne();
         let mergedSQL = mergeSQLQueryData([$left.element, $right.element]->map(x | $x->extractSelectSQLQuery()), $nodeId, $state, $context, $extensions);
         let leftVal = $state.inFilter->if(|$mergedSQL.filteringOperation->at(0),|$mergedSQL.columns->at(0));
         let rightVal = $state.inFilter->if(|$mergedSQL.filteringOperation->at(1),|$mergedSQL.columns->at(1));

         let filteringOperation = if($leftVal->hasReferenceToEnum() || $rightVal->hasReferenceToEnum(),
                                      |let firstVal  = ^EnumProcessingHolder(param = $leftParam, processedParam = $leftVal, currentPropertyMapping = $left);
                                       let secondVal = ^EnumProcessingHolder(param = $rightParam, processedParam = $rightVal, currentPropertyMapping = $right);
                                       processEqualsForEnum($firstVal, $secondVal, $context);,
                                      |if($leftVal->hasOptionalVarPlaceHolderValue() && $rightVal->hasOptionalVarPlaceHolderValue(),                                                   
                                          |^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$leftVal,
                                                                                                                              ^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$rightVal, ^DynaFunction(name = 'equal', parameters = [$leftVal,$rightVal]),^DynaFunction(name = 'equal', parameters = [^Literal(value = 1), ^Literal(value = 0)])]),   
                                                                                                                              ^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$rightVal, ^DynaFunction(name = 'equal', parameters = [^Literal(value = 1), ^Literal(value = 0)]),^DynaFunction(name = 'equal', parameters = [^Literal(value = 1), ^Literal(value = 1)])])]),
                                          |if($rightVal->hasOptionalVarPlaceHolderValue(),                                        
                                              |^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$rightVal, ^DynaFunction(name = 'equal', parameters = [$leftVal, $rightVal]), ^DynaFunction(name = 'isNull', parameters = [$leftVal])]),                                                                                                                                                           
                                              |if($leftVal->hasOptionalVarPlaceHolderValue(),
                                                  |^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$leftVal, ^DynaFunction(name = 'equal', parameters = [$leftVal, $rightVal]), ^DynaFunction(name = 'isNull', parameters = [$rightVal])]),      
                                                  |^DynaFunction(name = 'equal', parameters = [$leftVal, $rightVal]));                                           
                                              );
                                          );
                                     );

         let selectWithCursor = $left.element->extractSelectWithCursor($operation);

         ^$selectWithCursor(select = $state.inFilter->if(
                                    |^$mergedSQL(
                                            columns = $operation.select.columns->map(
                                               c|$c->match(
                                                  [
                                                     w:WindowColumn[1]|let colsInMerged = $mergedSQL.columns->filter(c|$c->extractTableAliasColumns().column.name==$w.columnName);
                                                                       if($colsInMerged->isEmpty(),|$w,|$colsInMerged->toOne());,
                                                     a: Alias[1]|let col = $mergedSQL.columns->filter(c|$c->instanceOf(Alias) && $c->cast(@Alias).name==$a.name);
                                                                 if($col->isEmpty(),|$a,|$col);,
                                                     r:RelationalOperationElement[1]|$r
                                                  ])),
                                            filteringOperation = $filteringOperation//,
                                            //savedFilteringOperation = []
                                     ),
                                    |^$mergedSQL(
                                            columns = $filteringOperation//,
                                            //savedFilteringOperation = []
                                     )
                               ),
                            currentTreeNode = [],
                            positionBeforeLastApplyJoinTreeNode = []

                     );
      );
}

Class meta::relational::functions::pureToSqlQuery::EnumProcessingHolder
{
  param : ValueSpecification[1];
  processedParam : RelationalOperationElement[1];
  currentPropertyMapping : OperationWithParentPropertyMapping[1];
}

function meta::relational::functions::pureToSqlQuery::hasReferenceToEnum(e:RelationalOperationElement[1]):Boolean[1]
{
  $e->hasEnumValue() || $e->hasEnumerationVarPlaceHolderValue()
}

function meta::relational::functions::pureToSqlQuery::hasEnumValue(e:RelationalOperationElement[1]):Boolean[1]
{
  $e->instanceOf(Literal) && $e->cast(@Literal).value->instanceOf(Enum)
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::hasEnumerationVarPlaceHolderValue(e:RelationalOperationElement[1]):Boolean[1]
{
  $e->instanceOf(Literal) && $e->cast(@Literal).value->instanceOf(VarPlaceHolder) && $e->cast(@Literal).value->cast(@VarPlaceHolder).type->instanceOf(Enumeration)
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::generateFreeMarkerOpSelectorForEnumParam(firstVal:FreeMarkerOperationHolder[1], secondVal:RelationalOperationElement[1], enumParam:RelationalOperationElement[1]):FreeMarkerOperationHolder[1]
{
  let enumFreeMarker = ^FreeMarkerOperationHolder(name = 'equalEnumOpSelector', parameters = [$firstVal, ^DynaFunction(name = 'in', parameters = [$secondVal, $firstVal]), ^DynaFunction(name = 'equal', parameters = [$secondVal, $firstVal])]);
  ^FreeMarkerOperationHolder(name = 'optionalVarPlaceHolderOpSelector', parameters = [$enumParam, $enumFreeMarker, ^DynaFunction(name = 'equal', parameters = [^Literal(value=0), ^Literal(value=1)])]);
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::generateFreeMarkerForEnumParam(propertyMapping:OperationWithParentPropertyMapping[1], enumParam:RelationalOperationElement[1]):FreeMarkerOperationHolder[1]
{  
  ^FreeMarkerOperationHolder(name = 'enumMap_' + fetchEnumFullPath($propertyMapping.currentPropertyMapping->cast(@RelationalPropertyMapping).transformer->cast(@EnumerationMapping<Any>)), parameters = [$enumParam->cast(@Literal)])
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::hasOptionalVarPlaceHolderValue(e:RelationalOperationElement[1]):Boolean[1]
{  
   $e->instanceOf(Literal) && $e->cast(@Literal).value->instanceOf(VarPlaceHolder) && $e->cast(@Literal).value->cast(@VarPlaceHolder).multiplicity->isNotEmpty() && $e->cast(@Literal).value->cast(@VarPlaceHolder).multiplicity->toOne()->isZeroOne();
}

function meta::relational::functions::pureToSqlQuery::validateParamHasDataTypeReturnType(vs:ValueSpecification[1]): Boolean[1]
{
    let type = $vs->match([
                            e : StoreMappingRoutedValueSpecification[1] | $e.value.genericType.rawType,
                            vs:ValueSpecification[1] | $vs.genericType.rawType
                         ]);

   assert($type->isEmpty() || $type->toOne()->instanceOf(DataType) || ($type->toOne() == Enum) || ($type->toOne() == Nil), | 'Filter expressions are only supported for Primitives and Enums. Filter contains a parameter of type ' + if($type->isEmpty(),|'',|$type->toOne()->toString()));
}

function meta::relational::functions::pureToSqlQuery::processEqualsForEnum(firstVal : EnumProcessingHolder[1], secondVal : EnumProcessingHolder[1], context : DebugContext[1]) : RelationalOperationElement[1]
{  
  let hasOnlyEnumValues = [$firstVal, $secondVal]->forAll(e|$e.processedParam->hasEnumValue());

    if($hasOnlyEnumValues,
        | ^DynaFunction(name = 'equal', parameters = [$firstVal, $secondVal]->map(v|^Literal(value=$v.processedParam->cast(@Literal).value->toString()))),
        | let enumVar = [$firstVal, $secondVal]->partition(e|$e.processedParam->hasEnumerationVarPlaceHolderValue());
          let hasEnumVarAndEnumProp = $enumVar.first.values->isNotEmpty() && $enumVar.second.values.currentPropertyMapping->toOne()->map(e|$e->cast(@OperationWithParentPropertyMapping).currentPropertyMapping->isNotEmpty() && $e->cast(@OperationWithParentPropertyMapping).currentPropertyMapping->cast(@RelationalPropertyMapping).transformer->toOne()->instanceOf(EnumerationMapping))->toOne();
          let hasEnumVarAndEnumVal = $enumVar.first.values->isNotEmpty() && $enumVar.second.values.processedParam->toOne()->hasEnumValue();
          if($hasEnumVarAndEnumProp,
              | let enumParamFreeMarker = generateFreeMarkerForEnumParam($enumVar.second.values.currentPropertyMapping->toOne(), $enumVar.first.values.processedParam->toOne());
                generateFreeMarkerOpSelectorForEnumParam($enumParamFreeMarker, $enumVar.second.values.processedParam->toOne(), $enumVar.first.values.processedParam->toOne());,
              | if($hasEnumVarAndEnumVal,
                    | let literal = $enumVar.first.values.processedParam->cast(@Literal).value->cast(@VarPlaceHolder); 
                      ^DynaFunction(name = 'equal', parameters = [^Literal(value=^VarPlaceHolder(name=$literal.name->toOne(),type = $literal.type->toOne(),multiplicity = $literal.multiplicity->toOne())), ^Literal(value = $enumVar.second.values.processedParam->cast(@Literal).value->toOne()->toString())]);,
                    | // Case 3 - EnumVal & EnumClassProp
                      let hasEnumProp = [$firstVal, $secondVal]->partition(e|$e.processedParam->hasEnumValue());
                      let sourceVal = enumToStoreValue($hasEnumProp.first.values.processedParam->cast(@Literal)->toOne(), $hasEnumProp.second.values.param->toOne()->evaluateAndDeactivate(), $hasEnumProp.second.values.currentPropertyMapping.currentPropertyMapping);
                      $sourceVal->match([
                                          l:Literal[1] |  ^DynaFunction(name = 'equal', parameters = [$hasEnumProp.second.values.processedParam->toOne(), $l]),
                                          ll: LiteralList[1] | ^DynaFunction(name = 'in', parameters = [$hasEnumProp.second.values.processedParam->toOne(), $ll])
                                        ]);
                  );
            );
      );
}

function meta::relational::functions::pureToSqlQuery::enumToStoreValue(enumWrapper : Literal[1],
        enumPropWrapper : ValueSpecification[1],
        currentPropertyMapping:PropertyMapping[*]):RelationalOperationElement[1]
{
    let enum = $enumWrapper->cast(@Literal).value;
    let expr = $enumPropWrapper->byPassRouterInfo()->cast(@SimpleFunctionExpression);

    let enumPropMapping = $currentPropertyMapping->at(0)->cast(@RelationalPropertyMapping);

    if ($expr.func.name == 'getEnum',
          | [],
          | let property = $expr.func->match([
                                      p:Property<Nil,Any|*>[1]|$p,
                                      n:NativeFunction<Any>[1]|
                                                                assert($n == map_T_m__Function_1__V_m_ || $n == map_T_$0_1$__Function_1__V_$0_1$_ || $n == map_T_MANY__Function_1__V_MANY_);
                                                               let lambda = $expr.parametersValues->evaluateAndDeactivate()->at(1)->byPassRouterInfo()->cast(@InstanceValue).values->at(0)->cast(@LambdaFunction<Any>);
                                                               $lambda.expressionSequence->at(0)->evaluateAndDeactivate()->byPassRouterInfo()->cast(@FunctionExpression).func->cast(@Property<Nil,Any|*>);
                                     ]);
             assertEquals($enumPropMapping.property, $property, 'The mapping must be for the enum property');
             );

    let sourceVal = if ($enumPropMapping->instanceOf(SemiStructuredRelationalPropertyMapping),
                        | $enum->id(),
                        | $enumPropMapping.transformer->toOne()->cast(@EnumerationMapping<Any> )->toSourceValues($enum)
                    );

    if ($sourceVal->size() == 1,
        | ^Literal(value=$sourceVal->toOne()),
        | ^LiteralList( values=$sourceVal->map(e | ^Literal(value = $e)) )
    );
}


function meta::relational::functions::pureToSqlQuery::processEnumValue(
        expression : FunctionExpression[1],
        currentPropertyMapping:PropertyMapping[*],
        operation : SelectWithCursor[1],
        vars : Map<VariableExpression, ValueSpecification>[1],
        state:State[1],
        joinType:JoinType[1],
        nodeId : String[1],
        aggFromMap:List<ColumnGroup>[1],
        context:DebugContext[1],
        extensions:Extension[*]
    ) : RelationalOperationElement[1]
{
    let enumValue = extractEnumValue($expression, $currentPropertyMapping, $context);
    let select = $operation.select;
    ^$operation(select = $state.inFilter->if(|^$select(filteringOperation = ^Literal(value = $enumValue)),|^$select(columns = ^Literal(value = $enumValue))));
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::extractEnumValue(
         expression : FunctionExpression[1],
         currentPropertyMapping:PropertyMapping[*],
         context:DebugContext[1]
   ) : Any[1]
{
    let enumeration = $expression->instanceValueAtParameter(0);
    let enumAsString = $expression->instanceValueAtParameter(1);

    print(if(!$context.debug, |'',
            | $context.space+ '  Extract Enum Value ('+$enumeration->cast(@Enumeration<Any>)->elementToPath()+'.'+$enumAsString->toString()+')\n'));


    let enum = extractEnumValue($enumeration->cast(@Enumeration<Any>), $enumAsString->cast(@String))->cast(@Enum);

   mapEnumValue($enum, $currentPropertyMapping, $context);

}

function <<access.private>> meta::relational::functions::pureToSqlQuery::mapEnumValue(
         enum : Enum[1],
         currentPropertyMapping:PropertyMapping[*],
         context:DebugContext[1]
   ) : Any[1]
{

    let hasPropertyMapping = $currentPropertyMapping->size() == 1 && $currentPropertyMapping->toOne()->instanceOf(RelationalPropertyMapping);

    print(if(!$context.debug, |'',
            | $context.space+ '  Has property mapping: '+$hasPropertyMapping->toString()+'\n'));


    let enumValue = if ($hasPropertyMapping,
                        |
                          print(if(!$context.debug, |'',
                                    | $context.space+ '     PropertyMapping: '+$currentPropertyMapping->toOne().property.name->joinStrings('')+'\n'));
                          let transformer = $currentPropertyMapping->toOne()->cast(@RelationalPropertyMapping).transformer;
                          let hasEnumMappingTransformer = !$transformer->isEmpty() && $transformer->toOne()->instanceOf(EnumerationMapping);
                          print(if(!$context.debug, |'',
                                    | $context.space+ '  Has EnumMapping Transformer: '+$hasEnumMappingTransformer->toString()+'\n'));
                          if($hasEnumMappingTransformer,
                                |$transformer->toOne()->cast(@EnumerationMapping<Any>)->toSourceValues($enum)->at(0),
                                |$enum
                          );,
                        | $enum
                     );

    assertSize($enumValue, 1, | 'Failed to find unique enum value for \''+$enum->toString()+'\' found '+$enumValue->size()->toString()+' values ('+$enumValue->makeString(', ')+')');

    $enumValue;
}

function meta::relational::functions::pureToSqlQuery::instanceValueAtParameter(expression : FunctionExpression[1], index : Integer[1]) : Any[1]
{
    instanceValuesAtParameter($expression,$index,[],[])->at(0);
}

function meta::relational::functions::pureToSqlQuery::processDistinct(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let nested = processValueSpecification($expression.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne();
   let mergedSQL = mergeSQLQueryData([$nested, $operation]->map(x | extractSelectSQLQuery($x)), $nodeId, $state, $context, $extensions);
   let selectWithCursor = $nested->extractSelectWithCursor($operation);
   ^$selectWithCursor(select = ^$mergedSQL(
                                      distinct = true
                                )
                     );
}

function meta::relational::functions::pureToSqlQuery::processUnary(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], f:meta::pure::metamodel::function::Function<{RelationalOperationElement[1]->RelationalOperationElement[1]}>[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   let nested = processValueSpecification($expression.parametersValues->at(0), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne()->cast(@SelectWithCursor);
   let existingSqlQuery = $nested.select;
   ^$nested(
      select = $state.inFilter->if(
                  |^$existingSqlQuery(
                        filteringOperation = $f->eval($existingSqlQuery.filteringOperation->toOne())
                    )
                  ,
                  |^$existingSqlQuery(
                        columns = $f->eval($existingSqlQuery.columns->toOne())
                    )
               )
   );
}

function meta::relational::functions::pureToSqlQuery::processVariableArity(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
    let select = $operation->cast(@SelectWithCursor).select;
    let source = ^$operation(select=^$select(filteringOperation = []));
    let args = processValueSpecification($expression.parametersValues->at(0), $currentPropertyMapping, $source, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions);
    let mergedSQL = mergeSQLQueryData($args->concatenate($source)->map(x | extractSelectSQLQuery($x)), $nodeId, $state, $context, $extensions);
    let currentTreeNode = $mergedSQL.data;
    ^SelectWithCursor(
       select = $state.inFilter->if(
                               | ^$mergedSQL(filteringOperation = newDynaFunction($expression.func.functionName->toOne(), $mergedSQL.filteringOperation));,
                               | let existingColsCount = $mergedSQL.columns->size() - $args->size();
                                 ^$mergedSQL(columns = $mergedSQL.columns->take($existingColsCount)->concatenate(newDynaFunction($expression.func.functionName->toOne(), $mergedSQL.columns->drop($existingColsCount))));
                          ),
       currentTreeNode = $currentTreeNode
    );
}


function meta::relational::functions::pureToSqlQuery::processStringPlus(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
    let args = $expression.parametersValues->map(p | processValueSpecification($p, $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions););
    let emptyString = ^Literal(value='');
    buildJoinStrings(mergeSQLQueryData($args->map(x | extractSelectSQLQuery($x)), $nodeId, $state, $context, $extensions), $emptyString, $emptyString, $emptyString, $operation, $nodeId, $state, $state.inFilter, $aggFromMap, $context, $extensions);
}

function meta::relational::functions::pureToSqlQuery::processJoinStrings(expression:FunctionExpression[1], currentPropertyMapping:PropertyMapping[*], operation:SelectWithCursor[1], vars:Map<VariableExpression, ValueSpecification>[1], state:State[1], joinType:JoinType[1], nodeId:String[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
    let params = $expression.parametersValues;
    let strings = processValueSpecification($params->at(0), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions);
    let size = $params->size();
    let emptyString = ^Literal(value='');
    let merged = mergeSQLQueryData($strings->map(x | extractSelectSQLQuery($x)->toOne()), $nodeId, $state, $context, $extensions);

    if (eq($size, 1),
        |  buildJoinStrings($merged, $emptyString, $emptyString, $emptyString, $operation, $nodeId, $state, $state.inFilter, $aggFromMap, $context, $extensions);,
        | if(eq($size, 2),
             | buildJoinStrings($merged, $emptyString, processValueSpecification($params->at(1), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne(), $emptyString, $operation, $nodeId, $state, $state.inFilter, $aggFromMap, $context, $extensions);,
             | buildJoinStrings($merged, processValueSpecification($params->at(1), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne(), processValueSpecification($params->at(2), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne(), processValueSpecification($params->at(3), $currentPropertyMapping, $operation, $vars, $state, JoinType.LEFT_OUTER, $nodeId, $aggFromMap, $context, $extensions)->toOne(), $operation, $nodeId, $state, $state.inFilter, $aggFromMap, $context, $extensions);
            );
        );
}


function meta::relational::functions::pureToSqlQuery::buildJoinStrings(strings:SelectSQLQuery[1], prefix:RelationalOperationElement[1], separator:RelationalOperationElement[1], suffix:RelationalOperationElement[1], operation:SelectWithCursor[1], nodeId:String[1], state:State[1], inFilter:Boolean[1], aggFromMap:List<ColumnGroup>[1], context:DebugContext[1], extensions:Extension[*]):RelationalOperationElement[1]
{
   print(if(!$context.debug, |'',
            | $context.space+ 'Start build join strings:' + $operation.select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

   let js = ^JoinStrings(
                         strings=$inFilter->if(|$strings.filteringOperation, |$strings.columns),
                         prefix=extractValue($prefix, $inFilter),
                         separator=extractValue($separator, $inFilter),
                         suffix=extractValue($suffix, $inFilter)
                        );

   let isAggregation = ($js.strings->size() == 1) && !$aggFromMap.values->isEmpty();

   let res = if($isAggregation,
                |manageAggregation($strings, $js, $operation, $state, $nodeId, $aggFromMap, $context, $extensions);,
                |^$operation(
                   select = $inFilter->if(
                                           |^SelectSQLQuery(
                                             columns = $operation.select.columns,
                                             data = $strings.data,
                                             filteringOperation = $js,
                                             extraFilteringOperation = $strings.extraFilteringOperation,
                                             savedFilteringOperation = $strings.savedFilteringOperation,
                                             orderBy = $strings.orderBy
                                            );,
                                           |^SelectSQLQuery(
                                             columns = $js,
                                             data = $strings.data,
                                             filteringOperation = $operation.select.filteringOperation,
                                             extraFilteringOperation = $strings.extraFilteringOperation,
                                             savedFilteringOperation = $strings.savedFilteringOperation,
                                             orderBy = $strings.orderBy
                                            );
                                       ),
                   currentTreeNode = [],
                   positionBeforeLastApplyJoinTreeNode = []
                 )
             );

   print(if(!$context.debug, |'',
            | $context.space+ 'End build join strings:' + $res.select->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+'\n'));

   $res;
}

function meta::relational::functions::pureToSqlQuery::extractSelectWithCursor(src:RelationalOperationElement[1], default:SelectWithCursor[1]):SelectWithCursor[1]
{
   $src->match(
                  [
                     o:SelectWithCursor[1] | $o,
                     o:Any[1] | $default
                  ]
              )
}

function meta::relational::functions::pureToSqlQuery::extractSelectSQLQuery(src:RelationalOperationElement[1]):SelectSQLQuery[0..1]
{
   $src->match(
                  [
                     o:SelectWithCursor[1] | $o.select,
                     l:Literal[1] | []
                  ]
              )
}

function meta::relational::functions::pureToSqlQuery::extractValue(src:RelationalOperationElement[1], inFilter: Boolean[1]):RelationalOperationElement[0..1]
{
   $src->match(
                  [
                     s  : SelectSQLQuery[1] | $inFilter->if( | $s.filteringOperation->toOne(), | $s.columns->toOne()),
                     o  : SelectWithCursor[1] | $inFilter->if( | $o.select.filteringOperation->toOne(), | $o.select.columns->toOne()),
                     l  : Literal[1] | $l,
                     ll : LiteralList[1] | $ll
                  ]
              )
}

function meta::relational::functions::pureToSqlQuery::reprocessJoinTreeNode(source:RelationalTreeNode[1], target:JoinTreeNode[1], list:OldAliasToNewAlias[*], nodeId:String[1]):Pair<JoinTreeNode, List<OldAliasToNewAlias>>[1]
{
   let oldTargetAlias = $target.alias;
   let newTargetAlias = ^TableAlias(name = $oldTargetAlias.name+$nodeId, relationalElement = $oldTargetAlias.relation->match([s:SemiStructuredArrayFlatten[1] | ^$s(navigation = $s.navigation->reprocessAliases($list)), r:RelationalOperationElement[1]|$r]));
   let newAliasMapping = ^OldAliasToNewAlias(first=$oldTargetAlias.name, second=$newTargetAlias);
   let val = $list->concatenate($newAliasMapping);

   let reprocessedResult = $target->children()->map(c| reprocessJoinTreeNode($target, $c, $val, buildNodeId($nodeId,'_r')));

   let propagateUp = $reprocessedResult->map(r|$r.second.values)->concatenate($newAliasMapping);
   pair(^$target(alias = $newTargetAlias, join = $target.join->reprocessJoin($val, []), childrenData = $reprocessedResult.first), ^List<OldAliasToNewAlias>(values=$propagateUp));
}

Class meta::relational::functions::pureToSqlQuery::MergeResultContainer
{
   node : RelationalTreeNode[1];
   columns : RelationalOperationElement[*];
   filteringOperation : RelationalOperationElement[*];
   groupBy : RelationalOperationElement[*];
   savedFilteringOperation : Pair<RelationalTreeNode, RelationalOperationElement>[*];
   leftSideOfFilter : RelationalTreeNode[0..1];
   extraFilteringOperation : RelationalOperationElement[*];
   oldToNewAliases : OldAliasToNewAlias[*];
}




function meta::relational::functions::pureToSqlQuery::possiblyMergeIsolatedBranches(commonNode:JoinTreeNode[1], childNode:JoinTreeNode[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):JoinTreeNode[1]
{
   if ($childNode.join.name->startsWith('__iso_') && $commonNode.alias.relationalElement->instanceOf(SelectSQLQuery) && $childNode.alias.relationalElement->instanceOf(SelectSQLQuery),
      |  let res = [
                     $commonNode.alias.relationalElement->cast(@SelectSQLQuery),
                     $childNode.alias.relationalElement->cast(@SelectSQLQuery)
                   ]->mergeSQLQueryData($nodeId, $state, $context, $extensions);
         let newFilteringOperation = $res.filteringOperation->filter(fo| $fo->extractTableAliasColumns().alias->isNotEmpty())->first();
         let mergedSub = ^$res(filteringOperation = $newFilteringOperation, columns = $res.columns->removeDuplicates({a,b|let a1 = $a->extractColumnEqualityKeyForMerge(); let a2 = $b->extractColumnEqualityKeyForMerge(); if($a1->isEmpty() || $a2->isEmpty(),|false,|$a1 == $a2);}));
         $commonNode->replaceTreeNodeRelationalElement($mergedSub, false, $extensions)->cast(@JoinTreeNode);,
      |$commonNode
   );
}

function meta::relational::functions::pureToSqlQuery::possiblyMergeUnions(commonNode:RelationalTreeNode[1], childNode:RelationalTreeNode[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):RelationalTreeNode[1]
{
   if ($commonNode.alias.relationalElement->instanceOf(Union) && $childNode.alias.relationalElement->instanceOf(Union),
      |  let union = $commonNode.alias.relationalElement->cast(@Union);
         let otherUnion = $childNode.alias.relationalElement->cast(@Union);

         let alias = $commonNode.alias;

         let newQueries = $union.queries->zip($otherUnion.queries)->map(q|let f = $q.first;
                                                                          let s = $q.second;
                                                                          let merged = [$f, $s]->mergeSQLQueryData($nodeId, $state, $context, $extensions);
                                                                                        ^$merged(filteringOperation = $merged.filteringOperation->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second);
                                                               );

         let merged = ^$union(queries = $newQueries,
                              currentTreeNodes = $newQueries.data
                      );

         let newAlias = ^$alias(relationalElement = $merged);

         if ($commonNode->instanceOf(JoinTreeNode),
            |let node = $commonNode->cast(@JoinTreeNode);
             ^$node
             (
               alias = $newAlias,
               join = $node.join->reprocessJoin(^OldAliasToNewAlias(first=$alias.name->toOne(), second=$newAlias), [])
             );,
            |^$commonNode
             (
               alias = $newAlias
             );
         );
      ,
      |$commonNode
   );
}




function meta::relational::functions::pureToSqlQuery::extractColumnEqualityKeyForMerge(column:RelationalOperationElement[1]):String[0..1]
{

   $column->match([d:DynaFunction[1] | $d.name->concatenate($d.parameters->map( p | $p->extractColumnEqualityKeyForMerge())->sort())->makeString('_'),
                   a:RelationalOperationElement[1] | let az = $a->extractColumnAliases(); if($az->isEmpty(), | [], | $az->at(0).name);
                  ])
}

Class meta::relational::functions::pureToSqlQuery::JoinTreeMetaData{
   transformedJtn : JoinTreeNode[1];
   jtnAliases : String[*];
   joinAliases : String[*];

   missingJoinAliases(){
      $this.joinAliases->filter(j|!$this.jtnAliases->contains($j))
   }:String[*];
}

function meta::relational::functions::pureToSqlQuery::buildAndTransformJoinMetaData(target:JoinTreeNode[1], parentJtns:JoinTreeNode[*], joinTransform : meta::pure::metamodel::function::Function<{Join[1],JoinTreeNode[*]->Join[1]}>[1]): JoinTreeMetaData[1]
{
   let newChildren = $target->children()->map(c| buildAndTransformJoinMetaData($c, $parentJtns->concatenate($target), $joinTransform));
   let newJoin = $joinTransform->eval($target.join,$parentJtns->concatenate($target));
   let newTarget = ^$target(childrenData=$newChildren.transformedJtn, join=$newJoin);
   let joinAliases = $newJoin.operation->gatherAllOperations(true)->map(o|$o->match([t:TableAliasColumn[1]|$t.alias.name, al:Alias[1]|$al.name,a:Any[1]|[]]));
   ^JoinTreeMetaData(transformedJtn=$newTarget, jtnAliases=$newTarget.alias.name->concatenate($newChildren.jtnAliases), joinAliases=$newChildren.joinAliases->concatenate($joinAliases)->distinct()->filter(a|$a != 'root'));
}

function meta::relational::functions::pureToSqlQuery::mergeOldAliasToNewAlias(resetAliasMap:Boolean[1], current:OldAliasToNewAlias[*], new:OldAliasToNewAlias[*]): OldAliasToNewAlias[*]{
   if($resetAliasMap,|[],|$current)->concatenate($new)->removeDuplicatesBy({x | $x.first})->filter(p|$p.first != $p.second.name)
}

function meta::relational::functions::pureToSqlQuery::reAliasMergedJoinOperations(mergeContainer:MergeResultContainer[1]): MergeResultContainer[1]{
   if($mergeContainer.node->instanceOf(RootJoinTreeNode) && !$mergeContainer.oldToNewAliases->isEmpty(),| let new_a = $mergeContainer.node;
                                                                                                                  let distinctOldToNewAliases = $mergeContainer.oldToNewAliases->distinct();
                                                                                                                  let newChildren = if(!$distinctOldToNewAliases->isEmpty(),|$new_a->children()->map(c|buildAndTransformJoinMetaData($c, [], {j:Join[1], parentJtns:JoinTreeNode[*]|let parentAliases=$parentJtns.alias.name; let oldToNewExcludeParents=$distinctOldToNewAliases->filter(a|!$parentAliases->contains($a.first)); $j->reprocessJoin($oldToNewExcludeParents, []);})).transformedJtn,|$new_a->children());
                                                                                                                  let new_new_a = ^$new_a(childrenData=$newChildren);
                                                                                                                  ^$mergeContainer(node = $new_new_a, savedFilteringOperation=$mergeContainer.savedFilteringOperation->map(p| let foundNode = $p.first->findNode($new_a->toOne(), $new_new_a);
                                                                                                                                                                                                                              if ($foundNode->isEmpty(), | $p, | pair($foundNode->toOne(), $p.second->reprocessAliases($distinctOldToNewAliases)));
                                                                                                                                                                                                                           ));
                                                                                                               ,|$mergeContainer);
}

function meta::relational::functions::pureToSqlQuery::merge(parentTargetTreeNode:MergeResultContainer[1], sourceTreeNode:RelationalTreeNode[1], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):MergeResultContainer[1]
{
   if (!$sourceTreeNode->children()->isEmpty(),
      |
        $sourceTreeNode->children()->fold(
           {
              childNode, a |
                 let commonNode = $a.node->children()->cast(@JoinTreeNode)->filter(jtn|eq($jtn.join.name, $childNode.join.name));

                 let res = if ($commonNode->isEmpty(),
                     |
                        let initAlias = ^OldAliasToNewAlias(first=$sourceTreeNode.alias.name, second=$a.node.alias);
                        let res = reprocessJoinTreeNode($sourceTreeNode, $childNode, $initAlias, $nodeId);
                        let newAliases = $res.second.values->add($initAlias);
                        let parentFilters = $a.filteringOperation->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second;
                        let parentSavedFilters = $a.savedFilteringOperation;
                        let parentExtraFilters  = $a.extraFilteringOperation;
                        let parentGroupBy = $a.groupBy;

                        let mergedOriginalNode = $a.node->possiblyMergeUnions($sourceTreeNode, $nodeId, $state, $context, $extensions);

                        let newOriginalNode = ^$mergedOriginalNode
                                              (
                                                 childrenData += $res.first
                                              );


                        ^MergeResultContainer
                        (
                           node = $newOriginalNode,
                           columns = $a.columns->reprocessAliases($newAliases),
                           filteringOperation = if($parentFilters->isEmpty(),|[], |$parentFilters->reprocessAliases($newAliases)->toOne()),
                           savedFilteringOperation = $parentSavedFilters->map(p|pair(findNodeWithAliasBreakOnFork($newOriginalNode,$newAliases->filter( a | $a.first==$p.first.alias.name)->toOne().second)->toOne(), $p.second->reprocessAliases($newAliases))),
                           extraFilteringOperation = $parentExtraFilters->reprocessAliases($newAliases),
                           groupBy = if($parentGroupBy->isEmpty(), |[], |$parentGroupBy->reprocessAliases($newAliases)),
                           oldToNewAliases=mergeOldAliasToNewAlias($a->instanceOf(RootJoinTreeNode), $a.oldToNewAliases, $res.second.values)
                        );
                     ,
                     |  let possiblyModifiedCommonNode = $commonNode->toOne()->possiblyMergeIsolatedBranches($childNode, $nodeId, ^$state(shouldIsolate=false), $context, $extensions)
                                                           ->possiblyMergeUnions($childNode, $nodeId, $state, $context, $extensions)->cast(@JoinTreeNode);

                        let replace = ^OldAliasToNewAlias(first=$commonNode->toOne().alias.name, second=$possiblyModifiedCommonNode.alias);

                        let mergeNodes = merge(^MergeResultContainer
                                                  (
                                                     node = $possiblyModifiedCommonNode->toOne(),
                                                     columns=$a.columns->map(c|$c->reprocessAliases($replace)),
                                                     filteringOperation = $a.filteringOperation->reprocessAliases($replace),
                                                     savedFilteringOperation = $a.savedFilteringOperation->map(p|pair(if ($p.first.alias.name == $commonNode.alias.name, |$possiblyModifiedCommonNode,|$p.first),$p.second->reprocessAliases($replace));),
                                                     extraFilteringOperation = $a.extraFilteringOperation->map(e|$e->reprocessAliases($replace)),
                                                     groupBy=$a.groupBy
                                                  ),
                                               $childNode,
                                               buildNodeId($nodeId, '_md'),
                                               $state,
                                               $context,
                                               $extensions
                                         );

                        let postMergeCommonNode = $mergeNodes.node->cast(@JoinTreeNode);

                        let commonTargetAlias = $postMergeCommonNode->toOne().alias;

                        let commonSourceAlias = $postMergeCommonNode->toOne().join->otherTableFromAlias($postMergeCommonNode->toOne().alias)->toOne();
                        let oldTargetAlias = $childNode.alias;
                        let oldSourceAlias = $childNode.join->otherTableFromAlias($childNode.alias);

                        let val = [
                                     ^OldAliasToNewAlias(first=$oldSourceAlias->toOne().name, second=$commonSourceAlias),
                                     ^OldAliasToNewAlias(first=$oldTargetAlias.name, second=$commonTargetAlias)
                                  ];

                        let mergedOriginalNode = $a.node->possiblyMergeUnions($sourceTreeNode, $nodeId, $state, $context, $extensions);

                        let parentFilters = $mergeNodes.filteringOperation->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second;
                        let parentSavedFilters = $mergeNodes.savedFilteringOperation;
                        let parentExtraFiler = $mergeNodes.extraFilteringOperation;
                        let parentGroupBy = $mergeNodes.groupBy;
                        let nodesToAdd = $a.node->children()->filter(c|$c != $commonNode);
                        let newOriginalNode = ^$mergedOriginalNode
                                              (
                                                 childrenData = if($state.preserveJoinOrder->isNotEmpty() && $state.preserveJoinOrder->toOne(),
                                                                   |$mergeNodes.node->concatenate($nodesToAdd),
                                                                   |$nodesToAdd->add($mergeNodes.node)
                                                                  )
                                              );

                        ^MergeResultContainer
                        (
                           node = $newOriginalNode,
                           columns = $mergeNodes.columns->reprocessAliases($val),
                           filteringOperation = if($parentFilters == [] || $parentFilters->isEmpty(),|[], |$parentFilters->reprocessAliases($val)->toOne()),
                           savedFilteringOperation = $parentSavedFilters->map(p|pair(if($p.first==$a.node ,|$newOriginalNode,|$p.first), $p.second->reprocessAliases($val));),
                           extraFilteringOperation = $parentExtraFiler->reprocessAliases($val),
                           groupBy = if($parentGroupBy->isEmpty(), |[], |$parentGroupBy->reprocessAliases($val)),
                           oldToNewAliases=mergeOldAliasToNewAlias($a->instanceOf(RootJoinTreeNode),$a.oldToNewAliases,$replace->concatenate($val)->concatenate($mergeNodes.oldToNewAliases))
                        );
                    );
                    $res->reAliasMergedJoinOperations();
           }
        ,
        $parentTargetTreeNode
      );
      ,
       |
        let newNode = $parentTargetTreeNode.node->possiblyMergeUnions($sourceTreeNode, $nodeId, $state, $context, $extensions);
        let remap = ^OldAliasToNewAlias(first=$sourceTreeNode.alias.name, second=$newNode.alias);
       ^$parentTargetTreeNode
        (
           node = $newNode,
           columns = $parentTargetTreeNode.columns->reprocessAliases($remap),
           filteringOperation = $parentTargetTreeNode.filteringOperation->reprocessAliases($remap),
           savedFilteringOperation = $parentTargetTreeNode.savedFilteringOperation->map(p|
																															 pair(
                                                                                           if($p.first == $sourceTreeNode, |$newNode, |$p.first),
																																  $p.second->reprocessAliases($remap)
																																 );
                                                                                    )
        );
  );
}


function meta::relational::functions::pureToSqlQuery::mergeSQLQueryData(preQuerySet:SelectSQLQuery[*], nodeId:String[1], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectSQLQuery[1]
{
   print(if(!$context.debug, |'',
            | $context.space+'   Merge\n'+$preQuerySet->map(q|$q.leftSideOfFilter->size()->toString()+' '+$q->meta::relational::functions::sqlQueryToString::sqlQueryToString(meta::relational::runtime::DatabaseType.H2, $extensions))->makeString($context.space+'     [\n'+$context.space+'       ','\n'+$context.space+'       ','\n'+$context.space+'     ]')+'\n'));

   let hasIsolations = $preQuerySet->map(p|$p.data->getAllNodeNames()->filter(n|$n->startsWith('__iso'))->makeString('|'))->removeDuplicates()->size() > 1;
   let querySet = $preQuerySet->map(q|let selfJoinAddedPreviously = if($q.data->isNotEmpty(),|$q.data->toOne()->addedSelfJoin(),|false);
                                    $q->manageIsolation([], [], $nodeId, false, ^$state(shouldIsolate = ($state.shouldIsolate || $hasIsolations) && !$selfJoinAddedPreviously), $context, $extensions););

   print(if(!$context.debug, |'',
            | $context.space+'   Merge(hasIsolations:'+$hasIsolations->toString()+')\n'+$querySet->map(q|$q.leftSideOfFilter->size()->toString()+' '+$q->meta::relational::functions::sqlQueryToString::sqlQueryToString(meta::relational::runtime::DatabaseType.H2, $extensions))->makeString($context.space+'     [\n'+$context.space+'       ','\n'+$context.space+'       ','\n'+$context.space+'     ]')+'\n'));

   $querySet->map(q|$q->validate($extensions));

   let res = $querySet->tail()->fold(
      {
         q,a |
               print(if(!$context.debug, |'',
                        | $context.space+'     (A): '+$a->printDebugQuery($context.space, $extensions)+
                          $context.space+'     (Q): '+$q->printDebugQuery($context.space, $extensions)
                       )
                    );
               let q_moved = if($q.columns->filter(c|$c->instanceOf(Alias) && $c->cast(@Alias).relationalElement->instanceOf(WindowColumn))->map(w|$a.filteringOperation->extractTableAliasColumns().column.name->contains($w->cast(@Alias).name))->contains(true),|$q->moveSelectQueryToSubSelect($q.data,[],'root',$context, $extensions),|$q);
               if ($q != [] && !$q.data->isEmpty()
                   ,|
                      // let shouldIsolate = shouldIsolateSubJoins($a, $q, $context->shift());
                      let new_a = $a;//if ($shouldIsolate,|$a->possiblyIsolateSubJoins($nodeId),|$a);
                      let new_q = $q_moved;//if ($a->isIsolated() || $shouldIsolate,|$q->possiblyIsolateSubJoins($nodeId),|$q);

                      let id = buildNodeId($nodeId, '_m'+$querySet->indexOf($q)->toString());

                      let merged = merge(
                                           ^MergeResultContainer(
                                              node = $new_a.data->toOne(),
                                              columns = $new_q.columns,
                                              filteringOperation = $new_q.filteringOperation,
                                              savedFilteringOperation = $new_q.savedFilteringOperation,
                                              extraFilteringOperation = $new_q.extraFilteringOperation,
                                              groupBy = $new_q.groupBy
                                            ),
                                            $new_q.data->toOne(),
                                            $id,
                                            $state,
                                            $context,
                                            $extensions
                                        );
                    let newGroupBy = $new_a.groupBy->concatenate($merged.groupBy)->removeDuplicates();

                    let newNodeAliases = $merged.node->toOne()->getAllNodes()->cast(@RelationalTreeNode).alias;
                    let remap = $newNodeAliases->map(n |^OldAliasToNewAlias(first=$n.name,second=$n));

                    ^$new_a
                         (
                            columns = $new_a.columns->concatenate($merged.columns)->removeDuplicates({a,b|$a->match([a:Alias[1]|$a.name,a:Any[1]|'']) == $b->match([b:Alias[1]|$b.name,b:Any[1]|'x'])}),
                            data = $merged.node->cast(@RootJoinTreeNode),
                            filteringOperation = $new_a.filteringOperation->reprocessAliases($remap)->concatenate($merged.filteringOperation),
                            savedFilteringOperation = $new_a.savedFilteringOperation->map(p|pair($p.first, $p.second->reprocessAliases($remap)))->concatenate($merged.savedFilteringOperation),
                            extraFilteringOperation = $new_a.extraFilteringOperation->reprocessAliases($remap)->concatenate($merged.extraFilteringOperation),
                            groupBy = $newGroupBy
                         );
                   ,| let cols = $a.columns->filter(c|$c->instanceOf(WindowColumn));
                        ^$a
                         (
                            columns = $a.columns->concatenate($q.columns)->filter(c|!$c->instanceOf(WindowColumn))->removeDuplicates({a,b|$a->match([a:Alias[1]|$a.name,a:Any[1]|'']) == $b->match([b:Alias[1]|$b.name,b:Any[1]|'x'])})->concatenate($cols),
                            filteringOperation += $q.filteringOperation,
                            savedFilteringOperation += $q.savedFilteringOperation,
                            extraFilteringOperation += $q.extraFilteringOperation,
                            groupBy = if ($q.groupBy->isEmpty(), | $a.groupBy, | $q.groupBy)
                         );
               );
      }, $querySet->first()->toOne()
   );

   let filtered = ^$res
   (
      leftSideOfFilter = if($querySet->at(0).leftSideOfFilter->isEmpty(),|[],|$querySet->at(0).leftSideOfFilter->toOne()->findOneNode($querySet->at(0).data->toOne(), $res.data->toOne())),
      savedFilteringOperation = $res.savedFilteringOperation->map(f|pair($f.second->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second
                                                            ->map(p| let originalQuery = $querySet->filter(q|!$q.data->isEmpty() && $q.data->toOne()->getAllNodes()->contains($p.first));
                                                                     pair(if ($originalQuery->isEmpty(),|$p.first,|$p.first->findOneNode($originalQuery->at(0).data->toOne(), $res.data->toOne())), $p.second);
                                                             ),
      extraFilteringOperation = $res.extraFilteringOperation->map(f|pair($f->buildUniqueName(true, $extensions), $f))->removeDuplicates({a,b|$a.first == $b.first}).second
   );


   $filtered->validate($extensions);

   print(if(!$context.debug, |'', |$context.space+'   Merge Result: '+$filtered->printDebugQuery($context.space, $extensions))
        );

   $filtered;
}

function meta::relational::functions::pureToSqlQuery::addExtraJoinColumns(tableAlias: TableAlias[1], j:Join[1]):TableAlias[1]
{
   let joinTableAliasColumns = $j.operation->extractTableAliasColumns()->filter(c|$c.alias==$tableAlias)->removeDuplicates();
   let updatedRelationalElement = $tableAlias.relationalElement->match([s:SelectSQLQuery[1] | let existingCols = $s.columns->map(col| $col->match([tac:TableAliasColumn[1] | $tac.column.name,
                                                                                                                                                   a:Alias[1] | $a.name
                                                                                                                                             ]));
                                                                                              //join alias is vs select, not safe to use the same alias within the select's join tree nodes, since it will likely match with the root (CorrelatedSubQuery), but the subselect could have many nodes
                                                                                              let allNodes = $s.data->toOne()->getAllNodes()->cast(@RelationalTreeNode);
                                                                                              let nodeAliasNameToRelation = $allNodes->map(n|pair($n.alias.name, $n.alias.relation))->newMap();
                                                                                              let colsToAdd = $joinTableAliasColumns->filter(c|!$existingCols->contains($c.column.name))->map(c|if($nodeAliasNameToRelation->get($c.alias.name).columns->contains($c.column),| $c
                                                                                                                                                                                                                                                                       ,| let aliasWithMatchingColumn = $allNodes.alias->filter(a|$a.relation->match([s:ViewSelectSQLQuery[1]|$s.view,r:Relation[1]|$r])->cast(@Relation).columns->contains($c.column));
                                                                                                                                                                                                                                                                          // checking sub-select for handling class mapping inner join filters
                                                                                                                                                                                                                                                                          let subSelectAliasWithMatchingColumn = $allNodes.alias->filter(a|$a.relation->instanceOf(SelectSQLQuery) && $a.relation.columns->filter(col | $col->extractColumnName() == $c.column.name)->extractTableAliasColumns().column->contains($c.column));
                                                                                                                                                                                                                                                                          if($aliasWithMatchingColumn->size()==1,
                                                                                                                                                                                                                                                                             |^Alias(name=$c.column.name, relationalElement=^$c(alias=$aliasWithMatchingColumn->toOne())),
                                                                                                                                                                                                                                                                             | if($subSelectAliasWithMatchingColumn->size() == 1,
                                                                                                                                                                                                                                                                                  |^Alias(name=$c.column.name, relationalElement=^$c(alias=$subSelectAliasWithMatchingColumn->toOne())),
                                                                                                                                                                                                                                                                                  |assert(false, | 'Unable to determine the select node alias to use for the extra column:'+$c.column.name->toOne()+if($aliasWithMatchingColumn->size() > 1,|' ,found matching aliases: '+$aliasWithMatchingColumn->map(a|$a.name)->makeString('[',',',']'),|' ,no valid aliases found'));^Alias(relationalElement = ^RelationalOperationElement(), name='fakeAlias');));
                                                                                                                                                                                              ));
                                                                                              ^$s(columns+=$colsToAdd);,
                                                                       r:RelationalOperationElement[1] | $r; ]);
   ^$tableAlias(relationalElement=$updatedRelationalElement);
}

Class meta::relational::functions::pureToSqlQuery::ApplyJoinInTreeState{
   select: SelectSQLQuery[1];
   position : RelationalTreeNode[1];
}

function <<access.private>> meta::relational::functions::pureToSqlQuery::applyJoinInTreeDeep(inputState : ApplyJoinInTreeState[1], joinTreeNode:JoinTreeNode[1], parent:SelectWithCursor[1], milestoningContext: TemporalMilestoningContext[0..1], joinTreeContainsInnerJoin:Boolean[1], nodeId:String[1], joinType:JoinType[1], reprocess:Boolean[1], extraColumns:TableAliasColumn[*], state:State[1], context:DebugContext[1], extensions:Extension[*]):ApplyJoinInTreeState[1]
{
   let sourceSelect=$inputState.select;
   let position=$inputState.position;
   let jt=if($joinTreeNode.joinType == [] || $joinTreeNode.joinType->isEmpty(),|$joinType, |$joinTreeNode.joinType->toOne());
   let appliedJoinTreeNode = applyOneJoin($position, $joinTreeNode, $nodeId, $jt, $reprocess, $state, $milestoningContext, $context, $extensions);
   let positionAliasWithExtraJoinCols = $position.alias->addExtraJoinColumns($appliedJoinTreeNode.join); //subselect may not have all cols required for join (prev isolation if applied may take care of this)
   let uniqueAppliedJoinTreeNode =  if($position.childrenData->filter(c|$c->cast(@JoinTreeNode).joinName==$appliedJoinTreeNode.joinName)->isEmpty()
                                      ,|^$appliedJoinTreeNode(join = reprocessJoin($appliedJoinTreeNode.join, [^OldAliasToNewAlias(first = $position.alias.name, second = $positionAliasWithExtraJoinCols)], []))
                                      ,| let newJoinName = $appliedJoinTreeNode.join.name+$appliedJoinTreeNode.join.operation->buildUniqueName(false, $extensions);
                                         let join = reprocessJoin($appliedJoinTreeNode.join, [^OldAliasToNewAlias(first = $position.alias.name, second = $positionAliasWithExtraJoinCols)], []);
                                         let newJoin = ^$join(name=$newJoinName);
                                         ^$appliedJoinTreeNode(joinName=$newJoinName,join=$newJoin);
                                       );

   let newPosition = if($position->instanceOf(JoinTreeNode),
                        |let positionJoinTreeNode = $position->cast(@JoinTreeNode);
                         ^$positionJoinTreeNode(childrenData += $uniqueAppliedJoinTreeNode, alias=$positionAliasWithExtraJoinCols, join = reprocessJoin($positionJoinTreeNode.join, [^OldAliasToNewAlias(first = $position.alias.name, second = $positionAliasWithExtraJoinCols)], []));,
                        |^$position(childrenData += $uniqueAppliedJoinTreeNode, alias=$positionAliasWithExtraJoinCols););

   let newRoot = $sourceSelect.data->toOne()->replaceTreeNode($position, $newPosition)->cast(@RootJoinTreeNode);

   let milestoningFilters = getAppliedJoinMilestoningFilters($milestoningContext, $joinTreeNode, $uniqueAppliedJoinTreeNode, $state);

   let newSelect = ^$sourceSelect(data=$newRoot,
                                  leftSideOfFilter=if($sourceSelect.leftSideOfFilter->isEmpty(),|[],|$sourceSelect.leftSideOfFilter->toOne()->findOneNode($sourceSelect.data->toOne(), $newRoot)),
                                  savedFilteringOperation=$sourceSelect.savedFilteringOperation->map(p|pair($p.first->findOneNode($sourceSelect.data->toOne(), $newRoot), $p.second))
                   );//force isolation

   let swc = ^SelectWithCursor(select=$newSelect, currentTreeNode=$uniqueAppliedJoinTreeNode);
   $swc->validate([], $extensions);
   let isolatedSwc = if(!$milestoningFilters->isEmpty() && !$joinTreeContainsInnerJoin,| let isInnerJoin=$jt == JoinType.INNER;
                                                                                         let isLeafJoinTreeNode = $joinTreeNode->children()->isEmpty();
                                                                                         let extraColumnsForIsolation = if($isLeafJoinTreeNode,|[$extraColumns],|[]);
                                                                                         let swcMilestoningFiltersIsolated = ^$swc(select=^$newSelect(savedFilteringOperation=$milestoningFilters))->manageIsolation($extraColumnsForIsolation, $nodeId, $isInnerJoin, ^$state(shouldIsolate=true, shouldIsolateNestedFilter=true), $context, $extensions);
                                                                                         let selectMilestoningFiltersIsolated = $swcMilestoningFiltersIsolated.select;
                                                                                         ^$swcMilestoningFiltersIsolated(select=^$selectMilestoningFiltersIsolated(savedFilteringOperation=$selectMilestoningFiltersIsolated.savedFilteringOperation->concatenate($newSelect.savedFilteringOperation->map(p|pair($p.first->findOneNode($newSelect.data->toOne(), $selectMilestoningFiltersIsolated.data->toOne()), $p.second)))));
                                                                                      ,| ^$swc(select=^$newSelect(savedFilteringOperation=$newSelect.savedFilteringOperation->concatenate($milestoningFilters))));
   let isolatedSelect = $isolatedSwc.select;
   let newIsolatedSelect=^$isolatedSelect(leftSideOfFilter = if($sourceSelect.leftSideOfFilter->isEmpty(),|[],|$sourceSelect.leftSideOfFilter->toOne()->findNode($sourceSelect.data->toOne(), $isolatedSelect.data->toOne())->first()));//isolation doesn't appear to manage this
   let isolatedAppliedJoinTreeNode = $isolatedSwc.currentTreeNode->cast(@JoinTreeNode)->toOne();
   let outputState=^ApplyJoinInTreeState(select=$newIsolatedSelect, position=$isolatedAppliedJoinTreeNode);

   $joinTreeNode->children()->fold({joinTreeNode, s|    let joinTypeToUse = if($joinTreeNode.joinType == [] || $joinTreeNode.joinType->isEmpty(),|$joinType, |$joinTreeNode.joinType->toOne());
                                                       applyJoinInTreeDeep(^$s(position=$isolatedAppliedJoinTreeNode), $joinTreeNode, $parent, $milestoningContext, $joinTreeContainsInnerJoin, buildNodeId($nodeId,'_l'), $joinTypeToUse, $reprocess, $extraColumns, $state, $context, $extensions);
                                                  }, $outputState);
}

function meta::relational::functions::pureToSqlQuery::applyJoinInTree(root:RootJoinTreeNode[1], position: RelationalTreeNode[1], joinTree:JoinTreeNode[1], parent:SelectWithCursor[1], nodeId:String[1], joinType:JoinType[1], reprocess:Boolean[1], shiftCurrentTreeNode:Boolean[1], extraColumns:TableAliasColumn[*], state:State[1], context:DebugContext[1], extensions:Extension[*]):SelectWithCursor[1]
{
  let joinTreeContainsInnerJoin = $joinTree->getAllNodes()->fold({n,b|($n->instanceOf(JoinTreeNode) && $n->cast(@JoinTreeNode).joinType==JoinType.INNER) || $b},false);
  let select = ^SelectSQLQuery(data=$root, leftSideOfFilter = if($parent.select.leftSideOfFilter->isEmpty(),|[],|$parent.select.leftSideOfFilter->toOne()->findNode($parent.select.data->toOne(), $root->cast(@RootJoinTreeNode))->first()));
  let finalState = applyJoinInTreeDeep(^ApplyJoinInTreeState(select=$select, position=$position), $joinTree, $parent, $parent.milestoningContext, $joinTreeContainsInnerJoin, $nodeId, $joinType, $reprocess, $extraColumns, $state, $context, $extensions);

  let selectWithJoinsApplied = $finalState.select;
  $selectWithJoinsApplied->validate($extensions);
  let positionInNewTree = $position->findOneNode($root, $selectWithJoinsApplied.data->toOne());
  let currentTreeNode = if($shiftCurrentTreeNode, |$finalState.position, |$positionInNewTree);

  ^SelectWithCursor(
     select = ^$selectWithJoinsApplied(extraFilteringOperation = $selectWithJoinsApplied.extraFilteringOperation->concatenate($parent.select.extraFilteringOperation)),
     currentTreeNode = $currentTreeNode,
     parent = $parent,
     positionBeforeLastApplyJoinTreeNode = $positionInNewTree,
     milestoningContext = $parent.milestoningContext
  );
}

function meta::relational::functions::pureToSqlQuery::findLastJoinTreeNode(node:RelationalTreeNode[1]):RelationalTreeNode[1]
{
   // Should use a flag in the structure for trees
   if ($node.childrenData->isEmpty(),
         |$node,
         |assert($node.childrenData->size() == 1, 'Can\'t find the last JoinTreeNode in a tree!');
          $node.childrenData->map(c|$c->cast(@RelationalTreeNode)->findLastJoinTreeNode());
   )->toOne();
}

function meta::relational::functions::pureToSqlQuery::findMainTable(relation : RelationalOperationElement[1]):Table[1]
{
   $relation->match([
                       t:Table[1]|$t,
                       v:View[1]|$v->mainTable(),
                       u:Union[1]|$u.queries->at(0).data.alias.relationalElement->toOne()->findMainTable(),
                       s:SelectSQLQuery[1]|if($s.preIsolationCurrentTreeNode->isEmpty(),
                                                  |$s.data->toOne()->findLastJoinTreeNode(),
                                                  |$s.preIsolationCurrentTreeNode->toOne();
                                           ).alias.relation->findMainTable();
                    ]);
}

function meta::relational::functions::pureToSqlQuery::findMainNamedRelation(relation : RelationalOperationElement[1]):NamedRelation[1]
{
   $relation->match([v:View[1]|$v,
                     s:SelectSQLQuery[1]|if($s.preIsolationCurrentTreeNode->isEmpty(),
                                                  |$s.data->toOne()->findLastJoinTreeNode(),
                                                  |$s.preIsolationCurrentTreeNode->toOne();
                                           ).alias.relation->findMainNamedRelation();,
                     r:RelationalOperationElement[1]|$r->findMainTable()]);
}

function meta::relational::functions::pureToSqlQuery::findTarget(join:Join[1], sourceNode:RelationalTreeNode[1], extensions:Extension[*]):TableAlias[1]
{
   if (!$join.target->isEmpty(), |$join.target->toOne(), | let sourceTableAlias = $sourceNode.alias;
                                                           let tb = $sourceTableAlias.relation->findMainNamedRelation();
                                                           let j = $join->otherTable($tb);
                                                           if ($j->isEmpty(),
                                                              | fail('Join ' + $join.name + ' not correctly specified/mapped. It does not join to the target table ' + $sourceTableAlias.relation->match([t:Table[1]|$t.name,
                                                                                                                                                                                                          u:Union[1]|'\'union\'',
                                                                                                                                                                                                          s:SelectSQLQuery[1]|'\''+$s->meta::relational::functions::sqlQueryToString::processOperation(meta::relational::runtime::DatabaseType.H2, $extensions)+' (mainTable: '+$tb.name+') \'';
                                                                                                                                                                                                         ])
                                                                                                                                                                                                   );
                                                                $j->toOne();,
                                                              | $j->toOne());
                                                           );
}

function meta::relational::functions::pureToSqlQuery::applyOneJoin(currentNode:RelationalTreeNode[1], joinTree:JoinTreeNode[1], nodeId:String[1], joinType:JoinType[1], reprocess:Boolean[1], state:State[1], milestoningContext: TemporalMilestoningContext[0..1], context:DebugContext[1], extensions:Extension[*]):JoinTreeNode[1]
{
   let join = $joinTree.join;
   let targetAliasInJoin = findTarget($join, $currentNode, $extensions);
   let sourceAliasInJoin = $join->otherTableFromAlias($targetAliasInJoin)->toOne();

   let newTargetAlias = createJoinTableAlias($targetAliasInJoin, $nodeId, $state, $milestoningContext, $context, $extensions);

   let res = ^$joinTree(
                 alias=$newTargetAlias,
                 join=if($reprocess,
                       |reprocessJoin(
                                          $join,
                                          [
                                            ^OldAliasToNewAlias(first=$sourceAliasInJoin.name->toOne(), second=$currentNode.alias),
                                            ^OldAliasToNewAlias(first=$targetAliasInJoin.name->toOne(), second=$newTargetAlias)
                                          ], []
                                     ),
                       |$join
                     ),
                 joinType = $joinType,
                 childrenData = []
             );
}

function meta::relational::functions::pureToSqlQuery::createJoinTableAlias(targetAliasInJoin:TableAlias[1], nodeId:String[1], state:State[1], milestoningContext: TemporalMilestoningContext[0..1], context:DebugContext[1], extensions:Extension[*]):TableAlias[1]
{
   let aliasName = if( $targetAliasInJoin.relation->instanceOf(Table),
                        | $targetAliasInJoin.relation->cast(@Table).name->replace(' ', '_')->replace('"', '')+$nodeId,|$targetAliasInJoin.name+$nodeId);

    let relationalElement = $targetAliasInJoin.relationalElement->processRelation([], $nodeId, false, 0, false, $milestoningContext, $state, $context, $extensions);

   ^TableAlias(relationalElement = $relationalElement, name=$aliasName);
}

function meta::relational::functions::pureToSqlQuery::findAliasMappingBySchemaName(relation:RelationalOperationElement[1], map:OldAliasToNewAlias[*]):OldAliasToNewAlias[*]
{
   $relation->match([
                     t:Table[1]|$map->filter(p|if($p.second.relation()->instanceOf(Table), |$t.schema.name == $p.second.relation()->cast(@Table).schema.name, |false)),
                     v:View[1]|$map->filter(p|if($p.second.relation()->instanceOf(View), |$v.schema.name == $p.second.relation()->cast(@View).schema.name, |false)),
                     r:RelationalOperationElement[1]|$map

   ]);
}

function meta::relational::functions::pureToSqlQuery::reprocessJoin(join:Join[1], map:OldAliasToNewAlias[*], oldColumnToNewColumn:Map<Column, Column>[0..1]):Join[1]
{
   let firstAliasMappingByName = $map->filter(p|$p.first == $join.aliases->at(0).first.name);
   let firstAliasMapping = if($firstAliasMappingByName->size() > 1, | findAliasMappingBySchemaName($join.aliases->at(0).first->cast(@TableAlias).relation(),$firstAliasMappingByName), |$firstAliasMappingByName);
   let first = if($firstAliasMapping->isEmpty(), | $join.aliases->at(0).first->cast(@TableAlias), | $firstAliasMapping->toOne().second->cast(@TableAlias));

   let secondAliasMappingByName = $map->filter(p|$p.first == $join.aliases->at(1).first.name);
   let secondAliasMapping = if($secondAliasMappingByName->size() > 1, | findAliasMappingBySchemaName($join.aliases->at(1).first->cast(@TableAlias).relation(),$secondAliasMappingByName), |$secondAliasMappingByName);
   let second = if ($secondAliasMapping->isEmpty(), | $join.aliases->at(1).first->cast(@TableAlias) ,| $secondAliasMapping->toOne().second->cast(@TableAlias));

   ^$join(
      target = if($join.target->isEmpty(),|[],|if($join.target.name == $join.aliases->at(0).first.name, |$first, |$second)),
      aliases = [^Pair<TableAlias,TableAlias>(first=$first, second=$second), ^Pair<TableAlias,TableAlias>(first=$second, second=$first)],
      operation=$join.operation->reprocessAliases($map, $oldColumnToNewColumn)->cast(@Operation)
   );
}

function meta::relational::functions::pureToSqlQuery::reprocessAliases(elements:RelationalOperationElement[*], map:OldAliasToNewAlias[*]):RelationalOperationElement[*]
{
   if($elements->isEmpty(), |[], |$elements->map(c | $c->reprocessAliases($map)))
}

function meta::relational::functions::pureToSqlQuery::reprocessAliases(element:RelationalOperationElement[1], map:OldAliasToNewAlias[*]):RelationalOperationElement[1]
{
   reprocessAliases($element, $map, []);
}

function meta::relational::functions::pureToSqlQuery::reprocessAliases(element:RelationalOperationElement[1], map:OldAliasToNewAlias[*], oldColumnToNewColumn:Map<Column, Column>[0..1]):RelationalOperationElement[1]
{
  $element->match(   [
                        c:TableAliasColumn[1]|let newByName = $map->filter(o| $o.first == $c.alias.name);
                                              let new = if($newByName->size() > 1, |findAliasMappingBySchemaName($c.alias.relation(), $newByName), |$newByName);
                                              let oldColumn = $c.column;
                                              let column = if($oldColumnToNewColumn->isEmpty(),
                                                              |$oldColumn,
                                                              |let newColumn = $oldColumnToNewColumn->toOne()->get($oldColumn);
                                                               if ($newColumn->isEmpty(),
                                                                  |$oldColumn,
                                                                  |$newColumn->toOne()
                                                               );
                                                          );
                                              if($new->isEmpty(),
                                                 |if($column == $oldColumn,
                                                     |$c,
                                                     |^$c (column = $column)
                                                  ),
                                                 |^$c(alias = $new->toOne().second, column = $column);
                                              );,
                        l:Literal[1]|$l,
                        ll:LiteralList[1]|$ll,
                        j:JoinStrings[1]|^$j(strings=$j.strings->map(s | reprocessAliases($s, $map, $oldColumnToNewColumn)));,
                        s:SelectSQLQuery[1]|^$s(filteringOperation = $s.filteringOperation->map(f|$f->reprocessAliases($map, $oldColumnToNewColumn)));,
                        t:TableAlias[1]| let new = $map->filter(o| $o.first == $t.name); if($new->isEmpty(),|$t,|$new->toOne().second);,
                        a:Alias[1]|^$a(relationalElement = $a.relationalElement->reprocessAliases($map, $oldColumnToNewColumn));,
                        d:DynaFunction[1]|^DynaFunction(name=$d.name, parameters=$d.parameters->map(p | $p->reprocessAliases($map, $oldColumnToNewColumn))),
                        f:FreeMarkerOperationHolder[1]|^FreeMarkerOperationHolder(name=$f.name, parameters=$f.parameters->map(p | $p->reprocessAliases($map, $oldColumnToNewColumn))),
                        op:UnaryOperation[1]|^$op(nested=$op.nested->reprocessAliases($map, $oldColumnToNewColumn)),
                        op:BinaryOperation[1]|^$op(left=$op.left->reprocessAliases($map, $oldColumnToNewColumn), right=$op.right->reprocessAliases($map, $oldColumnToNewColumn)),
                        op:VariableArityOperation[1]|^$op(args=$op.args->map(arg | $arg->reprocessAliases($map, $oldColumnToNewColumn))),
                        cn:ColumnName[1] | $cn,
                        wc: WindowColumn[1]|let window=$wc.window;
                                            let wf = $wc.func ;
                                            ^$wc(window=^$window(partition=$window.partition->map(p|$p->reprocessAliases($map, $oldColumnToNewColumn))->cast(@RelationalOperationElement), sortBy=$window.sortBy->map(p|$p->reprocessAliases($map, $oldColumnToNewColumn))->cast(@RelationalOperationElement),sortDirection=$window.sortDirection), func=$wf->reprocessAliases($map, $oldColumnToNewColumn)->cast(@DynaFunction));,
                        s:SemiStructuredPropertyAccess[1] | ^$s(operand = $s.operand->reprocessAliases($map, $oldColumnToNewColumn), property = $s.property->reprocessAliases($map, $oldColumnToNewColumn), index = $s.index->map(i | $i->reprocessAliases($map, $oldColumnToNewColumn))),
                        s:SemiStructuredArrayElementAccess[1] | ^$s(operand = $s.operand->reprocessAliases($map, $oldColumnToNewColumn), index = $s.index->reprocessAliases($map, $oldColumnToNewColumn)),
                        s:SemiStructuredArrayFlatten[1] | ^$s(navigation = $s.navigation->reprocessAliases($map, $oldColumnToNewColumn)),
                        s:SemiStructuredArrayFlattenOutput[1] | ^$s(tableAliasColumn = $s.tableAliasColumn->reprocessAliases($map, $oldColumnToNewColumn)->cast(@TableAliasColumn)),
                        r:RelationalOperationElement[1] | $r;
                    ]
                 );
}

function meta::relational::functions::pureToSqlQuery::reprocessTableAliasColumns(elements:RelationalOperationElement[*], map:Pair<TableAliasColumn, TableAliasColumn>[*]):RelationalOperationElement[*]
{
   if($elements->isEmpty(), |[], |$elements->map(c | $c->reprocessTableAliasColumns($map)))
}

function meta::relational::functions::pureToSqlQuery::reprocessTableAliasColumns(element:RelationalOperationElement[1], map:Pair<TableAliasColumn, TableAliasColumn>[*]):RelationalOperationElement[1]
{
  $element->match(   [
                        c:TableAliasColumn[1]|let new = $map->filter(o| $o.first == $c); if($new->isEmpty(),|$c,|$new->toOne().second);,
                        l:Literal[1]|$l,
                        ll:LiteralList[1]|$ll,
                        j:JoinStrings[1]|^$j(strings=$j.strings->map(s | reprocessTableAliasColumns($s,$map)));,
                        s:SelectSQLQuery[1]|^$s(filteringOperation = $s.filteringOperation->map(f|$f->reprocessTableAliasColumns($map)));,
                        t:TableAlias[1]| $t,
                        a:Alias[1]|^$a(relationalElement = $a.relationalElement->reprocessTableAliasColumns($map));,
                        d:DynaFunction[1]|^DynaFunction(name=$d.name, parameters=$d.parameters->map(p | $p->reprocessTableAliasColumns($map))),
                        op:UnaryOperation[1]|^$op(nested=$op.nested->reprocessTableAliasColumns($map)),
                        op:BinaryOperation[1]|^$op(left=$op.left->reprocessTableAliasColumns($map), right=$op.right->reprocessTableAliasColumns($map)),
                        op:VariableArityOperation[1]|^$op(args=$op.args->map(arg | $arg->reprocessTableAliasColumns($map))),
                        cn:ColumnName[1] | $cn,
                        s:SemiStructuredPropertyAccess[1] | ^$s(operand = $s.operand->reprocessTableAliasColumns($map), property = $s.property->reprocessTableAliasColumns($map), index = $s.index->map(i | $i->reprocessTableAliasColumns($map))),
                        s:SemiStructuredArrayElementAccess[1] | ^$s(operand = $s.operand->reprocessTableAliasColumns($map), index = $s.index->reprocessTableAliasColumns($map)),
                        s:SemiStructuredArrayFlatten[1] | ^$s(navigation = $s.navigation->reprocessTableAliasColumns($map)),
                        s:SemiStructuredArrayFlattenOutput[1] | ^$s(tableAliasColumn = $s.tableAliasColumn->reprocessTableAliasColumns($map)->cast(@TableAliasColumn))
                    ]
                 )
}

function meta::relational::functions::pureToSqlQuery::usePropertyName(element:RelationalOperationElement[1], property:AbstractProperty<Any>[1], relationalPropertyMappings:RelationalPropertyMapping[*], state: State[1], extensions:Extension[*]):RelationalOperationElement[1]
{
  $element->match(   [
                        c:TableAliasColumn[1]|if($c.alias.relationalElement->instanceOf(Union),
                                                   |let supportedColumnNames = $c.alias.relationalElement->cast(@Union).queries->at(0)->cast(@SelectSQLQuery).columns->cast(@Alias).name;
                                                    let column = $c.column;
                                                    let propertyName = $c.alias.relationalElement->cast(@Union)->getUnionPropertyName($property, $relationalPropertyMappings, $state, $extensions);
                                                    if ($supportedColumnNames->contains($propertyName),
                                                       |^$c(column = ^$column(name=$propertyName));,
                                                       |let range = range(0, $relationalPropertyMappings->size(), 1);
                                                        let newColList = $range->map(i|let colName = $relationalPropertyMappings->at($i).relationalOperationElement->match([r:RelationalOperationElementWithJoin[1]|$r.relationalOperationElement->toOne(), r:RelationalOperationElement[1]|$r])->cast(@TableAliasColumn).column.name;
                                                                      ^$c(column = ^$column(name=$colName+'_'+$i->toString()));
                                                                   );
                                                        if ($newColList->size() > 1,
                                                           |^DynaFunction(name='coalesce', parameters = $newColList),
                                                           |$newColList->at(0)
                                                        );
                                                    );
                                                   ,
                                                   |$c
                                              ),
                        l:Literal[1]|$l,
                        ll:LiteralList[1]|$ll,
                        j:JoinStrings[1]|^$j(strings=$j.strings->map(s | $s->usePropertyName($property, $relationalPropertyMappings, $state, $extensions)));,
                        s:SelectSQLQuery[1]|^$s(filteringOperation = $s.filteringOperation->map(f|$f->usePropertyName($property, $relationalPropertyMappings, $state, $extensions)));,
                        t:TableAlias[1]| $t,
                        a:Alias[1]|^$a(relationalElement = $a.relationalElement->usePropertyName($property, $relationalPropertyMappings, $state, $extensions));,
                        d:DynaFunction[1]|newDynaFunction($d.name, $d.parameters->map(p | $p->usePropertyName($property, $relationalPropertyMappings, $state, $extensions))),
                        op:UnaryOperation[1]|^$op(nested=$op.nested->usePropertyName($property, $relationalPropertyMappings, $state, $extensions)),
                        op:BinaryOperation[1]|^$op(left=$op.left->usePropertyName($property, $relationalPropertyMappings, $state, $extensions), right=$op.right->usePropertyName($property, $relationalPropertyMappings, $state, $extensions)),
                        op:VariableArityOperation[1]|^$op(args=$op.args->map(arg | $arg->usePropertyName($property, $relationalPropertyMappings, $state, $extensions))),
                        cn:ColumnName[1] |$cn
                    ]
                 )
}


function meta::relational::functions::pureToSqlQuery::extractColumnAliases(element:RelationalOperationElement[*]):Alias[*]
{
  $element->map(e|$e->match(
                          [
                              u:UnaryOperation[1]|$u.nested->extractColumnAliases(),
                              i:BinaryOperation[1]|$i.left->extractColumnAliases()->concatenate($i.right->extractColumnAliases()),
                              c:TableAliasColumn[1]|^Alias(name=$c.column.name, relationalElement=$c),
                              l:Literal[1]|[],
                              l:LiteralList[1]|[],
                              j:JoinStrings[1]|$j.strings->extractColumnAliases(),
                              d:DynaFunction[1]|$d.parameters->extractColumnAliases(),
                              a:Alias[1]|$a,
                              v:VariableArityOperation[1]|$v.args->extractColumnAliases()
                          ]
                      )
               );
}

function meta::relational::functions::pureToSqlQuery::extractStore(element:RelationalOperationElement[0..1]):meta::pure::store::Store[*]
{
  $element->map(e|$e->match(
                          [
                              c:TableAliasColumn[1]|$c.alias.database,
                              r:RelationalOperationElementWithJoin[1]|$r.relationalOperationElement->extractStore()->concatenate($r.joinTreeNode->flatten().database),
                              l:Literal[1]|[],
                              l:LiteralList[1]|[],
                              d:DynaFunction[1]|$d.parameters->map(p|$p->extractStore()),
                              a:Alias[1]|[]
                          ]
                      )
               );
}

function meta::relational::functions::pureToSqlQuery::flatten(element:JoinTreeNode[0..1]):JoinTreeNode[*]
{
   $element->concatenate($element->toOne()->children()->map(e|$e->flatten()));
}

function meta::relational::functions::pureToSqlQuery::extractTableAliasColumns(elements:JoinTreeNode[*]):TableAliasColumn[*]
{
   $elements->map(element|$element.join.operation->extractTableAliasColumns()->concatenate($element->children()->map(c|$c->extractTableAliasColumns())));
}

function meta::relational::functions::pureToSqlQuery::extractTableAliasColumns(element:RelationalOperationElement[*]):TableAliasColumn[*]
{
  $element->map(e|$e->match(
                          [
                              s:SelectSQLQuery[1]|$s.columns->extractTableAliasColumns()->concatenate($s.filteringOperation->extractTableAliasColumns()),
                              u:UnaryOperation[1]| $u.nested->extractTableAliasColumns(),
                              i:BinaryOperation[1]|$i.left->extractTableAliasColumns()->concatenate($i.right->extractTableAliasColumns()),
                              c:TableAliasColumn[1]|$c,
                              l:Literal[1]|[],
                              l:LiteralList[1]|[],
                              j:JoinStrings[1]|$j.strings->extractTableAliasColumns(),
                              d:DynaFunction[1]|$d.parameters->extractTableAliasColumns(),
                              a:Alias[1]|$a.relationalElement->extractTableAliasColumns(),
                              v:VariableArityOperation[1]|$v.args->extractTableAliasColumns(),
                              n:ColumnName[1]|[],
                              r:RelationalOperationElementWithJoin[1]|$r.relationalOperationElement->extractTableAliasColumns()->concatenate($r.joinTreeNode->extractTableAliasColumns()),
                              wc: WindowColumn[1]| $wc.window->extractTableAliasColumns()->concatenate($wc.func->extractTableAliasColumns()),
                              w:meta::relational::metamodel::Window[1]| $w.partition->extractTableAliasColumns()->concatenate($w.sortBy->extractTableAliasColumns()),
                              f:meta::relational::functions::pureToSqlQuery::metamodel::FreeMarkerOperationHolder[1]| $f.parameters->map(p|$p->extractTableAliasColumns());,
                              s:SemiStructuredObjectNavigation[1]|if($s.operand->type() != RelationalOperationElement, | $s.operand->extractTableAliasColumns(), | []),
                              s:SemiStructuredArrayFlatten[1]|$s.navigation->extractTableAliasColumns(),
                              s:SemiStructuredArrayFlattenOutput[1]|$s.tableAliasColumn->extractTableAliasColumns()
                          ]
                      )
               );
}

function meta::relational::functions::pureToSqlQuery::getJoinTreeNode(relationalPropertyMapping:RelationalPropertyMapping[1]):JoinTreeNode[0..1]
{
   $relationalPropertyMapping.relationalOperationElement->match([r:RelationalOperationElementWithJoin[1] | $r.joinTreeNode, a:Any[*] | []]);
}

function meta::relational::functions::pureToSqlQuery::getSourceRelationFromTargetRelation(joinTreeNode:JoinTreeNode[1], targetRelation:Relation[1]):Relation[1]
{
   $joinTreeNode->extractLine()->reverse()->fold({x,a | $x.join->otherTable($a->cast(@NamedRelation)).relationalElement->cast(@Relation)->toOne()}, $targetRelation);
}

function meta::relational::functions::pureToSqlQuery::replaceJoinTreeNodeWithLeafNode(relationalPropertyMapping:RelationalPropertyMapping[1]):RelationalPropertyMapping[1]
{
   let relationalOperationElementWithJoin = $relationalPropertyMapping.relationalOperationElement->cast(@RelationalOperationElementWithJoin);
   let joinTreeNode = $relationalOperationElementWithJoin.joinTreeNode;
   let updatedJoinTreeNode = $joinTreeNode->getLeafNodes()->cast(@JoinTreeNode)->toOne();
   let updatedRelationalOperationElementWithJoin = ^$relationalOperationElementWithJoin(joinTreeNode = $updatedJoinTreeNode);
   ^$relationalPropertyMapping(relationalOperationElement = $updatedRelationalOperationElementWithJoin);
}

function meta::relational::functions::pureToSqlQuery::getRelation(setId:String[1], mapping:Mapping[1]):Relation[1]
{
   $mapping->classMappingById($setId)->match([r:RootRelationalInstanceSetImplementation[1] | $r, e:EmbeddedRelationalInstanceSetImplementation[1] | $e.setMappingOwner])->toOne()->mainRelation();
}

function meta::relational::functions::pureToSqlQuery::isOrderedSubsetOf(aliases1:Pair<String, RelationalOperationElement>[*], aliases2:Pair<String, RelationalOperationElement>[*]):Boolean[1]
{
   if ($aliases1->isEmpty(),
       | true,
       | let index = $aliases2->indexOf($aliases1->head()->toOne());
         ($index != -1) && $aliases1->tail()->isOrderedSubsetOf($aliases2->slice($index + 1, $aliases2->size()));
   );
}

function meta::relational::functions::pureToSqlQuery::extractLine(j:JoinTreeNode[1]):JoinTreeNode[*]
{
   $j->concatenate(if($j->children()->isEmpty(),|[],|assert($j->children()->size()==1,'trees are not supported yet');$j->children()->toOne()->extractLine();))
}

function meta::relational::functions::pureToSqlQuery::buildTree(j:JoinTreeNode[*]):JoinTreeNode[0..1]
{
   if ($j->isEmpty(),
      |[],
      |let head = $j->head()->toOne();
       ^$head(childrenData = $j->tail()->buildTree());
   )
}

function meta::relational::functions::pureToSqlQuery::buildUniqueName(j:JoinTreeNode[*], unique:Boolean[1], extensions:Extension[*]):String[1]
{
   $j->map(jo|$jo.join.operation->buildUniqueName(true, $extensions))->joinStrings();
}

function meta::relational::functions::pureToSqlQuery::reprocessJoinTreeNode(j:JoinTreeNode[1], curried:meta::pure::metamodel::function::Function<{Join[1], ProcessingSide[1]->Join[1]}>[1], first:Boolean[1], sourceRelation:RelationalOperationElement[1], fakeAlias:TableAlias[1]):JoinTreeNode[1]
{
   let join = $j.join;

   let newJoin = if ($first || $j.childrenData->isEmpty(),
                     |$curried->eval($join, ^ProcessingSide(source=$first, target=$j.childrenData->isEmpty())),
                     |$join
                 );

   let source = $sourceRelation->match([
      v:View[1] | $v,
      nr:NamedRelation[1] | $nr->findMainTable()
   ]);

   ^$j
   (
      alias = if($j.childrenData->isEmpty(),
                 |$fakeAlias,
                 |
                   let otherTable = $join->otherTable($source);
                   assertNotEmpty($otherTable, | 'Unable to find other table from ' + $source.name + ' on join ' + $join.name);
                   $otherTable->toOne();
                 ),
      join = $newJoin,
      childrenData = $j.childrenData->cast(@JoinTreeNode)->map(c|$c->reprocessJoinTreeNode($curried, false, findMainTable($join->otherTable($source)->toOne().relationalElement)->cast(@Table), $fakeAlias))
   );
}

Class meta::relational::functions::pureToSqlQuery::ProcessingSide
{
   source : Boolean[1];
   target : Boolean[1];
}

function meta::relational::functions::pureToSqlQuery::findSupportedFunction(fe:FunctionExpression[1], supportedFunctions:Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>[1], contextBasedSupportedFunctions:Map<meta::pure::metamodel::function::Function<Any>, Pair<meta::pure::metamodel::function::Function<{FunctionExpression[1]->Boolean[1]}>, meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>>[1]):meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>[0..1]
{
   let supportedFunc = $supportedFunctions->get($fe.func);
   if($supportedFunc->isNotEmpty(),
      | $supportedFunc,
      | // Check for context based support
        $contextBasedSupportedFunctions->get($fe.func)->map({cb | if($cb.first->eval($fe), | $cb.second, | [])})->first()
   );
}

function meta::relational::functions::pureToSqlQuery::getGroupBy(viewSpecification:RelationalMappingSpecification[1]):GroupByMapping[0..1]
{
    $viewSpecification->match(
                            [
                                r   : RootRelationalInstanceSetImplementation[1] | $r->resolveGroupBy(),
                                rms : RelationalMappingSpecification[1]          | $rms.groupBy
                            ]
                        );
}

function meta::relational::functions::pureToSqlQuery::getFilter(viewSpecification:RelationalMappingSpecification[1]):FilterMapping[0..1]
{
    $viewSpecification->match(
                            [
                                r   : RootRelationalInstanceSetImplementation[1] | $r->resolveFilter(),
                                rms : RelationalMappingSpecification[1]          | $rms.filter
                            ]
                        );
}

function meta::relational::functions::pureToSqlQuery::getDistinct(viewSpecification:RelationalMappingSpecification[1]):Boolean[0..1]
{
    $viewSpecification->match(
                            [
                                r   : RootRelationalInstanceSetImplementation[1] | $r->resolveDistinct(),
                                rms : RelationalMappingSpecification[1]          | $rms.distinct
                            ]
                        );
}


function  meta::relational::functions::pureToSqlQuery::getRelationalTypeFromRelationalPropertyMapping(r:RelationalOperationElement[1]):meta::relational::metamodel::datatype::DataType[0..1]
{
    $r->match([t:TableAliasColumn[1]|$t.column.type,
               c:Column[1]|$c.type,
               a:Any[1] | []// TOFIX - support all possible Types  fail($a->type().name ->toOne() + ' is not supported yet')
                  ])->cast(@meta::relational::metamodel::datatype::DataType);

}

function meta::relational::functions::pureToSqlQuery::replaceAliasInSelectWithCursor(srcOperation:SelectWithCursor[1], oldNode:RelationalTreeNode[1], newAlias:TableAlias[1]):SelectWithCursor[1]
{
   if ($oldNode.alias == $newAlias,
       | $srcOperation,
       | let newNode = ^$oldNode(alias = $newAlias);

         let select = $srcOperation.select;
         let data = $select.data->toOne();
         let updatedData = $data->replaceTreeNode($oldNode, $newNode)->cast(@RootJoinTreeNode);
         let updatedSelect = ^$select(data = $updatedData);

         let currentTreeNode = $srcOperation.currentTreeNode;
         let updatedCurrentTreeNode = if ($currentTreeNode->isEmpty(),| [],| $currentTreeNode->toOne()->replaceTreeNode($oldNode, $newNode))->cast(@RelationalTreeNode);

         let positionBeforeLastApplyJoinTreeNode = $srcOperation.positionBeforeLastApplyJoinTreeNode;
         let updatedPositionBeforeLastApplyJoinTreeNode = if ($positionBeforeLastApplyJoinTreeNode->isEmpty(),| [],| $positionBeforeLastApplyJoinTreeNode->toOne()->replaceTreeNode($oldNode, $newNode))->cast(@RelationalTreeNode);

         ^$srcOperation(currentTreeNode = $updatedCurrentTreeNode, select = $updatedSelect, positionBeforeLastApplyJoinTreeNode = $updatedPositionBeforeLastApplyJoinTreeNode);
   );
}

function meta::relational::functions::pureToSqlQuery::getContextBasedSupportedFunctions():Map<meta::pure::metamodel::function::Function<Any>, Pair<meta::pure::metamodel::function::Function<{FunctionExpression[1]->Boolean[1]}>, meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>>[1]
{
   newMap([
      ^Pair<meta::pure::metamodel::function::Function<Any>, Pair<meta::pure::metamodel::function::Function<{FunctionExpression[1]->Boolean[1]}>, meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>>(
         first = meta::pure::functions::collection::at_T_MANY__Integer_1__T_1_,
         second = pair(
            meta::relational::functions::pureToSqlQuery::canProcessAt_FunctionExpression_1__Boolean_1_,
            meta::relational::functions::pureToSqlQuery::processAt_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_
         )
      )
   ])
}

function meta::relational::functions::pureToSqlQuery::getSupportedFunctions():Map<meta::pure::metamodel::function::Function<Any>,meta::pure::metamodel::function::Function<{FunctionExpression[1], PropertyMapping[0..1], SelectWithCursor[1], Map<VariableExpression, ValueSpecification>[1], State[1], JoinType[1], String[1], List<ColumnGroup>[1], DebugContext[1], Extension[*]->RelationalOperationElement[1]}>>[1]
{
   newMap([
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::annualized_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,   second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::cme_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,          second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::cw_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,           second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::cw_fm_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,        second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::CYMinus2_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,     second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::CYMinus3_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,     second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::mtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,          second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::p12wa_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,        second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::p12wtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,       second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::p4wa_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,         second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::p4wtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,        second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::p52wtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,       second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::p52wa_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,        second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::p12mtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,       second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pma_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,          second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pmtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,         second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pqtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,         second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::priorDay_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,     second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::priorYear_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,    second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pw_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,           second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pw_fm_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,        second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pwa_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,          second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pwtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,         second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pymtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,        second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pyqtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,        second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pytd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,         second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pywa_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,         second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::pywtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,        second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::qtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,          second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::reportEndDay_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_, second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::wtd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,          second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::calendar::ytd_Date_1__String_1__Date_1__Number_$0_1$__Number_$0_1$_,          second=meta::relational::functions::pureToSqlQuery::calendarAggregations::processCalendarAggPureToSQL_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::distinct_T_MANY__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processDistinct_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::getAll_Class_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processGetAll_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::getAllVersions_Class_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processGetAll_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::getAll_Class_1__Date_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processGetAll_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::getAll_Class_1__Date_1__Date_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processGetAll_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::getAllForEachDate_Class_1__Date_MANY__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processGetAllForEachDate_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::getAllVersionsInRange_Class_1__Date_1__Date_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processGetAll_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::filter_T_MANY__Function_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processFilter_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__OperationWithParentPropertyMapping_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::groupBy_K_MANY__Function_MANY__AggregateValue_MANY__String_MANY__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processObjectGroupBy_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::exists_T_MANY__Function_1__Boolean_1_, second=meta::relational::functions::pureToSqlQuery::processExists_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::contains_Any_MANY__Any_1__Boolean_1_, second=meta::relational::functions::pureToSqlQuery::processContains_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::in_Any_1__Any_MANY__Boolean_1_, second=meta::relational::functions::pureToSqlQuery::processIn_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::in_Any_$0_1$__Any_MANY__Boolean_1_, second=meta::relational::functions::pureToSqlQuery::processIn_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::sortBy_T_m__Function_$0_1$__T_m_, second=meta::relational::functions::pureToSqlQuery::processSortBy_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::isEmpty_Any_MANY__Boolean_1_, second=meta::relational::functions::pureToSqlQuery::processNotExists_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::count_Any_MANY__Integer_1_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::slice_T_MANY__Integer_1__Integer_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processSlice_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::take_T_MANY__Integer_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processTake_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::limit_T_MANY__Integer_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processTake_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::drop_T_MANY__Integer_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processDrop_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::map_T_MANY__Function_1__V_MANY_, second=meta::relational::functions::pureToSqlQuery::processMap_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__OperationWithParentPropertyMapping_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::map_T_m__Function_1__V_m_, second=meta::relational::functions::pureToSqlQuery::processMap_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__OperationWithParentPropertyMapping_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::map_T_$0_1$__Function_1__V_$0_1$_, second=meta::relational::functions::pureToSqlQuery::processMap_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__OperationWithParentPropertyMapping_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::first_T_MANY__T_$0_1$_, second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::concatenate_T_MANY__T_MANY__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processConcatenate_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::union_T_MANY__T_MANY__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processConcatenate_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::lang::cast_Any_m__T_1__T_m_, second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::lang::if_Boolean_1__Function_1__Function_1__T_m_,second=meta::relational::functions::pureToSqlQuery::processIf_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::greaterThan_Number_1__Number_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::greaterThan_String_1__String_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::greaterThan_Date_1__Date_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::greaterThanEqual_Number_1__Number_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::greaterThanEqual_String_1__String_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::greaterThanEqual_Date_1__Date_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::lessThan_Number_1__Number_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::lessThan_String_1__String_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::lessThan_Date_1__Date_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::lessThanEqual_Number_1__Number_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::lessThanEqual_String_1__String_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::lessThanEqual_Date_1__Date_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::and_Boolean_MANY__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::or_Boolean_$1_MANY$__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::and_Boolean_1__Boolean_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::or_Boolean_1__Boolean_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::isNotEmpty_Any_$0_1$__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processIsNotEmpty_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::isEmpty_Any_$0_1$__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processIsEmpty_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::lang::subType_Any_m__T_1__T_m_,second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::lang::whenSubType_Any_1__T_1__T_$0_1$_,second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::lang::whenSubType_Any_$0_1$__T_1__T_$0_1$_,second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::lang::whenSubType_Any_MANY__T_1__T_MANY_,second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::lang::eval_Function_1__T_n__V_m_,second=meta::relational::functions::pureToSqlQuery::processEvaluate_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::lang::eval_Function_1__V_m_,second=meta::relational::functions::pureToSqlQuery::processEvaluate_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::not_Boolean_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processNot_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::datePart_Date_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::weekOfYear_Date_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::dayOfWeek_Date_1__DayOfWeek_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::dayOfWeekNumber_Date_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::dayOfWeekNumber_Date_1__DayOfWeek_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::year_Date_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::hour_Date_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::minute_Date_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::second_Date_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::monthNumber_Date_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::quarterNumber_Date_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::dateDiff_Date_1__Date_1__DurationUnit_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::adjust_Date_1__Integer_1__DurationUnit_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::today__StrictDate_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::now__DateTime_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::firstDayOfThisMonth__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::firstDayOfThisQuarter__StrictDate_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::firstDayOfThisYear__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::firstDayOfWeek_Date_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::firstDayOfMonth_Date_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::firstDayOfQuarter_Date_1__StrictDate_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::firstDayOfYear_Date_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::mostRecentDayOfWeek_DayOfWeek_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::mostRecentDayOfWeek_Date_1__DayOfWeek_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::previousDayOfWeek_DayOfWeek_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::previousDayOfWeek_Date_1__DayOfWeek_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::dayOfMonth_Date_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::startsWith_String_1__String_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::endsWith_String_1__String_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::contains_String_1__String_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::substring_String_1__Integer_1__Integer_1__String_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::indexOf_String_1__String_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::length_String_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::plus_String_MANY__String_1_,second=meta::relational::functions::pureToSqlQuery::processStringPlus_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::joinStrings_String_MANY__String_1__String_1_,second=meta::relational::functions::pureToSqlQuery::processJoinStrings_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::joinStrings_String_MANY__String_1__String_1__String_1__String_1_,second=meta::relational::functions::pureToSqlQuery::processJoinStrings_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::parseInteger_String_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::toUpper_String_1__String_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::toLower_String_1__String_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::trim_String_1__String_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::toString_Any_1__String_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::replace_String_1__String_1__String_1__String_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::abs_Integer_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::abs_Number_1__Number_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::abs_Float_1__Float_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::divide_Number_1__Number_1__Float_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::pow_Number_1__Number_1__Number_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::exp_Number_1__Float_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::log_Number_1__Float_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::average_Integer_MANY__Float_1_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::average_Float_MANY__Float_1_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::average_Number_MANY__Float_1_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::max_Integer_MANY__Integer_$0_1$_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::max_Integer_$1_MANY$__Integer_1_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::max_Float_MANY__Float_$0_1$_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::max_Float_$1_MANY$__Float_1_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::max_Number_MANY__Number_$0_1$_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::max_Number_$1_MANY$__Number_1_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::max_StrictDate_MANY__StrictDate_$0_1$_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::date::max_Date_MANY__Date_$0_1$_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::minus_Float_MANY__Float_1_, second=meta::relational::functions::pureToSqlQuery::processVariableArity_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::minus_Integer_MANY__Integer_1_, second=meta::relational::functions::pureToSqlQuery::processVariableArity_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::minus_Number_MANY__Number_1_, second=meta::relational::functions::pureToSqlQuery::processVariableArity_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::times_Float_MANY__Float_1_, second=meta::relational::functions::pureToSqlQuery::processVariableArity_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::times_Integer_MANY__Integer_1_, second=meta::relational::functions::pureToSqlQuery::processVariableArity_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::times_Number_MANY__Number_1_, second=meta::relational::functions::pureToSqlQuery::processVariableArity_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::plus_Float_MANY__Float_1_, second=meta::relational::functions::pureToSqlQuery::processPlus_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::plus_Integer_MANY__Integer_1_, second=meta::relational::functions::pureToSqlQuery::processPlus_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::plus_Number_MANY__Number_1_, second=meta::relational::functions::pureToSqlQuery::processPlus_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::round_Number_1__Integer_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::round_Decimal_1__Integer_1__Decimal_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::round_Float_1__Integer_1__Float_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::ceiling_Number_1__Integer_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::floor_Number_1__Integer_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::stdDevSample_Number_MANY__Number_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::stdDevPopulation_Number_MANY__Number_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::sin_Number_1__Float_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::asin_Number_1__Float_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::cos_Number_1__Float_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::acos_Number_1__Float_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::tan_Number_1__Float_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::atan_Number_1__Float_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::atan2_Number_1__Number_1__Float_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::sqrt_Number_1__Float_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::mod_Integer_1__Integer_1__Integer_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::rem_Number_1__Number_1__Number_1_, second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::project_K_MANY__Function_MANY__String_MANY__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processProjectFunctions_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::project_T_MANY__Path_MANY__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processProjectPaths_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::project_T_MANY__ColumnSpecification_MANY__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processProjectColumns_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::concatenate_TabularDataSet_1__TabularDataSet_1__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processConcatenate_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::concatenate_TabularDataSet_1__TabularDataSet_MANY__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processConcatenate_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::groupBy_TabularDataSet_1__String_MANY__AggregateValue_MANY__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processGroupBy_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::filter_TabularDataSet_1__Function_1__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processTdsFilter_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::distinct_TabularDataSet_1__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processDistinct_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::slice_TabularDataSet_1__Integer_1__Integer_1__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processSlice_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::drop_TabularDataSet_1__Integer_1__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processDrop_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::limit_TabularDataSet_1__Integer_1__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processTake_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::limit_TabularDataSet_1__Integer_$0_1$__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processTake_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::take_TabularDataSet_1__Integer_1__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processTake_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::sort_TabularDataSet_1__String_MANY__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processTDSSortColumns_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::sort_TabularDataSet_1__SortInformation_MANY__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processTDSSortInformation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::sort_TabularDataSet_1__String_1__SortDirection_1__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processTDSSortSingular_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::equal_Any_MANY__Any_MANY__Boolean_1_, second=meta::relational::functions::pureToSqlQuery::processEquals_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::boolean::eq_Any_1__Any_1__Boolean_1_, second=meta::relational::functions::pureToSqlQuery::processEquals_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::multiplicity::toOne_T_MANY__T_1_, second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::multiplicity::toOneMany_T_MANY__T_$1_MANY$_, second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::lang::extractEnumValue_Enumeration_1__String_1__T_1_, second=meta::relational::functions::pureToSqlQuery::processEnumValue_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::parseDate_String_1__Date_1_,second=meta::relational::functions::pureToSqlQuery::processParseDate_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::parseFloat_String_1__Float_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::parseDecimal_String_1__Decimal_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::extend_TabularDataSet_1__BasicColumnSpecification_MANY__TabularDataSet_1_,second=meta::relational::functions::pureToSqlQuery::processTdsExtend_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::project_TabularDataSet_1__ColumnSpecification_MANY__TabularDataSet_1_,second=meta::relational::functions::pureToSqlQuery::processTdsProject_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::project_TableTDS_1__ColumnSpecification_MANY__TabularDataSet_1_,second=meta::relational::functions::pureToSqlQuery::processTdsProject_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::groupByWithWindowSubset_K_MANY__Function_MANY__AggregateValue_MANY__String_MANY__String_MANY__String_MANY__TabularDataSet_1_, second=meta::relational::functions::pureToSqlQuery::processObjectGroupByWithWindowSubSet_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::restrict_TabularDataSet_1__String_MANY__TabularDataSet_1_,second=meta::relational::functions::pureToSqlQuery::processTdsRestrict_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::renameColumns_TabularDataSet_1__Pair_MANY__TabularDataSet_1_,second=meta::relational::functions::pureToSqlQuery::processTdsRenameColumns_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::join_TabularDataSet_1__TabularDataSet_1__JoinType_1__Function_1__TabularDataSet_1_,second=meta::relational::functions::pureToSqlQuery::processTdsJoin_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::join_TabularDataSet_1__TabularDataSet_1__JoinType_1__String_$1_MANY$__String_$1_MANY$__TabularDataSet_1_,second=meta::relational::functions::pureToSqlQuery::processTdsJoinOnColumns_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::indexOf_String_1__String_1__Integer_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::projectWithColumnSubset_T_MANY__ColumnSpecification_MANY__String_MANY__TabularDataSet_1_,second=meta::relational::functions::pureToSqlQuery::processProjectWithColumnSubset_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::projectWithColumnSubset_T_MANY__Function_MANY__String_MANY__String_MANY__TabularDataSet_1_, second = meta::relational::functions::pureToSqlQuery::processProjectWithColumnSubsetFunctions_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::projectWithColumnSubset_T_MANY__Function_MANY__String_MANY__String_MANY__TabularDataSet_1_, second = meta::relational::functions::pureToSqlQuery::processProjectWithColumnSubsetFunctions_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::tableToTDS_Table_1__TableTDS_1_, second = meta::relational::functions::pureToSqlQuery::processTableToTDS_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::viewToTDS_View_1__TableTDS_1_, second = meta::relational::functions::pureToSqlQuery::processTableToTDS_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::olapGroupBy_TabularDataSet_1__SortInformation_$0_1$__OlapOperation_1__String_1__TabularDataSet_1_, second = meta::relational::functions::pureToSqlQuery::processTdsWindowColWithoutWindow_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::olapGroupBy_TabularDataSet_1__OlapOperation_1__String_1__TabularDataSet_1_, second = meta::relational::functions::pureToSqlQuery::processTdsWindowColWithoutWindowAndSort_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::olapGroupBy_TabularDataSet_1__String_MANY__OlapOperation_1__String_1__TabularDataSet_1_, second = meta::relational::functions::pureToSqlQuery::processTdsWindowColWithoutSort_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::olapGroupBy_TabularDataSet_1__String_MANY__SortInformation_$0_1$__OlapOperation_1__String_1__TabularDataSet_1_, second = meta::relational::functions::pureToSqlQuery::processTdsWindowColumn_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::tdsContains_T_1__Function_MANY__TabularDataSet_1__Boolean_1_, second = meta::relational::functions::pureToSqlQuery::processTdsContains_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::tdsContains_T_1__Function_MANY__String_MANY__TabularDataSet_1__Function_1__Boolean_1_, second = meta::relational::functions::pureToSqlQuery::processTdsContainsWithLambda_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::relational::functions::columnProjectionsFromRoot_Any_MANY__NamedRelation_1__String_MANY__Boolean_$0_1$__Integer_$0_1$__RelationData_1_, second = meta::relational::functions::pureToSqlQuery::processColumnProjectionsFromRoot_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::tds::tdsRows_TabularDataSet_1__TDSRow_MANY_, second = meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::graphFetch::execution::graphFetch_T_MANY__RootGraphFetchTree_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::graphFetch::execution::graphFetch_T_MANY__RootGraphFetchTree_1__Integer_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::graphFetch::execution::graphFetchChecked_T_MANY__RootGraphFetchTree_1__Integer_1__Checked_MANY_, second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::graphFetch::execution::graphFetchChecked_T_MANY__RootGraphFetchTree_1__Checked_MANY_, second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::objectReferenceIn_Any_1__String_MANY__Boolean_1_, second=meta::relational::functions::pureToSqlQuery::processObjectReferenceIn_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::matches_String_1__String_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::string::isAlphaNumeric_String_1__Boolean_1_,second=meta::relational::functions::pureToSqlQuery::processDynaFunction_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::percentile_Number_MANY__Float_1__Number_$0_1$_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::math::percentile_Number_MANY__Float_1__Boolean_1__Boolean_1__Number_$0_1$_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::functions::collection::isDistinct_T_MANY__Boolean_1_, second=meta::relational::functions::pureToSqlQuery::processAggregation_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_),
        ^PureFunctionToRelationalFunctionPair(first=meta::pure::mutation::save_T_MANY__RootGraphFetchTree_1__Mapping_1__Runtime_1__T_MANY_, second=meta::relational::functions::pureToSqlQuery::processNoOp_FunctionExpression_1__PropertyMapping_MANY__SelectWithCursor_1__Map_1__State_1__JoinType_1__String_1__List_1__DebugContext_1__Extension_MANY__RelationalOperationElement_1_)
   ])
}