// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::executionPlan::*;
import meta::pure::router::extension::*;
import meta::pure::mapping::*;
import meta::pure::runtime::*;
import meta::relational::metamodel::relation::*;
import meta::relational::metamodel::*;
import meta::relational::runtime::*;
import meta::relational::functions::sqlQueryToString::*;
import meta::relational::functions::typeInference::*;
import meta::relational::mapping::*;
import meta::relational::dbTestRunner::*;

function meta::relational::dbTestRunner::runDynaFunctionDatabaseTest(dynaFunc:DynaFunction[1], expectedResult:Literal[1..*], testConfig:DbTestConfig[1]): String[0..1]
{
  runDynaFunctionDatabaseTest($dynaFunc, $expectedResult, [] , $testConfig);
} 

function meta::relational::dbTestRunner::runDynaFunctionDatabaseTest(dynaFunc:DynaFunction[1], expectedResult:Literal[1..*], equalityComparator: Function<{Any[1..*],Any[1..*]->Boolean[1]}>[0..1] , testConfig:DbTestConfig[1]): String[0..1]
{ 
  //sqlQueryGenerator
  let sqlQuery = defaultDynaFunctionSqlQueryGenerator($dynaFunc,$expectedResult, $testConfig);

  let newExpectedResult = overwriteDynaFunctionExpectedResult($expectedResult, $testConfig);

  let sqlString = sqlQueryToString($sqlQuery, $testConfig.dbType, []);

  if($testConfig.expectedSql->isNotEmpty() && ($testConfig.expectedSql->toOne() != $sqlString),
    | 'Sql assert failed ,expected sql: '+ $testConfig.expectedSql->toOne()  +', actual sql : ' + $sqlString;,
    | if($testConfig.connection->isEmpty(),
      |   [] ,                                                     // test Connection not available ,do nothing further,
      |  
          let conn1= $testConfig.connection->toOne();
          let conn = ^$conn1(element= ^Database(name='dummyDB'));                      // overwite given connection db 
          
          let newExpectedResultTypes = $newExpectedResult->map(e|$e->inferRelationalType())->toOneMany();
          let plan = wrapSQLStringInExecutionPlan($sqlString, $newExpectedResultTypes, $testConfig.dbType,$conn) ;
          
          let res = executePlan($plan,defaultRelationalExtensions());
          if($res->isEmpty(),
              | [],                                  //legend engine not available 
              | let areEqual = if($equalityComparator->isNotEmpty(),
                                  | $equalityComparator->toOne()->eval($res.values, $newExpectedResult.value);, // expected values are wrapped in Literals currently
                                  | equal($res.values, $newExpectedResult.value)
                                 );
                  if($areEqual , 
                    | [],
                    | let expectedStr = $newExpectedResult.value->map(v|$v->toString())->makeString('[',', ',']');
                      let resStr = $res.values->map(v|$v->toString())->makeString('[',', ',']');
                      'Result assert failed ,expected Values : '+ $expectedStr  +', actual Values : ' + $resStr;
                    );
              );
       );
    );
}

function meta::relational::dbTestRunner::defaultDynaFunctionSqlQueryGenerator(dynaFunc:DynaFunction[1] , expectedResult:Literal[1..*], testConfig:DbTestConfig[1]): SQLQuery[1]
{ 
  $expectedResult->match([
    l:Literal[1] | $l.value->match([
                        b: Boolean[1] | ^SelectSQLQuery(columns = [^DynaFunction(name = 'case', parameters= [$dynaFunc, ^Literal(value=1), ^Literal(value=0)])]
                                                        );  ,              // if return type is boolean, wrap as : select case when 'dynaFunc'  then 1 else 0 
                        a: Any[1] | ^SelectSQLQuery(columns=[$dynaFunc]);
                  ]);,
    a:Any[*] | ^SelectSQLQuery(columns=[$dynaFunc]);
  ]);
}

function meta::relational::dbTestRunner::overwriteDynaFunctionExpectedResult(expectedResult:Literal[1..*], testConfig:DbTestConfig[1]): Literal[1..*]
{ 
  $expectedResult.value->match([
          b: Boolean[1] | if($b==true, |^Literal(value=1), |^Literal(value=0)),  // if dynaFunc returns true , returns 1 , else 0  
          a: Any[1] |  $expectedResult
    ]);
}

function meta::relational::dbTestRunner::floatEqualityComparatorGenerator(tolerance:Any[1..*]) :  Function<{Any[1..*], Any[1..*] -> Boolean[1]}>[1]
{
  {actual:Any[1..*], expected:Any[1..*] |      
        assert($expected->size() == $actual->size());
        assert($expected->size() == $tolerance->size());
        
        zip(zip($actual ,$expected ), $tolerance )->map(x|
                  $x->match([
                    a:Pair<Pair<Number,Number>,Number>[1] |
                          if( abs($a.first->cast(@Pair<Number,Number>).first - $a.first->cast(@Pair<Number,Number>).second) <= abs($a.second->cast(@Number)), |true, |false);,
                    b:Any[1] | false;
                  ]))->and();
  }
}

function meta::relational::dbTestRunner::wrapSQLStringInExecutionPlan(sqlString:String[1], resultTypes:meta::relational::metamodel::datatype::DataType[1..*], dbType:DatabaseType[1], connection:DatabaseConnection[1]):ExecutionPlan[1]
{
  let runtime = ^Runtime(connections=$connection);
  
  let resultType = ^DataTypeResultType(type= $resultTypes->at(0)->meta::relational::metamodel::datatype::dataTypeToCompatiblePureType());

  let resultColumns = $resultTypes->toIndexed()->map(e| 
            ^SQLResultColumn(label='result' + $e.first->toString(), dataType=$e.second));
  
  let sqlExecutionNode = ^SQLExecutionNode(
                        sqlQuery=$sqlString ,
                        connection=$connection , 
                        resultType=$resultType,
                        resultColumns=$resultColumns);

  ^ExecutionPlan(
    authDependent=false,
    runtime=$runtime,
    func={|true},
    mapping=^Mapping(name='dummyMapping'),
    rootExecutionNode=^RelationalDataTypeInstantiationExecutionNode(
          resultType=$resultType,
          executionNodes=[$sqlExecutionNode]
        )
    );
}

