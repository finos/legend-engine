package org.finos.legend.engine.plan.execution.stores.relational.test.generation.connection;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.finos.legend.engine.language.pure.compiler.Compiler;
import org.finos.legend.engine.language.pure.compiler.toPureGraph.CompileContext;
import org.finos.legend.engine.language.pure.compiler.toPureGraph.HelperValueSpecificationBuilder;
import org.finos.legend.engine.language.pure.compiler.toPureGraph.PureModel;
import org.finos.legend.engine.language.pure.grammar.from.PureGrammarParser;
import org.finos.legend.engine.plan.generation.PlanGenerator;
import org.finos.legend.engine.plan.generation.transformers.LegendPlanTransformers;
import org.finos.legend.engine.plan.platform.PlanPlatform;
import org.finos.legend.engine.protocol.pure.v1.model.context.PureModelContextData;
import org.finos.legend.engine.protocol.pure.v1.model.executionPlan.ExecutionPlan;
import org.finos.legend.engine.protocol.pure.v1.model.packageableElement.domain.Function;
import org.finos.legend.engine.shared.core.ObjectMapperFactory;
import org.finos.legend.pure.generated.core_relational_relational_router_router_extension;
import org.junit.Assert;
import org.junit.Test;

import java.io.StringWriter;
import java.util.Collections;

public class TestGeneration
{
    @Test
    public void testGenerationWithSnowflakeConnection() throws Exception
    {
        PureModelContextData contextData = PureGrammarParser.newInstance().parseModel(
                "" +
                        "Class p::A {name:String[1];}" +
                        "function p::f():p::A[*]{p::A.all();}\n" +
                        "###Relational\n" +
                        "Database p::db(Table tb (name VARCHAR(200)))\n" +
                        "###Mapping\n" +
                        "Mapping p::M (p::A : Relational {name : [p::db]tb.name })\n" +
                        "###Runtime\n" +
                        "Runtime p::R" +
                        "{" +
                        "   mappings:[p::M];" +
                        "   connections:[" +
                        "       p::db : [" +
                        "           c1: #{\n" +
                        "                   RelationalDatabaseConnection\n" +
                        "                   {\n" +
                        "                       type: Snowflake;\n" +
                        "                       specification: Snowflake\n" +
                        "                                      {\n" +
                        "                                           name: 'test';\n" +
                        "                                           account: 'account';\n" +
                        "                                           warehouse: 'warehouseName';\n" +
                        "                                           region: 'us-east2';\n" +
                        "                                           cloudType: 'aws';\n" +
                        "                                           quotedIdentifiersIgnoreCase : false;\n" +
                        "                                      };\n" +
                        "                       auth: SnowflakePublic\n" +
                        "                             {" +
                        "                                 publicUserName: 'name';\n" +
                        "                                 privateKeyVaultReference : 'key';\n" +
                        "                                 passPhraseVaultReference: 'val';" +
                        "                             };\n" +
                        "                   }\n" +
                        "               }#\n" +
                        "           ]" +
                        "   ];" +
                        "}");
        PureModel pureModel = Compiler.compile(contextData, null, null);

        String plan = PlanGenerator.generateExecutionPlanAsString(
                HelperValueSpecificationBuilder.buildLambda(contextData.getElementsOfType(Function.class).get(0).body, Collections.emptyList(), new CompileContext.Builder(pureModel).build()),
                pureModel.getMapping("p::M"),
                pureModel.getRuntime("p::R"),
                null,
                pureModel,
                "vX_X_X",
                PlanPlatform.JAVA,
                null,
                core_relational_relational_router_router_extension.Root_meta_pure_router_extension_defaultRelationalExtensions__RouterExtension_MANY_(pureModel.getExecutionSupport()),
                LegendPlanTransformers.transformers
        );

        ObjectMapper mapper = ObjectMapperFactory.getNewStandardObjectMapperWithPureProtocolExtensionSupports().enable(SerializationFeature.INDENT_OUTPUT);
        ExecutionPlan executionPlan = mapper.readValue(plan, ExecutionPlan.class);
        StringWriter writer = new StringWriter();
        mapper.writeValue(writer, executionPlan);

        assertGeneratedStringEquals(
                "{\n" +
                        "  \"_type\" : \"simple\",\n" +
                        "  \"authDependent\" : false,\n" +
                        "  \"globalImplementationSupport\" : {\n" +
                        "    \"_type\" : \"java\",\n" +
                        "    \"classes\" : [ {\n" +
                        "      \"name\" : \"A\",\n" +
                        "      \"package\" : \"_pure.app.p\",\n" +
                        "      \"source\" : \"package _pure.app.p;\\n\\nimport java.math.*;\\nimport java.util.*;\\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\\n\\npublic interface A extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject\\n{\\n    String getName();\\n    String getAlloyStoreObjectReference$();\\n}\"\n" +
                        "    }, {\n" +
                        "      \"name\" : \"A_p_A_BaseImpl\",\n" +
                        "      \"package\" : \"_pure.plan.root\",\n" +
                        "      \"source\" : \"package _pure.plan.root;\\n\\nimport com.fasterxml.jackson.annotation.JsonIgnore;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport com.fasterxml.jackson.annotation.JsonProperty;\\nimport com.fasterxml.jackson.core.JsonGenerator;\\nimport com.fasterxml.jackson.databind.JsonSerializer;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.SerializerProvider;\\nimport com.fasterxml.jackson.databind.module.SimpleModule;\\nimport java.io.IOException;\\nimport java.util.*;\\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\\n\\npublic class A_p_A_BaseImpl implements _pure.app.p.A\\n{\\n    private String name;\\n    private String setId$;\\n    public static String databaseConnection$;\\n    private static final ObjectMapper objectMapper$ = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).registerModule(new SimpleModule().addSerializer(PureDate.class, new JsonSerializer<PureDate>() { @Override public void serialize(PureDate value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeRawValue(\\\"\\\\\\\"\\\" + value.toString() + \\\"\\\\\\\"\\\"); } }));\\n    private String alloyStoreObjectReference$;\\n\\n    @JsonProperty(\\\"name\\\")\\n    public String getName()\\n    {\\n        return this.name;\\n    }\\n\\n    public void setName(String name)\\n    {\\n        this.name = name;\\n    }\\n\\n    @JsonIgnore\\n    public String getSetId$()\\n    {\\n        return this.setId$;\\n    }\\n\\n    public void setSetId$(String setId)\\n    {\\n        this.setId$ = setId;\\n    }\\n\\n    @JsonProperty(\\\"alloyStoreObjectReference$\\\")\\n    public String getAlloyStoreObjectReference$()\\n    {\\n        if (this.alloyStoreObjectReference$ == null)\\n        {\\n            try\\n            {\\n                StringBuilder referenceBuilder = new StringBuilder();\\n                referenceBuilder.append(\\\"001:\\\");\\n                referenceBuilder.append(\\\"010:\\\");\\n\\n                referenceBuilder.append(\\\"0000000010:\\\");\\n                referenceBuilder.append(\\\"Relational:\\\");\\n\\n                referenceBuilder.append(\\\"0000000004:\\\");\\n                referenceBuilder.append(\\\"p::M:\\\");\\n\\n                referenceBuilder.append(\\\"0000000003:\\\");\\n                referenceBuilder.append(\\\"p_A:\\\");\\n\\n                String setId = this.getSetId$();\\n                referenceBuilder.append(String.format(\\\"%010d\\\", setId.length()));\\n                referenceBuilder.append(\\\":\\\");\\n                referenceBuilder.append(setId);\\n                referenceBuilder.append(\\\":\\\");\\n\\n                String databaseConnectionString = _pure.plan.root.A_p_A_BaseImpl.databaseConnection$;\\n                referenceBuilder.append(String.format(\\\"%010d\\\", databaseConnectionString.length()));\\n                referenceBuilder.append(\\\":\\\");\\n                referenceBuilder.append(databaseConnectionString);\\n                referenceBuilder.append(\\\":\\\");\\n\\n                Map<String, Object> pkMap = new HashMap<>();\\n\\n                String pkMapString = objectMapper$.writeValueAsString(pkMap);\\n                referenceBuilder.append(String.format(\\\"%010d\\\", pkMapString.length()));\\n                referenceBuilder.append(\\\":\\\");\\n                referenceBuilder.append(pkMapString);\\n\\n                this.alloyStoreObjectReference$ = \\\"ASOR:\\\" + org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(referenceBuilder.toString().getBytes());\\n            }\\n            catch (Exception e)\\n            {\\n               throw new RuntimeException(e);\\n            }\\n        }\\n\\n        return this.alloyStoreObjectReference$;\\n    }\\n}\"\n" +
                        "    }, {\n" +
                        "      \"name\" : \"A_p_A_Impl\",\n" +
                        "      \"package\" : \"_pure.plan.root\",\n" +
                        "      \"source\" : \"package _pure.plan.root;\\n\\nimport com.fasterxml.jackson.annotation.JsonIgnore;\\nimport com.fasterxml.jackson.annotation.JsonProperty;\\nimport java.util.*;\\n\\npublic class A_p_A_Impl extends A_p_A_BaseImpl implements _pure.app.p.A\\n{\\n    public A_p_A_Impl()\\n    {\\n        this.setSetId$(\\\"p_A\\\");\\n    }\\n}\"\n" +
                        "    }, {\n" +
                        "      \"name\" : \"Execute\",\n" +
                        "      \"package\" : \"_pure.plan.root\",\n" +
                        "      \"source\" : \"package _pure.plan.root;\\n\\nimport java.sql.ResultSet;\\nimport java.util.*;\\nimport org.finos.legend.engine.plan.dependencies.store.relational.classResult.IRelationalClassInstantiationNodeExecutor;\\n\\npublic class Execute implements IRelationalClassInstantiationNodeExecutor\\n{\\n    private Helper helper;\\n\\n    public Execute()\\n    {\\n        this.helper = new Helper();\\n    }\\n\\n    public Object getObjectFromResultSet(ResultSet resultSet,\\n                                         String databaseTimeZone,\\n                                         String databaseConnection)\\n    {\\n        return this.helper.getObjectFromResultSet(resultSet, databaseTimeZone, databaseConnection);\\n    }\\n}\"\n" +
                        "    }, {\n" +
                        "      \"name\" : \"Helper\",\n" +
                        "      \"package\" : \"_pure.plan.root\",\n" +
                        "      \"source\" : \"package _pure.plan.root;\\n\\nimport java.sql.ResultSet;\\nimport java.sql.ResultSetMetaData;\\nimport java.sql.Types;\\nimport java.util.*;\\nimport java.util.function.*;\\nimport java.util.stream.*;\\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\\n\\npublic class Helper\\n{\\n    private static final List<Integer> STRING_TYPES = Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL);\\n    private static final List<Integer> INT_TYPES = Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL);\\n    private static final List<Integer> FLOAT_TYPES = Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL);\\n    private static final List<Integer> BOOL_TYPES = Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL);\\n    private static final List<Integer> STRICT_DATE_TYPES = Arrays.asList(Types.DATE, Types.NULL);\\n    private static final List<Integer> DATE_TIME_TYPES = Arrays.asList(Types.TIMESTAMP, Types.NULL);\\n    private List<Integer> columnTypes;\\n    private List<List<Integer>> propertyIndices;\\n    private List<List<Supplier<Object>>> propertyGetters;\\n    private Calendar calendar;\\n\\n    private Supplier<Object> getResultSetPropertyGetterForStringProperty(ResultSet resultSet,\\n                                                                         int columnIndex,\\n                                                                         int columnType,\\n                                                                         String propertyName)\\n    {\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n           return () -> {\\n                try\\n                {\\n                    return resultSet.getString(columnIndex);\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        else\\n        {\\n            throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type String from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n        }\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForIntegerProperty(ResultSet resultSet,\\n                                                                          int columnIndex,\\n                                                                          int columnType,\\n                                                                          String propertyName)\\n    {\\n        if (INT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Long res = null;\\n                    long r = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Long.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Integer from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForFloatProperty(ResultSet resultSet,\\n                                                                        int columnIndex,\\n                                                                        int columnType,\\n                                                                        String propertyName)\\n    {\\n        if (FLOAT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Double res = null;\\n                    double r = resultSet.getDouble(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Double.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (INT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Double res = null;\\n                    long r = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Double.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Float from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForDecimalProperty(ResultSet resultSet,\\n                                                                          int columnIndex,\\n                                                                          int columnType,\\n                                                                          String propertyName)\\n    {\\n        if (FLOAT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    java.math.BigDecimal res = null;\\n                    double r = resultSet.getDouble(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = java.math.BigDecimal.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (INT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    java.math.BigDecimal res = null;\\n                    long r = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = java.math.BigDecimal.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Decimal from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForBooleanProperty(ResultSet resultSet,\\n                                                                          int columnIndex,\\n                                                                          int columnType,\\n                                                                          String propertyName)\\n    {\\n        if (BOOL_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Boolean res = null;\\n                    boolean r = resultSet.getBoolean(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Boolean.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Boolean res = null;\\n                    String r = resultSet.getString(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Boolean.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (INT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Boolean res = null;\\n                    long r = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Boolean.valueOf(r == 1);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Boolean from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForStrictDateProperty(ResultSet resultSet,\\n                                                                             int columnIndex,\\n                                                                             int columnType,\\n                                                                             String propertyName)\\n    {\\n        if (STRICT_DATE_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    java.sql.Date r = resultSet.getDate(columnIndex);\\n                    if (r != null)\\n                    {\\n                        res = PureDate.fromSQLDate(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    String r = resultSet.getString(columnIndex);\\n                    if (r != null)\\n                    {\\n                        try\\n                        {\\n                            res = PureDate.parsePureDate(r);\\n                        }\\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\\n                        {\\n                            res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\\n                        }\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type StrictDate from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForDateTimeProperty(ResultSet resultSet,\\n                                                                           int columnIndex,\\n                                                                           int columnType,\\n                                                                           String propertyName)\\n    {\\n        if (DATE_TIME_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\\n                    if (r != null)\\n                    {\\n                        res = PureDate.fromSQLTimestamp(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    String r = resultSet.getString(columnIndex);\\n                    if (r != null)\\n                    {\\n                        try\\n                        {\\n                            res = PureDate.parsePureDate(r);\\n                        }\\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\\n                        {\\n                            res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\\n                        }\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type DateTime from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForDateProperty(ResultSet resultSet,\\n                                                                       int columnIndex,\\n                                                                       int columnType,\\n                                                                       String propertyName)\\n    {\\n        if (STRICT_DATE_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    java.sql.Date r = resultSet.getDate(columnIndex);\\n                    if (r != null)\\n                    {\\n                        res = PureDate.fromSQLDate(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (DATE_TIME_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\\n                    if (r != null)\\n                    {\\n                        res = PureDate.fromSQLTimestamp(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    String r = resultSet.getString(columnIndex);\\n                    if (r != null)\\n                    {\\n                        try\\n                        {\\n                            res = PureDate.parsePureDate(r);\\n                        }\\n                        catch (java.lang.IllegalArgumentException dateTimeParseException1)\\n                        {\\n                            try\\n                            {\\n                                res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\\n                            }\\n                            catch (java.time.format.DateTimeParseException dateTimeParseException2)\\n                            {\\n                                res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\\n                            }\\n                        }\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Date from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Object getAlloyNativeValueFromResultSet(ResultSet resultSet,\\n                                                    int columnIndex,\\n                                                    int columnType)\\n    {\\n        try\\n        {\\n            Object result = null;\\n            switch (columnType)\\n            {\\n                case Types.DATE:\\n                {\\n                    java.sql.Date date = resultSet.getDate(columnIndex);\\n                    if (date != null)\\n                    {\\n                        result = PureDate.fromSQLDate(date);\\n                    }\\n                    break;\\n                }\\n                case Types.TIMESTAMP:\\n                {\\n                    java.sql.Timestamp timestamp = resultSet.getTimestamp(columnIndex, this.calendar);\\n                    if (timestamp != null)\\n                    {\\n                        result = PureDate.fromSQLTimestamp(timestamp);\\n                    }\\n                    break;\\n                }\\n                case Types.TINYINT:\\n                case Types.SMALLINT:\\n                case Types.INTEGER:\\n                case Types.BIGINT:\\n                {\\n                    long num = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        result = Long.valueOf(num);\\n                    }\\n                    break;\\n                }\\n                case Types.REAL:\\n                case Types.FLOAT:\\n                case Types.DOUBLE:\\n                {\\n                    double num = resultSet.getDouble(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        result = Double.valueOf(num);\\n                    }\\n                    break;\\n                }\\n                case Types.DECIMAL:\\n                case Types.NUMERIC:\\n                {\\n                    result = resultSet.getBigDecimal(columnIndex);\\n                    break;\\n                }\\n                case Types.CHAR:\\n                case Types.VARCHAR:\\n                case Types.LONGVARCHAR:\\n                case Types.NCHAR:\\n                case Types.NVARCHAR:\\n                case Types.LONGNVARCHAR:\\n                case Types.OTHER:\\n                {\\n                    result = resultSet.getString(columnIndex);\\n                    break;\\n                }\\n                case Types.BIT:\\n                case Types.BOOLEAN:\\n                {\\n                    boolean bool = resultSet.getBoolean(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        result = Boolean.valueOf(bool);\\n                    }\\n                }\\n                case Types.BINARY:\\n                case Types.VARBINARY:\\n                case Types.LONGVARBINARY:\\n                {\\n                    byte[] bytes = resultSet.getBytes(columnIndex);\\n                    if (bytes != null)\\n                    {\\n                        result = this.encodeHex(bytes);\\n                    }\\n                    break;\\n                }\\n                case Types.NULL:\\n                {\\n                    // do nothing: value is already assigned to null\\n                    break;\\n                }\\n                default:\\n                {\\n                    result = resultSet.getObject(columnIndex);\\n                }\\n            }\\n            return result;}\\n        catch (Exception e)\\n        {\\n            throw new RuntimeException(e);\\n        }\\n    }\\n\\n    private String encodeHex(byte[] data)\\n    {\\n        final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\\n        final int l = data.length;\\n        final char[] out = new char[l << 1];\\n        for (int i = 0, j = 0; i < l; i++)\\n        {\\n            out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];\\n            out[j++] = DIGITS_LOWER[0x0F & data[i]];\\n        }\\n        return new String(out);\\n    }\\n\\n    public Object getObjectFromResultSet(ResultSet resultSet,\\n                                         String databaseTimeZone,\\n                                         String databaseConnection)\\n    {\\n        if (this.propertyIndices == null)\\n        {\\n            this.doSetup(resultSet, databaseTimeZone, databaseConnection);\\n        }\\n        final _pure.plan.root.A_p_A_Impl object = new _pure.plan.root.A_p_A_Impl();\\n        object.setSetId$(\\\"p_A\\\");\\n        int pkColIndex;\\n\\n        int propertyIndex;\\n\\n        propertyIndex = this.propertyIndices.get(0).get(0);\\n        {\\n            String res = (String) this.propertyGetters.get(0).get(0).get();\\n            if (res == null)\\n            {\\n                throw new RuntimeException(\\\"Error reading in property 'name'. Property of multiplicity [1] can not be null\\\");\\n            }\\n            object.setName(res);\\n        }\\n\\n        return object;\\n    }\\n\\n    private void doSetup(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\\n    {\\n        try\\n        {\\n            this.calendar = new GregorianCalendar(TimeZone.getTimeZone(databaseTimeZone));\\n            _pure.plan.root.A_p_A_BaseImpl.databaseConnection$ = databaseConnection;\\n            ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\\n            int columnCount = resultSetMetaData.getColumnCount();\\n            this.columnTypes = new ArrayList<>();\\n            List<String> columnNames = new ArrayList<>();\\n            for (int i = 1; i <= columnCount; i++)\\n            {\\n                String columnLabel = resultSetMetaData.getColumnLabel(i);\\n                columnNames.add(columnLabel.startsWith(\\\"\\\\\\\"\\\") && columnLabel.endsWith(\\\"\\\\\\\"\\\") ? columnLabel.substring(1, columnLabel.length() - 1).toUpperCase() : columnLabel.toUpperCase());\\n                this.columnTypes.add(resultSetMetaData.getColumnType(i));\\n            }\\n\\n            this.propertyIndices = new ArrayList<>();\\n            List<Integer> index_0 = new ArrayList<>();\\n            index_0.add(columnNames.indexOf(\\\"NAME\\\") + 1);\\n            this.propertyIndices.add(index_0);\\n\\n            this.propertyGetters = new ArrayList<>();\\n            int propertyIndex;\\n            Supplier<Object> propertyGetter = null;\\n\\n            List<Supplier<Object>> propertyGetter_0 = new ArrayList<>();\\n\\n            propertyIndex = this.propertyIndices.get(0).get(0);\\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(resultSet, propertyIndex, resultSetMetaData.getColumnType(propertyIndex), \\\"name\\\");\\n            propertyGetter_0.add(propertyGetter);\\n\\n            this.propertyGetters.add(propertyGetter_0);\\n        }\\n        catch (RuntimeException e)\\n        {\\n            throw e;\\n        }\\n        catch (Exception e)\\n        {\\n            throw new RuntimeException(e);\\n        }\\n    }\\n}\"\n" +
                        "    } ]\n" +
                        "  },\n" +
                        "  \"rootExecutionNode\" : {\n" +
                        "    \"_type\" : \"relationalClassInstantiation\",\n" +
                        "    \"executionNodes\" : [ {\n" +
                        "      \"_type\" : \"sql\",\n" +
                        "      \"connection\" : {\n" +
                        "        \"_type\" : \"RelationalDatabaseConnection\",\n" +
                        "        \"authenticationStrategy\" : {\n" +
                        "          \"_type\" : \"snowflakePublic\",\n" +
                        "          \"passPhraseVaultReference\" : \"val\",\n" +
                        "          \"privateKeyVaultReference\" : \"key\",\n" +
                        "          \"publicUserName\" : \"name\"\n" +
                        "        },\n" +
                        "        \"datasourceSpecification\" : {\n" +
                        "          \"_type\" : \"snowflake\",\n" +
                        "          \"accountName\" : \"account\",\n" +
                        "          \"cloudType\" : \"aws\",\n" +
                        "          \"databaseName\" : \"test\",\n" +
                        "          \"quotedIdentifiersIgnoreCase\" : false,\n" +
                        "          \"region\" : \"us-east2\",\n" +
                        "          \"warehouseName\" : \"warehouseName\"\n" +
                        "        },\n" +
                        "        \"element\" : \"p::db\",\n" +
                        "        \"postProcessorWithParameter\" : [ ],\n" +
                        "        \"postProcessors\" : [ ],\n" +
                        "        \"type\" : \"Snowflake\"\n" +
                        "      },\n" +
                        "      \"executionNodes\" : [ ],\n" +
                        "      \"resultColumns\" : [ {\n" +
                        "        \"dataType\" : \"VARCHAR(200)\",\n" +
                        "        \"label\" : \"\\\"name\\\"\"\n" +
                        "      } ],\n" +
                        "      \"resultType\" : {\n" +
                        "        \"_type\" : \"dataType\",\n" +
                        "        \"dataType\" : \"meta::pure::metamodel::type::Any\"\n" +
                        "      },\n" +
                        "      \"sqlQuery\" : \"select \\\"root\\\".name as \\\"name\\\" from tb as \\\"root\\\"\"\n" +
                        "    } ],\n" +
                        "    \"implementation\" : {\n" +
                        "      \"_type\" : \"java\",\n" +
                        "      \"executionClassFullName\" : \"_pure.plan.root.Execute\"\n" +
                        "    },\n" +
                        "    \"resultSizeRange\" : {\n" +
                        "      \"lowerBound\" : 0\n" +
                        "    },\n" +
                        "    \"resultType\" : {\n" +
                        "      \"_type\" : \"class\",\n" +
                        "      \"class\" : \"p::A\",\n" +
                        "      \"setImplementations\" : [ {\n" +
                        "        \"class\" : \"p::A\",\n" +
                        "        \"id\" : \"p_A\",\n" +
                        "        \"mapping\" : \"p::M\",\n" +
                        "        \"propertyMappings\" : [ {\n" +
                        "          \"enumMapping\" : { },\n" +
                        "          \"property\" : \"name\",\n" +
                        "          \"type\" : \"String\"\n" +
                        "        } ]\n" +
                        "      } ]\n" +
                        "    }\n" +
                        "  },\n" +
                        "  \"serializer\" : {\n" +
                        "    \"name\" : \"pure\",\n" +
                        "    \"version\" : \"vX_X_X\"\n" +
                        "  },\n" +
                        "  \"templateFunctions\" : [ \"<#function renderCollection collection separator prefix suffix defaultValue><#if collection?size == 0><#return defaultValue></#if><#return prefix + collection?join(suffix + separator + prefix) + suffix></#function>\", \"<#function collectionSize collection> <#return collection?size?c> </#function>\" ]\n" +
                        "}", writer.toString());
    }

    @Test
    public void testGenerationWithBigQueryConnection() throws Exception
    {
        PureModelContextData contextData = PureGrammarParser.newInstance().parseModel(
                "" +
                        "Class p::A {name:String[1];}" +
                        "function p::f():p::A[*]{p::A.all();}\n" +
                        "###Relational\n" +
                        "Database p::db(Table tb (name VARCHAR(200)))\n" +
                        "###Mapping\n" +
                        "Mapping p::M (p::A : Relational {name : [p::db]tb.name })\n" +
                        "###Runtime\n" +
                        "Runtime p::R" +
                        "{" +
                        "   mappings:[p::M];" +
                        "   connections:[" +
                        "       p::db : [" +
                        "           c1: #{\n" +
                        "                   RelationalDatabaseConnection\n" +
                        "                   {\n" +
                        "                       type: BigQuery;\n" +
                        "                       specification: BigQuery\n" +
                        "                                      {\n" +
                        "                                           projectId: 'proj1';\n" +
                        "                                           defaultDataset: 'dataset1';\n" +
                        "                                      };\n" +
                        "                       auth: GCPApplicationDefaultCredentials;\n" +
                        "                   }\n" +
                        "               }#\n" +
                        "           ]" +
                        "   ];" +
                        "}");
        PureModel pureModel = Compiler.compile(contextData, null, null);

        String plan = PlanGenerator.generateExecutionPlanAsString(
                HelperValueSpecificationBuilder.buildLambda(contextData.getElementsOfType(Function.class).get(0).body, Collections.emptyList(), new CompileContext.Builder(pureModel).build()),
                pureModel.getMapping("p::M"),
                pureModel.getRuntime("p::R"),
                null,
                pureModel,
                "vX_X_X",
                PlanPlatform.JAVA,
                null,
                core_relational_relational_router_router_extension.Root_meta_pure_router_extension_defaultRelationalExtensions__RouterExtension_MANY_(pureModel.getExecutionSupport()),
                LegendPlanTransformers.transformers
        );

        ObjectMapper mapper = ObjectMapperFactory.getNewStandardObjectMapperWithPureProtocolExtensionSupports().enable(SerializationFeature.INDENT_OUTPUT);
        ExecutionPlan executionPlan = mapper.readValue(plan, ExecutionPlan.class);
        StringWriter writer = new StringWriter();
        mapper.writeValue(writer, executionPlan);

        assertGeneratedStringEquals(
                "{\n" +
                        "  \"_type\" : \"simple\",\n" +
                        "  \"authDependent\" : false,\n" +
                        "  \"globalImplementationSupport\" : {\n" +
                        "    \"_type\" : \"java\",\n" +
                        "    \"classes\" : [ {\n" +
                        "      \"name\" : \"A\",\n" +
                        "      \"package\" : \"_pure.app.p\",\n" +
                        "      \"source\" : \"package _pure.app.p;\\n\\nimport java.math.*;\\nimport java.util.*;\\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\\n\\npublic interface A extends org.finos.legend.engine.plan.dependencies.store.shared.IReferencedObject\\n{\\n    String getName();\\n    String getAlloyStoreObjectReference$();\\n}\"\n" +
                        "    }, {\n" +
                        "      \"name\" : \"A_p_A_BaseImpl\",\n" +
                        "      \"package\" : \"_pure.plan.root\",\n" +
                        "      \"source\" : \"package _pure.plan.root;\\n\\nimport com.fasterxml.jackson.annotation.JsonIgnore;\\nimport com.fasterxml.jackson.annotation.JsonInclude;\\nimport com.fasterxml.jackson.annotation.JsonProperty;\\nimport com.fasterxml.jackson.core.JsonGenerator;\\nimport com.fasterxml.jackson.databind.JsonSerializer;\\nimport com.fasterxml.jackson.databind.ObjectMapper;\\nimport com.fasterxml.jackson.databind.SerializerProvider;\\nimport com.fasterxml.jackson.databind.module.SimpleModule;\\nimport java.io.IOException;\\nimport java.util.*;\\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\\n\\npublic class A_p_A_BaseImpl implements _pure.app.p.A\\n{\\n    private String name;\\n    private String setId$;\\n    public static String databaseConnection$;\\n    private static final ObjectMapper objectMapper$ = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL).registerModule(new SimpleModule().addSerializer(PureDate.class, new JsonSerializer<PureDate>() { @Override public void serialize(PureDate value, JsonGenerator gen, SerializerProvider serializers) throws IOException { gen.writeRawValue(\\\"\\\\\\\"\\\" + value.toString() + \\\"\\\\\\\"\\\"); } }));\\n    private String alloyStoreObjectReference$;\\n\\n    @JsonProperty(\\\"name\\\")\\n    public String getName()\\n    {\\n        return this.name;\\n    }\\n\\n    public void setName(String name)\\n    {\\n        this.name = name;\\n    }\\n\\n    @JsonIgnore\\n    public String getSetId$()\\n    {\\n        return this.setId$;\\n    }\\n\\n    public void setSetId$(String setId)\\n    {\\n        this.setId$ = setId;\\n    }\\n\\n    @JsonProperty(\\\"alloyStoreObjectReference$\\\")\\n    public String getAlloyStoreObjectReference$()\\n    {\\n        if (this.alloyStoreObjectReference$ == null)\\n        {\\n            try\\n            {\\n                StringBuilder referenceBuilder = new StringBuilder();\\n                referenceBuilder.append(\\\"001:\\\");\\n                referenceBuilder.append(\\\"010:\\\");\\n\\n                referenceBuilder.append(\\\"0000000010:\\\");\\n                referenceBuilder.append(\\\"Relational:\\\");\\n\\n                referenceBuilder.append(\\\"0000000004:\\\");\\n                referenceBuilder.append(\\\"p::M:\\\");\\n\\n                referenceBuilder.append(\\\"0000000003:\\\");\\n                referenceBuilder.append(\\\"p_A:\\\");\\n\\n                String setId = this.getSetId$();\\n                referenceBuilder.append(String.format(\\\"%010d\\\", setId.length()));\\n                referenceBuilder.append(\\\":\\\");\\n                referenceBuilder.append(setId);\\n                referenceBuilder.append(\\\":\\\");\\n\\n                String databaseConnectionString = _pure.plan.root.A_p_A_BaseImpl.databaseConnection$;\\n                referenceBuilder.append(String.format(\\\"%010d\\\", databaseConnectionString.length()));\\n                referenceBuilder.append(\\\":\\\");\\n                referenceBuilder.append(databaseConnectionString);\\n                referenceBuilder.append(\\\":\\\");\\n\\n                Map<String, Object> pkMap = new HashMap<>();\\n\\n                String pkMapString = objectMapper$.writeValueAsString(pkMap);\\n                referenceBuilder.append(String.format(\\\"%010d\\\", pkMapString.length()));\\n                referenceBuilder.append(\\\":\\\");\\n                referenceBuilder.append(pkMapString);\\n\\n                this.alloyStoreObjectReference$ = \\\"ASOR:\\\" + org.apache.commons.codec.binary.Base64.encodeBase64URLSafeString(referenceBuilder.toString().getBytes());\\n            }\\n            catch (Exception e)\\n            {\\n               throw new RuntimeException(e);\\n            }\\n        }\\n\\n        return this.alloyStoreObjectReference$;\\n    }\\n}\"\n" +
                        "    }, {\n" +
                        "      \"name\" : \"A_p_A_Impl\",\n" +
                        "      \"package\" : \"_pure.plan.root\",\n" +
                        "      \"source\" : \"package _pure.plan.root;\\n\\nimport com.fasterxml.jackson.annotation.JsonIgnore;\\nimport com.fasterxml.jackson.annotation.JsonProperty;\\nimport java.util.*;\\n\\npublic class A_p_A_Impl extends A_p_A_BaseImpl implements _pure.app.p.A\\n{\\n    public A_p_A_Impl()\\n    {\\n        this.setSetId$(\\\"p_A\\\");\\n    }\\n}\"\n" +
                        "    }, {\n" +
                        "      \"name\" : \"Execute\",\n" +
                        "      \"package\" : \"_pure.plan.root\",\n" +
                        "      \"source\" : \"package _pure.plan.root;\\n\\nimport java.sql.ResultSet;\\nimport java.util.*;\\nimport org.finos.legend.engine.plan.dependencies.store.relational.classResult.IRelationalClassInstantiationNodeExecutor;\\n\\npublic class Execute implements IRelationalClassInstantiationNodeExecutor\\n{\\n    private Helper helper;\\n\\n    public Execute()\\n    {\\n        this.helper = new Helper();\\n    }\\n\\n    public Object getObjectFromResultSet(ResultSet resultSet,\\n                                         String databaseTimeZone,\\n                                         String databaseConnection)\\n    {\\n        return this.helper.getObjectFromResultSet(resultSet, databaseTimeZone, databaseConnection);\\n    }\\n}\"\n" +
                        "    }, {\n" +
                        "      \"name\" : \"Helper\",\n" +
                        "      \"package\" : \"_pure.plan.root\",\n" +
                        "      \"source\" : \"package _pure.plan.root;\\n\\nimport java.sql.ResultSet;\\nimport java.sql.ResultSetMetaData;\\nimport java.sql.Types;\\nimport java.util.*;\\nimport java.util.function.*;\\nimport java.util.stream.*;\\nimport org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\\n\\npublic class Helper\\n{\\n    private static final List<Integer> STRING_TYPES = Arrays.asList(Types.CHAR, Types.VARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.LONGNVARCHAR, Types.OTHER, Types.NULL);\\n    private static final List<Integer> INT_TYPES = Arrays.asList(Types.TINYINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.NULL);\\n    private static final List<Integer> FLOAT_TYPES = Arrays.asList(Types.REAL, Types.FLOAT, Types.DOUBLE, Types.DECIMAL, Types.NUMERIC, Types.NULL);\\n    private static final List<Integer> BOOL_TYPES = Arrays.asList(Types.BIT, Types.BOOLEAN, Types.NULL);\\n    private static final List<Integer> STRICT_DATE_TYPES = Arrays.asList(Types.DATE, Types.NULL);\\n    private static final List<Integer> DATE_TIME_TYPES = Arrays.asList(Types.TIMESTAMP, Types.NULL);\\n    private List<Integer> columnTypes;\\n    private List<List<Integer>> propertyIndices;\\n    private List<List<Supplier<Object>>> propertyGetters;\\n    private Calendar calendar;\\n\\n    private Supplier<Object> getResultSetPropertyGetterForStringProperty(ResultSet resultSet,\\n                                                                         int columnIndex,\\n                                                                         int columnType,\\n                                                                         String propertyName)\\n    {\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n           return () -> {\\n                try\\n                {\\n                    return resultSet.getString(columnIndex);\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        else\\n        {\\n            throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type String from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n        }\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForIntegerProperty(ResultSet resultSet,\\n                                                                          int columnIndex,\\n                                                                          int columnType,\\n                                                                          String propertyName)\\n    {\\n        if (INT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Long res = null;\\n                    long r = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Long.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Integer from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForFloatProperty(ResultSet resultSet,\\n                                                                        int columnIndex,\\n                                                                        int columnType,\\n                                                                        String propertyName)\\n    {\\n        if (FLOAT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Double res = null;\\n                    double r = resultSet.getDouble(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Double.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (INT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Double res = null;\\n                    long r = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Double.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Float from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForDecimalProperty(ResultSet resultSet,\\n                                                                          int columnIndex,\\n                                                                          int columnType,\\n                                                                          String propertyName)\\n    {\\n        if (FLOAT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    java.math.BigDecimal res = null;\\n                    double r = resultSet.getDouble(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = java.math.BigDecimal.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (INT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    java.math.BigDecimal res = null;\\n                    long r = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = java.math.BigDecimal.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Decimal from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForBooleanProperty(ResultSet resultSet,\\n                                                                          int columnIndex,\\n                                                                          int columnType,\\n                                                                          String propertyName)\\n    {\\n        if (BOOL_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Boolean res = null;\\n                    boolean r = resultSet.getBoolean(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Boolean.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Boolean res = null;\\n                    String r = resultSet.getString(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Boolean.valueOf(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (INT_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    Boolean res = null;\\n                    long r = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        res = Boolean.valueOf(r == 1);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Boolean from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForStrictDateProperty(ResultSet resultSet,\\n                                                                             int columnIndex,\\n                                                                             int columnType,\\n                                                                             String propertyName)\\n    {\\n        if (STRICT_DATE_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    java.sql.Date r = resultSet.getDate(columnIndex);\\n                    if (r != null)\\n                    {\\n                        res = PureDate.fromSQLDate(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    String r = resultSet.getString(columnIndex);\\n                    if (r != null)\\n                    {\\n                        try\\n                        {\\n                            res = PureDate.parsePureDate(r);\\n                        }\\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\\n                        {\\n                            res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\\n                        }\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type StrictDate from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForDateTimeProperty(ResultSet resultSet,\\n                                                                           int columnIndex,\\n                                                                           int columnType,\\n                                                                           String propertyName)\\n    {\\n        if (DATE_TIME_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\\n                    if (r != null)\\n                    {\\n                        res = PureDate.fromSQLTimestamp(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    String r = resultSet.getString(columnIndex);\\n                    if (r != null)\\n                    {\\n                        try\\n                        {\\n                            res = PureDate.parsePureDate(r);\\n                        }\\n                        catch (java.lang.IllegalArgumentException dateTimeParseException)\\n                        {\\n                            res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\\n                        }\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type DateTime from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Supplier<Object> getResultSetPropertyGetterForDateProperty(ResultSet resultSet,\\n                                                                       int columnIndex,\\n                                                                       int columnType,\\n                                                                       String propertyName)\\n    {\\n        if (STRICT_DATE_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    java.sql.Date r = resultSet.getDate(columnIndex);\\n                    if (r != null)\\n                    {\\n                        res = PureDate.fromSQLDate(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (DATE_TIME_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    java.sql.Timestamp r = resultSet.getTimestamp(columnIndex, this.calendar);\\n                    if (r != null)\\n                    {\\n                        res = PureDate.fromSQLTimestamp(r);\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        if (STRING_TYPES.contains(columnType))\\n        {\\n            return () -> {\\n                try\\n                {\\n                    PureDate res = null;\\n                    String r = resultSet.getString(columnIndex);\\n                    if (r != null)\\n                    {\\n                        try\\n                        {\\n                            res = PureDate.parsePureDate(r);\\n                        }\\n                        catch (java.lang.IllegalArgumentException dateTimeParseException1)\\n                        {\\n                            try\\n                            {\\n                                res = PureDate.fromSQLTimestamp(java.sql.Timestamp.valueOf(r));\\n                            }\\n                            catch (java.time.format.DateTimeParseException dateTimeParseException2)\\n                            {\\n                                res = PureDate.fromSQLDate(java.sql.Date.valueOf(r));\\n                            }\\n                        }\\n                    }\\n                    return res;\\n                }\\n                catch (Exception e)\\n                {\\n                    throw new RuntimeException(e);\\n                }\\n            };\\n        }\\n        throw new RuntimeException(\\\"Error reading in property '\\\" + propertyName + \\\"' of type Date from SQL column of type '\\\" + columnType + \\\"'.\\\");\\n    }\\n\\n    private Object getAlloyNativeValueFromResultSet(ResultSet resultSet,\\n                                                    int columnIndex,\\n                                                    int columnType)\\n    {\\n        try\\n        {\\n            Object result = null;\\n            switch (columnType)\\n            {\\n                case Types.DATE:\\n                {\\n                    java.sql.Date date = resultSet.getDate(columnIndex);\\n                    if (date != null)\\n                    {\\n                        result = PureDate.fromSQLDate(date);\\n                    }\\n                    break;\\n                }\\n                case Types.TIMESTAMP:\\n                {\\n                    java.sql.Timestamp timestamp = resultSet.getTimestamp(columnIndex, this.calendar);\\n                    if (timestamp != null)\\n                    {\\n                        result = PureDate.fromSQLTimestamp(timestamp);\\n                    }\\n                    break;\\n                }\\n                case Types.TINYINT:\\n                case Types.SMALLINT:\\n                case Types.INTEGER:\\n                case Types.BIGINT:\\n                {\\n                    long num = resultSet.getLong(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        result = Long.valueOf(num);\\n                    }\\n                    break;\\n                }\\n                case Types.REAL:\\n                case Types.FLOAT:\\n                case Types.DOUBLE:\\n                {\\n                    double num = resultSet.getDouble(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        result = Double.valueOf(num);\\n                    }\\n                    break;\\n                }\\n                case Types.DECIMAL:\\n                case Types.NUMERIC:\\n                {\\n                    result = resultSet.getBigDecimal(columnIndex);\\n                    break;\\n                }\\n                case Types.CHAR:\\n                case Types.VARCHAR:\\n                case Types.LONGVARCHAR:\\n                case Types.NCHAR:\\n                case Types.NVARCHAR:\\n                case Types.LONGNVARCHAR:\\n                case Types.OTHER:\\n                {\\n                    result = resultSet.getString(columnIndex);\\n                    break;\\n                }\\n                case Types.BIT:\\n                case Types.BOOLEAN:\\n                {\\n                    boolean bool = resultSet.getBoolean(columnIndex);\\n                    if (!resultSet.wasNull())\\n                    {\\n                        result = Boolean.valueOf(bool);\\n                    }\\n                }\\n                case Types.BINARY:\\n                case Types.VARBINARY:\\n                case Types.LONGVARBINARY:\\n                {\\n                    byte[] bytes = resultSet.getBytes(columnIndex);\\n                    if (bytes != null)\\n                    {\\n                        result = this.encodeHex(bytes);\\n                    }\\n                    break;\\n                }\\n                case Types.NULL:\\n                {\\n                    // do nothing: value is already assigned to null\\n                    break;\\n                }\\n                default:\\n                {\\n                    result = resultSet.getObject(columnIndex);\\n                }\\n            }\\n            return result;}\\n        catch (Exception e)\\n        {\\n            throw new RuntimeException(e);\\n        }\\n    }\\n\\n    private String encodeHex(byte[] data)\\n    {\\n        final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\\n        final int l = data.length;\\n        final char[] out = new char[l << 1];\\n        for (int i = 0, j = 0; i < l; i++)\\n        {\\n            out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];\\n            out[j++] = DIGITS_LOWER[0x0F & data[i]];\\n        }\\n        return new String(out);\\n    }\\n\\n    public Object getObjectFromResultSet(ResultSet resultSet,\\n                                         String databaseTimeZone,\\n                                         String databaseConnection)\\n    {\\n        if (this.propertyIndices == null)\\n        {\\n            this.doSetup(resultSet, databaseTimeZone, databaseConnection);\\n        }\\n        final _pure.plan.root.A_p_A_Impl object = new _pure.plan.root.A_p_A_Impl();\\n        object.setSetId$(\\\"p_A\\\");\\n        int pkColIndex;\\n\\n        int propertyIndex;\\n\\n        propertyIndex = this.propertyIndices.get(0).get(0);\\n        {\\n            String res = (String) this.propertyGetters.get(0).get(0).get();\\n            if (res == null)\\n            {\\n                throw new RuntimeException(\\\"Error reading in property 'name'. Property of multiplicity [1] can not be null\\\");\\n            }\\n            object.setName(res);\\n        }\\n\\n        return object;\\n    }\\n\\n    private void doSetup(ResultSet resultSet, String databaseTimeZone, String databaseConnection)\\n    {\\n        try\\n        {\\n            this.calendar = new GregorianCalendar(TimeZone.getTimeZone(databaseTimeZone));\\n            _pure.plan.root.A_p_A_BaseImpl.databaseConnection$ = databaseConnection;\\n            ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\\n            int columnCount = resultSetMetaData.getColumnCount();\\n            this.columnTypes = new ArrayList<>();\\n            List<String> columnNames = new ArrayList<>();\\n            for (int i = 1; i <= columnCount; i++)\\n            {\\n                String columnLabel = resultSetMetaData.getColumnLabel(i);\\n                columnNames.add(columnLabel.startsWith(\\\"\\\\\\\"\\\") && columnLabel.endsWith(\\\"\\\\\\\"\\\") ? columnLabel.substring(1, columnLabel.length() - 1).toUpperCase() : columnLabel.toUpperCase());\\n                this.columnTypes.add(resultSetMetaData.getColumnType(i));\\n            }\\n\\n            this.propertyIndices = new ArrayList<>();\\n            List<Integer> index_0 = new ArrayList<>();\\n            index_0.add(columnNames.indexOf(\\\"NAME\\\") + 1);\\n            this.propertyIndices.add(index_0);\\n\\n            this.propertyGetters = new ArrayList<>();\\n            int propertyIndex;\\n            Supplier<Object> propertyGetter = null;\\n\\n            List<Supplier<Object>> propertyGetter_0 = new ArrayList<>();\\n\\n            propertyIndex = this.propertyIndices.get(0).get(0);\\n            propertyGetter = this.getResultSetPropertyGetterForStringProperty(resultSet, propertyIndex, resultSetMetaData.getColumnType(propertyIndex), \\\"name\\\");\\n            propertyGetter_0.add(propertyGetter);\\n\\n            this.propertyGetters.add(propertyGetter_0);\\n        }\\n        catch (RuntimeException e)\\n        {\\n            throw e;\\n        }\\n        catch (Exception e)\\n        {\\n            throw new RuntimeException(e);\\n        }\\n    }\\n}\"\n" +
                        "    } ]\n" +
                        "  },\n" +
                        "  \"rootExecutionNode\" : {\n" +
                        "    \"_type\" : \"relationalClassInstantiation\",\n" +
                        "    \"executionNodes\" : [ {\n" +
                        "      \"_type\" : \"sql\",\n" +
                        "      \"connection\" : {\n" +
                        "        \"_type\" : \"RelationalDatabaseConnection\",\n" +
                        "        \"authenticationStrategy\" : {\n" +
                        "          \"_type\" : \"gcpApplicationDefaultCredentials\"\n" +
                        "        },\n" +
                        "        \"datasourceSpecification\" : {\n" +
                        "          \"_type\" : \"bigQuery\",\n" +
                        "          \"defaultDataset\" : \"dataset1\",\n" +
                        "          \"projectId\" : \"proj1\"\n" +
                        "        },\n" +
                        "        \"element\" : \"p::db\",\n" +
                        "        \"postProcessorWithParameter\" : [ ],\n" +
                        "        \"postProcessors\" : [ ],\n" +
                        "        \"type\" : \"BigQuery\"\n" +
                        "      },\n" +
                        "      \"executionNodes\" : [ ],\n" +
                        "      \"resultColumns\" : [ {\n" +
                        "        \"dataType\" : \"VARCHAR(200)\",\n" +
                        "        \"label\" : \"\\\"name\\\"\"\n" +
                        "      } ],\n" +
                        "      \"resultType\" : {\n" +
                        "        \"_type\" : \"dataType\",\n" +
                        "        \"dataType\" : \"meta::pure::metamodel::type::Any\"\n" +
                        "      },\n" +
                        "      \"sqlQuery\" : \"select `root`.name as `name` from tb as `root`\"\n" +
                        "    } ],\n" +
                        "    \"implementation\" : {\n" +
                        "      \"_type\" : \"java\",\n" +
                        "      \"executionClassFullName\" : \"_pure.plan.root.Execute\"\n" +
                        "    },\n" +
                        "    \"resultSizeRange\" : {\n" +
                        "      \"lowerBound\" : 0\n" +
                        "    },\n" +
                        "    \"resultType\" : {\n" +
                        "      \"_type\" : \"class\",\n" +
                        "      \"class\" : \"p::A\",\n" +
                        "      \"setImplementations\" : [ {\n" +
                        "        \"class\" : \"p::A\",\n" +
                        "        \"id\" : \"p_A\",\n" +
                        "        \"mapping\" : \"p::M\",\n" +
                        "        \"propertyMappings\" : [ {\n" +
                        "          \"enumMapping\" : { },\n" +
                        "          \"property\" : \"name\",\n" +
                        "          \"type\" : \"String\"\n" +
                        "        } ]\n" +
                        "      } ]\n" +
                        "    }\n" +
                        "  },\n" +
                        "  \"serializer\" : {\n" +
                        "    \"name\" : \"pure\",\n" +
                        "    \"version\" : \"vX_X_X\"\n" +
                        "  },\n" +
                        "  \"templateFunctions\" : [ \"<#function renderCollection collection separator prefix suffix defaultValue><#if collection?size == 0><#return defaultValue></#if><#return prefix + collection?join(suffix + separator + prefix) + suffix></#function>\", \"<#function collectionSize collection> <#return collection?size?c> </#function>\" ]\n" +
                        "}", writer.toString());
    }

    private static void assertGeneratedStringEquals(String expected, String actual)
    {
        Assert.assertEquals(normalizeLineBreaks(expected), normalizeLineBreaks(actual));
    }

    private static String normalizeLineBreaks(String string)
    {
        return string.replaceAll("\\R", "\n");
    }
}
