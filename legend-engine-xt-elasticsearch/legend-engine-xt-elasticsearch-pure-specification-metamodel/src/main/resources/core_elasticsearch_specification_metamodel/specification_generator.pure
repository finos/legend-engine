// Copyright 2023 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::language::java::factory::*;
import meta::external::language::java::transform::*;
import meta::external::language::java::metamodel::project::*;
import meta::external::store::elasticsearch::specification::metamodel::*;

Class
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::GenerationState
[
  uniqueClasses: $this.nameToClasses->map(x | $x.first)->distinct()->size() == $this.nameToClasses->size()
]
{
  spec: Model[1];
  debug: Boolean[1];
  generated: meta::protocols::pure::vX_X_X::metamodel::PackageableElement[*];
  nameToClasses: Pair<TypeName, String>[*];
  pkgPrefix: String[1];

  log(msg: Function<{->String[1]}>[1]){
    if($this.debug, |println('(gen: ' + $this.nameToClasses->size()->toString() + ') | ' + $msg->eval()), |[]);
    $this.generated->size();
  }:Any[*];

  pureType(name: TypeName[1]){
    let pair = $this.nameToClasses->filter(x | $x.first == $name);
    assert($pair->isNotEmpty(), |'No type registered for %s.%s'->format([$name.namespace, $name.name]));
    $pair.second->toOne();
  }:String[1];

  esType(name: String[1]){
    let pair = $this.nameToClasses->filter(x | $x.second == $name);
    assert($pair->isNotEmpty(), |'No type registered for %s'->format($name));
    $this.type($pair.first->head());
  }:TypeDefinition[0..1];

  type(name: TypeName[0..1]){
    $this.spec.types->filter(x | $x.name == $name)->head();
  }:TypeDefinition[0..1];
}

function meta::external::store::elasticsearch::specification::metamodel::generatePureCode(specAsJson: String[1], pkgPrefix: String[1], apisToGenerate: String[*], debug: Boolean[1]): String[1]
{
  let state = $specAsJson->parse()->specToPure($pkgPrefix, $apisToGenerate, $debug);
  let protocol = ^meta::protocols::Protocol(name='pure', version='vX_X_X');
  let pmcd = ^meta::protocols::pure::vX_X_X::metamodel::PureModelContextData(
      _type = 'data',
      serializer = $protocol,
      elements = $state.generated
  );

  let pureCode = $pmcd->meta::json::toJSON(1000, meta::json::config(false, false, true, true));
}

function meta::external::store::elasticsearch::specification::metamodel::generateProtocolClasses(purePackage:String[1], javaPackage:String[1]): Project[1]
{
  // todo remove

  let profile = 'meta::external::store::elasticsearch::v7::metamodel::specification::ESProfile'->pathToElement()->cast(@Profile);

  let project = meta::protocols::generation::java::generateProtocolClasses($purePackage, $javaPackage, [], []);

  let pack =  $purePackage->pathToElement()->cast(@Package);
  let basePackageStr = $pack->elementToPath('.');

  let conventions = meta::protocols::generation::java::conventions($purePackage, $javaPackage, $basePackageStr, []);
  let elements = $pack->getAllPackageElements(true);
  $elements->fold({element, proj | $element->generateProtocolCode($proj, $conventions, $profile)}, $project);

  // todo add helper for mix ins
  // add deserializers
}

function <<access.private>> meta::external::store::elasticsearch::specification::metamodel::generateProtocolCode(
                                      elem: PackageableElement[1],                                      
                                      project: Project[1],
                                      conv: Conventions[1],
                                      esProfile: Profile[1]
                            ): Project[1]
{
  $elem->match(
    [      
      c: meta::pure::metamodel::type::Class<Any>[1]       | $c->generateProtocolCodeForClass($project, $conv, $esProfile),
      e: meta::pure::metamodel::type::Enumeration<Any>[1] | $e->generateProtocolCodeForEnum($project, $conv, $esProfile),
      s: Any[1]                                           | $project
    ]
  );
}

function <<access.private>> meta::external::store::elasticsearch::specification::metamodel::generateProtocolCodeForEnum(
                                      elem: Enumeration<Any>[1],                                      
                                      project: Project[1],
                                      conv : Conventions[1],
                                      esProfile: Profile[1]
                            ): Project[1]
{
  let name = $conv.typeAndPackageNameStrategy->toOne()->eval($elem, $conv);

  let enumClass = javaEnum('public', $name.first->javaPackage(), $name.second)
    ->addEntries($elem->enumValues()->cast(@Enum)->map({e| 
        let enumName = defaultIfEmpty(value4Tag($e, 'name', $esProfile)->first().value->cast(@String), $e.name)->toOne();
        javaEnumEntry($conv->identifier($e.name), $enumName);
      })
    )
    ->addField(javaField(['private', 'final'], javaString(), 'esName'))
    ->addConstructor({cls|
          let param = j_parameter(javaString(), 'esName');
          javaConstructor([], $param, j_this($cls)->j_field('esName')->j_assign($param));
      })
    ->addMethod({cls|
          javaMethod('public', javaString(), 'esName', [], j_return(j_this($cls)->j_field('esName')));
      });

  let mixIn = javaClass(['public', 'abstract'], $name.first->javaPackage(), $name.second + 'MixIn')
    ->addMethod(
        javaMethod(['public', 'abstract'], javaString(), 'esName', [])
          ->addAnnotation(^meta::external::language::java::metamodel::annotations::json::JsonValue())
      );

  $project->meta::external::language::java::factory::project::addClass($mixIn)->meta::external::language::java::factory::project::replaceClass($enumClass);
}

function <<access.private>> meta::external::store::elasticsearch::specification::metamodel::generateProtocolCodeForClass(
                                      elem: Class<Any>[1],                                      
                                      project: Project[1],
                                      conv : Conventions[1],
                                      esProfile: Profile[1]
                            ): Project[1]
{
  let name = $conv.typeAndPackageNameStrategy->toOne()->eval($elem, $conv);
  let javaClass = $project->meta::external::language::java::metamodel::project::getClass('src/main/java', $name.first->split('.'), $name.second)->toOne();

  // todo create mix in
  // if json type, switch to deduction (?)
  // add annotations for json property name
  // serializer/deserializer for dictionary properties
  // TaggedUnion deserializer
  // -- internal tag - add JsonTypeName too

  let basicMixIn = javaClass(['public', 'abstract'], $name.first->javaPackage(), $name.second + 'MixIn');

  // todo dont do this on external tagged

  let withTaggedUnion = if($elem->hasStereotype('TaggedUnion', $esProfile), 
    |
      let lambdaX = j_parameter(javaObject(), 'x');
      let pickFirstNotNullCode = javaStream()
        ->j_invoke(javaObject(), 'of', $javaClass.fields->map(f | j_this($javaClass)->j_field($f.name)), javaStream(javaObject()))
        ->js_filter(javaObjects()->j_methodReference('nonNull', javaFunctionType(javaObject(), javaBoolean())))
        ->js_resolve(javaObject())
        ->j_return();  
      let method = javaMethod('public', javaObject(), 'unionValue', [], $pickFirstNotNullCode);
      let unionClass = $javaClass->addMethod($method);
     
      pair($unionClass, $basicMixIn);
      ,
    | pair($javaClass, $basicMixIn)
  );

  let additionalPropertyProp = $elem.properties->filter(x | $x->hasStereotype('AdditionalProperty', $esProfile));
  let withAdditionalProperties = if ($additionalPropertyProp->size() == 1,
    |
      let prop = $additionalPropertyProp->toOne();
      let field = $javaClass.fields->filter(f | $f.name == $prop.name)->toOne();
      let fieldType = $field.type->cast(@meta::external::language::java::metamodel::ParameterizedType);
      let dictionaryClassName = $fieldType.rawType->cast(@meta::external::language::java::metamodel::Class).simpleName;
      let additionalPropertiesRawType = if($prop.multiplicity->hasToOneUpperBound(), |$fieldType.typeArguments->at(0), |$fieldType.typeArguments->at(0)->cast(@meta::external::language::java::metamodel::ParameterizedType).typeArguments->at(0));
      let additionalPropertiesType = if($dictionaryClassName == 'DictionaryEntryMultiValue', |javaList($additionalPropertiesRawType), |$additionalPropertiesRawType);
      let anyGetterReturnType = javaMap(javaString(), $additionalPropertiesType);
      let anyGetterCode = if($prop.multiplicity->hasToOneUpperBound(),
        |
          let lambdaX = j_parameter($field.type, 'x');
          javaOptional()
            ->j_invoke('ofNullable', j_this($javaClass)->j_field($field.name), javaOptional($field.type))
            ->j_invoke('map', j_lambda($lambdaX, javaCollections()->j_invoke('singletonMap', [$lambdaX->j_field('key', javaString()), $lambdaX->j_field('value', $additionalPropertiesType)], $anyGetterReturnType)), javaOptional($anyGetterReturnType))
            ->j_invoke('orElseGet', javaCollections()->j_methodReference('emptyMap', javaFunctionType([], javaMap(javaString(), $additionalPropertiesType))), $anyGetterReturnType)
            ->j_return();,
        |
          let lambdaX = j_parameter($fieldType.typeArguments->at(0), 'x');
          j_this($javaClass)->j_field($field.name)
            ->j_streamOf()
            ->j_invoke('collect', javaCollectors()->j_invoke('toMap', [j_lambda($lambdaX, $lambdaX->j_field('key', javaString())), j_lambda($lambdaX, $lambdaX->j_field('value', $additionalPropertiesType))], javaCollector()), $anyGetterReturnType)
            ->j_return();
          
      );

      let withAnyGetter = $withTaggedUnion.first->addMethod(javaMethod('public', $anyGetterReturnType, 'additionalProperties', [], $anyGetterCode));
      let withAnyGetterMixIn = $withTaggedUnion.second
          ->addMethod(
            javaMethod(['public', 'abstract'], $anyGetterReturnType, 'additionalProperties', [])
              ->addAnnotation(^meta::external::language::java::metamodel::annotations::json::JsonAnyGetter())
            )
          ->addField($field->addAnnotation(^meta::external::language::java::metamodel::annotations::json::JsonIgnore()));

      let keyParamDef = javaParam(javaString(), 'key');
      let keyParam = j_parameter($keyParamDef);
      let valueParamDef = javaParam($additionalPropertiesType, 'value');
      let valueParam = j_parameter($valueParamDef);

      let anySetterCode = if ($prop.multiplicity->hasToOneUpperBound(),
        |
          // do we need to verify if this is called multiple times?
          let classField = j_this($javaClass)->j_field($field.name);
          let newEntry = j_assign($classField, j_new($fieldType, []));
          let keyAssing = j_assign($classField->j_field('key', javaString()), $keyParam);
          let valueAssing = j_assign($classField->j_field('value', $additionalPropertiesType), $valueParam);
          j_block([$newEntry, $keyAssing, $valueAssing]);,
        |
          let newEntryParam = j_parameter($fieldType.typeArguments->at(0), 'newEntry');
          let var = $newEntryParam->j_declare(j_new($fieldType.typeArguments->at(0), []));
          let keyAssign = j_assign($newEntryParam->j_field('key', javaString()), $keyParam);
          let valueAssign = j_assign($newEntryParam->j_field('value', $additionalPropertiesType), $valueParam);         

          let assignToList = j_assign(j_this($javaClass)->j_field($field.name), 
            javaStream()
              ->j_invoke('concat', [j_streamOf(j_this($javaClass)->j_field($field.name)), j_streamOf($newEntryParam)], javaStream($fieldType.typeArguments->at(0)))
              ->j_invoke('collect', javaCollectors()->j_invoke('toList', [], javaCollector()), $field.type)
          );

          j_block([$var, $keyAssign, $valueAssign, $assignToList]);
      );
      let withAnySetter = $withAnyGetter->addMethod(javaMethod('public', javaVoid(), 'additionalProperties', [$keyParamDef, $valueParamDef], $anySetterCode));
      let withAnySetterMixIn = $withAnyGetterMixIn->addMethod(
        javaMethod(['public', 'abstract'], javaVoid(), 'additionalProperties', [$keyParamDef, $valueParamDef])
          ->addAnnotation(^meta::external::language::java::metamodel::annotations::json::JsonAnySetter())
      );
      pair($withAnySetter, $withAnySetterMixIn);,
    | $withTaggedUnion
  );

  $project
    ->meta::external::language::java::factory::project::addClass($withAdditionalProperties.second)
    ->meta::external::language::java::factory::project::replaceClass($withAdditionalProperties.first);
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::getBuiltInTypes(): Pair<TypeName, String>[*]
{
  [
    pair(^TypeName(namespace = '_builtins', name = 'null'), 'Nil'),
    pair(^TypeName(namespace = '_builtins', name = 'boolean'), 'Boolean'),
    pair(^TypeName(namespace = '_builtins', name = 'string'), 'String'),
    pair(^TypeName(namespace = '_builtins', name = 'number'), 'Number'),
    pair(^TypeName(namespace = '_types', name = 'integer'), 'Integer'),
    pair(^TypeName(namespace = '_types', name = 'long'), 'Integer'),
    pair(^TypeName(namespace = '_types', name = 'double'), 'Float'),
    pair(^TypeName(namespace = '_types', name = 'float'), 'Float'),
    pair(^TypeName(namespace = '_types', name = 'DictionaryResponseBase'), 'Map'),
    pair(^TypeName(namespace = '_spec_utils', name = 'Void'), 'Nil')
  ];
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::specToPure(spec: Model[1], pkgPrefix: String[1], apisToGenerate: String[*], debug: Boolean[1]): GenerationState[1]
{
  let state = ^GenerationState(spec = $spec, nameToClasses = getBuiltInTypes(), pkgPrefix = $pkgPrefix, debug = $debug);
  let apis = $spec.endpoints->filter(x|$x.name->in($apisToGenerate));
  assertEquals($apisToGenerate->size(), $apis->size());
  let topLevelTypes = $apis.response->concatenate($apis.request);
  let typeDefinitions = $spec.types->filter(x|$x.name->in($topLevelTypes));
  assertEquals($topLevelTypes->size(), $typeDefinitions->size());
  $typeDefinitions->typesToPureClasses($state);
  $state.log(|'Finished!');
  $state;
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::typesToPureClasses(types: TypeDefinition[*], state: GenerationState[1]): String[*]
{
  $types->map(type| $type.name->typeToPureClass($state));
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::typeToPureClass(name: TypeName[1], state: GenerationState[1]): String[1]
{
  if($state.nameToClasses->exists(x | $x.first == $name),
  |$state.pureType($name),
  {|
    let type = $state.type($name);

    let genericType = if($type->isEmpty(),
      {|
        $state.log(|'Registering generic name: %s.%s'->format([$name.namespace, $name.name]));
        $state->registerType($name, $name.name);
      },
      {|
        $type->match([
          request: Request[1] | $request->requestTypeToPure($state),
          response: Response[1] | $response->responseTypeToPure($state),
          interface: Interface[1] | $interface->interfaceTypeToPure($state),
          alias: TypeAlias[1] | $alias->aliasTypeToPure($state),
          enum: _Enum[1] | $enum->enumTypeToPure($state)
        ]);
      }
    );
    $state.log(|'Generating ended for type: %s.%s'->format([$name.namespace, $name.name]));
    $genericType;
  });
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::createClass(type: TypeDefinition[1], namePrefix: String[1], generics: TypeName[*], inherits: Inherits[0..1], implements: Inherits[*], behaviors: Behavior[*], state: GenerationState[1]): meta::protocols::pure::vX_X_X::metamodel::domain::Class[1]
{
  assert($implements->isEmpty(), |'Not support implements definitions!');

  let genericsForString = $generics->isEmpty()->if(
    |'',
    |$generics->map({g|
      assert($state.type($g)->isEmpty(), |'Generics should not have a type defined');
      $g.name;
    })->joinStrings('<', ', ', '>'));

  let superTypes = $inherits->map({superType |
    let instanceOf = ^InstanceOf(type = $superType.type, generics = $superType.generics);
    $instanceOf->instanceOfTypeToPureType($state);
  });

  let behaviorProperties = $behaviors->map(x | 
        if($x.type.namespace == '_spec_utils' && $x.type.name == 'AdditionalProperties',
      |  ^_Property(name = '__additionalProperties', required = false, type = ^DictionaryOf(key = $x.generics->at(0), singleKey = false, value = $x.generics->at(1))), 
      | if($x.type.namespace == '_spec_utils' && $x.type.name == 'AdditionalProperty',
      |  ^_Property(name = '__additionalProperty', required = false, type = ^DictionaryOf(key = $x.generics->at(0), singleKey = true, value = $x.generics->at(1))),
      | if($x.type.namespace == '_spec_utils' && $x.type.name->in('CommonQueryParameters'), // ignored in purpose 
      |  [],
      | fail('unsupported behavior: ' + $x.type.name);[];
    )))
  )->map({p | 
      let modelProp = $p->createProperty($state)->map(x | ^$x(stereotypes = ^meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr(profile = $state.pkgPrefix + '::ESProfile', value = 'AdditionalProperty')));
    });

  let class = ^meta::protocols::pure::vX_X_X::metamodel::domain::Class(
      _type = 'class',
      name = $namePrefix + $type.name->getPureName($state) + $genericsForString,
      package = $type.name->getPurePkg($state),
      taggedValues = addDocumentation($type.description, $type.docUrl, $type.specLocation, [], $type.esQuirk, $type.deprecation, $state),
      stereotypes = $type.deprecation->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr(profile = 'doc', value = 'deprecated')),
      superTypes = $superTypes,
      properties = $behaviorProperties
  );

  $state->registerType($type.name, $class.package->toOne() + '::' + $class.name);

  $class;
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::addDocumentation(description: String[0..1], docUrl: String[0..1], specLocation: String[0..1], since: String[0..1], esQuirk: String[0..1], deprecation: Deprecation[0..1], state: GenerationState[1]): meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue[*]
{
  $description->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile='doc', value='doc'), value = $x->cleanDocumentation()))
    ->concatenate($esQuirk->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile=$state.pkgPrefix + '::ESProfile', value='esQuirk'), value = $x)))
    ->concatenate($docUrl->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile=$state.pkgPrefix + '::ESProfile', value='docURL'), value = $x)))
    ->concatenate($specLocation->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile=$state.pkgPrefix + '::ESProfile', value='specLocation'), value = $x)))
    ->concatenate($since->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile=$state.pkgPrefix + '::ESProfile', value='since'), value = $x)))
    ->concatenate($deprecation->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile='doc', value='doc'), value = 'Deprecated: %s'->format([$x.description->cleanDocumentation()]))));
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::cleanDocumentation(doc: String[1]): String[1]
{
  $doc->replace('\n', ' ')->replace('\'', '\\\'')->replace('\r', '');
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::createProperty(property: _Property[1], state: GenerationState[1]): meta::protocols::pure::vX_X_X::metamodel::domain::Property[0..1]
{
  $state.log(|'Processing property started: %s (kind: %s)'->format([$property.name, $property.type->type()->elementToPath()]));

  let name = defaultIfEmpty($property.codegenName, $property.name)->toOne()->meta::external::language::java::transform::sanitizeIdentifier()->replace('.', '_');

  let toAnnotate = $property.type->match([
    {literal: LiteralValue[1] |
      let pureProperty = $literal.value->toOne()->match([
        {stringVal: String[1] |
          ^meta::protocols::pure::vX_X_X::metamodel::domain::Property(
            name = $name,
            type = 'String',
            multiplicity = PureOne->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity(),
            defaultValue = ^meta::protocols::pure::vX_X_X::metamodel::domain::DefaultValue(
              value = ^meta::protocols::pure::vX_X_X::metamodel::valueSpecification::raw::CString(_type = 'string', value = $stringVal)
            )
          );
        }
      ]);
    },
    {any: Any[1] |
      let pureType = $property.type->propertyTypeToPureType($state);
      let multiplicity = $property.type->propertyTypeMultiplicity($property.required);
      let pureProperty = ^meta::protocols::pure::vX_X_X::metamodel::domain::Property(
        name = $name,
        type = $pureType,
        multiplicity = $multiplicity->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity()
      );
    }
  ]);

  let nameTag = if ($property.name != $name, |^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile=$state.pkgPrefix + '::ESProfile', value='name'), value = $property.name), |[]);

  let containerStereotype = $property.containerProperty->filter(x | $x)->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr(profile = $state.pkgPrefix + '::ESProfile', value = 'ContainerProperty'));

  let docs = $property.stability->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile = $state.pkgPrefix + '::ESProfile', value = 'stability'), value = $x.name));

  let fullProp = ^$toAnnotate(
    stereotypes = $containerStereotype->concatenate($property.deprecation->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr(profile = 'doc', value = 'deprecated'))),
    taggedValues = addDocumentation($property.description, $property.docUrl, [], $property.since, $property.esQuirk, $property.deprecation, $state)->concatenate($docs)->concatenate($nameTag)
  );

  $state.log(|'Processing property finished: %s (kind: %s)'->format([$property.name, $property.type->type()->elementToPath()]));
  if($fullProp.type == 'Nil' || $name == '{dynamic_property}', |[], |$fullProp);
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::propertyTypeMultiplicity(type: ValueOf[1], required: Boolean[1]): Multiplicity[1]
{
  $type->match([
    arrayT: ArrayOf[1] | if($required, |OneMany, |ZeroMany),
    mapT: DictionaryOf[1] | if($required, |if($mapT.singleKey, |PureOne, |OneMany), |if($mapT.singleKey, |ZeroOne, |ZeroMany)),
    instanceT: InstanceOf[1] | $instanceT->instanceOfTypeMultiplicity($required),
    unionT: UnionOf[1] | $unionT->unionOfTypeMultiplicity($required),
    userDefT: UserDefinedValue[1] | if($required, |PureOne, |ZeroOne)
  ]);
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::instanceOfTypeMultiplicity(type: InstanceOf[1], required: Boolean[1]): Multiplicity[1]
{
  $type.type->match([
    alias: TypeAlias[1] | $alias.type->propertyTypeMultiplicity($required),
    any: Any[1] | if($required, |PureOne, |ZeroOne)
  ]);
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::unionOfTypeMultiplicity(type: UnionOf[1], required: Boolean[1]):Multiplicity[1]
{
  let multiplicities = $type.items->map(x | $x->propertyTypeMultiplicity($required))->distinct();
  if ($multiplicities->size() == 2, |$multiplicities->filter(x | $x->isToMany())->toOne(), |$multiplicities->toOne());
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::propertyTypeToPureType(type: ValueOf[1], state: GenerationState[1]): String[1]
{
  $type->match([
    arrayT: ArrayOf[1] | $arrayT.value->propertyTypeToPureType($state),
    {mapT: DictionaryOf[1] |
      let keyType = $mapT.key->propertyTypeToPureType($state);
      assert($keyType == 'String', |'dictionary with key that is not String are not supported');
      let keyMult = $mapT.key->propertyTypeMultiplicity(true);
      assert($keyMult == PureOne, |'dictionary with key that is not pure one are not supported');
      let valueType = $mapT.value->propertyTypeToPureType($state);
      let valueMult = $mapT.value->propertyTypeMultiplicity(false);
      let dictionaryClass = if($valueMult->isToMany(), |'DictionaryEntryMultiValue', |'DictionaryEntrySingleValue');
      '%s::%s<%s>'->format([ $state.pkgPrefix, $dictionaryClass, $valueType ]);
    },
    instanceT: InstanceOf[1] | $instanceT->instanceOfTypeToPureType($state),
    unionT: UnionOf[1] | $unionT->unionOfTypeToPureType($state),
    userDefT: UserDefinedValue[1] | 'Any'
  ]);
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::unionOfTypeToPureType(type: UnionOf[1], state: GenerationState[1]): String[1]
{
  let types = $type.items->map(x | $x->propertyTypeToPureType($state));

  $state.log(|'Generating started for union of type: %s'->format($types->joinStrings(', ')));  

  let distinct = $types->distinct()->filter(x | $x != 'Nil');
  if($distinct->size() == 1,
    {|
      $distinct->at(0);
    },
    {|
      let noPrimitives = $distinct->filter(x | $x->contains('::'));
      if($noPrimitives->size() == 1,
        |$noPrimitives->at(0),
        |
          if($distinct->exists(x | $x == 'String'),
            |'String',
            |
              fail($distinct->joinStrings('Too many types to union: ', ', ', ''));
              $distinct->at(0);
          )
      );
    }
  );
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::instanceOfTypeToPureType(type: InstanceOf[1], state: GenerationState[1]): String[1]
{
  $state.log(|'Generating started for instance of: %s.%s'->format([$type.type.namespace, $type.type.name]));
  let name = $type.type->typeToPureClass($state);
  if ($type.generics->isEmpty(),
    | $name,
    | $type.type->getPurePkg($state) + '::' + $type.type->getPureName($state) + $type.generics->map(x | $x->propertyTypeToPureType($state))->joinStrings('<', ', ', '>')
  );
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::enumTypeToPure(type: _Enum[1], state: GenerationState[1]): String[1]
{
  $state.log(|'Generating started for enum: %s.%s'->format([$type.name.namespace, $type.name.name]));  
  let values = $type.members->map({em |
    let name = defaultIfEmpty($em.codegenName, $em.name)->toOne()->replace('-', '_')->map(x | $x->in(['true', 'false'])->if(|'_' + $x, |$x))->meta::external::language::java::transform::sanitizeIdentifier();
    let nameTag = if ($em.name != $name, |^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile=$state.pkgPrefix + '::ESProfile', value='name'), value = $em.name), |[]);
    ^meta::protocols::pure::vX_X_X::metamodel::domain::EnumValue(
      value = $name,
      taggedValues = addDocumentation($em.description, [], [], $em.since, [], $em.deprecation, $state)->concatenate($nameTag),
      stereotypes = $em.deprecation->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr(profile = 'doc', value = 'deprecated'))
    );}
  );
  let name = $type.name->getPureName($state);
  let pkg = $type.name->getPurePkg($state);
  let enum = ^meta::protocols::pure::vX_X_X::metamodel::domain::Enumeration(
    _type = 'Enumeration',
    name = $name,
    package = $pkg,
    values = $values,
    taggedValues = addDocumentation($type.description, $type.docUrl, $type.specLocation, [], $type.esQuirk, $type.deprecation, $state),
    stereotypes = $type.deprecation->map(x | ^meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr(profile = 'doc', value = 'deprecated'))
  );
  $state->registerType($type.name, $pkg + '::' + $name);
  $state->registerForGeneration($enum);
  $pkg + '::' + $name;
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::collectInstanceOfInterface(type: ValueOf[1], state: GenerationState[1]): InstanceOf[*]
{
  $type->match([
    instanceT: InstanceOf[1] | $state.type($instanceT.type)->match([
      interface: Interface[1] | $instanceT,
      alias: TypeAlias[1] | $alias.type->collectInstanceOfInterface($state)
    ]),
    unionT: UnionOf[1] | $unionT.items->map(x | $x->collectInstanceOfInterface($state))
  ]);
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::aliasTypeToPure(type: TypeAlias[1], state: GenerationState[1]): String[1]
{
  $state.log(|'Generating started for alias: %s.%s'->format([$type.name.namespace, $type.name.name]));

  $type.variants->match([
    {externalTag: ExternalTag[1] |
      let items = $type.type->collectInstanceOfInterface($state);
      let names = $items->map(x | $state.type($x.type)).variantName;
      let stereotype = ^meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr(profile = $state.pkgPrefix + '::ESProfile', value = 'ExternalTagged');
      $type->taggedUnionAliasTypeToPure($names, $items, $stereotype, [], $state);
    },
    {internalTag: InternalTag[1] |
      let items = $type.type->collectInstanceOfInterface($state);
      let names = $items->map(x | $state.type($x.type))->cast(@Interface).properties->filter(x | $x.name == $internalTag.tag).type->cast(@LiteralValue).value->cast(@String);
      let tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue(tag = ^meta::protocols::pure::vX_X_X::metamodel::domain::TagPtr(profile=$state.pkgPrefix + '::ESProfile', value='internalTag'), value =  $internalTag.tag);
      $type->taggedUnionAliasTypeToPure($names, $items, [], $tag, $state);
    },
    {none: Any[0] |
      if($type.codegenNames->isEmpty(),
        {|
          let aliasType = $type.type->propertyTypeToPureType($state);
          $state->registerType($type.name, $aliasType);
        },
        {|
          $type->taggedUnionAliasTypeToPure($type.codegenNames, $type.type->cast(@UnionOf).items, [], [], $state);
        }
      );
    }
  ]);
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::taggedUnionAliasTypeToPure(type: TypeAlias[1], codegenNames: String[*], unions: ValueOf[*], extraStereoType: meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr[*], extraTags: meta::protocols::pure::vX_X_X::metamodel::domain::TaggedValue[*], state: GenerationState[1]): String[1]
{
  assert($codegenNames->size() == $unions->size(), |'Expects union to have 1-1 to codenames');

  let name = $type.name;

  let aliasClass = $type->createClass('', $type.generics, [], [], [], $state);
  let stereotypes = $aliasClass.stereotypes->concatenate(
        ^meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr(profile = $state.pkgPrefix + '::ESProfile', value = 'TaggedUnion'))
      ->concatenate($extraStereoType);

  let tags = $aliasClass.taggedValues->concatenate($extraTags);

  let properties = zip($codegenNames, $unions)
     ->map(pair | ^_Property(name = $pair.first, type = $pair.second, required = false))
     ->map(property| $property->createProperty($state))
     ->concatenate($aliasClass.properties);

  let classWithStereoTypes = ^$aliasClass(stereotypes = $stereotypes, properties = $properties, taggedValues = $tags);
  $state->registerForGeneration($classWithStereoTypes);
  $aliasClass.package->toOne() + '::' + $aliasClass.name;
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::interfaceTypeToPure(type: Interface[1], state: GenerationState[1]): String[1]
{
  $state.log(|'Generating started for interface: %s.%s'->format([$type.name.namespace, $type.name.name]));
  let class = $type->createClass('', $type.generics, $type.inherits, $type.implements, $type.behaviors, $state);

  let properties = $type.properties->map(prop | $prop->createProperty($state))
                    ->concatenate($class.properties);

  let classWithVariant = if($type.variants->isEmpty(),
      |$class,
      {|
        let stereotypes = $class.stereotypes
            ->concatenate(^meta::protocols::pure::vX_X_X::metamodel::domain::StereotypePtr(profile = $state.pkgPrefix + '::ESProfile', value = 'ContainerVariant'));
        ^$class(stereotypes = $stereotypes);
      }
  );

  let fullyInitClass = ^$classWithVariant(
    properties = $properties
  );
  $state->registerForGeneration($fullyInitClass);
  $fullyInitClass.package->toOne() + '::' + $fullyInitClass.name;
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::requestTypeToPure(type: Request[1], state: GenerationState[1]): String[1]
{
  $state.log(|'Generating started for request: %s.%s'->format([$type.name.namespace, $type.name.name]));

  let prefix = $type.name.namespace->split('.')->last()->toOne()->makeCamelCase(true);
  let class = $type->createClass($prefix, $type.generics, $type.inherits, $type.implements, $type.behaviors, $state);

  let bodyProps = $type.body->match([
    noBody: NoBody[1] | [],
    {propsBody: PropertiesBody[1] |
      let interface = ^Interface(
        properties = $propsBody.properties,
        generics = $type.generics,
        name = ^TypeName(name = $prefix + $type.name.name + 'Body', namespace = $type.name.namespace),
        specLocation = $type.specLocation
      );
      $interface->interfaceTypeToPure($state);
      ^_Property(name = 'body', type = ^InstanceOf(type = $interface.name, generics = $interface.generics->map(x | ^InstanceOf(type = $x))), required = true);
    },
    singleValue: ValueBody[1] | ^_Property(name = 'body', codegenName = $singleValue.codegenName, type = $singleValue.value, required = true)
  ]);

  let properties = $bodyProps->concatenate($type.path)->concatenate($type.query)->distinct()->map(prop| $prop->createProperty($state))
                      ->concatenate($class.properties);
  
  let fullyInitClass = ^$class(
    properties = $properties
  );
  $state->registerForGeneration($fullyInitClass);
  $fullyInitClass.package->toOne() + '::' + $fullyInitClass.name;
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::responseTypeToPure(type: Response[1], state: GenerationState[1]): String[1]
{
  $state.log(|'Generating started for response: %s.%s'->format([$type.name.namespace, $type.name.name]));

  assert($type.exceptions->isEmpty(), |'not supported for %s.%s'->format([$type.name.namespace, $type.name.name]) );

  let bodyProps = $type.body->match([
    {noBody: NoBody[1] |
      fail('Api with no response?');
      $state->registerType($type.name, 'Nil');
    },
    {propsBody: PropertiesBody[1] |
      if($type.inherits->filter(x | $x.type.name == 'DictionaryResponseBase')->size() == 1,
        {|
          let inherits = $type.inherits->toOne();
          let mapRaw = $inherits.type->typeToPureClass($state);
          let mapWithTypes = $mapRaw + $inherits.generics->map(p |$p->propertyTypeToPureType($state))->joinStrings('<', ', ', '>');
          $state->registerType($type.name, $mapWithTypes);
        },
        {|
          let prefix = $type.name.namespace->split('.')->last()->toOne()->makeCamelCase(true);
          let class = $type->createClass($prefix, $type.generics, $type.inherits, [], $type.behaviors, $state);
          let properties = $propsBody.properties->map(prop| $prop->createProperty($state))
                                ->concatenate($class.properties);
          let fullyInitClass = ^$class(
            properties = $properties
          );
          $state->registerForGeneration($fullyInitClass);
          $fullyInitClass.package->toOne() + '::' + $fullyInitClass.name;
        }
      );
    },
    {singleValue: ValueBody[1] |
      assert($type.inherits->isEmpty(), |'Single value but inherits?');
      let responseBody = $singleValue.value->propertyTypeToPureType($state);
      $state->registerType($type.name, $responseBody);
    }
  ]);
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::registerForGeneration(state: GenerationState[1], class: meta::protocols::pure::vX_X_X::metamodel::PackageableElement[1]): meta::protocols::pure::vX_X_X::metamodel::PackageableElement[1]
{
  $state->mutateAdd('generated', $class);
  $class;
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::registerType(state: GenerationState[1], name: TypeName[1], class: String[1]): String[1]
{
  $state->mutateAdd('nameToClasses', pair($name, $class));
  $class;
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::getPurePkg(type: TypeName[1], state: GenerationState[1]): String[1]
{
  let namespace = $type.namespace->replace('_', '')->replace('.', '::');
  '%s::%s'->format([$state.pkgPrefix, $namespace]);
}

function
<<access.private>>
meta::external::store::elasticsearch::specification::metamodel::getPureName(type: TypeName[1], state: GenerationState[1]): String[1]
{
  $type.name->replace('.', '_')->makeCamelCase(true);
}