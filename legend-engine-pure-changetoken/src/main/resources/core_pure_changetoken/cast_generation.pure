// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::language::java::metamodel::project::*;
import meta::external::language::java::factory::project::*;
import meta::external::language::java::factory::*;
import meta::pure::executionPlan::engine::java::*;
import meta::pure::changetoken::*;
import meta::pure::functions::meta::*;
import meta::external::language::java::metamodel::*;
import meta::pure::changetoken::cast_generation::*;
import meta::pure::functions::collection::*;

// entry point into cast generation
function meta::pure::changetoken::cast_generation::generateCast(versionsFuncName:String[1], outputClassName:String[1]):Project[1]
{
  let versions = functionDescriptorToId($versionsFuncName + '():Versions[1]')
    ->pathToElement()->cast(@ConcreteFunctionDefinition<{->Versions[1]}>)
    ->eval();

  let class = javaClass(['public'], javaPackage('org.finos.legend.engine.generated.meta.pure.changetoken.cast_generation'), $outputClassName);
  let paramNode = j_parameter(jsonNode(), 'node');
  let class2 = _generateUpcastFunction($class, $versions);
  
  let paramVersion = j_parameter(javaString(), 'version');
  let downcastMethod = javaMethod(['public', 'static'], jsonNode(), 'downcast', [$paramNode, $paramVersion],
    j_return($paramNode)
  );
  newProject()->addClass($class2->addMethods([$downcastMethod]));
}


function <<access.private>> meta::pure::changetoken::cast_generation::_generateUpcastFunction(
  class:meta::external::language::java::metamodel::Class[1],
  versions:Versions[1]
):meta::external::language::java::metamodel::Class[1]
{
  let paramNode = j_parameter(jsonNode(), 'node');

  let codeAndClass = $versions.versions->fold(
    { 
      ver, resP |
      if($ver.prevVersion->size() != 0,
      {|
        let p = $class->_generateSingleUpcastFunction($ver, $paramNode);
        let resPF = $resP.first;
        pair(^$resPF(values+=$p.first), $p.second);
      },
      |$resP
      );
    }, 
    pair(^List<Code>(), $class)
  );


  let verVar = j_variable(javaString(), 'version');
  // public static JsonNode upcast(JsonNode node)
  let upcastMethod = javaMethod(['public', 'static'], jsonNode(), 'upcast', [$paramNode],
    j_block(
      [
        // if (!node.isObject() || !node.has("version")) throw new RuntimeException("Missing version")
        j_if(
          j_or(
            j_not($paramNode->j_invoke('isObject', [], javaBoolean())),
            j_not($paramNode->j_invoke('has', [j_string('version')], javaBoolean()))),
          javaRuntimeException()->j_new([j_string('Missing version')])->j_throw()),
        // 
        $verVar->j_declare($paramNode->j_invoke('get', [j_string('version')], jsonNode())->j_invoke('asText', [], javaString()))
      ]
      ->concatenate($codeAndClass.first.values)
      ->concatenate([
        j_if(
          j_not($verVar->j_invoke('equals', j_string($versions.versions->at($versions.versions->size()-1).version))),
          javaRuntimeException()->j_new(j_plus(j_string('Unexpected version: '), $verVar))->j_throw()
        )
      ])
      ->concatenate([j_return($paramNode)])));
      
  $codeAndClass.second->addMethod($upcastMethod);
}


function <<access.private>> meta::pure::changetoken::cast_generation::_generateSingleUpcastFunction(
  class:meta::external::language::java::metamodel::Class[1], 
  version:Version[1], 
  paramNode:Code[1]
):Pair<Code,meta::external::language::java::metamodel::Class>[1]
{
  let funcName = '_upcast_to_' + ($version.version->replace(':', '_'));

  let methodBody = $version.changeTokens
    ->filter(t|$t->instanceOf(AddField))
    ->fold({t,res|
      _handleAddField($t->cast(@AddField), $paramNode, $version.version)
    }, [])->add(j_return($paramNode));

  let singleUpcastMethod = javaMethod(['private', 'static'], jsonNode(), $funcName, [$paramNode], j_block($methodBody));
  let class2 = $class->addMethod($singleUpcastMethod);

  let verVar = j_variable(javaString(), 'version');
  let ifCond = j_if($verVar->j_invoke('equals', [j_string($version.prevVersion->toOne())]),
    j_block([
      $paramNode->j_assign($class2->j_invoke($funcName, $paramNode)),
      $verVar->j_assign($paramNode->j_invoke('get', [j_string('version')], jsonNode())->j_invoke('asText', [], javaString()))
    ]));

  pair($ifCond, $class2);
}


function <<access.private>> meta::pure::changetoken::cast_generation::_handleAddField(token:AddField[1], paramNode:Code[1], version:String[1]):Code[1]
{
  let objVar = j_variable(objectNode(), 'object');
  let typeVar = j_variable(javaString(), 'type');
  j_if($paramNode->j_invoke('isObject', [], javaBoolean()),
    j_block([
      $objVar->j_declare($paramNode->j_cast(objectNode())),      
      j_if(
        j_eq($objVar->j_invoke('get', [j_string('@type')], jsonNode()), j_null()),
        javaRuntimeException()->j_new(j_string('Missing @type'))->j_throw()
      ),
      $typeVar->j_declare($objVar->j_invoke('get', [j_string('@type')], jsonNode())->j_invoke('asText', [], javaString())),
      j_if(
        $typeVar->j_invoke('equals', [j_string($token.class)]),
        j_block([
          $objVar->j_assign($objVar->j_invoke('deepCopy', [], objectNode())), // TODO: is there a shallow copy?
          $paramNode->j_assign($objVar),
          $objVar->j_invoke('put', [j_string('abc'), j_int($token.defaultValue->cast(@ConstValue).value->cast(@Integer))], javaVoid()) // TODO: need copy logic here too and other formatters
        ])
      ),
      $objVar->j_invoke('put', [j_string('version'), j_string($version)], javaVoid()) // TODO: this belongs in the outer handler, not per token
    ]));
}

function <<access.private>> meta::pure::changetoken::cast_generation::objectNode():meta::external::language::java::metamodel::Class[1] { javaClass('com.fasterxml.jackson.databind.node.ObjectNode'); }
