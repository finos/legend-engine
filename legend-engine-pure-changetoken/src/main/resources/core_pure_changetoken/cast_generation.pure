// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::language::java::metamodel::project::*;
import meta::external::language::java::factory::project::*;
import meta::external::language::java::factory::*;
import meta::pure::executionPlan::engine::java::*;
import meta::pure::changetoken::*;
import meta::pure::functions::meta::*;
import meta::external::language::java::metamodel::*;
import meta::pure::changetoken::cast_generation::*;
import meta::pure::functions::collection::*;

// entry point into cast generation
function meta::pure::changetoken::cast_generation::generateCast(versionsFuncName:String[1], outputClassName:String[1]):Project[1]
{
  // load Versions()
  let versions = functionDescriptorToId($versionsFuncName + '():Versions[1]')
    ->pathToElement()->cast(@ConcreteFunctionDefinition<{->Versions[1]}>)
    ->eval();

  // generated class  
  let class = javaClass(['public'], javaPackage('org.finos.legend.engine.generated.meta.pure.changetoken.cast_generation'), $outputClassName);
  
  newProject()->addClass(
    $class
      ->_generateUpcastFunction($versions)
      ->_generateDowncastFunction($versions)
  );
}

function <<access.private>> meta::pure::changetoken::cast_generation::_generateDowncastFunction(
  class:meta::external::language::java::metamodel::Class[1],
  versions:Versions[1]
)
:meta::external::language::java::metamodel::Class[1]
{
  let paramNode = j_parameter(jsonNode(), 'node');
  let paramVersion = j_parameter(javaString(), 'targetVersion');

  // code for the main downcast() method (lots of IFs) and the class with added methods
  let codeAndClass = $versions.versions->reverse()->fold(
    { 
      ver, resP |
      if($ver.prevVersion->size() != 0,
      {|
        let p = $class->_generateSingleDowncastFunction($ver, $paramVersion);
        let resPF = $resP.first;
        pair(^$resPF(values+=$p.first), $p.second);
      },
      |$resP
      );
    }, 
    pair(^List<Code>(), $class)
  );


  let verVar = j_variable(javaString(), 'version');
  let objVar = j_variable(objectNode(), 'objectNode');
  // public static JsonNode upcast(JsonNode node)
  let downcastMethod = javaMethod(['public', 'static'], jsonNode(), 'downcast', [$paramNode, $paramVersion],
    j_block(
      [
        // if (!node.isObject() || !node.has("version")) throw new RuntimeException("Missing version")
        j_if(
          j_or(
            j_not($paramNode->j_invoke('isObject', [], javaBoolean())),
            j_not($paramNode->j_invoke('has', [j_string('version')], javaBoolean()))),
          javaRuntimeException()->j_new([j_string('Missing version')])->j_throw()),
        // ObjectNode objectNode = node.deepCopy()
        $objVar->j_declare($paramNode->j_invoke('deepCopy', [], objectNode())),
        // String version = objectNode.get("version").asText()
        $verVar->j_declare($objVar->j_invoke('get', [j_string('version')], jsonNode())->j_invoke('asText', [], javaString()))        
      ]
      // [if (version.equals(<version>)) {...}]+
      ->concatenate($codeAndClass.first.values)
      // if (!version.equals(<first_version>) || !targetVersion.equals(version)) throw new RuntimeException('Unexpected version')
      ->concatenate([
        j_if(
          j_or(
            j_not($verVar->j_invoke('equals', j_string($versions.versions->at(0).version))),
            j_not($paramVersion->j_invoke('equals', $verVar))
          ),
          javaRuntimeException()->j_new(j_plus(j_string('Unexpected version: '), $verVar))->j_throw()
        )
      ])
      // return objectNode
      ->concatenate([j_return($objVar)])));
      
  $codeAndClass.second->addMethod($downcastMethod);
}


function <<access.private>> meta::pure::changetoken::cast_generation::_generateUpcastFunction(
  class:meta::external::language::java::metamodel::Class[1],
  versions:Versions[1]
):meta::external::language::java::metamodel::Class[1]
{
  let paramNode = j_parameter(jsonNode(), 'node');

  // code for the main upcast() method (lots of IFs) and the class with added methods
  let codeAndClass = $versions.versions->fold(
    { 
      ver, resP |
      if($ver.prevVersion->size() != 0,
      {|
        let p = $class->_generateSingleUpcastFunction($ver);
        let resPF = $resP.first;
        pair(^$resPF(values+=$p.first), $p.second);
      },
      |$resP
      );
    }, 
    pair(^List<Code>(), $class)
  );


  let verVar = j_variable(javaString(), 'version');
  let objVar = j_variable(objectNode(), 'objectNode');
  // public static JsonNode upcast(JsonNode node)
  let upcastMethod = javaMethod(['public', 'static'], jsonNode(), 'upcast', [$paramNode],
    j_block(
      [
        // if (!node.isObject() || !node.has("version")) throw new RuntimeException("Missing version")
        j_if(
          j_or(
            j_not($paramNode->j_invoke('isObject', [], javaBoolean())),
            j_not($paramNode->j_invoke('has', [j_string('version')], javaBoolean()))),
          javaRuntimeException()->j_new([j_string('Missing version')])->j_throw()),
        // ObjectNode objectNode = node.deepCopy()
        $objVar->j_declare($paramNode->j_invoke('deepCopy', [], objectNode())),
        // String version = objectNode.get("version").asText()
        $verVar->j_declare($objVar->j_invoke('get', [j_string('version')], jsonNode())->j_invoke('asText', [], javaString()))        
      ]
      // [if (version.equals(<version>)) {...}]+
      ->concatenate($codeAndClass.first.values)
      // if (!version.equals(<current_version>)) throw new RuntimeException('Unexpected version')
      ->concatenate([
        j_if(
          j_not($verVar->j_invoke('equals', j_string($versions.versions->at($versions.versions->size()-1).version))),
          javaRuntimeException()->j_new(j_plus(j_string('Unexpected version: '), $verVar))->j_throw()
        )
      ])
      // return objectNode
      ->concatenate([j_return($objVar)])));
      
  $codeAndClass.second->addMethod($upcastMethod);
}


// upcast a single version
function <<access.private>> meta::pure::changetoken::cast_generation::_generateSingleUpcastFunction(
  class:meta::external::language::java::metamodel::Class[1], 
  version:Version[1]
):Pair<Code,meta::external::language::java::metamodel::Class>[1]
{
  let mainFuncName = '_upcast_to_' + ($version.version->replace(':', '_'));
  let objRecurseFuncName = $mainFuncName + '_object';
  let arrRecurseFuncName = $mainFuncName + '_array';
  let objVar = j_parameter(objectNode(), 'objectNode');

  // private static _upcast_to_version(ObjectNode objectNode)
  let class2 = $class->addMethod(javaMethod(['private', 'static'], objectNode(), $mainFuncName, [$objVar], j_block([
    // objectNode.put('version', <current_version>)
    $objVar->j_invoke('put', [j_string('version'), j_string($version.version)], javaVoid()),
    // return _upcast_to_version_object(objectNode)
    j_return($class->j_invoke($objRecurseFuncName, [$objVar], objectNode()))
  ])));

  let typeVar = j_variable(javaString(), 'type');
  let changeTokenHandlers = $version.changeTokens
    ->filter(t|$t->instanceOf(AddField)) // TODO: handle all changetoken types
    ->fold({t,res|
      _handleAddFieldUpcast($t->cast(@AddField), $objVar, $typeVar, $version.version)
    }, []);

  // private static _upcast_to_version_object(ObjectNode objectNode)
  let class3 = $class2->addMethod(javaMethod(['private', 'static'], objectNode(), $objRecurseFuncName, [$objVar], j_block(
    [
      // if(objectNode.get("@type") == null) throw new RuntimeException("Missing @type")
      j_if(
        j_eq($objVar->j_invoke('get', [j_string('@type')], jsonNode()), j_null()),
        javaRuntimeException()->j_new(j_string('Missing @type'))->j_throw()
      ),
      // 
      $typeVar->j_declare($objVar->j_invoke('get', [j_string('@type')], jsonNode())->j_invoke('asText', [], javaString()))
    ]
    ->concatenate($changeTokenHandlers)
    ->concatenate($class2->_generateSingleUpcastObjectRecurseBlock($objRecurseFuncName, $arrRecurseFuncName, $objVar))
    ->concatenate([
      j_return($objVar)
    ]))));

  let verVar = j_variable(javaString(), 'version');
  // if (version.equals(version))
  let ifCond = j_if($verVar->j_invoke('equals', [j_string($version.prevVersion->toOne())]),
    j_block([
      // objectNode = Class._upcast_to_version(objectNode)
      $objVar->j_assign($class3->j_invoke($mainFuncName, $objVar)),
      // version = objectNode.get("version").asText()
      $verVar->j_assign($objVar->j_invoke('get', [j_string('version')], jsonNode())->j_invoke('asText', [], javaString()))
    ]));

  let class4 = $class3->addMethod($class3->_generateSingleUpcastArrayRecurseFunction($objRecurseFuncName, $arrRecurseFuncName));

  pair($ifCond, $class4);
}


// downcast a single version
function <<access.private>> meta::pure::changetoken::cast_generation::_generateSingleDowncastFunction(
  class:meta::external::language::java::metamodel::Class[1], 
  version:Version[1],
  paramVersion:Code[1]
):Pair<Code,meta::external::language::java::metamodel::Class>[1]
{
  let mainFuncName = '_downcast_to_' + ($version.prevVersion->toOne()->replace(':', '_'));
  let objRecurseFuncName = $mainFuncName + '_object';
  let arrRecurseFuncName = $mainFuncName + '_array';
  let objVar = j_parameter(objectNode(), 'objectNode');

  // private static _downcast_to_version(ObjectNode objectNode)
  let class2 = $class->addMethod(javaMethod(['private', 'static'], objectNode(), $mainFuncName, [$objVar], j_block([
    // objectNode.put('version', <previous_version>)
    $objVar->j_invoke('put', [j_string('version'), j_string($version.prevVersion->toOne())], javaVoid()),
    // return _downcast_to_version_object(objectNode)
    j_return($class->j_invoke($objRecurseFuncName, [$objVar], objectNode()))
  ])));

  let typeVar = j_variable(javaString(), 'type');
  let changeTokenHandlers = $version.changeTokens
    ->filter(t|$t->instanceOf(AddField)) // TODO: handle all changetoken types
    ->fold({t,res|
      _handleAddFieldUpcast($t->cast(@AddField), $objVar, $typeVar, $version.version) // XXX
    }, []);

  // private static _downcast_to_version_object(ObjectNode objectNode)
  let class3 = $class2->addMethod(javaMethod(['private', 'static'], objectNode(), $objRecurseFuncName, [$objVar], j_block(
    [
      // if(objectNode.get("@type") == null) throw new RuntimeException("Missing @type")
      j_if(
        j_eq($objVar->j_invoke('get', [j_string('@type')], jsonNode()), j_null()),
        javaRuntimeException()->j_new(j_string('Missing @type'))->j_throw()
      ),
      // 
      $typeVar->j_declare($objVar->j_invoke('get', [j_string('@type')], jsonNode())->j_invoke('asText', [], javaString()))
    ]
    ->concatenate($changeTokenHandlers)
    ->concatenate($class2->_generateSingleUpcastObjectRecurseBlock($objRecurseFuncName, $arrRecurseFuncName, $objVar))
    ->concatenate([
      j_return($objVar)
    ]))));

  let verVar = j_variable(javaString(), 'version');
  // if (version.equals(cur_version))
  let ifCond = j_if($verVar->j_invoke('equals', [j_string($version.version)]),
    [
      // if (targetVersion.equals(version)) return objectNode
      j_if($paramVersion->j_invoke('equals', [$verVar]), j_return($objVar)),
      // objectNode = Class._downcast_to_version(objectNode)
      $objVar->j_assign($class3->j_invoke($mainFuncName, $objVar)),
      // version = objectNode.get("version").asText()
      $verVar->j_assign($objVar->j_invoke('get', [j_string('version')], jsonNode())->j_invoke('asText', [], javaString()))
    ]);

  let class4 = $class3->addMethod($class3->_generateSingleUpcastArrayRecurseFunction($objRecurseFuncName, $arrRecurseFuncName));

  pair($ifCond, $class4);
}


function <<access.private>> meta::pure::changetoken::cast_generation::_generateSingleUpcastArrayRecurseFunction( /// XXX: rename
  class:meta::external::language::java::metamodel::Class[1], 
  objRecurseFuncName:String[1],
  arrRecurseFuncName:String[1]
):Method[1]
{
  let arrVar = j_parameter(arrayNode(), 'arrayNode');
  let i = j_variable(javaInt(), 'i');
  let arrI = $arrVar->j_invoke('get', [$i], jsonNode());

  // private static ArrayNode _upcast_to_version_array(ArrayNode arrayNode)
  javaMethod(['private', 'static'], arrayNode(), $arrRecurseFuncName, [$arrVar], j_block([
    // for(int i = 0; i < arrayNode.size(); i++)
    j_for($i->j_declare(j_int(0)), $i->j_lt($arrVar->j_invoke('size', [], javaInt())), $i->j_inc(), [
      // if (arrayNode.get(i).isArray())
      j_if($arrI->j_invoke('isArray', [], javaBoolean()),
        // arrayNode.set(i, Class._upcast_to_version_array((ArrayNode)arrayNode.get(i)))
        $arrVar->j_invoke('set', [$i, $class->j_invoke($arrRecurseFuncName, [$arrI->j_cast(arrayNode())], arrayNode())], javaVoid()),
        // else if (arrayNode.get(i).isObject())
        j_if($arrI->j_invoke('isObject', [], javaBoolean()),
          // arrayNode.set(i, Class._upcast_to_version_object((ObjectNode) arrayNode.get(i)))
          $arrVar->j_invoke('set', [$i, $class->j_invoke($objRecurseFuncName, [$arrI->j_cast(objectNode())], objectNode())], javaVoid())
        )
      )
    ]),
    j_return($arrVar)
  ]));
}

function <<access.private>> meta::pure::changetoken::cast_generation::_generateSingleUpcastObjectRecurseBlock( // XXX: rename
  class:meta::external::language::java::metamodel::Class[1], 
  objRecurseFuncName:String[1],
  arrRecurseFuncName:String[1],
  objVar:Code[1]
):Code[1..*]
{
  let entryType = ^ParameterizedType(
      rawType=javaClass('java.util.Map.Entry'), 
      typeArguments=[javaString(), jsonNode()]);
  let itType = ^ParameterizedType(
    rawType=javaClass('java.util.Iterator'), 
    typeArguments=[$entryType]);
  let itVar = j_variable($itType, 'it');

  let enVar = j_variable($entryType, 'en');
  let innerObjectNodeVar = j_variable(objectNode(), 'innerObjectNode');
  let newInnerObjectNodeVar = j_variable(objectNode(), 'newInnerObjectNode');  
  let arrayNodeVar = j_variable(arrayNode(), 'arrayNode');
  let newArrayNodeVar = j_variable(arrayNode(), 'newArrayNode');

  [
    // Iterator<Map.Entry<String, JsonNode>> it = objectNode.fields();
    $itVar->j_declare($objVar->j_invoke('fields', [], $itType)),

    // while (it.hasNext())
    j_while($itVar->j_invoke('hasNext', [], javaBoolean()), [
      //     Map.Entry<String, JsonNode> en = it.next();
      $enVar->j_declare($itVar->j_invoke('next', [], $entryType)),
      //     if (en.getValue().isObject())
      j_if($enVar->j_invoke('getValue', [], jsonNode())->j_invoke('isObject', [], javaBoolean()),
        [
          //         ObjectNode innerObjectNode = Class._upcast_to_version_object((ObjectNode) en.getValue());
          $innerObjectNodeVar->j_declare($class->j_invoke($objRecurseFuncName, [$enVar->j_invoke('getValue', [], jsonNode())->j_cast(objectNode())], objectNode())),
          //         ObjectNode newInnerObjectNode = objectNode.putObject(en.getKey());
          $newInnerObjectNodeVar->j_declare($objVar->j_invoke('putObject', [$enVar->j_invoke('getKey', [], javaString())], javaVoid())),
          //         newInnerObjectNode.setAll(innerObjectNode);
          $newInnerObjectNodeVar->j_invoke('setAll', [$innerObjectNodeVar], javaVoid())
        ],
        //     } else if( en.getValue().isArray()) {
        j_if($enVar->j_invoke('getValue', [], jsonNode())->j_invoke('isArray', [], javaBoolean()), 
        [
          //         ArrayNode arrayNode = Class._upcast_to_version_array((ArrayNode) en.getValue());
          $arrayNodeVar->j_declare($class->j_invoke($arrRecurseFuncName, [$enVar->j_invoke('getValue', [], jsonNode())->j_cast(arrayNode())], arrayNode())),
          //         ArrayNode newArrayNode = objectNode.putArray(en.getKey());
          $newArrayNodeVar->j_declare($objVar->j_invoke('putArray', [$enVar->j_invoke('getKey', [], javaString())], javaVoid())),
          //         newArrayNode.addAll(arrayNode);
          $newArrayNodeVar->j_invoke('addAll', [$arrayNodeVar], javaVoid())
        ])
      )
    ])
  ];
}

function <<access.private>> meta::pure::changetoken::cast_generation::_handleAddFieldUpcast(
  token:AddField[1], objVar:Code[1], typeVar:Code[1], version:String[1]):Code[1]
{
  // if (type.equals(token.class))
  j_if(
    $typeVar->j_invoke('equals', [j_string($token.class)]),
    j_block([
      // objectNode.put(fieldName, defaultValue)
      $objVar->j_invoke('put', [j_string($token.fieldName), j_int($token.defaultValue->cast(@ConstValue).value->cast(@Integer))], javaVoid()) // TODO: need copy logic here too and other formatters
    ])
  );
}

function <<access.private>> meta::pure::changetoken::cast_generation::objectNode():meta::external::language::java::metamodel::Class[1] { javaClass('com.fasterxml.jackson.databind.node.ObjectNode'); }
function <<access.private>> meta::pure::changetoken::cast_generation::arrayNode():meta::external::language::java::metamodel::Class[1] { javaClass('com.fasterxml.jackson.databind.node.ArrayNode'); }
